<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>C Plus Plus | 清辉 の Blog</title><meta name="author" content="含光"><meta name="copyright" content="含光"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="核心篇The BasicsScope and Lifetime• Local scope:   A name declared in a function (§1.4) or lambda (§5.5) is called a local name. Its scope extends from its point of declaration to the end of the block in">
<meta property="og:type" content="article">
<meta property="og:title" content="C Plus Plus">
<meta property="og:url" content="https://zuowanghang.github.io/2022/04/11/C-Plus-Plus/index.html">
<meta property="og:site_name" content="清辉 の Blog">
<meta property="og:description" content="核心篇The BasicsScope and Lifetime• Local scope:   A name declared in a function (§1.4) or lambda (§5.5) is called a local name. Its scope extends from its point of declaration to the end of the block in">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2022/11/30/bla2mxhQ9jwJMGO.jpg">
<meta property="article:published_time" content="2022-04-11T04:07:50.000Z">
<meta property="article:modified_time" content="2023-03-30T03:11:33.138Z">
<meta property="article:author" content="含光">
<meta property="article:tag" content="C&#x2F;C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2022/11/30/bla2mxhQ9jwJMGO.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zuowanghang.github.io/2022/04/11/C-Plus-Plus/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C Plus Plus',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-30 11:11:33'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (false) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s2.loli.net/2022/11/30/m3onYl1iO4ZuwT8.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s2.loli.net/2022/11/30/bla2mxhQ9jwJMGO.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="清辉 の Blog"><span class="site-name">清辉 の Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">C Plus Plus</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-04-11T04:07:50.000Z" title="发表于 2022-04-11 12:07:50">2022-04-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-30T03:11:33.138Z" title="更新于 2023-03-30 11:11:33">2023-03-30</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="C Plus Plus"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="核心篇"><a href="#核心篇" class="headerlink" title="核心篇"></a>核心篇</h1><h2 id="The-Basics"><a href="#The-Basics" class="headerlink" title="The Basics"></a>The Basics</h2><h3 id="Scope-and-Lifetime"><a href="#Scope-and-Lifetime" class="headerlink" title="Scope and Lifetime"></a>Scope and Lifetime</h3><p>• <strong>Local scope:</strong>  </p>
<p>A name declared in a function (§1.4) or lambda (§5.5) is called a local name. Its scope extends from its point of declaration to the end of the block in which its declaration occurs. A block is delimited by a { } pair. Function argument names are considered local names.</p>
<p>• <strong>Class scope:</strong> </p>
<p> A name is called a member name (or a class member name) if it is defifined in a class (§2.2, §2.3, Chapter 4), outside any function (§1.4), lambda (§5.5), or enum class (§2.5). Its scope extends from the opening { of its enclosing declaration to the end of that declaration.</p>
<p>• <strong>Namespace scope:</strong>  </p>
<p>A name is called a namespace member name if it is defifined in a namespace (§3.3) outside any function, lambda (§5.5), class (§2.2, §2.3, Chapter 4), or enumclass (§2.5). Its scope extends from the point of declaration to the end of its namespace.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> cnt = <span class="number">-1</span> ;</span><br><span class="line">	cout &lt;&lt; ::cnt &lt;&lt; endl;	<span class="comment">// 输出全局</span></span><br><span class="line">	cout &lt;&lt; cnt &lt;&lt; endl;	<span class="comment">// 输出局部</span></span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>



<p><strong>Note：</strong> </p>
<p>An object must be constructed (initialized) before it is used and will be destroyed at the end of its scope. For a namespace object the point of destruction is the end of the program. For a member, the point of destruction is determined by the point of destruction of the object of which it is a member. An object created by new ‘‘lives’’ until destroyed by delete 562. User-Degined Types</p>
<h2 id="几个关键字"><a href="#几个关键字" class="headerlink" title="几个关键字"></a>几个关键字</h2><h3 id="Constants"><a href="#Constants" class="headerlink" title="Constants"></a>Constants</h3><p><strong>Const:</strong> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">const: meaning roughly &quot;I promise not to change this value.&quot; This is used primarily to specify interfaces, so that data can be passed to functions without fear of it being modified.the compiler enforces the promise made by const</span></span><br><span class="line"><span class="comment">意思是大致是 “保证不会改变这个值。” 这主要用于指定接口，以便数据可以传递给函数而不用担心它被修改。编译器强制执行Const</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<p><strong>Contexptr:</strong> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">constexpr: meaning roughly &quot;to be evaluated at compile time.’&quot; This is used primarily to specify constants, to allow lacement of data in read-only memory (where it is unlikely to be corrupted) and for performance.</span></span><br><span class="line"><span class="comment">含义大致“在编译时进行评估。”这主要用于指定常量，以允许在只读存储器中放置数据（不太可能损坏）和性能。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<p><strong>Sample:</strong> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> dmv = <span class="number">17</span>; <span class="comment">// dmv is a named constant</span></span><br><span class="line"><span class="type">int</span> var = <span class="number">17</span>; <span class="comment">// var is not a constant</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">double</span> max1 = <span class="number">1.4</span>∗<span class="built_in">square</span>(dmv); <span class="comment">// OK if square(17) is a constant expression</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">double</span> max2 = <span class="number">1.4</span>∗<span class="built_in">square</span>(var); <span class="comment">// error : var is not a constant expression</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> max3 = <span class="number">1.4</span>∗<span class="built_in">square</span>(var); <span class="comment">// OK, may be evaluated at run time</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">sum</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">double</span>&gt;&amp;)</span></span>; <span class="comment">// sum will not modify its argument (§1.8)</span></span><br><span class="line">vector&lt;<span class="type">double</span>&gt; v &#123;<span class="number">1.2</span>, <span class="number">3.4</span>, <span class="number">4.5</span>&#125;; <span class="comment">// v is not a constant</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> s1 = <span class="built_in">sum</span>(v); <span class="comment">// OK: evaluated at run time</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">double</span> s2 = <span class="built_in">sum</span>(v); <span class="comment">// error : sum(v) not constant expression</span></span><br></pre></td></tr></table></figure>



<h3 id="2-2-类型转换"><a href="#2-2-类型转换" class="headerlink" title="2.2 类型转换"></a>2.2 类型转换</h3><p>C++自动执行的类型转换：</p>
<ul>
<li>将一种算数类型的值赋给另一种算术类型bian</li>
<li>表达式中包含不同的类型时，C++将对值进行转换</li>
<li>将参数传递给函数时，C++将对值进行转换</li>
</ul>
<p><strong>初始化和赋值进行的转换：</strong> </p>
<ul>
<li>从 int 到 float、double、这些空间比原始空间大的，一般不会出问题</li>
<li>从 double、float 等到 int 的转换会出现截断，造成数据丢失</li>
<li>将一个值赋给取值范围更大的类型通常不会导致什么问题</li>
</ul>
<p><strong>潜在的数值转换问题：</strong> </p>
<table>
<thead>
<tr>
<th align="left">转换</th>
<th>潜在的问题</th>
</tr>
</thead>
<tbody><tr>
<td align="left">将较大浮点类型转换为较小的浮点类型，如将double转换成float</td>
<td>精度（有效数位）降低值可能超出目标类型的范围，在这种情况下。结果将是不确定的</td>
</tr>
<tr>
<td align="left">将浮点类型转换为整型</td>
<td>小数部分丢失，原来的值可能超出目标类型的取值范围，在这种情况下，结果将是不确定的（较小的值只是截断小数部分）</td>
</tr>
<tr>
<td align="left">将较大的整型转换为较小的整型，如将long转换为short</td>
<td>原来的值可能超出目标类型的范围，通常只复制右边的字节（低位）</td>
</tr>
</tbody></table>
<p>将0赋给bool变量时，将被转换为false，而非零值将被转换为true。</p>
<p><strong>以 { } 方式进行初始化时进行的转换（C++11)：</strong>  </p>
<p>C++将使用大括号的初始化称为初始化列表（list-initialization），因为这种初始化常用于给更复杂的数据类型提供值列表。与使用赋值运算符的初始化方式相比，它对类型转换的要求更严格。具体地说，列表初始化不允许缩窄（narrowing），及变量的类型可能无法表示赋给它的值。例如，不允许将浮点型转换成整型。在不同的整型之间或将整型转换成浮点型可能被允许，条件是编译器知道目标变量能够正确的存储赋给它的值。例如：将long变量初始化为int值，因为long总是至少和int一样长；相反方向的转换也可能被允许，只要int变量能够存储赋给它的long常量。</p>
<p><strong>表达式中的转换：</strong> </p>
<p>当同一个表达式中包含两种不同的算术类型时，C++将执行两种类型转换：</p>
<ol>
<li>一些类型在出现时便会自行转换；</li>
<li>有些类型在与其他类型同时出现在表达式中时将被转换。</li>
</ol>
<ul>
<li>自动转换：</li>
</ul>
<p> 在计算表达式时，C++将bool、char、unsigned char、signed char和short值转换为int。具体地说，true将被转换成1，false将被转换成0.这些转换被称为整型提升（integral promotion）（通常将int类型选择为计算机最自然的类型，这意味着计算机使用这种类型时，运算速度可能最快）。</p>
<ul>
<li>另外一些整型提升：如果short比int短，则unsigned int类型将被转换为int；如果两种类型的长度相同，则unsigned short类型将被转换为unsigned int。这种规则确保了在对unsignedshort进行提升时不会损失数据。同样地，wchar_t将被提升为下列类型中第一个宽度足够存储wchar_t取值范围的类型：int、unsigned int、long或者unsigned long。</li>
<li>将不同类型进行算术运算时，也会进行一些转换，例如将int和float相加时（使用的是双精度浮点型运算方式）。当运算涉及两种类型时，较小的类型将被转换为较大的类型。</li>
<li>校验表：<ol>
<li>如果有一个操作数的类型是long double，则将另一个操作数转换为long double。</li>
<li>否则，如果有一个操作数的类型是double，则将另一个操作数转换为double。</li>
<li>否则，如果有一个操作数的类型是float，则将另一个操作数的类型转换为float。</li>
<li>否则，说明操作数都是整型，因此执行整型提升。</li>
<li>在这种情况下，如果两个操作数都是由符号或无符号的，且其中一个操作数的级别比另一个低，则转换为级别高的类型。</li>
<li>如果一个操作数位有符号的，另一个操作数位无符号的，且无符号操作数的级别比有符号操作数高，则将有符号操作数转换为无符号操作数所属的类型。</li>
<li>否则，如果有符号类型可表示无符号类型的所有可能取值，则将无符号操作数转换为有符号操作数所属的类型</li>
<li>否则，将两个操作数都转换为有符号类型的无符号版本。</li>
</ol>
</li>
</ul>
<p><strong>传递参数时的转换：</strong> </p>
<p>传递参数时的类型转换通常由C++函数原型控制。然而，也可以取消原型对参数传递的控制，尽管这样做并不明智。在这种情况下，C++将对char和short欸行（signed和unsigned）应用整型提升。另外，为保持与传统C语言中大量代码的兼容性，再将参数传递给取消原型对参数传递控制的函数时，C++将float参数提升为double。</p>
<p><strong>强制类型转换：</strong> </p>
<p>C++还允许通过强制类型转换机制显式地进行类型转换，（C++认识到，必须有类型转换，而又时又需要推翻这些规则）。强制类型转换的格式有两种。例如，为将存储在变量thron中的int值转换为long类型，可以使用下属表达式中的一种：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">long</span>) thron;	<span class="comment">// returns a type long conversion of thron</span></span><br><span class="line"><span class="built_in">long</span> (thron);	<span class="comment">// returns a type long conversion of thron</span></span><br></pre></td></tr></table></figure>

<p>强制类型转换并不会修改变量本身，而是创建一个新的指定类型的值，可以在表达式中使用这个值。比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="built_in">int</span>(<span class="string">&#x27;Q&#x27;</span>); <span class="comment">//displays the integer code for &#x27;Q&#x27;</span></span><br></pre></td></tr></table></figure>

<p>强制类型转换地通用格式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(typeName) value;	<span class="comment">// converts value to typeName type</span></span><br><span class="line"><span class="built_in">typeName</span> (value)	<span class="comment">// call opaerator() overload functuion, converts value to typeName type</span></span><br></pre></td></tr></table></figure>

<p>第一种格式来自C语言，第二种格式是纯粹的C++。新格式的想法时，要让强制类型转换就像是函数调用（其实就是函数调用，调用的是运算符 () 重载函数）。这样对内置类型地强制转换就像是位用户定义的类设计的类型转换。</p>
<h3 id="2-3-User-defined-data-type"><a href="#2-3-User-defined-data-type" class="headerlink" title="2.3 User_defined data type"></a>2.3 User_defined data type</h3><p><strong>Structures:</strong> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">The first step in building a new type is often to organize the elements it needs into a data structure,</span></span><br><span class="line"><span class="comment">a struct:</span></span><br><span class="line"><span class="comment">struct Vector &#123;</span></span><br><span class="line"><span class="comment">int sz; // number of elements</span></span><br><span class="line"><span class="comment">double∗ elem; // pointer to elements</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">We use . (dot) to access struct members through a name (and through a reference) and −&gt; to</span></span><br><span class="line"><span class="comment">access struct members through a pointer.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<p><strong>Classes：</strong> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Having the data specified separately from the operations on it has advantages, such as the ability to</span></span><br><span class="line"><span class="comment">use the data in arbitrary ways. However, a tighter connection between the representation and the</span></span><br><span class="line"><span class="comment">operations is needed for a user-defined type to have all the properties expected of a ‘‘real type.’’ In</span></span><br><span class="line"><span class="comment">particular, we often want to keep the representation inaccessible to users, so as to ease use, guarantee consistent use of the data, and allow us to later improve the representation. To do that we have</span></span><br><span class="line"><span class="comment">to distinguish between the interface to a type (to be used by all) and its implementation (which has</span></span><br><span class="line"><span class="comment">access to the otherwise inaccessible data). The language mechanism for that is called a class. A</span></span><br><span class="line"><span class="comment">class is defined to have a set of members, which can be data, function, or type members. The interface is defined by the public members of a class, and private members are accessible only through</span></span><br><span class="line"><span class="comment">that interface.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<p><strong>Unions:</strong> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">A union is a struct in which all members are allocated at the same address so that the union occupies only as much space as its largest member. Naturally, a union can hold a value for only one</span></span><br><span class="line"><span class="comment">member at a time. For example, consider a symbol table entry that holds a name and a value:</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Type</span> &#123; str, num &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Entry</span> &#123;</span><br><span class="line"><span class="type">char</span>∗ name;</span><br><span class="line">Type t;</span><br><span class="line"><span class="type">char</span>∗ s; <span class="comment">// use s if t==str</span></span><br><span class="line"><span class="type">int</span> i; <span class="comment">// use i if t==num</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Entry∗ p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p−&gt;t == str)</span><br><span class="line">cout &lt;&lt; p−&gt;s;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Maintaining the correspondence between a type field (here, t) and the type held in a union is error-prone. To avoid errors, one can encapsulate a union so that the correspondence between a type field and access to the union members is guaranteed. At the application level, abstractions relying on such tagged unions are common and useful, but use of &quot;naked&quot; unions is best minimized.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<p><strong>Enumerations:</strong> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Enumerations are used to represent small sets of integer values. They are used to make code more readable and less error-prone than it would have been had the symbolic (and mnemonic) enumerator names not been used.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">By default, an enum class has only assignment, initialization, and comparisons (e.g., == and &lt; )defined</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">If you don’t want to explicitly qualify enumerator names and want enumerator values to be ints (without the need for an explicit conversion), you can remove the class from enum class to get a &quot;plain&quot; enum. The enumerators from a &quot;plain&quot; enum are entered into the same scope as the name of their enum and implicitly converts to their integer value.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">By default, the integer values of enumerators starts with 0 and increases by one for each additional enumerator. The &quot;plain&quot; enums hav e been in C++ (and C) from the earliest days, so even though they are less well behaved, they are common in current code.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 红、黄、蓝、白、黑 五种颜色的球若干，每次取三个，每次去出的三个球颜色都不同的情况满足要求</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Display</span><span class="params">(<span class="type">int</span> color)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">color_set</span>&#123; red, yellow, blue, white, black &#125;;    <span class="comment">// 可以在定义枚举提示声明枚举变量</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = red; i &lt;= black; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = red; j &lt;= black; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i != j)  <span class="comment">// 前两个球颜色不一样再继续判断</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(k = red; k  &lt;= black; k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(i != k &amp;&amp; j != k)</span><br><span class="line">                    &#123;</span><br><span class="line">                        cout &lt;&lt; ++count;</span><br><span class="line">                        cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">15</span>);</span><br><span class="line">                        <span class="built_in">Display</span>(i);</span><br><span class="line">                        cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">15</span>);</span><br><span class="line">                        <span class="built_in">Display</span>(j);</span><br><span class="line">                        cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">15</span>);</span><br><span class="line">                        <span class="built_in">Display</span>(k);</span><br><span class="line">                        cout &lt;&lt; endl;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Display</span><span class="params">(<span class="type">int</span> color)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(color)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>: cout &lt;&lt; <span class="string">&quot;black&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: cout &lt;&lt; <span class="string">&quot;white&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: cout &lt;&lt; <span class="string">&quot;blue&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: cout &lt;&lt; <span class="string">&quot;yellow&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: cout &lt;&lt; <span class="string">&quot;red&quot;</span>;  <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: cout &lt;&lt; <span class="string">&quot;Wrong color!&quot;</span> &lt;&lt; endl; <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-4-指针与OOP原理"><a href="#2-4-指针与OOP原理" class="headerlink" title="2.4 指针与OOP原理"></a>2.4 指针与OOP原理</h3><p>面向对象编程与传统的过程性编程的区别在于，OOP强调的是在运行阶段（而不是在编译阶段）进行决策。运行阶段指的是程序正在运行时，编译阶段指的是编译器将程序结合起来时。运行阶段决策就好比度假时，训责参观那些经典取决于天气和当时的心情；而编译阶段决策更像不管在什么条件下，都坚持预先设定的日程安排。</p>
<p>运行阶段决策体供了灵活性，可以根据当时的情况进行调整。例如，考虑为数组分配内存的情况。传统的方法是声明一个数组。要在C++中声明数组，必须指定数组的长度。因此，数组长度在程序编译时就设定好了；这就是编译阶段决策。</p>
<p>程序员可能认为，在80%的情况下，一个包含20个元素的数组就足够了，但程序有时需要处理200个元素。为了安全起见，使用了一个包含200个元素的数组。这样，程序在大多数情况下都浪费了内存。OOP通过将这样的决策推迟到运行阶段进行，使程序更灵活。在程序运行后，可以这次告诉它只需要20个元素，而还可以下次告诉它需要205个元素。</p>
<p>总之，使用OOP时，可以在运行阶段确定数组长度。为使用这种方法，语言必须允许在程序运行时创建数组。C++采取的方法是，使用关键字new请求正确数量的内存以及指针来追踪新分。配的内存的位置。</p>
<p>在运行阶段做决策并非OOP独有的，但是用C++编写这样的代码比C语言简单。</p>
<p>​    </p>
<h2 id="程序的内存模型"><a href="#程序的内存模型" class="headerlink" title="程序的内存模型"></a>程序的内存模型</h2><p>a. 代码区：存放函数体的二进制代码，由操作系统进行管理</p>
<p>b.全局区：存放全局变量、静态变量以及常量</p>
<p>c.栈  区：由编译器自动分配释放，存放函数的参数值、局部变量等</p>
<p>d.堆  区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收</p>
<p><img src="https://s2.loli.net/2023/03/25/Bwo1nzFTvKCDaNh.jpg" alt="内存分区模型"></p>
<h3 id="程序执行前"><a href="#程序执行前" class="headerlink" title="程序执行前"></a>程序执行前</h3><p><img src="https://s2.loli.net/2023/03/25/XFYZC3pj5Mqi2ze.png" alt="程序执行前"></p>
<p><strong>代码区和全局区</strong> </p>
<p>局部常量（const修饰的局部变量）和局部变量都不在全局区内</p>
<p>常量区中存放const修饰的全局变量和字符串常量</p>
<h3 id="代码执行过程后"><a href="#代码执行过程后" class="headerlink" title="代码执行过程后"></a>代码执行过程后</h3><p><strong>栈区</strong> </p>
<p> <img src="https://s2.loli.net/2023/03/25/frGMSoFXnJHbqcC.png" alt="栈区"></p>
<p>形参和局部变量也是存放在栈区中</p>
<p><strong>堆区</strong> </p>
<p><img src="https://s2.loli.net/2023/03/25/HGIj3whTRl7kX6Y.png" alt="堆区"> </p>
<h3 id="使用new操作符"><a href="#使用new操作符" class="headerlink" title="使用new操作符"></a>使用new操作符</h3><p><strong>基础语法：</strong> </p>
<p>使用new的方法：</p>
<p>创建单个数据：数据类型* 指针名 = new 数据类型(数值)；</p>
<p>创建数组：数据类型* 指针名 = new 数据类型[数据个数]；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//堆区的数据由程序员管理开辟释放，如果想要释放队却的数据则可以使用关键字delete</span><br><span class="line">//delete p;</span><br><span class="line">//cout &lt;&lt; *p &lt;&lt; endl;//使用了delete清除数据之后再进行输出操作会出现warning，在运行中程序异常中断,因为内存已释放，禁止非法访问</span><br><span class="line">//释放数组空间的操作：delete后面加[]</span><br><span class="line">//delete[] arr;</span><br></pre></td></tr></table></figure>

<p><strong>释放空间的方式</strong> </p>
<p>如果是单个数据则仅需delete 数据名 以分号结尾即可</p>
<p>如果是整个数组则需要delete[] 数组指针 以分号结尾</p>
<p><strong>特性</strong> ：定位new运算符</p>
<p>通常，new负责在堆中找到一个足以满足要求的内存块。new运算符还有另一种变体，被称为定位new运算符，它能让程序员指定要使用的位置。程序员可能使用这种特性来设置其内存管理规程，处理需要通过特定地址访问的硬件或在特定位置创建对象。</p>
<p>要使用定位new运算符特性，首先需要包含头文件new，它提供了这种版本的bew运算符原型；然后将new运算符用于提供了地址的参数，除需要指定参数外，句法与常规new运算符相同。具体地说，使用new定位运算符时，变量后面可以有方括号，也可以没有。下面演示new运算符的4种用法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;new&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">chaff</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> dross[<span class="number">20</span>];</span><br><span class="line">  <span class="type">int</span> slag;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">char</span> buffer1[<span class="number">50</span>];</span><br><span class="line"><span class="type">char</span> buffer2[<span class="number">500</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    chaff *p1, *p2;</span><br><span class="line">    <span class="type">int</span> *p3, *p4;</span><br><span class="line">    <span class="comment">// first, the regular forms of new</span></span><br><span class="line">    p1 = <span class="keyword">new</span> chaff;	<span class="comment">// place structure in heap</span></span><br><span class="line">    p3 = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">20</span>];	<span class="comment">//place int array in heap</span></span><br><span class="line">    <span class="comment">// now, the two forms of placement new</span></span><br><span class="line">    p2 = <span class="built_in">new</span> (buffer1) chaff;	<span class="comment">// place structure in buffer1</span></span><br><span class="line">    p4 = <span class="built_in">new</span> (buffer2) <span class="type">int</span>[<span class="number">20</span>];	<span class="comment">// place int array in buffer2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>使用两个静态数组来定位new运算符提供内存空间。因此，上述代码从buffer1中分配空间给结构chaff，从buffer2中分配空间给一个包含20个元素的int数组。
</code></pre>
<h3 id="自动存储、静态存储和动态存储"><a href="#自动存储、静态存储和动态存储" class="headerlink" title="自动存储、静态存储和动态存储"></a>自动存储、静态存储和动态存储</h3><ol>
<li>自动存储</li>
</ol>
<p> 在函数内部定义的常规变量使用自动存储空间，被称为自动变量（局部变量，声明时可以省略auto关键字），他们在所属函数被调用时产生，在该函数结束时消亡。</p>
<p> 自动变量通常存储在栈中。这意味着执行代码块时，其中的变量依次加入到栈中，而在离开代码块时，将按相反的顺序释放这些变量，这被称为后进先出（LIFO）。因此。在程序执行过程中，栈不断的增大和缩小。</p>
<ol start="2">
<li>静态存储</li>
</ol>
<p>静态存储是整个程序执行期间都存在的存储方式。使变量成为静态的方式有两种：一种是在函数外面定义它；另一种是在声明时使用关键字static：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">double</span> fee = <span class="number">56.50</span>;</span><br></pre></td></tr></table></figure>

<p>在K&amp;R C中，只能初始化静态数组和静态结构，而C++ Release 2.0（及后续版本） 和 ANSI C中，也可以初始化自动数组和自动结构。</p>
<p>自动存储和静态存储的关键在于：这些方法严格地限制了变量的寿命。变量可能存在于程序的整个生命周期（静态变量），也可能只是在特定函数被执行时存在（自动变量）。</p>
<ol start="3">
<li>动态存储</li>
</ol>
<p>new 和 delete 运算符提供了一种比自动变量和静态变量更灵活的方式。他们管理了一个内存池，这在C++中被称为自由存储空间（free store）或堆（heap）。该内存池同用于静态变量和自动变量的内存是自动分开的。new和delete让程序员对程序和使用内存有更大的控制权。然而，内存管理也更复杂了。在栈中，自动添加和删除机制使得占用的内存总是连续的但new和delete的互相影响可能导致占用的自由存储区不连续，这使得追踪新分配的位置更困难。</p>
<p><strong>栈、堆和内存泄露</strong> </p>
<p> 如果使用new运算符在自由存储空间（或堆）上创建变量之后，没有调用delete，则即使包含指针的内存由于作用域规则和对象生命周期的原因被释放，在自由存储空间上动态分配的变量或结构也将继续存在。实际上，将会无法访问自由存储空间中的结构，因为指向这些内存的指针无效。这导致内存泄漏被泄漏的内容将在程序的整个生命周期内都不可使用；这些内训被分配出去，但无法收回。极端情况（不过不常见）使，内存泄漏可能非常严重，以致于应用程序可用的内存被耗尽，出现内存耗尽错误，导致程序崩溃。另外，这种泄露还会给一些操作系统或在相同的内存空间中运行的应用程序带来负面影响，导致他们崩溃。</p>
<p> 即使是最好的程序员和软件公司，也可能导致内存泄漏。要避免内存泄露，最好是养成一种习惯，即同时使用new和delete运算符，在自由存储空间上动态分配内存，随后便释放它。C++智能指针有助于完成这种事情。</p>
<p><strong>注意：</strong> 指针是功能强大的C++工具之一，但也最危险，因为他们执行对计算机不太友好的操作，如使用未经初始化的指针来访问内存或者试图释放同一个内存块两次。另外，在通过实践习惯指针表示法和指针概念之前，指针时容易引起迷惑的。由于指针式C++编程的重要组成部分，后续会更加深入的讨论它。</p>
<p><strong>基于范围的for循环</strong> </p>
<p>C++11新增了一种循环，基于范围的（range_based）的for循环。这简化了一种常见的循环任务：对数组（或容器类，如vector和array）的每个元素执行相同的操作，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> prices[<span class="number">5</span>] = &#123; <span class="number">4.99</span>, <span class="number">10.99</span>, <span class="number">6.87</span>, <span class="number">7.99</span>, <span class="number">8.49</span> &#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">double</span> x : prices)</span><br><span class="line">	cout &lt;&lt; x &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p> 其中，x最初表示数组prices的第一个元素。显示第一个元素后，不断执行循环，而x依次表示数组的其他元素。因此，上述代码i显示全部5个元素，每个元素各占一行。总之，该循环显示数组中的各个值。</p>
<p> 要修改数组的元素，需要使用不同的循环变量语法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">double</span> &amp;x : prices)</span><br><span class="line">	x *= <span class="number">0.80</span>;	<span class="comment">// 20% off for sale</span></span><br></pre></td></tr></table></figure>

<p> 符号&amp;表明x是一个引用变量，这种声明让接下来的代码能够修改数组的内容，而第一种语法不能。这种用法主要是用在各种模板容器的遍历中。</p>
<h2 id="cin-get-ch-与cin-get"><a href="#cin-get-ch-与cin-get" class="headerlink" title="cin.get(ch)与cin.get()"></a>cin.get(ch)与cin.get()</h2><table>
<thead>
<tr>
<th>属性</th>
<th>cin.get(ch)</th>
<th>ch = cin.get()</th>
</tr>
</thead>
<tbody><tr>
<td>传递输入字符的方式</td>
<td>赋给参数ch</td>
<td>将函数返回值赋给ch</td>
</tr>
<tr>
<td>用于字符输入时函数的返回值</td>
<td>istream对象（执行bool转换后为true）</td>
<td>int类型的字符串编码</td>
</tr>
<tr>
<td>达到EOF时函数的返回值</td>
<td>istream对象（执行bool转换后为false）</td>
<td>EOF</td>
</tr>
</tbody></table>
<pre><code>使用字符参数版本更符合对象方式，因为其返回值是istream对象。这意味着可以将他们拼接起来。
</code></pre>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cin.<span class="built_in">get</span>(ch1).<span class="built_in">get</span>(ch2);	<span class="comment">// 这种方式也是可行的</span></span><br></pre></td></tr></table></figure>

<p>因为函数调用cin.get(ch1)返回一个cin对象，然后便可以通过该对象调用get(ch2)。</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><h3 id="引用的基础语法"><a href="#引用的基础语法" class="headerlink" title="引用的基础语法"></a>引用的基础语法</h3><ol>
<li>int a=10;</li>
<li>int &amp;b=a;</li>
<li>b=20;</li>
<li>cout &lt;&lt; a     &lt;&lt;endl;//输出为20</li>
</ol>
<p>引用相当于给数据添加了一个别名或者叫绰号，通过引用进行的操作都是对地址的操作，对b进行赋值操作后，a的值也会改变（内存是同一块）</p>
<h3 id="引用的注意事项"><a href="#引用的注意事项" class="headerlink" title="引用的注意事项"></a>引用的注意事项</h3><ol>
<li>引用必须初始化</li>
<li>引用一旦初始化就不得更改，只要做了a的引用就不能再成为b的引用</li>
</ol>
<p>注意：如果引用了函数中定义的的局部变量，对其的第一次输出操作可以正常执行，但是超过一次，输出将为随机数</p>
<h3 id="引用作为函数的参数（形参）"><a href="#引用作为函数的参数（形参）" class="headerlink" title="引用作为函数的参数（形参）"></a>引用作为函数的参数（形参）</h3><p>在函数中进行交换数值的操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap03</span><span class="params">(<span class="type">int</span>&amp; a,<span class="type">int</span>&amp; b)</span></span></span><br><span class="line"><span class="function"><span class="comment">//这里是接收形参的操作，也是进行引用的操作，只是“绰号与原名相同”</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;由于进行过一次交换操作，下面一次交换的结果应与第一次相同&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;swap03形参:&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;swap03形参:&quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">swap03</span>(a, b);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;swap03实参:&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;swap03实参:&quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>能够实现交换两个数的数值的目的</p>
<h3 id="引用做函数的返回值"><a href="#引用做函数的返回值" class="headerlink" title="引用做函数的返回值"></a>引用做函数的返回值</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//引用做函数的返回值</span></span><br><span class="line"><span class="comment">//1.不要返回局部变量的引用</span></span><br><span class="line"><span class="comment">//2.函数的调用可以作为左值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1 */</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;<span class="comment">//局部变量，储存在栈区，程序运行结束后由操作系统回收内存</span></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2 */</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> a = <span class="number">10</span>;<span class="comment">//静态变量，储存于全局区，生存周期较长</span></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.局部变量引用做函数返回值</span></span><br><span class="line">    <span class="type">int</span>&amp; ref = <span class="built_in">test01</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ref=&quot;</span> &lt;&lt; ref &lt;&lt; endl;<span class="comment">//编译器保留的</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ref=&quot;</span> &lt;&lt; ref &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; endl;<span class="comment">//输出随机数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>&amp; ret = <span class="built_in">test02</span>();<span class="comment">//使用引用接收返回值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ret=&quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ret=&quot;</span> &lt;&lt; ret&lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>() = <span class="number">1000</span>;<span class="comment">//函数返回值是个引用，进行赋值操作后，输出的是赋给的值</span></span><br><span class="line">    <span class="comment">//（这样的赋值操作是直接对内存中存储的值进行更改），因此ret的值会随之改变</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ret=&quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ret=&quot;</span> &lt;&lt; ret &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="引用的本质"><a href="#引用的本质" class="headerlink" title="引用的本质"></a>引用的本质</h3><p>引用的本质在C++内部实现是一个指针常量</p>
<p>C++推荐使用引用，因为语法比较简单，实质上引用本身也是指针，只不过一些不容易理解的指针操作都由编译器代替我们做了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">	</span><br><span class="line"><span class="comment">//发现是引用即将其转换为：int* const ref = &amp;a;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>&amp; ref)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ref = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//自动转换为 int* const ref = &amp;a; 常量指针是指向的地址不可改，这里解释了引用不可更改的原因</span></span><br><span class="line">	<span class="type">int</span>&amp; ref = a;</span><br><span class="line">	</span><br><span class="line">	ref = <span class="number">20</span>;<span class="comment">//内部发现ref是引用，自动转换为：*ref=20。</span></span><br><span class="line">		</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref:&quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">func</span>(a);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="CV-限定符"><a href="#CV-限定符" class="headerlink" title="CV-限定符"></a>CV-限定符</h3><p><strong>const使用方式</strong> </p>
<p><img src="https://s2.loli.net/2023/03/25/bt43VWGzN76ULfy.png" alt="const使用方式"> </p>
<p>将引用参数声明为常量数据的引用的理由：</p>
<ul>
<li>使用const可以避免无意中修改数据的编程错误</li>
<li>使用const引用使函数能够处理const和非const实参，否则将只接受非const数据</li>
<li>使用const引用使函数能够正确生成并使用临时变量</li>
</ul>
<p><strong>volatile使用方式</strong> </p>
<p>菜鸟教程：<a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/c-volatile-keyword.html">https://www.runoob.com/w3cnote/c-volatile-keyword.html</a></p>
<p>volatile产生的主要原因是操作系统会偏向于将经常使用的值存入寄存器，这种情况下数据的读取速度会更快，但是由于变量可能会在任何时候发生变化（如，在其它程序的影响下，多线程情况下等），所以为了避免使用时拿到的值不是变量的真实值，需要告诉操作系统，每次使用这个值的时候都从内存读取，而不是从寄存器中取。</p>
<h3 id="常量引用"><a href="#常量引用" class="headerlink" title="常量引用"></a>常量引用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用场景：用来修饰函数形参，防止误操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShowValue</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//val=1000;//添加了const以后会报错，但是加了const以后，可以不用担心变量的值在函数内被无端改变</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;val=&quot;</span> &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//int&amp; ref = a;//这里是可以的，只是如果不同数据类型的变量名相同会导致程序运行失败。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//int&amp; ref=10;//错误，引用的必须是合适的内存地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//const int&amp; ref = 10;</span></span><br><span class="line">    <span class="comment">//正确，但是其实是两步操作。</span></span><br><span class="line">    <span class="comment">//1.int temp = 10;</span></span><br><span class="line">    <span class="comment">//2.const int&amp; ref = &amp;temp;//需要理解常量指针是偏向于 “指针” ，而不是偏向于常量。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//ref = 20;//错误，</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>&amp; ref = a;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ref=&quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">ShowValue</span>(a);<span class="comment">//ShowValue(ref);</span></span><br><span class="line">    <span class="comment">//再次输出查看值是否改变</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ref=&quot;</span> &lt;&lt; ref &lt;&lt; endl;<span class="comment">//输出a还是ref是没有区别的</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2023/03/25/WekYUpNq7QjvZis.png" alt="const使用理由"></p>
<h2 id="Classes-and-Objects"><a href="#Classes-and-Objects" class="headerlink" title="Classes and Objects"></a>Classes and Objects</h2><ul>
<li>C++面向对象的三大特性：封装，继承，多态。</li>
<li>C++中认为一切都可以视为对象，对象有属性和行为</li>
</ul>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p><strong>意义：</strong> </p>
<ul>
<li>将属性作和行为作为一个整体，表示生活中的事物；</li>
<li>将属性和行为加以权限控制</li>
<li>意义一的体现形式：创建圆类，创建一个具体的圆，进行相关的操作。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="number">3.14</span>;<span class="comment">//#define PI 3.14</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建圆这个类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">circle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//访问权限</span></span><br><span class="line">    <span class="comment">//公共权限</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="comment">//半径</span></span><br><span class="line">    <span class="type">double</span> r;<span class="comment">//或者 int r;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取圆的周长的函数</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">calculate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * PI * r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;              &lt;&lt;&lt;------注意这个分号</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//通过圆这个类，创建一个具体的圆</span></span><br><span class="line">    circle c1;</span><br><span class="line">    c1.r = <span class="number">10</span>;          &lt;---调用类中元素的方式</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;圆的周长为：&quot;</span> &lt;&lt; c1.<span class="built_in">calculate</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="C-内联函数"><a href="#C-内联函数" class="headerlink" title="C++内联函数"></a>C++内联函数</h3><p>  内联函数时C++为提高程序运行速度所做的一项改进。常规函数与内联函数之间的主要区别不在于编写方式。而在于C++编译器如何将他们组合到程序中。要了解他们之间的区别，必须深入到程序内部。</p>
<p>  编译过程的最终产品时可执行程序——由一组机器语言指令组成。运行程序时，操作系统将这些指令载入到计算机的内存中，因此每一条指令都有特定的地址。计算机随后将逐步执行这些指令。有时（如有循环或分支语句时），将跳过一些指令，向前或向后跳到特定地址。常规函数调用也是程序跳到另一个地址（函数的地址），并在函数结束时返回。典型实现：执行到函数调用指令时，程序将在函数调用后立即存储该指令的内存地址，并将参数复制到堆栈中（为此保留的内存块），跳到标记函数的起点的内存单元，执行函数代码（也许还需将返回值放入到寄存器中），然后跳回到地址被保存的指令处。来回跳跃位置意味着以前使用函数时，需要一定的开销。</p>
<p>  C++内联函数提供了另一种选择。内联函数的编译代码与其他程序代码“内联“起来了。也就是说，编译器将使用相应的代码替换函数调用，程序无需跳转到另一个位置执行代码，再调回来。因此，内联函数的运行速度比常规函数稍快，但代价是需要占用更多的内存。<strong>如果程序在10个不同的地方来回调用同一个内联函数，则程序将包含该函数代码的10个副本（使用函数体替换函数调用，占用代码区内存）</strong>。</p>
<p>  应有选择地使用内联函数。如果执行函数代码的时间比处理函数调用机制的时间长，则节省的时间将只占整个过程的很小一部分。如果大妈执行的时间很短，则内联函数调用就可以节省非内联函数调用使用的大部分时间。另一方面，由于这个过程相当快，因此尽管节省了该过程的大部分时间，但节省的时间绝对值并不大，除非该函数经常被调用。</p>
<pre><code>要使用这些特性，必须采取下属措施之一：
</code></pre>
<ul>
<li><p>函数声明前加上关键字inline</p>
</li>
<li><p>函数定义前加上关键字inline</p>
<p>通常做法是省略原型，将/个定义（即函数头和所有函数代码）放在本应提供原型的地方。程序员请求将函数作为内联函数时，编译器不一定会满足这种请求。它可能认为该函数过大或者注意到函数调用了自己（内联函数不能递归），因此，部将其作为内联函数；而头屑编译器没有启用或实现这种特性。</p>
</li>
</ul>
<h3 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h3><ul>
<li>Public: 成员类内类外均可访问</li>
<li>Protected: 成员类内可访问，类外不可访问</li>
<li>Private: 成员类内可访问，类外不可访问</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">访问权限：</span></span><br><span class="line"><span class="comment">1、公共权限 public 成员类内可用，类外也可用</span></span><br><span class="line"><span class="comment">2、受保护权限 protected 成员类内可用，类外不可用</span></span><br><span class="line"><span class="comment">3、私有权限 private 成员类内可访问，类外不可访问</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">indvl</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string name;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	string car;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> pwd = <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span><span class="comment">//函数也可以添加属性</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		name = <span class="string">&quot;zs&quot;</span>;</span><br><span class="line">		car = <span class="string">&quot;桂C 0987&quot;</span>;</span><br><span class="line">		pwd = <span class="number">12345</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	indvl p1;</span><br><span class="line">	p1.name = <span class="string">&quot;zhangsan&quot;</span>;</span><br><span class="line">	<span class="comment">//p1.car = &quot;贵C 0987&quot;;不可访问</span></span><br><span class="line">	<span class="comment">//p1.pwd = 23456;不可访问</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="Structures-and-Classes"><a href="#Structures-and-Classes" class="headerlink" title="Structures and Classes"></a>Structures and Classes</h3><ul>
<li>struct默认访问权限为public</li>
<li>class默认访问权限为private</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct默认访问权限为public</span></span><br><span class="line"><span class="comment">class默认访问权限为private</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">p</span></span><br><span class="line">&#123;</span><br><span class="line">	string p_name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">stu</span></span><br><span class="line">&#123;</span><br><span class="line">	string s_name;</span><br><span class="line">	<span class="type">int</span> age = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">p</span> p1;</span><br><span class="line">	p1.p_name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">stu</span> s1;</span><br><span class="line">	<span class="comment">//s1.s_name = &quot;李思思&quot;;//不可访问</span></span><br><span class="line">	<span class="comment">//s1.age = 18;//不可访问</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="类设置为私有"><a href="#类设置为私有" class="headerlink" title="类设置为私有"></a>类设置为私有</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">成员属性设置为私有的优点：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1、可以自己控制读写权限(由程序员控制)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2、对于写可以检测数据的有效性</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>虽然在类外不能直接访问类内成员，但是可以通过定义具有public属性的函数来对类内元素进行访问</p>
<ul>
<li>函数一：设置元素的值</li>
<li>函数二：获取或接收元素的值</li>
</ul>
<p>类中元素使用“.”调用与结构体类似；类中函数的调用方式与类中元素的调用一致。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">成员属性设置为私有：</span></span><br><span class="line"><span class="comment">1、可以自己控制读写权限(由程序员控制)</span></span><br><span class="line"><span class="comment">2、对于写可以检测数据的有效性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设计一个人的“类”</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">indvl</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//姓名 要求可读可写</span></span><br><span class="line">	string i_name;</span><br><span class="line">	<span class="comment">//年龄 要求只读 -&gt; 可读可写</span></span><br><span class="line">	<span class="type">int</span> i_age = <span class="number">0</span>;<span class="comment">//一般都需要初始化，否则输出为乱码；</span></span><br><span class="line">	<span class="comment">//爱人 要求只写</span></span><br><span class="line">	string i_lover;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//设置姓名</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">set_name</span><span class="params">(string name)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		i_name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取姓名</span></span><br><span class="line">	<span class="function">string <span class="title">get_name</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> i_name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//设置年龄</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">set_age</span><span class="params">(<span class="type">int</span> age)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (age &gt;= <span class="number">0</span> &amp;&amp; age &lt;= <span class="number">150</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			i_age = age;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/*i_age = 0;*/</span></span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;这是个老妖精！&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取年龄</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">get_age</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		i_age = <span class="number">18</span>;<span class="comment">//默认值</span></span><br><span class="line">		<span class="keyword">return</span> i_age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//设置爱人</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">set_lover</span><span class="params">(string lover)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		i_lover = lover;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	indvl p;</span><br><span class="line">	p.<span class="built_in">set_name</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名为：&quot;</span> &lt;&lt; p.<span class="built_in">get_name</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;年龄为：&quot;</span> &lt;&lt; p.<span class="built_in">get_age</span>() &lt;&lt; endl;<span class="comment">//不允许直接改年龄，只能读</span></span><br><span class="line"></span><br><span class="line">	p.<span class="built_in">set_lover</span>(<span class="string">&quot;王冰冰&quot;</span>);</span><br><span class="line">	<span class="comment">//cout&lt;&lt; &quot;爱人是：&quot; &lt;&lt; p.i_lover &lt;&lt; endl;禁止访问i_lover</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-5-案例"><a href="#5-5-案例" class="headerlink" title="5.5 案例"></a>5.5 案例</h3><h4 id="5-5-1-立方体"><a href="#5-5-1-立方体" class="headerlink" title="5.5.1 立方体"></a>5.5.1 立方体</h4><ul>
<li>判断两个立方体相等的方式为判断两个立方体的体积和表面积是否同时相等</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">立方体设计：</span></span><br><span class="line"><span class="comment">1、创建立方体类</span></span><br><span class="line"><span class="comment">2、设计属性和行为</span></span><br><span class="line"><span class="comment">3、分别利用全局函数和成员函数判断两个立方体是否相等</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cube</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//公共权限，提供对类中元素和函数的调用</span></span><br><span class="line">    <span class="comment">//设置长</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_len</span><span class="params">(<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_l = len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//读取长</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_len</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置宽</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_wid</span><span class="params">(<span class="type">int</span> wid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_w = wid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//读取宽</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_wid</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置高</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_hei</span><span class="params">(<span class="type">int</span> hei)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_h = hei;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//读取高</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_hei</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算表面积</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">calculate_S</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">2</span> * m_l * m_h + <span class="number">2</span> * m_l * m_w + <span class="number">2</span> * m_w * m_h);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">calculate_V</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (m_l * m_w * m_h);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//成员函数判断是否相等</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">judgement_c_m</span><span class="params">(Cube &amp;c1,Cube &amp;c2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (c1.s == c2.s &amp;&amp; c1.v == c2.v)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_l;</span><br><span class="line">    <span class="type">int</span> m_w;</span><br><span class="line">    <span class="type">int</span> m_h;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> s;</span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line">&#125;;<span class="comment">//根据实际开发经验，要求类内元素访问权限为私有</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">equal</span><span class="params">(<span class="type">int</span> s1,<span class="type">int</span> s2,<span class="type">int</span> v1,<span class="type">int</span> v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s1 == s2 &amp;&amp; v1 == v2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Cube c1;<span class="comment">//立方体一</span></span><br><span class="line"></span><br><span class="line">    c1.<span class="built_in">set_len</span>(<span class="number">10</span>);</span><br><span class="line">    c1.<span class="built_in">set_wid</span>(<span class="number">10</span>);</span><br><span class="line">    c1.<span class="built_in">set_hei</span>(<span class="number">20</span>);</span><br><span class="line">    c1.s = c1.<span class="built_in">calculate_S</span>();</span><br><span class="line">    c1.v = c1.<span class="built_in">calculate_V</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;表面积为：&quot;</span> &lt;&lt; c1.s &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;体积为：&quot;</span> &lt;&lt; c1.v &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Cube c2;<span class="comment">//立方体二</span></span><br><span class="line"></span><br><span class="line">    c2.<span class="built_in">set_len</span>(<span class="number">10</span>);</span><br><span class="line">    c2.<span class="built_in">set_wid</span>(<span class="number">10</span>);</span><br><span class="line">    c2.<span class="built_in">set_hei</span>(<span class="number">18</span>);</span><br><span class="line">    c2.s = c2.<span class="built_in">calculate_S</span>();</span><br><span class="line">    c2.v = c2.<span class="built_in">calculate_V</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;表面积为：&quot;</span> &lt;&lt; c2.s &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;体积为：&quot;</span> &lt;&lt; c2.v &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> rst = <span class="built_in">equal</span>(c1.s, c1.v, c2.s, c2.v);</span><br><span class="line">    <span class="keyword">if</span> (rst)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;全局函数：两个立方体是相等的&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;全局函数：两个立方体不相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rst = c2.<span class="built_in">judgement_c_m</span>(c1,c2);<span class="comment">//终究是函数，直接调用，跟输入和计算都顺序无关</span></span><br><span class="line">    <span class="keyword">if</span> (rst)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;类内函数：两个立方体是相等的&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;类内函数：两个立方体不相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="5-5-2-点和圆的位置关系"><a href="#5-5-2-点和圆的位置关系" class="headerlink" title="5.5.2 点和圆的位置关系"></a>5.5.2 点和圆的位置关系</h4><p><strong>主要思想为：</strong> </p>
<ul>
<li>类中调用其他类：圆类调用点类（圆心）。</li>
<li>类的内容信息（如类中函数声明、类名、访问权限等）一般放在“.h”头文件中，通过包含头文件可以同样可以实现目标。</li>
<li>类中函数的具体实现可以另存在如“circle.cpp”和“point.cpp”中，而且“circle.cpp”和“point.cpp”必须调用“.h”头文件而主函数所在的文件中不需要调用“circle.cpp”和“point.cpp”</li>
</ul>
<p>point.h</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Point</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	//设置横坐标</span><br><span class="line">	void Set_X(int x);</span><br><span class="line"></span><br><span class="line">	//接收横坐标</span><br><span class="line">	int Get_X();</span><br><span class="line"></span><br><span class="line">	//设置纵坐标</span><br><span class="line">	void Set_Y(int y);</span><br><span class="line">	</span><br><span class="line">	//接收纵坐标</span><br><span class="line">	int Get_Y();</span><br><span class="line">	</span><br><span class="line">private:</span><br><span class="line">	int m_X;</span><br><span class="line">	int m_Y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>point.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;06 point.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置横坐标</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Point::Set_X</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	m_X = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接收横坐标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Point::Get_X</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> m_X;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置纵坐标</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Point::Set_Y</span><span class="params">(<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	m_Y = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接收纵坐标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Point::Get_Y</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> m_Y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>circle.h</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;06 point.h&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//设置半径</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Set_R</span><span class="params">(<span class="type">int</span> r)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//接收半径</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Get_R</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//设置圆心</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Set_Center</span><span class="params">(Point center)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//接收圆心</span></span><br><span class="line">	<span class="function">Point <span class="title">Get_Center</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_R;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//以类为类中成员</span></span><br><span class="line">	Point m_center;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>点和圆的位置关系.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;06 point.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;06 circle.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//企业开发中往往将类中的权限设为私有</span></span><br><span class="line"><span class="comment">//如果需要进行必要的访问则可以选择设置接口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//class Point</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//public:</span></span><br><span class="line"><span class="comment">//	//设置横坐标</span></span><br><span class="line"><span class="comment">//	void Set_X(int x)</span></span><br><span class="line"><span class="comment">//	&#123;</span></span><br><span class="line"><span class="comment">//		m_X = x;</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"><span class="comment">//	//接收横坐标</span></span><br><span class="line"><span class="comment">//	int Get_X()</span></span><br><span class="line"><span class="comment">//	&#123;</span></span><br><span class="line"><span class="comment">//		return m_X;</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"><span class="comment">//	//设置纵坐标</span></span><br><span class="line"><span class="comment">//	void Set_Y(int y)</span></span><br><span class="line"><span class="comment">//	&#123;</span></span><br><span class="line"><span class="comment">//		m_Y	 = y;</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"><span class="comment">//	//接收纵坐标</span></span><br><span class="line"><span class="comment">//	int Get_Y()</span></span><br><span class="line"><span class="comment">//	&#123;</span></span><br><span class="line"><span class="comment">//		return m_Y;</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"><span class="comment">//private:</span></span><br><span class="line"><span class="comment">//	int m_X;</span></span><br><span class="line"><span class="comment">//	int m_Y;</span></span><br><span class="line"><span class="comment">//&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//class Circle</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//public:</span></span><br><span class="line"><span class="comment">//	//设置半径</span></span><br><span class="line"><span class="comment">//	void Set_R(int r)</span></span><br><span class="line"><span class="comment">//	&#123;</span></span><br><span class="line"><span class="comment">//		m_R = r;</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"><span class="comment">//	//接收半径</span></span><br><span class="line"><span class="comment">//	int Get_R()</span></span><br><span class="line"><span class="comment">//	&#123;</span></span><br><span class="line"><span class="comment">//		return m_R;</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"><span class="comment">//	//设置圆心</span></span><br><span class="line"><span class="comment">//	void Set_Center(Point center)</span></span><br><span class="line"><span class="comment">//	&#123;</span></span><br><span class="line"><span class="comment">//		m_center = center;</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"><span class="comment">//	//接收圆心</span></span><br><span class="line"><span class="comment">//	Point Get_Center()</span></span><br><span class="line"><span class="comment">//	&#123;</span></span><br><span class="line"><span class="comment">//		return m_center;</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"><span class="comment">//private:</span></span><br><span class="line"><span class="comment">//	int m_R;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	//以类为类中成员</span></span><br><span class="line"><span class="comment">//	Point m_center;</span></span><br><span class="line"><span class="comment">//&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断点和圆的位置关系</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Position</span><span class="params">(Circle &amp;c,Point &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> dt;</span><br><span class="line">	<span class="type">int</span> dr;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//计算两点之间距离的平方的关系</span></span><br><span class="line">	dt = (c.<span class="built_in">Get_Center</span>().<span class="built_in">Get_X</span>() - p.<span class="built_in">Get_X</span>()) * (c.<span class="built_in">Get_Center</span>().<span class="built_in">Get_X</span>() - p.<span class="built_in">Get_X</span>())+</span><br><span class="line">	(c.<span class="built_in">Get_Center</span>().<span class="built_in">Get_Y</span>() - p.<span class="built_in">Get_Y</span>()) * (c.<span class="built_in">Get_Center</span>().<span class="built_in">Get_Y</span>() - p.<span class="built_in">Get_Y</span>());</span><br><span class="line"></span><br><span class="line">	<span class="comment">//计算半径的平方</span></span><br><span class="line">	dr = c.<span class="built_in">Get_R</span>() * c.<span class="built_in">Get_R</span>();</span><br><span class="line">	<span class="comment">//判断关系</span></span><br><span class="line">	<span class="keyword">if</span> (dt==dr)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;点在圆上&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (dt &gt; dr)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;点在圆外&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;点在圆内&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//创建一个圆</span></span><br><span class="line">	Circle c;</span><br><span class="line">	c.<span class="built_in">Set_R</span>(<span class="number">10</span>);</span><br><span class="line">	Point center;</span><br><span class="line">	center.<span class="built_in">Set_X</span>(<span class="number">10</span>);</span><br><span class="line">	center.<span class="built_in">Set_Y</span>(<span class="number">0</span>);</span><br><span class="line">	c.<span class="built_in">Set_Center</span>(center);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建一个点（圆内）</span></span><br><span class="line">	Point p1;</span><br><span class="line">	p1.<span class="built_in">Set_X</span>(<span class="number">10</span>);</span><br><span class="line">	p1.<span class="built_in">Set_Y</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建第二个点（圆外）</span></span><br><span class="line">	Point p2;</span><br><span class="line">	p2.<span class="built_in">Set_X</span>(<span class="number">10</span>);</span><br><span class="line">	p2.<span class="built_in">Set_Y</span>(<span class="number">11</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建第三个点（圆上）</span></span><br><span class="line">	Point p3;</span><br><span class="line">	p3.<span class="built_in">Set_X</span>(<span class="number">10</span>);</span><br><span class="line">	p3.<span class="built_in">Set_Y</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断点和圆的位置关系</span></span><br><span class="line">	<span class="built_in">Position</span>(c,p1);</span><br><span class="line">	<span class="built_in">Position</span>(c,p2);</span><br><span class="line">	<span class="built_in">Position</span>(c,p3);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-6-对象特性"><a href="#5-6-对象特性" class="headerlink" title="5.6 对象特性"></a>5.6 对象特性</h3><h4 id="5-6-1-构造函数和析构函数"><a href="#5-6-1-构造函数和析构函数" class="headerlink" title="5.6.1 构造函数和析构函数"></a>5.6.1 构造函数和析构函数</h4><p>（1）构造函数 初始化类 没有返回值不写void</p>
<ul>
<li>构造函数的名称与类名一致可以有参数，可以发生重载</li>
<li>创建类的时候会对进行调用而且只调用一次</li>
</ul>
<p>（2）析构函数 进行清理操作 没有返回值不写void</p>
<ul>
<li>析构函数的名称与类名一致 在名称前面加~</li>
<li> 析构函数不可以有参数 不能发生重载</li>
<li> 对象在销毁前会对析构函数进行调用而且只调用一次</li>
</ul>
<p><strong>注意：</strong> </p>
<ul>
<li>构造函数和析构函数都是一定会有的实现，如果程序员不写，那么编译器会自动生成空实现的构造函数和析构函数    </li>
<li>对于建立在不通过代码区域的对象来说析构函数的调用时机不同</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象的初始化和清理</span></span><br><span class="line"><span class="comment">//1、构造函数进行初始化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 1.构造函数 初始化类 没有返回值不写void</span></span><br><span class="line">	<span class="comment">// 构造函数的名称与类名一致可以有参数，可以发生重载</span></span><br><span class="line">	<span class="comment">// 创建类的时候会对进行调用而且只调用一次</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person构造函数的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 2.析构函数 进行清理操作 没有返回值不写void</span></span><br><span class="line">	<span class="comment">// 析构函数的名称与类名一致 在名称前面加~</span></span><br><span class="line">	<span class="comment">// 析构函数不可以有参数 不能发生重载</span></span><br><span class="line">	<span class="comment">// 对象在销毁前会对析构函数进行调用而且只调用一次</span></span><br><span class="line">	~<span class="built_in">Person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person析构函数的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数和析构函数都是一定会有的实现，如果程序员不写，那么编译器会自动生成空实现的构造函数和析构函数	</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person p;<span class="comment">//建立在栈上的数据在函数运行完之后即被释放</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Person p;//对于建立在不通过代码区域的对象来说析构函数的调用时机不同</span></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="构造函数的分类及调用"><a href="#构造函数的分类及调用" class="headerlink" title="构造函数的分类及调用"></a>构造函数的分类及调用</h4><p><strong>分类：</strong>  </p>
<ul>
<li>按照参数可以分为   有参构造和无参构造（默认构造）</li>
<li>按照类型可以分为   普通构造和拷贝构造</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数的分类及调用</span></span><br><span class="line"><span class="comment">//分类</span></span><br><span class="line"><span class="comment">//按照参数可以分为   有参构造和无参构造（默认构造）</span></span><br><span class="line"><span class="comment">//按照类型可以分为   普通构造和拷贝构造</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">man</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//普通构造：</span></span><br><span class="line">	<span class="comment">//无参构造</span></span><br><span class="line">	<span class="built_in">man</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;man构造函数的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//有参构造</span></span><br><span class="line">	<span class="built_in">man</span>(<span class="type">int</span> a)</span><br><span class="line">	&#123;</span><br><span class="line">		age = a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//拷贝构造函数（只做复制不做修改所以使用const，传输地址所以使用引用）</span></span><br><span class="line">	<span class="built_in">man</span>(<span class="type">const</span> man &amp;m)</span><br><span class="line">	&#123;</span><br><span class="line">		age = m.age;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;man拷贝构造函数的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">man</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;man析构函数的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> age=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//1.括号法</span></span><br><span class="line">	<span class="comment">//man m1;//默认构造函数调用</span></span><br><span class="line">	<span class="comment">//man m2(10);//调用有参构造函数</span></span><br><span class="line">	<span class="comment">//man m3(m2);//调用拷贝构造函数</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//注意事项1：</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	* 调用默认构造函数时不要加()，如果使用“Man m1();”的话，编译器自动认为这给语句为函数声明</span></span><br><span class="line"><span class="comment">	* 返回值为man的一个类，函数名为m1。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;m2的年龄为：&quot; &lt;&lt; m2.age &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//				//输出结果均为10</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;m3的年龄为：&quot; &lt;&lt; m3.age &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.显示法</span></span><br><span class="line">	man m1;</span><br><span class="line">	man m2=<span class="built_in">man</span>(<span class="number">10</span>);<span class="comment">//有参构造</span></span><br><span class="line">	man m3 = <span class="built_in">man</span>(m2);<span class="comment">//拷贝构造</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 匿名对象:</span></span><br><span class="line">	<span class="comment">// man(10);//特点：当前行结束后	系统立即处理匿名对象</span></span><br><span class="line">	<span class="comment">// cout &lt;&lt; &quot;aaa&quot; &lt;&lt; endl;//会看到打印aaa之前有默认构造函数以及默认析构函数的调用痕迹（输出）</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//注意事项2：</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	* 不要用拷贝构造函数初始化匿名对象</span></span><br><span class="line"><span class="comment">	* 例如：“man(m3);”针对此行代码，编译器会认为man(m3)等价于man m3；（对象声明）</span></span><br><span class="line"><span class="comment">	*又因为上文中已经定义了m3所以会提示重定义</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//3.隐式转换法</span></span><br><span class="line">	man m4 = <span class="number">10</span>;<span class="comment">//实质上等价于	man m4 = man(10); 发生有参构造函数调用</span></span><br><span class="line">	man m5 = m4;<span class="comment">//拷贝构造</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong> </p>
<ul>
<li>注意事项1：  <ul>
<li>调用默认构造函数时不要加()，如果使用“Man m1();”的话，编译器自动认为这给语句为函数声明</li>
<li>返回值为man的一个类，函数名为m1。</li>
</ul>
</li>
<li>注意事项2：<ul>
<li>不要用拷贝构造函数初始化匿名对象</li>
<li>例如：“man(m3);”针对此行代码，编译器会认为man(m3)等价于man m3；（对象声明）</li>
<li>又因为上文中已经定义了m3所以会提示重定义</li>
</ul>
</li>
</ul>
<h4 id="拷贝构造函数的使用时机"><a href="#拷贝构造函数的使用时机" class="headerlink" title="拷贝构造函数的使用时机"></a>拷贝构造函数的使用时机</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">man</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">man</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;man默认构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">man</span>(<span class="type">int</span> a)</span><br><span class="line">	&#123;</span><br><span class="line">		m_age = a;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;man有参构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">man</span>(<span class="type">const</span> man &amp;p)</span><br><span class="line">	&#123;</span><br><span class="line">		m_age = p.m_age;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;man拷贝构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">man</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;man析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> m_age = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拷贝构造函数调用时机</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.使用一个已经创建完毕的对象来初始化一个新对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">man <span class="title">m1</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">man <span class="title">m2</span><span class="params">(m1)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;m1的年龄：&quot;</span> &lt;&lt; m1.m_age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;m2的年龄：&quot;</span> &lt;&lt; m2.m_age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.值传递的方式给函数参数传值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(man m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;test02()调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	man m;<span class="comment">//调用默认构造和析构函数</span></span><br><span class="line">	<span class="built_in">func</span>(m);<span class="comment">//调用拷贝构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.值传递方式返回局部对象</span></span><br><span class="line"><span class="function">man <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	man m_1;<span class="comment">//局部变量，函数结束即回收空间</span></span><br><span class="line">	cout &lt;&lt; &amp;m_1 &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> m_1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	man m = <span class="built_in">func1</span>();<span class="comment">//m_1已经被回收，所以这个m的地址跟m_1的地址绝对不同</span></span><br><span class="line">	cout &lt;&lt; &amp;m &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*test01();</span></span><br><span class="line"><span class="comment">	test02();*/</span></span><br><span class="line">	<span class="built_in">test03</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="构造函数调用规则"><a href="#构造函数调用规则" class="headerlink" title="构造函数调用规则"></a>构造函数调用规则</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数的调用规则</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.创建一个类，C++编译器至少给这个类添加三个函数</span></span><br><span class="line"><span class="comment">构造函数（空实现）</span></span><br><span class="line"><span class="comment">析构函数（空实现）</span></span><br><span class="line"><span class="comment">拷贝构造函数（值拷贝）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2.如果创建了有参构造函数，编译器将不再提供无参构造函数，但是依然提供拷贝构造函数</span></span><br><span class="line"><span class="comment">如果写了拷贝构造函数编译器将不再提供其他普通构造函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">man</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">/*man()</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		cout &lt;&lt; &quot;man默认构造函数调用&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">man</span>(<span class="type">int</span> a)</span><br><span class="line">	&#123;</span><br><span class="line">		m_age = a;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;man有参构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">man</span>(<span class="type">const</span> man&amp; p)</span><br><span class="line">	&#123;</span><br><span class="line">		m_age = p.m_age;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;man拷贝构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">man</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;man析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> m_age = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//void test01()</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//	man m;</span></span><br><span class="line"><span class="comment">//	m.m_age = 18;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	man m1(m);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	cout &lt;&lt; &quot;m1的年龄为：&quot; &lt;&lt; m1.m_age &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">man <span class="title">m2</span><span class="params">(<span class="number">28</span>)</span></span>;</span><br><span class="line">	<span class="function">man <span class="title">p</span><span class="params">(m2)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*test01();*/</span></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="5-6-5-深拷贝与浅拷贝"><a href="#5-6-5-深拷贝与浅拷贝" class="headerlink" title="5.6.5 深拷贝与浅拷贝"></a>5.6.5 深拷贝与浅拷贝</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> m_age = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span>* height = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>



<p><strong>浅拷贝：</strong> </p>
<p>指的是在拷贝对象时，只进行简单的赋值操作，这种行为带来的影响是：如果对象中包含建立在堆区的数据，并且使用指针指向这块内存地址，浅拷贝操作只是将这块内存的地址复制过来，但是并没有独立开辟空间。两个对象中只要有一个对指针的值进行了改动，另一个也会跟着受到牵连。析构会对这一块内存重复释放。</p>
<p><strong>深拷贝：</strong> </p>
<p>使用new操作符或者malloc函数在堆区开辟数据，使指针成员指向这块内存。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">man</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">man</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;man默认构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">man</span>(<span class="type">int</span> a , <span class="type">int</span> Height)</span><br><span class="line">	&#123;</span><br><span class="line">		m_age = a;</span><br><span class="line">		height = <span class="keyword">new</span> <span class="built_in">int</span>(Height);</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;man有参构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		解决方案是给复制后的值另new一块内存单元，将相同的数据被存储到不同的内存中之后，</span></span><br><span class="line"><span class="comment">		再执行析构函数就不会有任何问题了</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="built_in">man</span>(<span class="type">const</span> man&amp; m)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;man 拷贝构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="comment">//height = m.height;//编译器的默认浅拷贝实现</span></span><br><span class="line">		m_age = m.m_age;</span><br><span class="line">		<span class="comment">//深拷贝操作：</span></span><br><span class="line">		height = <span class="keyword">new</span> <span class="built_in">int</span>(*m.height);<span class="comment">//括号里的必须是数据，不能是地址。</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	~<span class="built_in">man</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//析构代码，将程序员在堆区上开辟的空间释放掉</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		*   浅拷贝的操作是将指针指向的地址拷贝下来，其带来的问题是堆区的内存有被重复释放的可能</span></span><br><span class="line"><span class="comment">		* </span></span><br><span class="line"><span class="comment">		*	触发断点的原理是：堆区上的数据被释放的过程是遵循后进先出的原则的，</span></span><br><span class="line"><span class="comment">		*   当析构函数判断出m2.height不为空时即释放内存中的内容，此内存单元被置为不可访问的状态，m2.height被置为空</span></span><br><span class="line"><span class="comment">		*   但是m1.height不为空，此时程序还需要再对m1.height进行一次释放，</span></span><br><span class="line"><span class="comment">		*   此时的操作被编译器认作非法操作</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		<span class="keyword">if</span> (height != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> height;</span><br><span class="line">			height = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;man析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> m_age = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span>* height = <span class="literal">NULL</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">man <span class="title">m1</span><span class="params">(<span class="number">18</span>, <span class="number">170</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;m1的年龄为：&quot;</span> &lt;&lt; m1.m_age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;m1的身高为：&quot;</span> &lt;&lt; *m1.height &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="function">man <span class="title">m2</span><span class="params">(m1)</span></span>;<span class="comment">//在程序员没有写拷贝构造函数的情况下成功实现了拷贝构造的功能，虽然只是简单的复制操作，此即为浅拷贝</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;m2的年龄为：&quot;</span> &lt;&lt; m2.m_age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;m2的身高为：&quot;</span> &lt;&lt; *m2.height &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="构造函数初始化列表"><a href="#构造函数初始化列表" class="headerlink" title="构造函数初始化列表"></a>构造函数初始化列表</h4><p>本质上是在构造函数调用成员类型的构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">indavl</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//traditional initializing mathod</span></span><br><span class="line">	<span class="comment">/*indavl(int a, int b, int c)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		m_a = a;</span></span><br><span class="line"><span class="comment">		m_b = b;</span></span><br><span class="line"><span class="comment">		m_c = c;</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化列表法</span></span><br><span class="line">	<span class="comment">//构造函数形参列表之后给冒号</span></span><br><span class="line">	<span class="built_in">indavl</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c) :<span class="built_in">m_a</span>(a), <span class="built_in">m_b</span>(b), <span class="built_in">m_c</span>(c)<span class="comment">//灵活赋值</span></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> m_a;</span><br><span class="line">	<span class="type">int</span> m_b;</span><br><span class="line">	<span class="type">int</span> m_c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*indavl i1(10, 20, 30);*/</span></span><br><span class="line">	<span class="function">indavl <span class="title">i1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; i1.m_a &lt;&lt;endl &lt;&lt; i1.m_b &lt;&lt; endl  &lt;&lt; i1.m_c &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="5-6-7-类作为其它类的成员"><a href="#5-6-7-类作为其它类的成员" class="headerlink" title="5.6.7 类作为其它类的成员"></a>5.6.7 类作为其它类的成员</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Phone</span>(string Mp_name)</span><br><span class="line">	&#123;</span><br><span class="line">		m_pname = Mp_name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Phone</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Phone的析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string m_pname;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Phone m_Phone = pName;等价于Phone(pName);</span></span><br><span class="line">	<span class="built_in">Person</span>(string name, string pName): <span class="built_in">m_Name</span>(name),<span class="built_in">m_Phone</span>(pName)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person的构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person的析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string m_Name;</span><br><span class="line">	Phone m_Phone;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当将其他类作为类的成员的时候，需要先构造类对象再构造自身</span></span><br><span class="line"><span class="comment">//析构的顺序是相反的，即先释放自身类的对象随后释放成员类的对象</span></span><br><span class="line"><span class="comment">//类似先进后出，先出后进</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;苹果MAX&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot;拿着&quot;</span> &lt;&lt; p.m_Phone.m_pname &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="5-6-8-静态成员变量"><a href="#5-6-8-静态成员变量" class="headerlink" title="5.6.8 静态成员变量"></a>5.6.8 静态成员变量</h4><p><strong>静态成员变量：</strong> </p>
<ol>
<li>所有对象共享同一套数据</li>
<li>编译阶段分配内存</li>
<li>类内声明，类外初始化</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">静态成员变量：</span></span><br><span class="line"><span class="comment">1、所有对象共享同一套数据</span></span><br><span class="line"><span class="comment">2、编译阶段分配内存</span></span><br><span class="line"><span class="comment">3、类内声明，类外初始化</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//静态成员变量：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">num</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//默认为私有属性</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//类内声明</span></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> m_a;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//静态成员变量也有访问权限，与其他所有私有成员一样类外不可访问</span></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类外初始化</span></span><br><span class="line"><span class="type">int</span> num::m_a = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> num::m_b = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	num p;</span><br><span class="line">	cout &lt;&lt; p.m_a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	num p2;</span><br><span class="line">	p2.m_a = <span class="number">200</span>;</span><br><span class="line">	cout &lt;&lt; p.m_a &lt;&lt; endl;<span class="comment">//200</span></span><br><span class="line">	cout &lt;&lt; p2.m_a &lt;&lt; endl;<span class="comment">//200</span></span><br><span class="line">	<span class="comment">//数据共有，一个改变，其余的也会随之改变</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//静态成员变量不属于某一个对象，而是所有对象共享一份数据</span></span><br><span class="line">	<span class="comment">//访问方式:</span></span><br><span class="line">	<span class="comment">//1、通过对象进行访问</span></span><br><span class="line">	num n1;</span><br><span class="line">	cout &lt;&lt; n1.m_a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、通过类名进行访问</span></span><br><span class="line">	cout &lt;&lt; num::m_a &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; num::m_b &lt;&lt; endl;//不可访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="5-6-9-静态成员函数"><a href="#5-6-9-静态成员函数" class="headerlink" title="5.6.9 静态成员函数"></a>5.6.9 静态成员函数</h4><p><strong>静态成员函数：</strong> </p>
<ol>
<li>所有对象共用一个函数</li>
<li>静态成员函数只能访问静态成员变量</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">静态成员函数：</span></span><br><span class="line"><span class="comment">1、所有对象共用一个函数</span></span><br><span class="line"><span class="comment">2、静态成员函数只能访问静态成员变量，没有this指针</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">num</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//静态成员函数</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//静态成员函数能够访问静态成员变量</span></span><br><span class="line">		m_a = <span class="number">100</span>;</span><br><span class="line">		<span class="comment">//m_b = 200;//静态成员函数不可访问非静态成员变量</span></span><br><span class="line">		<span class="comment">//因为静态成员函数无法区分是哪个对象的m_b（静态成员变量共用数据，非静态成员变量与之不同）；</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;静态成员函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> m_a;</span><br><span class="line">	<span class="type">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num::m_a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//1、通过对象访问</span></span><br><span class="line">	num p;</span><br><span class="line">	p.<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、通过类名访问</span></span><br><span class="line">	num::<span class="built_in">func</span>();</span><br><span class="line">	<span class="comment">//私有属性类外不可访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="5-6-10-C-对象模型"><a href="#5-6-10-C-对象模型" class="headerlink" title="5.6.10 C++对象模型"></a>5.6.10 C++对象模型</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//成员函数和成员变量是分开存储的</span></span><br><span class="line"><span class="comment">// 静态成员函数和静态成员变量只有一份，所以它不是任何一个对象的私有属性</span></span><br><span class="line"><span class="comment">// 空对象占用的空间为 1 bit</span></span><br><span class="line">   <span class="comment">// C++会给每个空的对象分配一字节的空间，目的是区分空的对象在内存中的位置</span></span><br><span class="line">   <span class="comment">// 每个空对象都应该有一个独一无二的内存地址</span></span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数和成员变量是分开存储的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">empty_class</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态成员函数和静态成员变量只有一份，所以它不是任何一个对象的私有属性</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">num</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> m_a;<span class="comment">//非静态成员函数，属于类上</span></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> m_b;<span class="comment">//静态成员变量，不属于类上的元素</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;&#125;<span class="comment">//非静态成员函数，不属于类上</span></span><br><span class="line">	     </span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;&#125;<span class="comment">//静态成员函数，不属于类上</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	empty_class e;</span><br><span class="line">	<span class="comment">//空对象占用的空间为1bit</span></span><br><span class="line">	    <span class="comment">//C++会给每个空的对象分配一字节的空间，目的是区分空的对象在内存中的位置</span></span><br><span class="line">    <span class="comment">//每个空对象都应该有一个独一无二的内存地址</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;size of an empty class is &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(e) &lt;&lt; endl;<span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">	num n;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;size of n is &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(n) &lt;&lt; endl;<span class="comment">//4</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="5-6-11-this指针"><a href="#5-6-11-this指针" class="headerlink" title="5.6.11 this指针"></a>5.6.11 this指针</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 每一个非静态成员函数只会诞生一份函数实例，即多个对象会共用同一串代码</span></span><br><span class="line"><span class="comment">* 这一节主要解决：被不同对象调用的同一串代码如何判断是哪一个对象调用的自己</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*			this指针指向被调成员函数所属对象</span></span><br><span class="line"><span class="comment">*			this指针是隐含在所有非静态成员函数内的一种指针，即静态成员函数中没有this指针</span></span><br><span class="line"><span class="comment">*			无需声明，直接调用即可</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* this指针的用途</span></span><br><span class="line"><span class="comment">* 1、当形参与成员函数名相同时，可以使用this指针来区分</span></span><br><span class="line"><span class="comment">* 2、在类的非静态成员函数下返回对象本身，可使用return *this</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">num</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:	</span><br><span class="line">	<span class="built_in">num</span>(<span class="type">int</span> value)<span class="comment">//添加this指针之后形参和赋值号右边的值被视为同一个变量</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//value = value;//无法输出正常值</span></span><br><span class="line">		<span class="comment">//this指针指向被调成员函数所属对象</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;value = value;<span class="comment">//this指向的变量与类内的value属性被视为同一类变量</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">num&amp; <span class="title">func</span><span class="params">(num&amp; p)</span><span class="comment">//引用的实质即为根据内存找单元改内容，不加地址符改不动数值</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; value;</span><br><span class="line">		<span class="keyword">this</span>-&gt;value += p.value;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">//返回本身的话，p-&gt;age的值返回为增加后的值，再次调用则在原来的基础上再加</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、解决命名冲突问题</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">num <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1的值为：&quot;</span> &lt;&lt; p1.value &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、返回对象本身使用*this</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">num <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">num <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//链式编程思想</span></span><br><span class="line">	p2.<span class="built_in">func</span>(p1).<span class="built_in">func</span>(p1).<span class="built_in">func</span>(p1);<span class="comment">//把别人的值加到自身</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2的值为：&quot;</span> &lt;&lt; p2.value &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="5-6-12-空指针调用成员函数"><a href="#5-6-12-空指针调用成员函数" class="headerlink" title="5.6.12  空指针调用成员函数"></a>5.6.12  空指针调用成员函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//空指针调用成员函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">num</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;this is a function inside num class.&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> == <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//这里的value对于空指针来说是未开辟的，访问操作非法</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;value is &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;value &lt;&lt; endl;<span class="comment">//value等价于this-&gt;value</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	num* p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	p-&gt;<span class="built_in">func1</span>();<span class="comment">//单独正常输出，因为这一行代码没有涉及到内存空间问题</span></span><br><span class="line"></span><br><span class="line">	p-&gt;<span class="built_in">func2</span>();<span class="comment">//因为p为空，没有分配内存地址就去访问内存当然会崩</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="5-6-13-const修饰成员函数"><a href="#5-6-13-const修饰成员函数" class="headerlink" title="5.6.13 const修饰成员函数"></a>5.6.13 const修饰成员函数</h4><p>常指针函数：</p>
<ul>
<li>1、成员函数加const之后称为常函数</li>
<li>2、常函数内部不可修改成员</li>
<li>3、成员属性声明时加关键字mutable后，在常函数内部依然可以修改成员属性</li>
</ul>
<p>常对象：</p>
<ul>
<li>1、声明对象前加const称该对象为常对象</li>
<li>2、常对象只能调用常函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 常指针函数：</span></span><br><span class="line"><span class="comment">* 1、成员函数加const之后称为常函数</span></span><br><span class="line"><span class="comment">* 2、常函数内部不可修改成员</span></span><br><span class="line"><span class="comment">* 3、成员属性声明时加关键字mutable后，在常函数内部依然可以修改成员属性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 常对象：</span></span><br><span class="line"><span class="comment">* 1、声明对象前加const称该对象为常对象</span></span><br><span class="line"><span class="comment">* 2、常对象只能调用常函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">num</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">//this指针的本质是一个常量指针，不能修改指向</span></span><br><span class="line">	<span class="comment">//const num* const this//指针指向的值以及指针指向都不可改动</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span><span class="type">const</span><span class="comment">//加在其他位置都不合适，所以干脆放在了后面</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//在没有加const之前在函数内部修改成员属性直接使用类似value = 100;/this-&gt;value = 0;的操作即可</span></span><br><span class="line">		<span class="comment">//添加const之后this-&gt;value = 0;为非法操作</span></span><br><span class="line">		<span class="comment">//this = NULL;也是非法操作</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;m_a = <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;类内普通成员函数的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> value;</span><br><span class="line">	<span class="keyword">mutable</span> <span class="type">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	num p;</span><br><span class="line">	<span class="comment">//p.display();//未提供构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> num p1;<span class="comment">//对象前面加const变为常对象</span></span><br><span class="line">	<span class="comment">//p1.value = 100;//不可修改</span></span><br><span class="line">	p1.m_a = <span class="number">100</span>;<span class="comment">//m_a是特殊值，常对象下也可以修改</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//常对象只能调用常函数</span></span><br><span class="line">	p1.<span class="built_in">display</span>();</span><br><span class="line">	<span class="comment">//p1.func();</span></span><br><span class="line">	<span class="comment">//如果常对象可以调用普通成员函数，而普通成员函数内部又对属性进行了未知修改，则会给程序员的工作增加负担</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><p>引用一篇个人觉得非常好的博客<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42683011/article/details/102087764%EF%BC%8C%E4%BB%A5%E4%B8%8B%E5%86%85%E5%AE%B9%E5%9F%BA%E6%9C%AC%E4%B8%8A%E8%BD%AC%E8%87%AA%E6%AD%A4%E5%8D%9A%E5%AE%A2%E3%80%82">https://blog.csdn.net/qq_42683011/article/details/102087764，以下内容基本上转自此博客。</a></p>
<p><strong>重载</strong> </p>
<p>是指同一可访问区内被声明的几个具有不同参数列（参数的类型，个数，顺序不同）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型。</p>
<p><strong>重写：</strong> </p>
<p>是指派生类中存在重新定义的函数。其函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致。只有函数体不同（花括号内），派生类调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有virtual修饰。</p>
<p><strong>重载和重写的区别：</strong><br>（1）范围区别：重写和被重写的函数在不同的类中，重载和被重载的函数在同一类中。</p>
<p>（2）参数区别：重写与被重写的函数参数列表一定相同，重载和被重载的函数参数列表一定不同。</p>
<p>（3）virtual的区别：重写的基类函数必须要有virtual修饰，重载函数和被重载函数可以被virtual修饰，也可以没有。</p>
<p><strong>Advice：</strong> </p>
<ul>
<li>有些运算符必须作为类成员被重载(下面具体说明)</li>
<li>复合赋值运算符(+=, -=, *=, /=, %=等), 通常来说应该作为类成员, 但C++标准没有强制</li>
<li>改变对象状态的运算符, 与给定类型密切相关的运算符(如++自增,–-自减, *解引用), 通常作为类成员</li>
<li>具有对称性的运算符(即左右操作数互换后不影响重载运算符内部操作的, 如算数运算符, 关系运算符等)通常作为普通函数或友元函数</li>
</ul>
<p><strong>限制：</strong> </p>
<ul>
<li>实际上，operator能重载的运算符只有运算符对操作数的操作，不能改变其他东西。</li>
</ul>
<ol>
<li>operator重载相应的运算符时仍需要遵守其原定语法，不能将双目运算符重载为单目运算符（实际上也是编译器判定参数的一个标准），也不能修改运算符的优先级；</li>
<li>重载运算符时不能覆盖原有运算，即操作数中必须有一个自建类型，这虽然限制了操作性，但保护了程序的正常执行；</li>
<li>只能重载原有运算符，不能创建新的运算符，比如**之类的；</li>
<li>不能重载特定运算符</li>
</ol>
<p><img src="https://s2.loli.net/2023/03/25/cQuy72A5lLCB31U.png" alt="运算符表"></p>
<ol>
<li><p>必须作为类成员函数的运算符重载：</p>
<p><strong>C++规定，= 赋值运算符，[]下标运算符，()函数调用运算符，-&gt;指针访问成员运算符，只能是类的成员不能定义为全局函数然后声明为友元。</strong> </p>
<p>因为，对于static静态成员函数，由于没有this指针，只能访问到类的static静态成员，导致无法对类对象进行操作，而对于友元函数，编译器在类中寻找是否存在自建的 operator= 时，判定条件为是否有显式（explicit）地提供一个以本类或本类的引用为参数的运算符重载函数，而友元函数不属于类所有，所以编译器在类中找不到用户自定义的 operator= 函数，会自动生成默认的 operator= 函数，这样，在调用时会产生冲突（两个都合适，不知道调用哪个），所以C++限制了 operator= 的重载位置（只能在类内）；</p>
</li>
<li><p>重载运算符无法保留一些运算符原有的特性</p>
<ol>
<li> &amp;&amp;以及||，这两个运算符对算子的操作顺序无法保留；</li>
<li> &amp;&amp;以及||，这两个运算符的重载版本无法保留原有的短路求值属性；</li>
</ol>
</li>
</ol>
<p><strong>不该重载的韵运算符：</strong> </p>
<p><strong>包含与（&amp;&amp;）、或（||）、还有 取地址符（&amp;），因为在C++中已经定义了其对类对象那的操作，重载该运算符会导致其失去一部分功能，为类的使用者带来麻烦。</strong> </p>
<p><strong>参数：</strong> </p>
<p>一般的，以赋值运算符的重载版本为例，其参数是所在类的 const 类型的引用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Person &amp;p)<span class="comment">//返回引用类型避免再次调用拷贝构造函数创建副本</span></span><br></pre></td></tr></table></figure>

<p>添加const是因为：</p>
<ul>
<li>我们不希望传入的赋值模板在这个函数中遇到任何修改</li>
<li>加上const，对于函数而言，它能够接受 const 和 非const 类型的参数，如果不加 const 就只能接受 非const类型的参数</li>
</ul>
<p>使用引用的原因：</p>
<ul>
<li>避免在调用时对实参的拷贝（以传过来的参数为模板创建的临时变量）</li>
</ul>
<p><strong>返回值：</strong> </p>
<p>一般地，返回值是被赋值者的引用（但有时返回左值还是右值需要深究），即*this</p>
<ul>
<li>直接返回引用，避免再次发生拷贝（以返回对象为模板创建的临时变量）</li>
<li>更重要的是，根据赋值运算符从左到右的结合律，可以实现连续赋值，体现的是C++的链式编程思想，如果返回的是值，则执行连续赋值操作后得到的是匿名副本（不可改变的右值），再重复赋值操作就会出错</li>
</ul>
<p><strong>调用时机：</strong> </p>
<p>当使用运算符而非基本对象时，编译器会根据调用的运算符和操作数类型查找相应的重载运算符函数，如果找不到就会出错，需要格外注意的情况：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Peron p1;</span><br><span class="line">Person p2;</span><br><span class="line">p2 = p1;	<span class="comment">// 调用赋值运算符</span></span><br><span class="line">Person p3 = p1; <span class="comment">// 调用拷贝构造函数</span></span><br></pre></td></tr></table></figure>

<p>运算符的操作在类对象的定义中通常被编译器link到类的初始化，从而与真正的运算符重载无缘。</p>
<h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p><strong>作用：</strong> </p>
<ul>
<li>不同的函数函数名可以相同，提高复用性，但是函数实现的作用应当相似</li>
</ul>
<p><strong>函数重载应当满足的条件：</strong> </p>
<ol>
<li>同一个作用域下</li>
<li>函数名相同</li>
<li>参数名不同，参数个数不同或者参数顺序不同</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 引用作为重载条件</span></span><br><span class="line"><span class="comment">//2. 函数重载遇到函数默认值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 引用作为重载条件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>&amp; a)</span><span class="comment">//接收的是地址</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func(int&amp; a)的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//int 和 const int 的类型是不一样的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.2</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; a)</span><span class="comment">//接收常量</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func(const int&amp; a)的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 函数重载遇到函数默认值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a)</span><span class="comment">//没有默认参数值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func(int a)的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.2</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b=<span class="number">10</span>)</span><span class="comment">//有默认参数值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func(int a,int b=10)的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    //调用函数1.1：func(int&amp; a)</span></span><br><span class="line"><span class="comment">    int a = 10;</span></span><br><span class="line"><span class="comment">    func(a);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//func(10);//调用1.2：(const int&amp; a), 由于int&amp; a 与 10（常量） 一定不可能相等，所以只能调用函数1.2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//func2(10);//报错，无法运行，这句话可以调用2.1，也可以调用2.2，因含有二义性发生错误</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//func2(10,20);//调用函数2.2，因为有2.2参数传输到函数里</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*函数2.1无法在其他函数保留的情况下单独被调用*/</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p><strong>注意：</strong> </p>
<ul>
<li>1、如果没有运算符重载不能实现将两个一般情况下不满足直接相加的数据进行加运算，比如：新建数据类型，不满足加法运算的数据类型。编译器会报错，“没有与这些操作数匹配的’+’（或其他）运算符，操作类型为 Data +  Data（Data为类）”</li>
<li>2、运算符重载只能对自定义数据类型进行定义运算规则，默认可以进行运算的数据类型之间的运算不可改变（int+int,string+string）</li>
<li>3、运算符重载不可滥用（加中写减）</li>
</ul>
<p><strong>operator 重载运算符方式:</strong><br>    既然是用于自建类型的运算, 则其可以有两种定义方式:</p>
<ul>
<li><p>作为自建类型的成员函数, 定义在类的内部</p>
<p>此时operator的参数数目比具体重载的运算符操作数数目少一, 因为此时使用的一个隐含参数为* this, 并将其作为左操作数(第一个操作数)<br>如果需要将* this作为右操作数, 只能将operator作为友元函数</p>
</li>
<li><p>作为自建类型的友元函数, 定义在类的内部或外部</p>
<p>此时operator的参数数目与具体重载的运算符操作数数目相同<br>​</p>
</li>
</ul>
<h4 id="重载-运算符"><a href="#重载-运算符" class="headerlink" title="重载 + 运算符"></a>重载 + 运算符</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加号运算符重载</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 复习函数重载的内容：</span></span><br><span class="line"><span class="comment">* 不同函数使用相同名称通过重新定义实现不同的功能，重载的条件可以是引用（int 和 const int 的类型是不一样的，“数据类型  &amp;”和普通的“数据类型”也是不一样的），参数个数不同，参数数据类型不同，但是不能以函数的返回值类型为标准实现函数重载</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//1、成员函数实现函数重载</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//成员函数实现重载</span></span><br><span class="line">	<span class="comment">/*Data operator+(Data &amp;d)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		Data temp;</span></span><br><span class="line"><span class="comment">		temp.m_a = this-&gt;m_a + d.m_a;</span></span><br><span class="line"><span class="comment">		temp.m_b = this-&gt;m_b + d.m_b;</span></span><br><span class="line"><span class="comment">		return temp;</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> m_a;</span><br><span class="line">	<span class="type">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、全局函数实现函数重载</span></span><br><span class="line">Data <span class="keyword">operator</span>+(<span class="type">const</span> Data &amp;d1, <span class="type">const</span> Data &amp;d2)</span><br><span class="line">&#123;</span><br><span class="line">	Data temp;</span><br><span class="line">	temp.m_a = d1.m_a + d2.m_a;</span><br><span class="line">	temp.m_b = d1.m_b + d2.m_b;</span><br><span class="line">	cout &lt;&lt; temp.m_a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; temp.m_b &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运算符重载中的函数重载</span></span><br><span class="line">Data <span class="keyword">operator</span>+(<span class="type">const</span> Data&amp; d1, <span class="type">int</span> num)</span><br><span class="line">&#123;</span><br><span class="line">	Data temp;</span><br><span class="line">	temp.m_a = d1.m_a + num;</span><br><span class="line">	temp.m_b = d1.m_b + num;</span><br><span class="line">	cout &lt;&lt; temp.m_a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; temp.m_b &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Data d1;</span><br><span class="line">	d1.m_a = <span class="number">7</span>;</span><br><span class="line">	d1.m_b = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">	Data d2;</span><br><span class="line">	d2.m_a = <span class="number">8</span>;</span><br><span class="line">	d2.m_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Data d3 = d1 + d2;//报错：没有与这些操作数匹配的&#x27;+&#x27;运算符，操作类型为 Data +  Data</span></span><br><span class="line"></span><br><span class="line">	Data d3;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	* 成员函数实现重载：</span></span><br><span class="line"><span class="comment">	*d3 = d1.operator+(d2);</span></span><br><span class="line"><span class="comment">	*实质是调用p1成员函数operator+，传入d2，实现d3 = d1 + d2;的操作</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	*全局函数实现重载：</span></span><br><span class="line"><span class="comment">	* 注意函数的位置，这里使用的如果是全局函数则需要保证全局函数在teat01之前实现</span></span><br><span class="line"><span class="comment">	*可以使用d3 = operator+(d1, d2);实质是调用全局函数直接操作；</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	d3 = d1 + d2;</span><br><span class="line"></span><br><span class="line">	Data d4 = d1 + <span class="number">10</span>;<span class="comment">//Data d4 = operator+(d1, 10);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 注意：</span></span><br><span class="line"><span class="comment">* 1、如果没有运算符重载不能实现将两个一般情况下不满足直接相加的数据进行加运算</span></span><br><span class="line"><span class="comment">* 2、运算符重载只能对自定义数据类型进行定义运算规则，默认可以进行运算的数据类型之间的运算不可改变（int+int,string+string）</span></span><br><span class="line"><span class="comment">* 3、运算符重载不可滥用（加中写减）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong> 原先说比较偏向于使用全局函数重载的版本是因为：原以为成员函数重载版本在调用时一定要使用operator+，但是实际上并不是这样，成员函数也可以 p1 + p2 。</p>
<p>至于主流为什么使用全局函数重载版本，C++标准规定，成员函数中进行的运算，对象只能位于运算符左边，即 obj.age + n; 这种形式</p>
<h4 id="重载-lt-lt-和-gt-gt-运算符"><a href="#重载-lt-lt-和-gt-gt-运算符" class="headerlink" title="重载 &lt;&lt; 和 &gt;&gt; 运算符"></a>重载 &lt;&lt; 和 &gt;&gt; 运算符</h4><p>由于I/O操作通常需要读写对象的参与，且自建成员通常为右操作数，所以重载运算符一般设置为友元函数（成员函数中，如果需要类内成员变量参与运算，类内成员必须在运算符的左侧）。</p>
<p>这类重载函数通常需要使用C++ IO库成员，但是I/O对象无法被拷贝或者赋值，所有的操作只能通过指针过着引用来完成，所以函数参数和返回值通常是IO对象的引用（IO对象的引用引用相当于给IO对象起别名，未必一定要叫 cout 和 cin）。</p>
<p>另外，由于向流中写入或读取数据会导致流的状态发生变化，所以重载运算符的函数中无法使用const类型的IO成员</p>
<p><strong>重载 &lt;&lt; 运算符：</strong> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, <span class="type">const</span> person&amp; p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//默认构造函数，或提供接口</span></span><br><span class="line">	<span class="built_in">person</span>(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">	&#123;</span><br><span class="line">		m_a = a;</span><br><span class="line">		m_b = b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//利用成员函数进行插入运算符的重载，得到的调用形式是p &lt;&lt; cout;与原先的想法不一致，代码有问题</span></span><br><span class="line">	<span class="comment">/*void operator&lt;&lt;(ostream cout)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line">	<span class="type">int</span> m_a;</span><br><span class="line">	<span class="type">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数无法帮助我们达到目的，所以选择使用全局函数</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;cout,<span class="type">const</span> person&amp; p)</span><br><span class="line"><span class="comment">//cout是输出流对象，全局只能有一个。以引用的形式调用</span></span><br><span class="line"><span class="comment">//引用的本质是给元素起别名，所以cout也可以写成out</span></span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;m_a= &quot;</span> &lt;&lt; p.m_a &lt;&lt; <span class="string">&quot;\t m_b= &quot;</span> &lt;&lt; p.m_b &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//cout &lt;&lt; p1;//没有与这些操作数匹配的 &quot;&lt;&lt;&quot; 运算符，没有这样的输出方式，需要重载</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//链式编程，输出后返回cout，可以实现不断地往后追加</span></span><br><span class="line">	cout &lt;&lt; p1 &lt;&lt; <span class="string">&quot;Hello world!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>重载 &gt;&gt; 运算符：</strong> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这个也比较简单，只是需要注意分界字符的问题（空格等）</span></span><br><span class="line"><span class="comment">在重载函数中分别输入自定义数据类型的成员</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<p><strong>总结：</strong> </p>
<ul>
<li><p>为了与通常习惯相近，我比较偏好设置 &lt;&lt; 和 &gt;&gt; 运算符重载版本为友元函数，并且，由于在函数中不用修改传入参数的值，所以将函数的第二个参数设置为const类型。</p>
</li>
<li><p>针对&gt;&gt;的重载运算符:<br>由于输入的特殊性, 在重载运算符函数中有必要考虑可能的输入失败的情况并作出补救措施(如重置成初始状态)<br>判断方法可以通过IO成员内置的标识符来判定（eofbit, failbit, goodbit）。常见的错误有:</p>
<ul>
<li>流中含有错误类型的数据时读取操作可能失败</li>
<li>、当读取到文件末尾或遇到流中的其他错误</li>
</ul>
</li>
</ul>
<p>在类对象的输出中，应该尽可能少的进行格式化输出，而将这个任务交给类的使用者，使其更加自如地使用这个类。 </p>
<h4 id="重载-运算符-1"><a href="#重载-运算符-1" class="headerlink" title="重载 ++ 运算符"></a>重载 ++ 运算符</h4><ul>
<li>对于前置++运算符的重载，要求其参数为空</li>
<li>对于后置版本的++运算符重载，要求其参数只有一个，并且必须是int</li>
</ul>
<p>作用是为了区分前置和后置版本，同时告诉编译器这个运算符后面是有参数的，这样编译器才知道这是后置版本，编译器在调用后置版本的重载运算符时候传入一个0给形参，但是一般不会使用到这个值，所以一般不提供标识符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//自增运算符重载</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myinteger</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, Myinteger myint);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Myinteger</span>()<span class="comment">//稍加改动即可以作为接口使用</span></span><br><span class="line">	&#123;</span><br><span class="line">		num = <span class="number">0</span>;<span class="comment">//构造函数初始化数据</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//重载前置++运算符</span></span><br><span class="line">	<span class="comment">//返回引用是为了能够实现多次自增操作，这里体现的是值传递和址传递的区别（形参和实参）</span></span><br><span class="line">	<span class="comment">//对地址进行操作才能保证有效自增（数据被记录）</span></span><br><span class="line">	Myinteger&amp; <span class="keyword">operator</span>++()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//先对数据进行自增</span></span><br><span class="line">		num++;</span><br><span class="line">		<span class="comment">//然后返回自身，返回的是引用说明在下一次参与运算时拿到的是引用</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//重载后置++运算符</span></span><br><span class="line">	<span class="comment">//注意函数重载的条件：void operator++(int)   int作为占位参数，可以将前置和后置区分开，返回值类型不能作为函数重载的条件</span></span><br><span class="line">	Myinteger <span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//1、记录当前值</span></span><br><span class="line">		Myinteger temp = *<span class="keyword">this</span>;</span><br><span class="line">		<span class="comment">//2、自增</span></span><br><span class="line">		num++;</span><br><span class="line">		<span class="comment">//3、返回记录值</span></span><br><span class="line">		<span class="keyword">return</span> temp;	<span class="comment">// 局部变量，出了函数就销毁，不可返回引用</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为了保证输出的时候cout在左侧，使用全局函数，并且为了能够实现打印类内私有元素的目的使用了友元技术</span></span><br><span class="line"><span class="comment">//重载插入运算符</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, Myinteger myint)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; myint.num &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Myinteger myint;</span><br><span class="line">	cout &lt;&lt; ++(++myint) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; myint++ &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; myint &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>前置递增返回引用，后置递增返回值</li>
<li>i = 1, cout &lt;&lt; ++i + ++i &lt;&lt; endl;      // 6 因为返回的是引用</li>
</ul>
<h4 id="重载-–-运算符"><a href="#重载-–-运算符" class="headerlink" title="重载 – 运算符"></a>重载 – 运算符</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myinteger</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, Myinteger myint);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Myinteger</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		num = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//前置--</span></span><br><span class="line">	Myinteger&amp; <span class="keyword">operator</span>--()</span><br><span class="line">	&#123;</span><br><span class="line">		num--;<span class="comment">//这是编译器认识的数据类型，可以进行自减操作</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//后置--</span></span><br><span class="line">	Myinteger <span class="keyword">operator</span>--(<span class="type">int</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Myinteger temp = *<span class="keyword">this</span>;</span><br><span class="line">		num--;</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, Myinteger myint)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; myint.num &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Myinteger myint;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;test01&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; myint &lt;&lt; endl;<span class="comment">//myint 的数据类型是 Myinteger，必须重载运算符，不然无法输出</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; myint-- &lt;&lt; endl;//如果想要</span></span><br><span class="line">	cout &lt;&lt; --(--myint) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; myint &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后置运算符重载之后会使得原有定义的 -- 失效</span></span><br><span class="line"><span class="comment">//重载后的 -- 需要左值，这一点与自增一样</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Myinteger myint;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;test02&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; myint &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; (myint--)-- &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; myint &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="重载-运算符-2"><a href="#重载-运算符-2" class="headerlink" title="重载 = 运算符"></a>重载 = 运算符</h4><p><strong>必须要作为类内成员函数进行重载的</strong> </p>
<p>为了解决对象之间的相互赋值中出现的浅拷贝问题</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> age)<span class="comment">//浅拷贝将m_age的地址和值全复制了过去，析构的时候重复释放内存空间</span></span><br><span class="line">	&#123;</span><br><span class="line">		m_age = <span class="keyword">new</span> <span class="built_in">int</span>(age);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (m_age)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_age;</span><br><span class="line">			m_age = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Person&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Person &amp;p)<span class="comment">//返回引用类型避免再次调用拷贝构造函数创建副本</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (m_age)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="comment">//判断赋值号右边元素在堆区是否有数据，有则释放；所以this指向的是赋值号右边的元素</span></span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;未知身份的人的年龄&quot;</span> &lt;&lt; *<span class="keyword">this</span> -&gt; m_age &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">delete</span> <span class="keyword">this</span> -&gt; m_age;<span class="comment">//delete m_age;</span></span><br><span class="line">			<span class="keyword">this</span> -&gt; m_age = <span class="literal">NULL</span>;<span class="comment">//m_age = NULL;</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span> -&gt; m_age = <span class="keyword">new</span> <span class="built_in">int</span>(*p.m_age);</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> *m_age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="number">30</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1.m_age = &quot;</span> &lt;&lt; *p1.m_age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2.m_age = &quot;</span> &lt;&lt; *p2.m_age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p3.m_age = &quot;</span> &lt;&lt; *p3.m_age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	p3 = p2 = p1;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1.m_age = &quot;</span> &lt;&lt; *p1.m_age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2.m_age = &quot;</span> &lt;&lt; *p2.m_age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p3.m_age = &quot;</span> &lt;&lt; *p3.m_age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="type">int</span> c = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">	c = b = a;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回值是对象引用，另外，对于赋值运算符重载函数，我们要避免自赋值情况（即自己给自己赋值）的发生，一般地，我们通过比较赋值者与被赋值者的地址是否相同来判断两者是否是同一对象（正如例1中的if (this != &amp;str)一句）。</p>
<p>​     为什么要避免自赋值呢？</p>
<p> ①为了效率。显然，自己给自己赋值完全是毫无意义的无用功，特别地，对于基类数据成员间的赋值，还会调用基类的赋值运算符重载函数，开销是很大的。如果我们一旦判定是自赋值，就立即return *this，会避免对其它函数的调用。</p>
<p>②如果类的数据成员中含有指针，自赋值有时会导致灾难性的后果。对于指针间的赋值（注意这里指的是指针所指内容间的赋值，这里假设用_p给p赋值），先要将p所指向的空间delete掉（为什么要这么做呢？因为指针p所指的空间通常是new来的，如果在为p重新分配空间前没有将p原来的空间delete掉，会造成内存泄露），然后再为p重新分配空间，将_p所指的内容拷贝到p所指的空间。如果是自赋值，那么p和_p是同一指针，在赋值操作前对p的delete操作，将导致p所指的数据同时被销毁。那么重新赋值时，拿什么来赋？</p>
<p>​    所以，对于赋值运算符重载函数，一定要先检查是否是自赋值，如果是，直接return *this。</p>
<p>转自<a target="_blank" rel="noopener" href="https://www.cnblogs.com/zpcdbky/p/5027481.html">https://www.cnblogs.com/zpcdbky/p/5027481.html</a></p>
<h4 id="重载-运算符-3"><a href="#重载-运算符-3" class="headerlink" title="重载 == 运算符"></a>重载 == 运算符</h4><p><strong>算术和关系运算符：</strong> </p>
<ul>
<li>算术和关系运算符通常为对称性的，一般情况下重载为非成员函数</li>
<li>由于不需要对两操作数作出修改，所以两参数一般设置为const引用</li>
<li>由于计算结果会产生一个新值，独立于两操作数之外，所以通常存储在临时的局部变量中，最后返回该变量</li>
<li>较为方便的做法是：先重载相应的复合赋值运算符，再使用它来定义算术运算符（运算结果需要接收，使用赋值运算符），这种复用的思想也可以用在其他的重载运算符中：通常是在一类运算符中定义了某一个，而后用其定义其他的重载运算符，并且也应该重载该类中其他运算符</li>
<li>对于赋值运算符，类似于类的拷贝构造函数有一个非常需要注意的点就是要避免浅拷贝（进行深拷贝, 如在拷贝函数中申请新的内存等）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		m_name = name;</span><br><span class="line">		m_age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>==(Person&amp; p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span> -&gt; m_name == p.m_name &amp;&amp; <span class="keyword">this</span> -&gt; m_age == p.m_age)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>!=(Person&amp; p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_name == p.m_name &amp;&amp; <span class="keyword">this</span>-&gt;m_age == p.m_age)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string m_name;</span><br><span class="line">	<span class="type">int</span> m_age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;Jerry&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (p1 == p2)</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;p1 和 p2 是相等的&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;p1 和 p2 是不相等的&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">if</span>(p1 != p2)</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;p1 和 p2 是不相等的&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;p1 和 p2 是相等的&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="函数调用-运算符重载"><a href="#函数调用-运算符重载" class="headerlink" title="函数调用 () 运算符重载"></a>函数调用 () 运算符重载</h4><ul>
<li>函数调用运算符也能重载（只能作为成员函数）</li>
<li>由于重载后的函数对象使用方式非常像函数调用，因此又被称为仿函数</li>
<li>函数对象没有固定写法，非常灵活（可以定义在结构体中，也可以作为内中公有成员）</li>
<li>函数对象既可以像函数一样使用类对象，并向其传递特定数目和类型的参数，编译器会调用不同的重载函数完成相应的操作，并且是唯一一种支持参数缺省的运算符重载</li>
<li>通常，函数对象中的数据成员被用于定制operator() 函数调用运算符中的一些操作，并且函数对象经常作为泛型编程的实参被传递（水很深）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//仿函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPrint</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> string text)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; text &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">const</span> string text)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; text &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MyPrint myprint;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//myprint()(&quot;Hello world!&quot;);//错误：无法使用给定参数列表调用 函数 &quot;MyPrint::operator()&quot;</span></span><br><span class="line">	<span class="built_in">myprint</span>(<span class="string">&quot;Hello world!&quot;</span>);	<span class="comment">// 因为使用起来非常像函数调用，所以叫做仿函数</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">MyPrint</span>()(<span class="string">&quot;Hello world!&quot;</span>); <span class="comment">// 匿名对象，传入字符串，调用默认拷贝构造函数</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">Print</span>(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//仿函数是灵活的，有很多使用场景所以没有固定的写法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyAddition</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="type">int</span> num1, <span class="type">const</span> <span class="type">int</span> num2)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//函数重载旨在使用同一个函数名不同的函数体实现不同的功能</span></span><br><span class="line">		<span class="keyword">return</span> num1 + num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MyAddition case01;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; <span class="built_in">case01</span>(<span class="number">100</span>, <span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//匿名函数对象</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;匿名函数对象MyAddition()(100, 100)：&quot;</span> &lt;&lt; <span class="built_in">MyAddition</span>()(<span class="number">100</span>, <span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="下标运算符-重载"><a href="#下标运算符-重载" class="headerlink" title="下标运算符 [] 重载"></a>下标运算符 [] 重载</h4><ul>
<li><strong>必须作为成员函数重载</strong>  </li>
<li>通常返回所访问元素的引用（提供修改操作，与原生版本相同）</li>
<li>最好是同时定义下标运算符重载的常量版本和非常量版本，即返回值为 const 常量引用 和 非常量引用的版本</li>
</ul>
<h4 id="成员访问-gt-运算符"><a href="#成员访问-gt-运算符" class="headerlink" title="成员访问 -&gt; 运算符"></a>成员访问 -&gt; 运算符</h4><p><strong>注意：</strong>  </p>
<ul>
<li><p>这个箭头与解引用运算符一样，都是单目运算符，尽管看起来像双目运算符，但其右操作数并不是表达式，而是对用类成员的一个标识符，编译器将通过此标识符获取特定成员</p>
</li>
<li><p>通常情况下，解引用标识符*与箭头标示符-&gt;一同作为成员函数</p>
</li>
<li><p>通常情况下，<strong>这两个运算符的重载函数设置为底层const，并将返回值设置为非const的成员引用</strong> </p>
<p><strong>因为成员访问通常不会修改类对象，但是调用方有权修改返回的值</strong>  </p>
</li>
<li><p><strong>对于箭头运算符的重载，其返回值必须是某个对象，或指向某个对象的指针，其余情况都会报错</strong> </p>
</li>
<li><p>使用箭头运算符时，有且仅有两种情况，任何其他类型的左操作数都会报错</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pointer为指向类对象的指针. 此时两条语句等效</span></span><br><span class="line">pointer-&gt;member;	<span class="comment">//编译器调用的是-&gt; 的内置版本, 与重载版本无关</span></span><br><span class="line">*(pointer).member;</span><br><span class="line"></span><br><span class="line"><span class="comment">//pointer为某个类的对象时:</span></span><br><span class="line">pointer-&gt;member; 	<span class="comment">//此时编译器调用的才是重载运算符版本</span></span><br><span class="line"><span class="comment">//相当于:</span></span><br><span class="line">pointer.<span class="keyword">operator</span>-&gt;()  -&gt;member; 	<span class="comment">//对, 就是这么一个奇葩玩意</span></span><br><span class="line"><span class="comment">//相当于调用了-&gt;的重载函数, 并将它的返回值在做了一次-&gt;运算</span></span><br></pre></td></tr></table></figure>

<p>此时有两种情况：</p>
<ol>
<li>如果箭头运算符重载函数返回的是指向该类的指针，则呈现的是上面描述的第一种情况</li>
<li>如果箭头运算符重载函数返回的是该类的某个成员（有可能时类对象自身的引用），且这个成员中也重载了operator-&gt;，则继续调用该成员中的重载版本，否则将报错，因为内置的operator-&gt;的左操作数不可以是指针以外的对象。</li>
</ol>
<p>想要让operator-&gt;正常结束调用过程，就只能是第一种情况，箭头运算符重载函数找到了出口，出口的情况有两种，一是重载函数返回的是相同类的指针，正常出程序，二是函数返回是另一个的类的引用，但是该类也重载了箭头运算符，再调用该类的箭头运算符（出得了就出程序，出不了就继续上述情况，结果要么是出了程序，要么是因为返回的是引用继续调用（无限或有限地递归调用），或者因为返回的某个类没有重载箭头运算符而报错）</p>
<p>找到了一个比较绕的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #include &lt;iostream&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// using namespace std;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// class myClass</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// public:</span></span><br><span class="line"><span class="comment">//     myClass &amp;operator-&gt;()</span></span><br><span class="line"><span class="comment">//     &#123;</span></span><br><span class="line"><span class="comment">//         cout &lt;&lt; &quot;Operator -&gt; Overload\n&quot;;</span></span><br><span class="line"><span class="comment">//         return *this;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     void action()</span></span><br><span class="line"><span class="comment">//     &#123;</span></span><br><span class="line"><span class="comment">//         //do something...</span></span><br><span class="line"><span class="comment">//         return;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// int main()</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     myClass obj;</span></span><br><span class="line"><span class="comment">//     obj-&gt;action(); // 报错 circular pointer delegation detected (循环指针)</span></span><br><span class="line"><span class="comment">//     return 0;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Origin</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Wrapper</span></span><br><span class="line">&#123;</span><br><span class="line">    Origin *orig;</span><br><span class="line">    Origin *<span class="keyword">operator</span>-&gt;() <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> orig;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Wrapper2</span></span><br><span class="line">&#123;</span><br><span class="line">    Wrapper *wrap;	<span class="comment">// 如果下面的函数返回自身就会死在循环递归里（返回的是引用），如果wrap没有重载箭头运算符就会报错</span></span><br><span class="line">    Wrapper &amp;<span class="keyword">operator</span>-&gt;() <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> *wrap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Origin o;</span><br><span class="line">    o.a = <span class="number">7</span>;</span><br><span class="line">    Wrapper w;</span><br><span class="line">    w.orig = &amp;o;</span><br><span class="line">    Wrapper2 w2;</span><br><span class="line">    w2.wrap = &amp;w;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;&amp;o.a\t\t\t\t&quot;</span> &lt;&lt; &amp;o.a &lt;&lt; std::endl;	<span class="comment">// 输出a的地址</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;&amp;wrap\t\t\t\t&quot;</span> &lt;&lt; w2.wrap &lt;&lt; std::endl;	<span class="comment">// 输出wrap的地址，与w的地址相同</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;&amp;w\t\t\t\t&quot;</span> &lt;&lt; &amp;w &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;w-&gt;a&quot;</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;\t\t\t\t&quot;</span> &lt;&lt; w-&gt;a &lt;&lt; std::endl; <span class="comment">// w.operator-&gt;().operator-&gt;()-&gt;a，从Wrapper2.operator-&gt;()，到 Wrapperoperator-&gt;() 再调用内置的箭头运算符出循环</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;w.operator-&gt;()&quot;</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;\t\t\t&quot;</span> &lt;&lt; w.<span class="keyword">operator</span>-&gt;() &lt;&lt; std::endl; <span class="comment">// 返回的是orig，即&amp;o</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;w.operator-&gt;()-&gt;a&quot;</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;\t\t&quot;</span> &lt;&lt; w.<span class="keyword">operator</span>-&gt;()-&gt;a &lt;&lt; std::endl;	<span class="comment">// 结合上面一句，这里经过Wrapper.operator-&gt;() 再调用默认的箭头运算符 输出 a</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;w2-&gt;a&quot;</span>	<span class="comment">// Wrapper2.operator-&gt;() 再 Wrapper.operator-&gt;() 最后默认的箭头运算符</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;\t\t\t\t&quot;</span> &lt;&lt; w2-&gt;a &lt;&lt; std::endl; </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;&amp;w2.operator-&gt;()&quot;</span>	<span class="comment">// &amp;orig 即 &amp;o</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;\t\t&quot;</span> &lt;&lt; &amp;w2.<span class="keyword">operator</span>-&gt;() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;w2.operator-&gt;()-&gt;a&quot;</span>	<span class="comment">// 同 w.operator-&gt;()-&gt;a， 同 w-&gt;a</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;\t\t&quot;</span> &lt;&lt; w2.<span class="keyword">operator</span>-&gt;()-&gt;a &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;w2.operator-&gt;().operator-&gt;()&quot;</span>	<span class="comment">// 返回orig，即 &amp;o</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; w2.<span class="keyword">operator</span>-&gt;().<span class="keyword">operator</span>-&gt;() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;w2.operator-&gt;().operator-&gt;()-&gt;a&quot;</span>	<span class="comment">// 即 w-&gt;a</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; w2.<span class="keyword">operator</span>-&gt;().<span class="keyword">operator</span>-&gt;()-&gt;a &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>上述代码来源于下方博文：</strong> <a target="_blank" rel="noopener" href="https://blog.csdn.net/u013009575/article/details/19246353">https://blog.csdn.net/u013009575/article/details/19246353</a></p>
<p><img src="https://s2.loli.net/2023/03/25/ZUifA5hqznLVM3l.jpg" alt="箭头运算符重载"> </p>
<h4 id="合适的重载运算符的时机"><a href="#合适的重载运算符的时机" class="headerlink" title="合适的重载运算符的时机"></a><strong>合适的重载运算符的时机</strong></h4><p>重载函数为类服务，自然也要从类的整体设计上考虑和使用该重载何种运算符，何时应该使用成员函数：通常当某些类的早些操作在逻辑上与对应的运算符相关，则更应该设置为重载运算符的形式：</p>
<ul>
<li>对类执行IO操作，通常重载的 &gt;&gt; 和 &lt;&lt; 使其与内置数据类型的IO一致</li>
<li>对类执行关系操作，包括 &gt;、&lt;、&lt;=、&gt;=、==、!=六种</li>
</ul>
<p>如果没有特殊需要，重载这些运算符时，参数与返回值的设置最好与内置版本相兼容，符合用户使用习惯，更不容易出错</p>
<p><strong>重载运算符的本意是为了方便使用：</strong> </p>
<p>一切都是建立在对原有运算符的功能的理解上的，如果一个操作在功能上存在一定的二义性，或者与常规的理解有一定的偏差，则此时不应该扭曲原有运算符的含义与逻辑（不应该重载），转而使用一个成员函数并在函数名上给出提示更能方便使用。</p>
<p><strong>关于运算符重载函数的匹配：</strong> </p>
<ul>
<li>运算符重载在C++中同样作为函数来使用，所以仍然遵循函数的匹配模式</li>
</ul>
<p>但是总体上来说，运算符重载函数的候选集合比普通重载函数要大：当操作数中有自定义数据类型时，函数匹配列表中的候选函数应该包括该运算符的非成员重载版本（+、-、*、/ 等）以及内置版本，且如果运算符左侧操作数是自定义类型，则还要包括该类中定义的成员函数重载版本</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="继承的基础语法"><a href="#继承的基础语法" class="headerlink" title="继承的基础语法"></a>继承的基础语法</h3><p><strong>继承的好处：</strong> </p>
<ul>
<li>提高代码复用性</li>
</ul>
<p><strong>语法：</strong> </p>
<p>class class_son :  inheritance_method base_class</p>
<p>子类 – 派生类</p>
<p>父类 – 基类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过编码保存，GB2312</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BasePage</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;黑马程序员网、搜索、登录/注册...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;C++、Java、Python、Javascript...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;帮助中心、联系我们、站内导航、商业合作...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Java</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Java学习视频...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cpp</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;C++学习视频...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Python</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Python学习视频...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Java ja;</span><br><span class="line">    Cpp cpp;</span><br><span class="line">    Python py;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Java页面\n&quot;</span> &lt;&lt; endl;</span><br><span class="line">    ja.<span class="built_in">header</span>();</span><br><span class="line">    ja.<span class="built_in">left</span>();</span><br><span class="line">    ja.<span class="built_in">content</span>();</span><br><span class="line">    ja.<span class="built_in">footer</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&lt;!------------分割线------------!&gt;\n&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;C++页面\n&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cpp.<span class="built_in">header</span>();</span><br><span class="line">    cpp.<span class="built_in">left</span>();</span><br><span class="line">    cpp.<span class="built_in">content</span>();</span><br><span class="line">    cpp.<span class="built_in">footer</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&lt;!------------分割线------------!&gt;\n&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Python页面\n&quot;</span> &lt;&lt; endl;</span><br><span class="line">    py.<span class="built_in">header</span>();</span><br><span class="line">    py.<span class="built_in">left</span>();</span><br><span class="line">    py.<span class="built_in">content</span>();</span><br><span class="line">    py.<span class="built_in">footer</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&lt;!------------分割线------------!&gt;\n&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>派生类中的成员包括两部分：</strong> </p>
<ol>
<li>从基类继承过来的，运算符重载无法继承，除非父类提供从子类到父类的构造函数</li>
<li>自己增加的成员</li>
</ol>
<ul>
<li>从基类中继承属性体现了共用性，而子类中新增成员属性则体现了子类的个性</li>
</ul>
<h3 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h3><p><img src="https://s2.loli.net/2023/03/25/doajmtYqeQsBXDK.png" alt="继承方式"> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BasePage</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_a;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> m_b;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_a = <span class="number">10</span>;<span class="comment">//基类中的公共权限 到子类中依然是公共属性</span></span><br><span class="line">		m_b = <span class="number">20</span>;<span class="comment">//基类中的保护权限 到子类中也是公共属性</span></span><br><span class="line">		<span class="comment">//m_c = 30;//基类中的私有权限 子类继承得到，访问不到</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保护继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span> : <span class="keyword">protected</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_a = <span class="number">100</span>;<span class="comment">//基类中的公共权限在保护继承中变为保护权限</span></span><br><span class="line">		m_b = <span class="number">200</span>;</span><br><span class="line">		<span class="comment">//m_c = 300;//基类中的私有权限 子类继承得到，访问不到</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son3</span> : <span class="keyword">private</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_a = <span class="number">100</span>;<span class="comment">//父类公共成员和保护成员经过私有继承到子类中变为私有成员</span></span><br><span class="line">		m_b = <span class="number">100</span>;</span><br><span class="line">		<span class="comment">//m_c = 100;//无法访问</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Grandson</span> : <span class="keyword">public</span> Son3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">/*m_a = 200;Son3中的属性均为私有，即使继承得到也无法访问</span></span><br><span class="line"><span class="comment">		m_b = 200;</span></span><br><span class="line"><span class="comment">		m_c = 200;*/</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son1 s1;</span><br><span class="line">	s1.m_a = <span class="number">100</span>;<span class="comment">//公共权限类外可以访问</span></span><br><span class="line">	<span class="comment">//s1.m_b = 200;//保护权限类外不可访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son2 s1;</span><br><span class="line">	<span class="comment">/*s1.m_a = 1000;</span></span><br><span class="line"><span class="comment">	* 均为保护属性，类外不可访问</span></span><br><span class="line"><span class="comment">	s1.m_b = 1000; */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son3 s1;</span><br><span class="line">	<span class="comment">/*s1.m_a = 1000;</span></span><br><span class="line"><span class="comment">	* 访问不到 </span></span><br><span class="line"><span class="comment">	s1.m_b = 1000;*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line">	<span class="built_in">test03</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="继承中的对象模型"><a href="#继承中的对象模型" class="headerlink" title="继承中的对象模型"></a>继承中的对象模型</h3><p><strong>从基类中继承的成员，有哪些属于派生类？</strong> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_a;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> m_b;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用developer command prompt for VS 2019 查看对象模型</span></span><br><span class="line"><span class="comment">//跳转盘符进入文件所在文件夹</span></span><br><span class="line"><span class="comment">//输入dir查看文件夹信息</span></span><br><span class="line"><span class="comment">//输入 cl /d1 reportSingleClassLayou类名（例如：Son1） 文件名，按下回车查看类信息</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//子类可以继承但是无法访问</span></span><br><span class="line">	<span class="comment">//输出为16，父类中所有非静态成员都会被子类继承</span></span><br><span class="line">	<span class="comment">//父类的私有属性成员被隐藏了，虽然访问不到，但是确实被继承了</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;size of Son1 = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Son1) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>基类中的所有属性都可以被继承，但是访问得到的才是自己的，访问不到的都是基类的</strong> </p>
<h3 id="继承中构造和析构顺序"><a href="#继承中构造和析构顺序" class="headerlink" title="继承中构造和析构顺序"></a>继承中构造和析构顺序</h3><p>在学习模板的时候，说过，要先知道父类的类型才能给子类分配空间，跟这里应该有一些关系</p>
<p><strong>子类创建对象时，会调用子类本身的构造函数，也会调用父类的构造函数</strong> </p>
<p><strong>问题：</strong> 父类和子类的构造和析构顺序？</p>
<p>“白发人送黑发人”，构造时，先调用父类构造，析构时，先调用子类析构</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承中的构造和析构顺序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base的构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Base</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base的析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Son</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Son的构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Son</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Son的析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//Base b;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		继承中的构造和析构顺序如下：</span></span><br><span class="line"><span class="comment">		与调用无关，先构造父类，再构造子类，程序结束时先析构子类，最后析构父类</span></span><br><span class="line"><span class="comment">		“白发人送黑发人系列”</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	Son s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong> 继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</p>
<h3 id="继承中同名成员的处理方式"><a href="#继承中同名成员的处理方式" class="headerlink" title="继承中同名成员的处理方式"></a>继承中同名成员的处理方式</h3><p><strong>问题：</strong> 当子类和父类有同名成员，如何通过子类对象访问到父类中的同名数据？</p>
<ul>
<li>子类中的成员直接使用一般方式访问其中成员即可</li>
<li>子类想要拿到父类的成员则需要在访问时加上作用域</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承中同名成员的处理方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_a = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base下 func() 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base下 func(int a) 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_a = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*void func()</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		cout &lt;&lt; &quot;Son下 func() 调用&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同名成员属性</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son s;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Son的m_a的值：&quot;</span> &lt;&lt; s.m_a &lt;&lt; endl;<span class="comment">//最直接输出的一定是自己的，因为拿自己的才最容易</span></span><br><span class="line">	<span class="comment">//如果想要通过子类访问父类中的同名成员一定要加 作用域</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Son继承来的Base的m_a的值：&quot;</span> &lt;&lt; s.Base::m_a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同名成员函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son s;</span><br><span class="line">	s.<span class="built_in">func</span>();	<span class="comment">//就算此时Son中并没有定义func()，这句也是可以执行的，因为不存在歧义性，如果发生了重名，调用的也会是Son中的那一个</span></span><br><span class="line">	s.Base::<span class="built_in">func</span>();<span class="comment">//调用Base中的func()</span></span><br><span class="line">	s.Base::<span class="built_in">func</span>(<span class="number">100</span>);<span class="comment">//调用父类中重载后的函数func(int a)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果子类中出现于父类中同名的函数，子类的同名函数会将继承过来的所有同名函数，包括重载函数</span></span><br><span class="line">	<span class="comment">//如果想要访问到父类中隐藏的同名函数需要加 作用域</span></span><br><span class="line">	s.Base::<span class="built_in">func</span>(<span class="number">100</span>);</span><br><span class="line">	<span class="comment">//为了不因为歧义发生莫名其妙的错误，建议只要调用父类中的成员函数都加上作用域</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong> </p>
<ol>
<li>子类对象可以直接访问到子类中同名成员</li>
<li>子类对象加作用域可以访问到父类同名成员</li>
<li>当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名</li>
</ol>
<p>函数</p>
<h3 id="继承同名静态成员的处理方式"><a href="#继承同名静态成员的处理方式" class="headerlink" title="继承同名静态成员的处理方式"></a>继承同名静态成员的处理方式</h3><p><strong>问题：</strong> 继承中同名的静态成员变量在子类对象上应该如何进行访问？</p>
<p>与其余同名成员的访问方式一致，访问子类的只需要直接访问，访问基类的则需要加作用域</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> m_a;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base - static void func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base - static void func(int a)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Base::m_a = <span class="number">100</span>;<span class="comment">//静态成员变量类外赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> m_a;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Son - static void func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Son:: m_a = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同名静态成员变量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//1、通过对象访问静态成员变量</span></span><br><span class="line">	Son s1;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\n通过对象访问静态成员变量&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Son 下 m_a：&quot;</span> &lt;&lt; s1.m_a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Base 下 m_a：&quot;</span> &lt;&lt; s1.Base::m_a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、通过类访问静态成员变量</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\n通过类访问静态成员变量&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Son 下 m_a：&quot;</span> &lt;&lt; Son::m_a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Base 下 m_a：&quot;</span> &lt;&lt; Son::Base::m_a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同名静态成员函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son s2;</span><br><span class="line">	<span class="comment">//1、通过对象访问静态成员变量</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\n通过对象访问静态成员函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	s2.<span class="built_in">func</span>();</span><br><span class="line">	s2.Base::<span class="built_in">func</span>();</span><br><span class="line">	s2.Base::<span class="built_in">func</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、通过类访问静态成员变量</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\n通过类访问静态成员函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	Son::<span class="built_in">func</span>();</span><br><span class="line">	Son::Base::<span class="built_in">func</span>();</span><br><span class="line">	Son::Base::<span class="built_in">func</span>(<span class="number">100</span>);</span><br><span class="line">	<span class="comment">//子类中有同名静态成员  会使得继承过来的父类中的静态成员被隐藏</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong> 同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类</p>
<p>名）</p>
<h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><p>C++允许<strong>一个类继承多个类</strong> </p>
<p>语法： class 子类 ：继承方式 父类1 ， 继承方式 父类2…</p>
<p>多继承可能会引发父类中有同名成员出现，需要加作用域区分</p>
<p><strong>C++实际开发中不建议用多继承</strong> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Base1</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		m_a = <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Base2</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		m_a = <span class="number">200</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多继承</span></span><br><span class="line"><span class="comment">//语法：子类 : 继承方式 父类1, 继承方式 父类2...</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Son</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		m_c = <span class="number">300</span>;</span><br><span class="line">		m_d = <span class="number">400</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> m_c;</span><br><span class="line">	<span class="type">int</span> m_d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son s;</span><br><span class="line">	<span class="comment">//如果多个父类中出现了同名成员，访问时需要添加作用域</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Size of Son = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(s) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Base1 m_a:&quot;</span> &lt;&lt; s.Base1::m_a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Base2 m_a:&quot;</span> &lt;&lt; s.Base2::m_a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>  多继承中如果父类中出现了同名情况，子类使用时候要加作用域</p>
<h3 id="菱形继承（Diamond-inheritance）"><a href="#菱形继承（Diamond-inheritance）" class="headerlink" title="菱形继承（Diamond inheritance）"></a>菱形继承（Diamond inheritance）</h3><p><strong>菱形继承概念：</strong> </p>
<ul>
<li>两个派生类继承同一个基类，又有某个类同时继承者两个派生类</li>
</ul>
<p>这种继承被称为菱形继承，或者钻石继承，典型的菱形继承案例：</p>
<p><img src="https://s2.loli.net/2023/03/25/LnPCFME5rui8Tyx.png" alt="菱形继承之前"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 问题：*/</span></span><br><span class="line"><span class="number">1.</span> 羊继承了动物的数据，驼同样继承了动物的数据，当羊驼使用数据时，就会产生二义性。</span><br><span class="line"><span class="number">2.</span> 羊驼继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Camel</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sheep</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Alpaca</span> : <span class="keyword">public</span> Camel, <span class="keyword">public</span> Sheep&#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用虚继承之后Animal类被称为虚基类，Sheep类和Camel类被称为基类</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Alpaca A;</span><br><span class="line"></span><br><span class="line">	A.Sheep::m_age = <span class="number">18</span>;</span><br><span class="line">	A.Camel::m_age = <span class="number">28</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//当菱形继承时，两个父类拥有同名数据，需要使用作用域加以区分</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;A.Sheep::m_age = &quot;</span> &lt;&lt; A.Sheep::m_age &lt;&lt; endl;<span class="comment">//没有使用虚继承之前输出18 28</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;A.Camel::m_age = &quot;</span> &lt;&lt; A.Camel::m_age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;A.m_age = &quot;</span> &lt;&lt; A.m_age &lt;&lt; endl;<span class="comment">//使用虚继承之后不会再报错，而且上面三行代码输出结果一致且均为28</span></span><br><span class="line">	<span class="comment">// 生物的年龄是确定的，唯一的，所以多个年龄就造成了空间浪费</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2023/03/25/ghKOsa2pNnqCjey.png" alt="虚继承之前"></p>
<p>Sheep中从Animal继承了一份age，Camel从Animal继承了一份age，经过Alpaca继承Sheep和Camel之后，Alpaca有父类的两个ge，以及自己的两个age，但它本身只需要一个，所以产生了资源浪费。</p>
<p><img src="https://s2.loli.net/2023/03/25/NrWKgpQtMEdiGsa.png" alt="虚继承之后"></p>
<p><img src="https://s2.loli.net/2023/03/25/leRkQJDoijV5MBs.png" alt="虚继承实现原理"></p>
<p>虚继承使派生类除了继承基类成员作为自己的成员之外，内部还会有一份内存来保存哪些是基类的成员。当 <strong>Alpaca</strong> 继承 <strong>Sheep</strong> 和 <strong>Camel</strong> 之后，编译器根据虚继承多出来的内存，查到 <strong>Sheep</strong> 和 <strong>Camel</strong> 拥有共同的基类的成员，就不会从 <strong>Sheep</strong> 和  <strong>Camel</strong>  中继承这些，而是直接从共同的基类中继承成员，也就是说，<strong>Alpaca</strong>直接继承<strong>Animal</strong>的成员，然后再继承 <strong>Sheep</strong> 和 <strong>Camel</strong> 各自新增的成员（带有Sheep和Camel自身属性的age）。</p>
<p>这样， <strong>Alpaca</strong> 就不会从  <strong>Sheep</strong> 和 <strong>Camel</strong> 那里多继承两份age，但是，这样也导致Alpaca中所有age属性一致（改一个全部都会变），Alpaca拿不到基类中的年龄。</p>
<p><strong>总结：</strong> </p>
<ul>
<li>菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义</li>
<li>利用虚继承相对而言可以解决菱形继承问题</li>
</ul>
<p>关于C++虚继承的内存模型</p>
<blockquote>
<p>参考 <a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_37973607/article/details/90599495">https://blog.csdn.net/m0_37973607/article/details/90599495</a></p>
</blockquote>
<blockquote>
<p>还有一篇     <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/41309205">https://zhuanlan.zhihu.com/p/41309205</a></p>
</blockquote>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><p><strong>多态分为两类：</strong> </p>
<ul>
<li>静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名</li>
<li>动态多态: 派生类和虚函数实现运行时多态</li>
</ul>
<p><strong>函数名联编</strong></p>
<ul>
<li>将源代码中的函数调用解释为执行特定的函数代码块被称为函数名联编</li>
</ul>
<p><strong>早期联编与晚期联编</strong> </p>
<p>在C++中，由于函数重载的缘故，联编这项任务变得比C语言更加复杂。编译器必须查看函数参数以及函数名才能确定使用哪个函数。</p>
<ul>
<li>C/C++编译器可以在编译过程完成这种联编，在编译过程中进行的联编被称为静态联编（static binding），又称为早期联编（early binding）【编译器对非虚函数使用静态联编】；</li>
<li>虚函数使得联编这项任务更加困难，使用哪一个函数是不能在编译时确定的，因为编译器不知道用户将选择哪种类型的对象。所以编译器必须能够在程序运行时选择正确的虚方法代码，这被称为动态联编（dynamic binding），又称为晚期联编（late binding）。</li>
</ul>
<p><strong>虚成员函数与动态联编</strong> </p>
<p>方面动态联编使程序员能够重新定义类方法，而静态联编在这很差。没有摒弃静态联编的原因有两个——效率和概念模型。</p>
<ul>
<li>效率<ul>
<li>为使程序能够在运行阶段进行决策，必须采取一些方法来追踪基类指针或引用指向的对象模型，这增加了额外的开销（如果类不会用作基类，则不需要动态联编，在这些情况下使用静态联编更合理，效率也更高），由于静态联编的效率更高，因此被设置为C++的默认选择，Strousstrup说，C++的指导原则之一是，不要为不使用的特性付出代价（内存或处理时间），仅当程序设计确实需要虚函数时，才使用它们。</li>
</ul>
</li>
<li>概念模型<ul>
<li>在设计类时，可能包含一些不在派生类重新定义的成员函数，不将该函数设置为虚函数，有两方面好处——效率更高且仅将那些预期被重新定义的方法声明为虚的。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动物类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Bark</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;动物叫&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Bark</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;小猫叫&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Bark</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;犬吠&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 动态多态需要满足的条件</span></span><br><span class="line"><span class="comment">1、有继承关系</span></span><br><span class="line"><span class="comment">2、子类重写父类虚函数（重写和重载不一样，重载是说函数名一样参数不同。重写是指函数名一样，参数列表一样。而且子类中重写的同名函数也是可以加virtual关键字的，并且不会对输出有影响）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">动态多态使用：</span></span><br><span class="line"><span class="comment">父类的指针或者引用 指向子类的对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//无论这里使用的是对象、引用又或者是指针，属于函数地址早绑定，在编译阶段就已经确定了函数的地址</span></span><br><span class="line"><span class="comment">//如果是想要让“小猫”说话就应该让地址晚绑定，即需要在程序运行阶段确定函数地址，需要在基类的同名函数定义前加入virtual关键字</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">barking</span><span class="params">(Animal &amp;animal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	animal.<span class="built_in">Bark</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Cat cat;</span><br><span class="line">	<span class="built_in">barking</span>(cat);</span><br><span class="line"></span><br><span class="line">	Dog dog;</span><br><span class="line">	<span class="built_in">barking</span>(dog);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//添加virtual关键字之前输出为1（空类），添加virtual关键字之后输出4，4是一个指针变量的大小</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Size of class Animal = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Animal) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong> </p>
<p>多态满足条件</p>
<ul>
<li>有继承关系且子类重写父类中的虚函数</li>
</ul>
<p>多态使用条件</p>
<ul>
<li>父类指针或引用指向子类对象</li>
</ul>
<p>重写：函数返回值类型 函数名 参数列表 完全一致称为重写</p>
<h3 id="二元运算计算器类"><a href="#二元运算计算器类" class="headerlink" title="二元运算计算器类"></a>二元运算计算器类</h3><p><strong>案例描述：</strong> </p>
<ul>
<li>分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类</li>
</ul>
<p><strong>多态的优点：</strong> </p>
<ul>
<li>代码组织结构清晰</li>
<li>可读性强</li>
<li>利于前期和后期的扩展以及维护</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Calculator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">float</span> <span class="title">Result</span><span class="params">(<span class="type">char</span> op)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">switch</span> (op)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">				<span class="keyword">return</span> num1 + num2;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">				<span class="keyword">return</span> num1 - num2;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">				<span class="keyword">return</span> num1 * num2;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">				<span class="keyword">return</span> (<span class="type">float</span>) num1 / num2;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">			&#123;</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;输入错误！&quot;</span> &lt;&lt; endl;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> num1 = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> num2 = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Calculator c;</span><br><span class="line">	c.num1 = <span class="number">10</span>;</span><br><span class="line">	c.num2 = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;普通实现&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; c.num1 &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; c.num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">Result</span>(<span class="string">&#x27;+&#x27;</span>) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; c.num1 &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; c.num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">Result</span>(<span class="string">&#x27;-&#x27;</span>) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; c.num1 &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; c.num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">Result</span>(<span class="string">&#x27;*&#x27;</span>) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; c.num1 &lt;&lt; <span class="string">&quot; / &quot;</span> &lt;&lt; c.num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">Result</span>(<span class="string">&#x27;/&#x27;</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">float</span> <span class="title">Result</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> m_num1 = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> m_num2 = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddCalaulator</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">float</span> <span class="title">Result</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_num1 + m_num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubCalculator</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">float</span> <span class="title">Result</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_num1 - m_num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MultiCalaulator</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">	<span class="function"><span class="type">float</span> <span class="title">Result</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_num1 * m_num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExCalculator</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">	<span class="function"><span class="type">float</span> <span class="title">Result</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (<span class="type">float</span>) m_num1 / m_num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Remainder</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">	<span class="function"><span class="type">float</span> <span class="title">Result</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_num1 % m_num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	浮点型数据不能进行取余运算，函数重写必须保证派生类成员函数返回值类型、函数名、参数表与基类一致</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;多态实现&quot;</span> &lt;&lt; endl;</span><br><span class="line">	Base *ptr = <span class="keyword">new</span> AddCalaulator;</span><br><span class="line">	ptr -&gt; m_num1 = <span class="number">10</span>;</span><br><span class="line">	ptr -&gt; m_num2 = <span class="number">30</span>;</span><br><span class="line">	cout &lt;&lt; ptr -&gt; m_num1 &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; ptr -&gt; m_num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; ptr -&gt; <span class="built_in">Result</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span> ptr;</span><br><span class="line"></span><br><span class="line">	ptr = <span class="keyword">new</span> SubCalculator;</span><br><span class="line">	ptr -&gt; m_num1 = <span class="number">10</span>;</span><br><span class="line">	ptr -&gt; m_num2 = <span class="number">30</span>;</span><br><span class="line">	cout &lt;&lt; ptr -&gt; m_num1 &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; ptr -&gt; m_num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; ptr -&gt; <span class="built_in">Result</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span> ptr;</span><br><span class="line"></span><br><span class="line">	ptr = <span class="keyword">new</span> MultiCalaulator;</span><br><span class="line">	ptr -&gt; m_num1 = <span class="number">10</span>;</span><br><span class="line">	ptr -&gt; m_num2 = <span class="number">30</span>;</span><br><span class="line">	cout &lt;&lt; ptr -&gt; m_num1 &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; ptr -&gt; m_num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; ptr -&gt; <span class="built_in">Result</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span> ptr;</span><br><span class="line"></span><br><span class="line">	ptr = <span class="keyword">new</span> ExCalculator;</span><br><span class="line">	ptr -&gt; m_num1 = <span class="number">10</span>;</span><br><span class="line">	ptr -&gt; m_num2 = <span class="number">30</span>;</span><br><span class="line">	cout &lt;&lt; ptr -&gt; m_num1 &lt;&lt; <span class="string">&quot; / &quot;</span> &lt;&lt; ptr -&gt; m_num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; ptr -&gt; <span class="built_in">Result</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span> ptr;</span><br><span class="line"></span><br><span class="line">	ptr = <span class="keyword">new</span> Remainder;</span><br><span class="line">	ptr-&gt;m_num1 = <span class="number">10</span>;</span><br><span class="line">	ptr-&gt;m_num2 = <span class="number">30</span>;</span><br><span class="line">	cout &lt;&lt; ptr -&gt; m_num1 &lt;&lt; <span class="string">&quot; % &quot;</span> &lt;&lt; ptr -&gt; m_num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; ptr -&gt; <span class="built_in">Result</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span> ptr;</span><br><span class="line">	ptr = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong> C++开发提倡利用多态设计程序架构，因为多态优点很多</p>
<p><strong>虚函数的工作原理</strong> </p>
<p>C++规定了虚函数的行为，但将实现方法留给了编译器作者。</p>
<p>通常，编译器处理虚函数的方法是：给每个对象添加一个隐藏成员。隐藏成员中保存了一个指向函数地址数组的指针。这种数组被称为虚函数表（virtual function table， vtable）。虚函数表中存储了为类对象进行声明的虚函数地址。例如，基类对象包含一个指针，该指针指向基类中所有虚函数的地址表。派生类对象将包含一个独立地址表的指针。如果派生类提供了虚函数的新定义，该虚函数表将保存新函数的地址；如果派生类没有重新定义虚函数，该vtbl将保存函数原始版本的地址。如果派生类定义了新的虚函数，则该函数需要在对象中添加1个地址成员，只是表的大小不同而已。</p>
<p>调用虚函数时，恒旭将查看存储在对象中的vtbl地址，然后转向相应的函数地址表。</p>
<p>总之，使用虚函数时，在内存和执行速度方面有一定的成本，包括：</p>
<ul>
<li><p>每个对象都增大，增大量为存储地址的空间；</p>
</li>
<li><p>对于每个类，编译器都创建一个虚函数地址表（数组）；</p>
</li>
<li><p>对于每个函数调用，都需要执行一项额外的操作，即到表中查找地址。</p>
<p>虽然非虚函数的效率比虚函数稍高，但不具备动态联编功能。</p>
</li>
</ul>
<h3 id="有关虚函数的注意事项"><a href="#有关虚函数的注意事项" class="headerlink" title="有关虚函数的注意事项"></a>有关虚函数的注意事项</h3><ul>
<li>在基类方法声明中使用关键字virtual可使该方法在基类以及所有派生类（包括从派生类派生出来的类）中是虚的；</li>
<li>如果使用指向对象的引用或指针来调用虚方法，程序将使用对象类型定义的方法，而不是用为引用或指针类型定义的方法。这成为动态联编或晚期联编。这种行为非常重要，因为这样基类指针或引用可以指向派生类对象；</li>
<li>如果定义的类将被用作基类，则应将那些要在派生类中重新定义的类方法声明为虚的。</li>
</ul>
<p><strong>1. 构造函数</strong>  </p>
<p>构造函数不能是虚函数，创建派生类对象时，将调用派生类的构造函数，而不是积累的构造函数，然后，派生类的构造函数将使用积累的一个构造函数，这种顺序不同于继承机制。因此，派生类不继承基类的构造函数，所以类构造函数声明为虚的没有什么意义。</p>
<p><strong>2. 析构函数</strong> </p>
<p>析构函数应当是虚函数，除非类不用作基类。例如，假设Employee是基类，Singer是派生类，并添加一个char *成员，该成员指向由new分配的内存。当Singer对象过期时，必须调用~Singer() 析构函数来释放内存。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Employee *pe = <span class="keyword">new</span> Singer;	<span class="comment">// legal because Employee is base for Singer</span></span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line"><span class="keyword">delete</span> pe;	<span class="comment">// ~Employee() or Singer()?</span></span><br></pre></td></tr></table></figure>

<p>如果使用默认的静态联编，delete语句将调用<del>Employee()析构函数。这将释放由Singer对象中的Employee部分指向的内存，但不会释放新的类成员指向的内存，然后，调用</del>Employee()</p>
<p>析构函数来释放Employee组件指向的内存。</p>
<p>这意味着，即使基类不需要显式析构函数提供服务，也不应依赖于默认构造函数，而应提供虚析构函数，即使它不执行任何操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vitual ~<span class="built_in">BaseClass</span>()	&#123; &#125;</span><br></pre></td></tr></table></figure>

<pre><code>另外，给类定义一个虚析构函数并非错误，即使这个类不用做基类；这只是一个效率方面的问题。
</code></pre>
<p><strong>3. 友元</strong> </p>
<p>友元不能是虚函数，因为有缘不是类成员，而只有成员才能是虚函数。如果由于这个原因引起了设计问题，可以通过让友元函数使用虚成员函数来解决问题。</p>
<p><strong>4. 没有重新定义</strong> </p>
<p>如果派生类中没有重新定义函数，将使用该函数的基类版本，例外的情况是基类版本是隐藏的。</p>
<p><strong>5. 重新定义将隐藏方法</strong> </p>
<pre><code>假设创建了如下所示的代码：
</code></pre>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dwelling</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">showperks</span><span class="params">(<span class="type">int</span> a)</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="comment">// do something</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hovel</span> : <span class="keyword">public</span> Dwelling</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">showperks</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="comment">// do something</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这将导致问题没可能会出现类似瞎买你这样的编译器警告：</p>
<p><code> wranning: Hovel::showperks(void) hides Dwelling::showperks(int)</code></p>
<p>也可能不会出现警告。但不管结果怎样，代码将具有如下含义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hovel trump;</span><br><span class="line">trump.<span class="built_in">showperks</span>();	<span class="comment">// valid</span></span><br><span class="line">trump.<span class="built_in">hoeperks</span>(<span class="number">5</span>);	<span class="comment">// invalid</span></span><br></pre></td></tr></table></figure>

<p>新定义将showperks() 定义为一个不接受任何参数的函数。重新定义不会生成函数的两个重载版本，而是隐藏了接受一个int 参数的积累八本。总之，重新定义继承的方法并不是重载。如果重新定义派生类中的函数，将不只是使用相同的函数参数列表覆盖基类声明，无论参数列表是否相同，该操作将隐藏所有的同名基类方法。</p>
<p>这引出了两条经验规则：第一，如果重新定义继承的方法，应确保与原来的原型完全相同，但如果返回类型是基类引用或指针，则可以修改为指向派生类的引用或指针（这种例外是新出现的）。这种特性被称为返回类型协变（covariance of return type)，因为允许返回类型随类类型变化而变化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dwelling</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// a base method</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Dwelling&amp; <span class="title">build</span><span class="params">(<span class="type">int</span> n)</span></span>;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hovel</span> : <span class="keyword">public</span> Dwelling</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// a derived method with a covariant return type</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> Hovel&amp; <span class="title">build</span><span class="params">(<span class="type">int</span> n)</span></span>;	<span class="comment">// same function signature</span></span><br><span class="line">	<span class="comment">// do something</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意，这种例外只适用于返回值，而不适用于参数。</p>
<p>第二，如果基类方法被重载了，则应在派生类中重新定义所有的基类版本。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dwelling</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// three overloaded showperks()</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">showperks</span><span class="params">(<span class="type">int</span> a)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">showperks</span><span class="params">(<span class="type">double</span> x)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">showperks</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hovel</span> : <span class="keyword">public</span> Dwelling</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// three redefined showperks()</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">showperks</span><span class="params">(<span class="type">int</span> a)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">showperks</span><span class="params">(<span class="type">double</span> x)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">showperks</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果只重新定义一个版本，则另外两个版本将被隐藏，派生类对象将无法使用它们。注意，如果不需要修改，则新定义可只调用基类版本：</p>
<p><code>void Hovel::showperks() const &#123; Dwelling::showperks(); &#125;</code></p>
<h3 id="纯虚函数和抽象基类"><a href="#纯虚函数和抽象基类" class="headerlink" title="纯虚函数和抽象基类"></a>纯虚函数和抽象基类</h3><p>在多态中，通常父类中虚函数的实现是提供接口的，主要都是调用子类重写的内容，因此可以将虚函数改为<strong>纯虚函数</strong> </p>
<p>纯虚函数语法：    $virtual 返回值类型 函数名 （参数列表）= 0 ;$</p>
<p>当类中有了纯虚函数，这个类也称为 <code>抽象基类</code></p>
<p><strong>抽象基类特点：</strong> </p>
<ul>
<li>无法实例化对象</li>
<li>子类必须重写抽象基类中的纯虚函数，否则也属于抽象基类</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">	<span class="comment">//纯虚函数如下，此类为抽象基类 Abstract base class</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Result</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> num1 = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> num2 = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">next_geneation</span> : Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Result</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;这个函数是基类纯虚函数的重写&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">other_func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;这个函数不是父类函数的重写&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//Base b;//报错：不允许使用抽象基类“Base”的对象</span></span><br><span class="line">	<span class="comment">//next_geneation n;//同样报错</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//Base b1;//抽象基</span></span><br><span class="line">    类还是不允许实例化对象，但是派生类可以正常实例化对象</span><br><span class="line">	next_geneation m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="制作drinks"><a href="#制作drinks" class="headerlink" title="制作drinks"></a>制作drinks</h3><p><strong>案例描述：</strong> </p>
<ul>
<li>制作饮品的大致流程为：煮水 - 冲泡 - 倒入杯中 - 加入辅料</li>
<li>利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Abstractcheif</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">What_to_do</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//烧水</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//冲调</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//倒水</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Pour</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//调味</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Flavour</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//具体制作</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Make_Drink</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">What_to_do</span>();</span><br><span class="line">		<span class="built_in">Boil</span>();</span><br><span class="line">		<span class="built_in">Brew</span>();</span><br><span class="line">		<span class="built_in">Pour</span>();</span><br><span class="line">		<span class="built_in">Flavour</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Coffee</span> : <span class="keyword">public</span> Abstractcheif</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">What_to_do</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;给阿姨倒杯卡布奇诺&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//烧水</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;煮百岁山&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//冲调</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;冲泡咖啡&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//倒水</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Pour</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;倒入杯中&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//调味</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Flavour</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;加入方糖、牛奶和可可&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tea</span> : <span class="keyword">public</span> Abstractcheif</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">What_to_do</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;保温杯里泡枸杞&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//烧水</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;煮农夫山泉&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//冲调</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;放入茶叶、换水&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//倒水</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Pour</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;沏茶&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//调味</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Flavour</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;加入枸杞、金银花和甘草&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Do_work</span><span class="params">(Abstractcheif *abc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	abc -&gt; <span class="built_in">Make_Drink</span>();</span><br><span class="line">	<span class="keyword">delete</span> abc;</span><br><span class="line">	abc = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">Do_work</span>(<span class="keyword">new</span> Coffee);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">Do_work</span>(<span class="keyword">new</span> Tea);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="虚析构和纯虚析构"><a href="#虚析构和纯虚析构" class="headerlink" title="虚析构和纯虚析构"></a>虚析构和纯虚析构</h3><p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p>
<p>解决方式：将父类中的析构函数改为<strong>虚析构或者纯虚析构</strong> </p>
<p><strong>虚析构和纯虚析构共性：</strong> </p>
<ul>
<li>可以解决父类指针释放子类对象</li>
<li>都需要有具体的函数实现</li>
</ul>
<p><strong>虚析构和纯虚析构区别：</strong> </p>
<ul>
<li>如果是纯虚析构，该类属于抽象类，无法实例化对象</li>
</ul>
<p><strong>虚析构语法：</strong> </p>
<blockquote>
<p>virtual ~类名(){}</p>
</blockquote>
<p><strong>纯虚析构语法：</strong> </p>
<blockquote>
<p>virtual ~类名() = 0;</p>
</blockquote>
<blockquote>
<p>类名::~类名(){}</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Animal</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Animal 构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Speak</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//使用虚析构解决 父类指针指向子类对象时内存释放不干净的问题</span></span><br><span class="line">	<span class="comment">/*virtual ~Animal()</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		cout &lt;&lt; &quot;Animal 虚析构函数调用&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() = <span class="number">0</span>;<span class="comment">//纯虚析构函数也需要代码实现，因为父类在堆区可能会有数据，也需要删除</span></span><br><span class="line">	<span class="comment">//纯虚析构函数也属于纯虚函数，Animal类即为抽象类无法实例化对象</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Animal :: ~<span class="built_in">Animal</span>()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Animal 纯虚析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Cat</span>(string name)</span><br><span class="line">	&#123;</span><br><span class="line">		m_name = <span class="keyword">new</span> <span class="built_in">string</span>(name);</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Cat 构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; *m_name &lt;&lt; <span class="string">&quot;猫在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Cat</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Cat 析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	string *m_name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Animal *animal = <span class="keyword">new</span> <span class="built_in">Cat</span>(<span class="string">&quot;Tom&quot;</span>);<span class="comment">//父类指针指向子类对象触发多态</span></span><br><span class="line">	animal -&gt; <span class="built_in">Speak</span>();<span class="comment">//不使用-&gt;调用而使用.调用会报错</span></span><br><span class="line">	<span class="comment">//父类指针销毁时不会调用子类的析构函数，如果子类在堆区有对象，会导致内存泄漏</span></span><br><span class="line">	<span class="keyword">delete</span> animal;</span><br><span class="line">	animal = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">没有虚析构的输出：</span></span><br><span class="line"><span class="comment">Animal 构造函数调用</span></span><br><span class="line"><span class="comment">Cat 构造函数调用</span></span><br><span class="line"><span class="comment">Tom猫在说话</span></span><br><span class="line"><span class="comment">Animal 析构函数调用</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">虚析构之后输出：</span></span><br><span class="line"><span class="comment">Animal 构造函数调用</span></span><br><span class="line"><span class="comment">Cat 构造函数调用</span></span><br><span class="line"><span class="comment">Tom猫在说话</span></span><br><span class="line"><span class="comment">Cat 析构函数调用</span></span><br><span class="line"><span class="comment">Animal 析构函数调用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong> </p>
<ol>
<li>虚析构或纯虚析构就是用来解决通过父类指针释放子类对象</li>
<li>如果子类中没有堆区数据，可以不写为虚析构或纯虚析构</li>
<li>拥有纯虚析构函数的类也属于抽象类</li>
</ol>
<h3 id="计算机组装"><a href="#计算机组装" class="headerlink" title="计算机组装"></a>计算机组装</h3><p><strong>案例描述：</strong> </p>
<ul>
<li>电脑主要组成部件为 CPU（用于计算），显卡（用于显示），内存条（用于存储）</li>
<li>将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如Intel厂商和Lenovo厂商</li>
<li>创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口</li>
<li>测试时组装三台不同的电脑进行工作</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//抽象CPU类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPU</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//抽象的计算函数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">calculate</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//抽象显卡类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VideoCard</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//抽象的显示函数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//抽象内存条类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Memory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//抽象的存储函数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">storage</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//电脑类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Computer</span>(CPU *cpu, VideoCard *vc, Memory *mem)</span><br><span class="line">	&#123;</span><br><span class="line">		m_cpu = cpu;</span><br><span class="line">		m_vc = vc;</span><br><span class="line">		m_mem = mem;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//提供工作的函数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//让零件工作起来，调用接口</span></span><br><span class="line">		m_cpu-&gt;<span class="built_in">calculate</span>();</span><br><span class="line">		m_vc-&gt;<span class="built_in">display</span>();</span><br><span class="line">		m_mem-&gt;<span class="built_in">storage</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//提供析构函数 释放3个电脑零件</span></span><br><span class="line">	~<span class="built_in">Computer</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//释放CPU零件</span></span><br><span class="line">		<span class="keyword">if</span> (m_cpu != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_cpu;</span><br><span class="line">			m_cpu = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//释放显卡零件</span></span><br><span class="line">		<span class="keyword">if</span> (m_vc != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_vc;</span><br><span class="line">			m_vc = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//释放内存条零件</span></span><br><span class="line">		<span class="keyword">if</span> (m_mem != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_mem;</span><br><span class="line">			m_mem = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	CPU *m_cpu;		 <span class="comment">//CPU的零件指针</span></span><br><span class="line">	VideoCard *m_vc; <span class="comment">//显卡零件指针</span></span><br><span class="line">	Memory *m_mem;	 <span class="comment">//内存条零件指针</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//具体厂商</span></span><br><span class="line"><span class="comment">//Intel厂商</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelCPU</span> : <span class="keyword">public</span> CPU</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">calculate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Intel的CPU开始计算了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelVideoCard</span> : <span class="keyword">public</span> VideoCard</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Intel的显卡开始显示了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelMemory</span> : <span class="keyword">public</span> Memory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">storage</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Intel的内存条开始存储了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Lenovo厂商</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LenovoCPU</span> : <span class="keyword">public</span> CPU</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">calculate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Lenovo的CPU开始计算了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LenovoVideoCard</span> : <span class="keyword">public</span> VideoCard</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Lenovo的显卡开始显示了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LenovoMemory</span> : <span class="keyword">public</span> Memory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">storage</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Lenovo的内存条开始存储了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//第一台电脑零件</span></span><br><span class="line">	CPU *intelCpu = <span class="keyword">new</span> IntelCPU;</span><br><span class="line">	VideoCard *intelCard = <span class="keyword">new</span> IntelVideoCard;</span><br><span class="line">	Memory *intelMem = <span class="keyword">new</span> IntelMemory;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第一台电脑开始工作：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//创建第一台电脑</span></span><br><span class="line">	Computer *computer1 = <span class="keyword">new</span> <span class="built_in">Computer</span>(intelCpu, intelCard, intelMem);</span><br><span class="line">	computer1-&gt;<span class="built_in">work</span>();</span><br><span class="line">	<span class="keyword">delete</span> computer1;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;-----------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第二台电脑开始工作：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//第二台电脑组装</span></span><br><span class="line">	Computer *computer2 = <span class="keyword">new</span> <span class="built_in">Computer</span>(<span class="keyword">new</span> LenovoCPU, <span class="keyword">new</span> LenovoVideoCard, <span class="keyword">new</span> LenovoMemory);</span><br><span class="line">	;</span><br><span class="line">	computer2-&gt;<span class="built_in">work</span>();</span><br><span class="line">	<span class="keyword">delete</span> computer2;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;-----------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第三台电脑开始工作：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//第三台电脑组装</span></span><br><span class="line">	Computer *computer3 = <span class="keyword">new</span> <span class="built_in">Computer</span>(<span class="keyword">new</span> LenovoCPU, <span class="keyword">new</span> IntelVideoCard, <span class="keyword">new</span> LenovoMemory);</span><br><span class="line">	;</span><br><span class="line">	computer3-&gt;<span class="built_in">work</span>();</span><br><span class="line">	<span class="keyword">delete</span> computer3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="类设计回顾"><a href="#类设计回顾" class="headerlink" title="类设计回顾"></a>类设计回顾</h3><h4 id="编译器生成的成员函数"><a href="#编译器生成的成员函数" class="headerlink" title="编译器生成的成员函数"></a>编译器生成的成员函数</h4><p><strong>1. 默认拷贝构造函数</strong> </p>
<p>默认构造函数要么没有参数，要么所有的参数都有默认值。如果没有定义任何构造函数，编译器将定义默认构造函数，使程序员能够创建对象。</p>
<p>自动生成的默认构造函数的一项功能是，调用基类的默认构造函数以及调用本身是对象的成员所属类的默认构造函数。</p>
<p>另外，如果派生类构造函数的成员初始化列表中没有显式调用基类构造函数，则编译器将使用基类的默认构造函数，则编译器将使用基类的默认构造函数来构造派生类对象的基类部分。在这种情况下，如果基类没有提供构造函数，将导致编译阶段错误。</p>
<p>如果定义了某种构造函数，编译器将不会提供默认构造函数。在这种情况下，如果需要使用默认构造函数，则必须自己提供。</p>
<p>提供构造函数的动机之一是确保对象总能被正确的初始化。另外，如果包含汉指针成员则必须初始化这些成员。因此，最好提供一个现实默认构造函数，将所有的类数据成员都初始化为合理的值。</p>
<p>如下情况下，需要使用复制构造函数：</p>
<ul>
<li><p>将新对象初始化为一个同类对象</p>
</li>
<li><p>按值将对象传递给函数</p>
</li>
<li><p>函数按值返回对象</p>
</li>
<li><p>编译器生成临时对象</p>
</li>
</ul>
<blockquote>
<p>在某些情况下，成员初始化是不合适的。例如，使用new初始化的指针成员通常要求深拷贝。</p>
</blockquote>
<p><strong>3. 赋值运算符</strong> </p>
<ul>
<li><strong>必须作为类内成员函数进行重载的</strong> </li>
</ul>
<p>默认的赋值操作运算符用于处理同类对象之间的赋值。不要降幅至于吃u实话混淆了。如果语句创建新的对象，则要初始；如果语句修改已有对象的值，则是赋值。</p>
<p>默认赋值为成员赋值，如果成员时是对象，则默认成员赋值将使用相应类的赋值运算符。如果需要显式定义复制构造函数，基于相同的原因，也需要显式定义赋值运算符（返回值为对应类对象的引用）。</p>
<h4 id="其它的类方法"><a href="#其它的类方法" class="headerlink" title="其它的类方法"></a>其它的类方法</h4><p><strong>1. 构造函数</strong> </p>
<pre><code>构造函数不同于其他类方法。因为它创建新对象，而其他类方法只是被现有的对象调用。这是构造函数不被继承的原因之一。继承意味着派生类对象可以使用基类方法，然而，构造函数在完成其工作之前，对象并不存在。
</code></pre>
<p><strong>2. 析构函数</strong>  </p>
<pre><code>一定要定义显示析构函数来释放类构造函数使用new 分配的所有内存。并完成类对象所需的任何特殊的清理工作。对于积累，即使它不需要析构函数，也应提供一个析构函数。
</code></pre>
<p><strong>3. 转换</strong> </p>
<pre><code>使用一个参数就可以调用的构造函数定义了从参数类型到类类型的转换。如：
</code></pre>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Star</span>(<span class="type">const</span> <span class="type">char</span> *)	<span class="comment">// converts char * to Star</span></span><br><span class="line"><span class="built_in">Star</span>(<span class="type">const</span> Spectral &amp;, <span class="type">int</span> members = <span class="number">1</span>)	<span class="comment">// converts Spectral to Star</span></span><br></pre></td></tr></table></figure>

<pre><code>将可转换的类型传递给以类为参数的函数时，将调用转换构造函数。例如，下如下代码中：
</code></pre>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Star north;</span><br><span class="line">north = <span class="string">&quot;polaris&quot;</span>;</span><br></pre></td></tr></table></figure>

<pre><code>第二条语句将Star::operator=(const Star &amp;) 函数，使用Star::Star( const char * ) 生成一个Star对象，该对象将被用作上述赋值运算符函数的参数。这里假设没有定义将 char * 赋给Star 的赋值运算符。

在一个带参数的构造函数原型中使用explicit 将禁止进行隐式转换。但仍允许显式转换。
</code></pre>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Star</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// do something</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">Star</span><span class="params">( <span class="type">const</span> <span class="type">char</span> * )</span></span>;</span><br><span class="line">	<span class="comment">// do something</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">Star north;</span><br><span class="line">north = <span class="string">&quot;polaris&quot;</span>;	<span class="comment">// not allowed</span></span><br><span class="line">north = <span class="built_in">Star</span>(<span class="string">&quot;Polaris&quot;</span>);	<span class="comment">// allowed，使用匿名对象调用编译生成的赋值运算符进行赋值操作</span></span><br></pre></td></tr></table></figure>

<pre><code>要将类对象转换为其他类型，应定义转换函数。转换函数可以是没有参数的类成员函数，也可以是返回值被声明为目标类型的类成员函数。即使没有声明返回值类型，函数也应返回所需的转换值。下面是一些示例：
</code></pre>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Star::<span class="keyword">operator</span> <span class="title">double</span> <span class="params">()</span> </span>&#123; <span class="comment">// do sonmething &#125;	// converts Star to double</span></span><br><span class="line">Star::<span class="keyword">operator</span> <span class="type">const</span> <span class="type">char</span> * () &#123; <span class="comment">// do somethiong &#125;	// converts Star to const char </span></span><br></pre></td></tr></table></figure>

<pre><code>应力值的使用这样的函数，仅当它们有帮助时才使用。另外，对于某些类，包含转换函数将增加代码的二义性。例如，假设已经为Vector （矢量）定义了 double 转换，并编写了下面的代码：
</code></pre>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vector <span class="title">ius</span><span class="params">(<span class="number">6.0</span>, <span class="number">0.0</span>)</span></span>;</span><br><span class="line">Vector ius = ius + <span class="number">20.2</span>;	<span class="comment">// amibiguous</span></span><br></pre></td></tr></table></figure>

<pre><code>编译器可以将ius 转换为double 并使用假发，或将20.2 转换成Vector（使用构造函数之一）并使用Vector 加法。但除了指出二义性外，它什么也不做。

C++11支持将关键字explicit 用于转换函数。与构造函数一样explicit 允许使用强制类型转换进行显示转换，但不允许隐式转换。
</code></pre>
<p><strong>4. 按值传递对象与传递引用</strong> </p>
<pre><code>通常，编写使用对象作为参数的函数时，应按引用而不是安置来传递对象。这样做的原因之一是为了提高效率。按值传递对象涉及到生成临时拷贝，即调用复制构造函数，然后调用析构函数调用这些函数需要时间，复制大量对象比传递引用花费的时间要多得多。如果函数不修改对象，应将参数声明为const 引用。

按引用传递对象的另一个原因是，在继承使用虚函数时，被定义为接受基类引用参数的函数可以接受派生类。
</code></pre>
<p><strong>5. 返回对象和返回引用</strong> </p>
<pre><code>有些类方法返回对象（某些成员函数，比如加运算符重载函数），而另一些则返回引用（赋值运算符重载函数）。有时方法必须返回对象，但是可以不返回对象，则应返回引用。
</code></pre>
<p><strong>6.  使用const</strong> </p>
<ul>
<li><p>应当特别注意，可以使用它来确保不修改参数</p>
</li>
<li><p>使用const 来确保不修改调用它的对象</p>
<p>通常，可以将返回引用的函数放在赋值语句的左侧，这实际上意味着可以将值赋给引用的对象。但可以使用const 来确保引用或指针返回的值不能用于修改对象中的数据：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> Stock &amp; <span class="title">Stock::topval</span><span class="params">(<span class="type">const</span> Stock &amp;s)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( s.total &gt; total_val )</span><br><span class="line">    	<span class="keyword">return</span> s;	<span class="comment">// arguement obj</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    	<span class="keyword">return</span> *<span class="keyword">this</span>;	<span class="comment">// invoking obj</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>该方法返回对this 或s 的引用。因为this 和 s 都被声明为const ，所以函数不能对他们进行修改，这意味着返回的引用也必须被声明为const。
  
注意，如果函数将参数声明为指向const 的引用或指针，则不能将该参数传递给另一个函数，除非后者也确保了参数也不会被修改。
</code></pre>
</li>
</ul>
<h4 id="公有继承的考虑因素"><a href="#公有继承的考虑因素" class="headerlink" title="公有继承的考虑因素"></a>公有继承的考虑因素</h4><pre><code>通常，在程序使用继承时，有很多问题需要注意。
</code></pre>
<p><strong>1. is-a 关系</strong> </p>
<p>要遵循is-a关系。如果派生类不是一种特殊的类，则不要使用共有派生。例如，不应从Brain类派生出 Programmer类。如果要指出程序员有大脑，应将Brain类对象作为Programmer类的成员。</p>
<p>在某些情况下，最好的办法可能是创建包含纯虚函数的抽象数据类，并从它派生出其他的类。</p>
<p>表示 is-a 关系最好的方式之一是，无需进行显式类型转换，基类指针或引用就可以指向派生类对象，反过来是行不通的。向下强制转换可能有意义，也可能没有。</p>
<p><strong>2. 什么不能被继承</strong> </p>
<ul>
<li><p>构造函数是不能被继承的，即创建派生类对象时，必须调用派生类构造函数（可以初始化列表，调用基类构造函数）</p>
</li>
<li><p>析构函数也是不能继承的</p>
</li>
<li><p>赋值运算符也是不能继承的</p>
</li>
</ul>
<p>C++11 新增了一种让程序员能够继承构造函数的机制，但默认仍不能继承构造函数。</p>
<p><strong>3. 赋值运算符</strong> </p>
<ul>
<li>如果类构造函数使用new 来初始化指针，则需要提供一个显式赋值运算符。</li>
</ul>
<p><strong>4. 私有成员和保护乘员</strong> </p>
<p>对派生类而言，保护成员类似于公有成员，但对于外部来说，保护成员与私有成员类似。派生类可以直接访问基类的保护乘员，但只能通过基类的成员函数来访问私有成员。因此，将基类成员设置为私有的可以提高安全性，而将它们设置为保护成员则可以简化代码编写工作，并提高访问速度。Stroustrup指出，使用私有数据比使用保护数据更好，但是保护方法很有用。</p>
<p><strong>5. 虚方法</strong> </p>
<p>设计基类时，必须确定是否将类方法声明为虚的。如果重新定义则在基类中将方法设置为虚。</p>
<p><strong>6. 析构函数</strong> </p>
<pre><code>基类的析构函数应当是虚方法，如此，当通过指向对象的基类指针或引用来删除派生对象时，程序首先调用派生类的析构函数，然后调用基类的析构函数，而不仅仅是调用基类的析构函数。
</code></pre>
<p><strong>7. 友元函数</strong> </p>
<pre><code>由于友元函数并非类成员，因此不能被继承。程序员如果想要派生类的友元函数能够使用基类的友元函数。为此，可以通过强制类型转换将派生类引用或指针转换为基类引用或指针，然后使用转换后的指针或引用来调用基类的友元函数：
</code></pre>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="type">const</span> hasDMA ＆hs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// type cast to match operator&lt;&lt;(ostream &amp; , const hasDMA &amp;)</span></span><br><span class="line">    os &lt;&lt; (<span class="type">const</span> baseDMA &amp;)hs;</span><br><span class="line">    os &lt;&lt; <span class="string">&quot;Style: &quot;</span> &lt;&lt; hs.style &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>或者使用dynamic_cast&lt;&gt;来进行强制转换：
</code></pre>
<p><code>os &lt;&lt; dynamic_cast&lt;const baseDMA &amp;&gt; (hs);</code></p>
<p><strong>8. 有关使用基类方法的说明</strong> </p>
<pre><code>以公有派生的类的对象可以通过多种方式来调用基类的方法
</code></pre>
<ul>
<li>派生类对象自动使用继承而来的基类方法。如果派生类没有重新定义该方法</li>
<li>派生类的构造函数自动调用基类的构造函数（初始化列表）</li>
<li>派生类的构造函数自动调用基类的默认构造函数，如果没有在成员初始化列表中指定其他构造函数</li>
<li>派生类构造函数显式地调用成员初始化列表中的指定的基类构造函数</li>
<li>派生类方法可以使用作用域解析运算符来调用公有的和受保护的基类方法</li>
<li>派生类的友元函数可以通过强制类型转换，将派生类引用或指针转换为基类引用或指针，然后使该引用或指针来调用基类的友元函数。（派生-&gt;基类，特殊处理派生类中的新增属性）</li>
</ul>
<h4 id="成员函数属性"><a href="#成员函数属性" class="headerlink" title="成员函数属性"></a>成员函数属性</h4><table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">能否继承</th>
<th align="center">成员还是友元</th>
<th align="center">默认能否生成</th>
<th align="center">能否为虚函数</th>
<th align="center">是否可以有返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">构造函数</td>
<td align="center">否</td>
<td align="center">成员</td>
<td align="center">能</td>
<td align="center">否</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center">析构函数</td>
<td align="center">否</td>
<td align="center">成员</td>
<td align="center">能</td>
<td align="center">能</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center">=</td>
<td align="center">否</td>
<td align="center">成员</td>
<td align="center">能</td>
<td align="center">能</td>
<td align="center">能</td>
</tr>
<tr>
<td align="center">&amp;</td>
<td align="center">能</td>
<td align="center">任意</td>
<td align="center">能</td>
<td align="center">能</td>
<td align="center">能</td>
</tr>
<tr>
<td align="center">转换函数</td>
<td align="center">能</td>
<td align="center">成员</td>
<td align="center">否</td>
<td align="center">能</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center">()</td>
<td align="center">能</td>
<td align="center">成员</td>
<td align="center">否</td>
<td align="center">能</td>
<td align="center">能</td>
</tr>
<tr>
<td align="center">[]</td>
<td align="center">能</td>
<td align="center">成员</td>
<td align="center">否</td>
<td align="center">能</td>
<td align="center">能</td>
</tr>
<tr>
<td align="center">-&gt;</td>
<td align="center">能</td>
<td align="center">成员</td>
<td align="center">否</td>
<td align="center">能</td>
<td align="center">能</td>
</tr>
<tr>
<td align="center">op=</td>
<td align="center">能</td>
<td align="center">任意</td>
<td align="center">否</td>
<td align="center">能</td>
<td align="center">能</td>
</tr>
<tr>
<td align="center">new</td>
<td align="center">能</td>
<td align="center">静态成员</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">void*</td>
</tr>
<tr>
<td align="center">delete</td>
<td align="center">能</td>
<td align="center">静态成员</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">void</td>
</tr>
<tr>
<td align="center">其他运算符</td>
<td align="center">能</td>
<td align="center">任意</td>
<td align="center">否</td>
<td align="center">能</td>
<td align="center">能</td>
</tr>
<tr>
<td align="center">其他成员</td>
<td align="center">能</td>
<td align="center">成员</td>
<td align="center">否</td>
<td align="center">能</td>
<td align="center">能</td>
</tr>
<tr>
<td align="center">友元</td>
<td align="center">否</td>
<td align="center">友元</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">能</td>
</tr>
</tbody></table>
<p><strong>要特别注意转换函数</strong> ，严格来说它没有返回值，要返回的类型就是其函数名</p>
<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><h3 id="简单文件输入-输出"><a href="#简单文件输入-输出" class="headerlink" title="简单文件输入/输出"></a>简单文件输入/输出</h3><pre><code>**对于文件输入**，C++使用类似于cout的东西，如下是一些有关于cout用于控制台输出的基本事实，为文件输出做准备：
</code></pre>
<ul>
<li><p>必须包含iostream头文件</p>
</li>
<li><p>头文件iostream定义了一个用来处理输出的ostream类</p>
</li>
<li><p>头文件iostream声明了一个名为cout的ostream对象</p>
</li>
<li><p>必须指明名称空间std</p>
</li>
<li><p>可以结合使用cout和运算符&lt;&lt;来显示各种类型的数据（文件输出与此相同）</p>
</li>
<li><p>必须包含头文件fstream</p>
</li>
<li><p>头文件定义了一个用于处理文件输出的ofstream类</p>
</li>
<li><p>需要声明一个或多个ofstream对象，并以自己喜欢的方式命名，条件是遵守常见的命名规则</p>
</li>
<li><p>必须指明名称空间std（为引用ofstream，必须使用using编译指令或前缀std::）</p>
</li>
<li><p>需要将ofstream对象与文件关联起来。为此，方法之一是使用open()方法</p>
</li>
<li><p>使用完文件后，应使用close()方法将其关闭</p>
</li>
<li><p>可结合ofstream对象和运算符&lt;&lt;来输出各种类型的数据</p>
<p><strong>注意</strong>，方法open()接受一个C-style的字符串，如果文件名定义为string类型，则open()方法参数应该是stringName.c_str()。</p>
<p>并且默认写入状态是覆盖原有内容。</p>
</li>
</ul>
<pre><code>**对于文本文件输入**，它是基于控制台输入的。控制台输入涉及多个方面，下面总结这些方面：
</code></pre>
<ul>
<li><p>必须包含头文件iostream</p>
</li>
<li><p>头文件iostream定义了一个用于处理输入的istream类</p>
</li>
<li><p>头文件iostream声明了一个名为cin的istream对象</p>
</li>
<li><p>必须指明名称空间std</p>
</li>
<li><p>可以结合使用cin和运算符&gt;&gt;来读取各种类型的数据</p>
</li>
<li><p>可以使用cin和get()方法来读取一个字符，使用cin和getline()来读取一行字符</p>
</li>
<li><p>可以结合使用cin和eof()，fail()方法来判断输入是否成功</p>
</li>
<li><p>对象cin本身被用作测试条件时，如果最后一个读取操作成功，它将被转换为bool值true，否则将被转换为false</p>
<p>文件输出与其极其相似：</p>
</li>
<li><p>必须包含头文件fstream</p>
</li>
<li><p>头文件fstream定义了一个用于处理输入的ifstream类</p>
</li>
<li><p>需要声明一个或多个ifstream对象，并以自己喜欢的方式命名对象，条件是遵守常用命名规则</p>
</li>
<li><p>必须指明名称空间std</p>
</li>
<li><p>需要将ifstream对象与文件关联起来，方法之一是使用open()方法</p>
</li>
<li><p>使用完文件后，应使用close()方法将其关闭</p>
</li>
<li><p>可结合使用ifstream对象和运算符&gt;&gt;来读取各种类型的数据</p>
</li>
<li><p>可以使用ifstream对象和get()方法来读取一个字符，使用ifstream对象和getline()来读取一行字符</p>
</li>
<li><p>可以结合使用ifstream和eof()、fail()等方法来判断输入是否成功</p>
</li>
<li><p>ifstream对象本身被用作测试条件时，如果最后一个读取操作成功，它将被转换为bool值true，否则将被转换为false</p>
</li>
</ul>
<p>包含头文件 <fstream></p>
<p>文件类型：</p>
<ul>
<li>文本文件</li>
<li>二进制文件</li>
</ul>
<p>文件操作的类别：</p>
<ul>
<li>ofstream    写文件</li>
<li>ifstream         读文件</li>
<li>fstream          读写操作</li>
</ul>
<h3 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h3><ol>
<li>头文件</li>
<li>创建写入流对象             ofstream ofs;</li>
<li>打开文件                          ofs.open(“文件路径”, 打开方式);</li>
<li>写数据                ofs &gt;&gt; “data”;</li>
<li>关闭文件               ofs.close();</li>
</ol>
<table>
<thead>
<tr>
<th>文件打开方式</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>ios::in</td>
<td>读模式打开文件</td>
</tr>
<tr>
<td>ios::out</td>
<td>写模式打开文件</td>
</tr>
<tr>
<td>ios::ate</td>
<td>初始位置：文件尾（追加模式），打开时指针在文件尾， 可以通过seekp等操作移动指针位置。</td>
</tr>
<tr>
<td>ios::app</td>
<td>追加方式写文件，每次写操作都在文件尾</td>
</tr>
<tr>
<td>ios::trunc</td>
<td>覆盖模式，重新创建文件</td>
</tr>
<tr>
<td>ios::binary</td>
<td>二进制模式打开</td>
</tr>
</tbody></table>
<p>文件打开方式可以配合使用，模式与模式之间使用 | 分隔</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. #include &lt;fstream&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. create fstream obj</span></span><br><span class="line">    ofstream ofs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. pattern open file</span></span><br><span class="line">    ofs.<span class="built_in">open</span>(<span class="string">&quot;01_test.txt&quot;</span>, ios::out);   <span class="comment">// C-style string </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. write something into file</span></span><br><span class="line">    ofs &lt;&lt; <span class="string">&quot;姓名：张三 &quot;</span> &lt;&lt; <span class="string">&quot;年龄：19&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. close file</span></span><br><span class="line">    ofs.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ALL DONE&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. #include &lt;fstream&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. create fstream obj </span></span><br><span class="line">    ifstream ifs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. open file with ios::in and judge op success</span></span><br><span class="line">    ifs.<span class="built_in">open</span>(<span class="string">&quot;01_test.txt&quot;</span>, ios::in);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Fialed to open file&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. read file</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// method one</span></span><br><span class="line">    <span class="comment">// char buf[1024] = &#123; 0 &#125;;</span></span><br><span class="line">    <span class="comment">// while (ifs &gt;&gt; buf)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// &#125; </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// mothod two </span></span><br><span class="line">    <span class="comment">// char buf[1024] = &#123; 0 &#125;;</span></span><br><span class="line">    <span class="comment">// while (ifs.getline(buf, 1024))  // char*, max size, one char-one bit</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// method three</span></span><br><span class="line">    <span class="comment">// string buf;</span></span><br><span class="line">    <span class="comment">// while (getline(ifs, buf))   // overloaded getline(cin, string);</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// method four</span></span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span> (ifs.<span class="built_in">get</span>(ch) &amp;&amp; ch != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; ch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. close file</span></span><br><span class="line">    ifs.<span class="built_in">close</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ALL DONE&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="二进制写文件"><a href="#二进制写文件" class="headerlink" title="二进制写文件"></a>二进制写文件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// string.c_str();</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>(string n, <span class="type">int</span> a) : <span class="built_in">name</span>(n), <span class="built_in">age</span>(a) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. #include &lt;fstream&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. create ifstream obj</span></span><br><span class="line">    ofstream ofs;</span><br><span class="line">    <span class="comment">// 3. open file</span></span><br><span class="line">    ofs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::out | ios::binary);</span><br><span class="line">    <span class="comment">// 4. write</span></span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;张三&quot;</span>, <span class="number">78</span>)</span></span>;</span><br><span class="line">    ofs.<span class="built_in">write</span>((<span class="type">const</span> <span class="type">char</span>*)&amp;p, <span class="built_in">sizeof</span>(p));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. close file</span></span><br><span class="line">    ofs.<span class="built_in">close</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ALL DONE&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="二进制读文件"><a href="#二进制读文件" class="headerlink" title="二进制读文件"></a>二进制读文件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// string.c_str();</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>(string n, <span class="type">int</span> a) : <span class="built_in">name</span>(n), <span class="built_in">age</span>(a) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. #include &lt;fstream&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. create ifstream obj</span></span><br><span class="line">    ofstream ofs;</span><br><span class="line">    ifstream ifs;</span><br><span class="line">    <span class="comment">// 3. open file</span></span><br><span class="line">    ofs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::out | ios::binary);</span><br><span class="line">    <span class="comment">// 4. write</span></span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;张三&quot;</span>, <span class="number">78</span>)</span></span>;</span><br><span class="line">    ofs.<span class="built_in">write</span>((<span class="type">const</span> <span class="type">char</span>*)&amp;p, <span class="built_in">sizeof</span>(p));</span><br><span class="line"></span><br><span class="line">    Person p1;</span><br><span class="line">    ifs.<span class="built_in">read</span>((<span class="type">char</span> *)&amp;p1, <span class="built_in">sizeof</span>(p));</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; p1.name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p1.age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. close file</span></span><br><span class="line">    ofs.<span class="built_in">close</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ALL DONE&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>涉及到编码，事情变得异常复杂，所以不建议二进制读写</p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>程序有时会遇到运行阶段错误，导致程序无法正常的运行下去。例如，程序请求打开一个不可用的文件，请求过多内存，或者遭遇不可忍受的值。通常，程序员会试图预防这些意外情况。C++异常为处理这种情况提供了一种强大而灵活的工具。异常是比较新的C++功能，有些老的编译器可能没有实现。另外，有些编译器默认关闭这种特性，需要手动启用。</p>
<p>一种比较为大众所熟知的情况是：计算两个数的算术平均数，即</p>
<blockquote>
<p>2.0 * x * y / ( x + y)</p>
</blockquote>
<p>如果 y 与 x 互为相反数，则上述公式将导致被零除——一种不被允许的运算，很多新式编译器通过生成一个表示无穷大的特殊浮点数来处理，cout将这种值显示为Inf、inf、INF或类似的东西；而其他编译器可能生成在发生被零除时崩溃的程序。最好编写在所有系统上都以相同的受控方式运行的代码。</p>
<h3 id="调用abort"><a href="#调用abort" class="headerlink" title="调用abort ()"></a>调用abort ()</h3><p>对上述提到的问题，处理方式之一是：如果两参数互为相反数，则调用abort()函数，其原型位于头文件<cstdlib>中，其典型实现是向标准错误流发送消息 abnormal program termination（程序异常终止），然后终止程序。它还返回一个随实现而异的值，告诉操作系统（如果程序是由另一个进程调用的，则告诉父进程），处理失败。abort()函数是否刷新文件缓冲区（用于存储读写到文件中的数据的内存区域）取决于实现。如果愿意，也可以使用exit()，该函数刷新文件缓冲区，但不显示消息。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// error1.cpp - using the abort() function</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">hmean</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == -b)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;untenable arguments to hmean()\n&quot;</span>;</span><br><span class="line">        std::<span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2.0</span> * a * b / (a + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> x, y, z;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter two numbers: &quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (std::cin &gt;&gt; x &gt;&gt; y)</span><br><span class="line">    &#123;</span><br><span class="line">        z = <span class="built_in">hmean</span>(x, y);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Harmonic mean of &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; z &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Enter next set of numbers &lt;q to quit&gt;: &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Bye!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3 6 </span></span><br><span class="line"><span class="comment">10 -10</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>为避免异常终止，程序应在调用hmean()函数之前检查x和y的值。然而，依靠程序员来执行这种检查是不安全的。</p>
<h3 id="返回错误码"><a href="#返回错误码" class="headerlink" title="返回错误码"></a>返回错误码</h3><p>一种比异常终止更灵活的方法是，使用函数的返回值来指出问题。例如，istream类的 get(void)成员通常返回下一个输入字符的ASCII码，但达到文件尾时，将返回特殊值EOF，对于hmean()来说，这种方法不管用。任何数值都是有效的返回值，因此不存在可用于指出问题的特殊值。在这种情况下，可使用指针参数或指针引用来将值返回给调用程序，并使用函数的返回值来指出是成功了还是失败了，另外还给函数该函数增加了第三个参数，用于提供答案。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// error2.cpp - returning an error code</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cfloat&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hmean</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b, <span class="type">double</span> *ans)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == -b)</span><br><span class="line">    &#123;</span><br><span class="line">        *ans = DBL_MAX;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        *ans = <span class="number">2.0</span> * a * b / (a + b);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> x, y, z;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter two numbers: &quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (std::cin &gt;&gt; x &gt;&gt; y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">hmean</span>(x, y, &amp;z))</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Harmonic mean of &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; z &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;One value should not be the negative of the other - try again&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Enter next set of numbers &lt;a to quit&gt;: &quot;</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Bye!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序设计避免了错误输入的恶果，让用户能够继续输入。当然，设计确实依靠用户检查函数返回值，这项工作是程序员不常做的。C++ primer plus 这本书罗列的程序中都没有检查cout是否成功输出的。</p>
<p>第三个参数可以是指针或者引用。对内置类型的数据，很多程序员偏向于使用指针，因为这样可以明显地看出是哪一个参数用于提供答案。</p>
<p>另一种在某一个地方存储返回条件的方法是使用一个全局变量。可能出现问题的函数可以在出现问题时将该全局变量设置为特定的值，而调用程序检查该变量。传统的C语言数学库就是使用这种方法，它使用的全局变量名为errno。当然，必须确保其他函数没有将该全局变量用于其它目的。</p>
<h3 id="异常机制"><a href="#异常机制" class="headerlink" title="异常机制"></a>异常机制</h3><p>C++异常是对程序运行过程中发生的异常情况（例如被零除）的一种响应。异常提供了将控制权从程序的一部分传递到另一部分的途径，对异常的处理有三部分：</p>
<ul>
<li>引发异常</li>
<li>使用处理程序捕捉异常</li>
<li>使用try块</li>
</ul>
<p>程序在出现问题时引发异常。修改调用abort()函数的程序，使hmean引发异常，而不是调用    abort()函数。throw语    句实际上是跳转，即命令程序跳到另一语句。throw关键字表示引发异常，紧随其后的值（例如字符串或对象）指出了异常的特征。</p>
<p>程序使用异常处理程序（exception handler）来捕捉异常，异常处理程序位于要处理问题的程序中。catch关键字表示捕获异常。处理程序以关键字catch开头，随后是位于括号中的类型声明，它指出了异常处理程序要响应的异常类型；然后是一个用花括号括起的代码块，指出要采取的措施。catch关键字和异常类型用作标签，指出当异常被引发时，程序应当跳到该位置执行。</p>
<pre><code>try块标识其中特定的异常可能被激活的代码块，它后面跟一个或多个catch块。try块是由关键字try指示的，关键字try的后面是一个由花括号括起的代码块，表明需要注意这些代码引发的异常。
</code></pre>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// error3.cpp - using an exception</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">hmean</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == -b)</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&quot;bad hmean() argumrnts: a = -b not allowed&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2.0</span> * a * b / (a + b); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> x, y, z;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter two numbers: &quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (std::cin &gt;&gt; x &gt;&gt; y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;   <span class="comment">// start of try block</span></span><br><span class="line">            z = <span class="built_in">hmean</span>(x, y);</span><br><span class="line">        &#125;   <span class="comment">// end of try block</span></span><br><span class="line">        <span class="built_in">catch</span> (<span class="type">const</span> <span class="type">char</span> *s)   <span class="comment">// start of exception handler</span></span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; s &lt;&lt; std::endl;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Enter a new pair of numbers: &quot;</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;   <span class="comment">// end of exception handler</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Harmonic mean of &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; z &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Enter next set of numbers &lt;q to quit&gt;: &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Bye!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="将对象作为异常类型"><a href="#将对象作为异常类型" class="headerlink" title="将对象作为异常类型"></a>将对象作为异常类型</h3><p>通常，引发异常的函数将传递一个对象。这样做的优点之一是，可以在使用不同的异常类型来区分不同的函数在不同情况下引发的异常。另外，对象可以携带信息，程序员可以根据这些信息来确定引发异常的原因。同时，catch块可以根据这些信息来确定决定采取什么样的措施。</p>
<p>exc_mean.h</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// exc_mean.h   exception classes for hmean() gmean()</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">bad_hmean</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> v1;</span><br><span class="line">    <span class="type">double</span> v2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">bad_hmean</span>(<span class="type">double</span> a = <span class="number">0</span>, <span class="type">double</span> b= <span class="number">0</span>):<span class="built_in">v1</span>(a), <span class="built_in">v2</span>(b) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mesg</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">bad_hmean::mesg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;hmean(&quot;</span> &lt;&lt; v1 &lt;&lt; v2 &lt;&lt; <span class="string">&quot;): invalid arguments : a = -b&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">bad_gmean</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> v1;</span><br><span class="line">    <span class="type">double</span> v2;</span><br><span class="line">    <span class="built_in">bad_gmean</span>(<span class="type">double</span> a, <span class="type">double</span> b):<span class="built_in">v1</span>(a), <span class="built_in">v2</span>(b) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">mesg</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">bad_gmean::mesg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;gmean() arguments should be &gt;= 0&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>04_error4.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// error4.cpp using exception classes</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;04_exc_mean.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// function prototypes</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">hmean</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">gmean</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::cin;</span><br><span class="line">    <span class="keyword">using</span> std::cout;</span><br><span class="line">    <span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> x, y, z;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter two numbers: &quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; x &gt;&gt; y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            z = <span class="built_in">hmean</span>(x, y);</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Harmonic mean of &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; z &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Geometric mean of &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;and &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; <span class="built_in">gmean</span>(x, y) &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Enter next set of numbers &lt;q to quit&gt;: &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">catch</span> (bad_hmean &amp;bg)   <span class="comment">// start of catch block</span></span><br><span class="line">        &#123;</span><br><span class="line">            bg.<span class="built_in">mesg</span>();</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Try again.&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">catch</span> (bad_gmean &amp;hg)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; hg.<span class="built_in">mesg</span>();</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Values used &quot;</span> &lt;&lt; hg.v1 &lt;&lt; hg.v2 &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Sorry, you don&#x27;t get to play any more&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;   <span class="comment">// end of catch block</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Bye!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">hmean</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == --b)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">bad_hmean</span>(a, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2.0</span> * a * b / (a + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">hmean</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; <span class="number">0</span> || b &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">bad_gmean</span>(a, b);</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">sqrt</span>(a * b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4 12 </span></span><br><span class="line"><span class="comment">5 -5</span></span><br><span class="line"><span class="comment">5 -2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="异常规范与C-11"><a href="#异常规范与C-11" class="headerlink" title="异常规范与C++11"></a>异常规范与C++11</h3><p>有时候，一种理念看似有前途，但实际使用效果并不好。异常规范（exception specification）就是这样一个例子。这是C++98新增的一项功能，但C++11却将之摒弃，这意味着C++11仍然处于标准之中，但以后可能会从标准中剔除。因此不建议使用。</p>
<p>忽视异常规范前，至少应该了解它到底是怎样的，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">harm</span><span class="params">(<span class="type">double</span> a)</span> <span class="title">throw</span><span class="params">(bad_thing)</span></span>;	<span class="comment">// may throw bad_thing exception</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">marm</span><span class="params">(<span class="type">double</span>)</span> <span class="title">throw</span><span class="params">()</span></span>;	<span class="comment">// doesn&#x27;t throw an exception</span></span><br></pre></td></tr></table></figure>

<p>其中throw()部分就是异常规范，它可能出现在函数原型和函数定义中，可包含类型列表，也可不包含。</p>
<p>异常规范的作用之一是，告诉用户可能需要使用try块。然而，这项工作也可使用注释轻松完成。异常规范的另一个作用是，让编译器添加执行阶段检查的代码，检查是否违反了异常规范。这很难检查。例如，marm()可能本身不会引发异常，但它可能调用另一个函数，而这个函数调用的另一个函数引发了异常。另外，程序员在编写代码时可能不会有异常，但库更新之后它却会引发异常。总之，编程社区达成的一致意见是，最好不要使用这项新功能。而C++11 也建议忽略异常规范。</p>
<pre><code>尽管如此，C++11确实支持一种特殊的异常规范：程序员可以使用新增的关键字noexcept指出程序不会发生异常：
</code></pre>
<p><code>double marm() noexcrpt;        // marm() doesn&#39;t throw an exception</code> </p>
<p>有关这种异常规范是否有必要存在和有用存在一些争议，见仁见智。</p>
<p>vector的构造函数是显式声明了不会出现异常的。</p>
<h3 id="栈解退"><a href="#栈解退" class="headerlink" title="栈解退"></a>栈解退</h3><p>我觉得其中比较经典的一段话是：C++通常是如何处理函数调用和函数返回的：</p>
<blockquote>
<p>C++通常将信息放在栈中来处理函数调用。具体地说，程序将调用函数的指令的地址（返回地址）放到栈中。当被调用的函数执行完毕后，程序将使用改地址来确定从哪里开始继续执行。另外，函数调用将函数参数放到栈中。在栈中，这些函数参数被视为自动变量。如果被调用的函数创建了新的自动变量，则这些变量也将被添加到栈中。如果被调用那个的函数调用了另一个函数，则后者的信息将被添加到栈中，依此类推。当函数结束时，程序流程将跳到该函数被调用是存储的地址处，同时栈顶的元素将被释放。因此，函数通常返回到调用它的函数，依此类推，同时每个函数都在结束时释放其自动变量。如果自动变量是类对象，则类的析构函数将被调用。</p>
</blockquote>
<p>现在假设函数由于出现异常（而不是由于返回）而终止，则程序也将释放栈中的内存，但不会在释放栈第一个返回地址后停止，知道找到一个位于try块中返回的地址。随后，控制权将转到块尾的异常处理程序，而不是函数调用后面的第一条语句。这个过程被称为<strong>栈解退</strong>。引发机制的一个非常重要的特性是，和函数返回一样，对于栈中的自动类对象，类的析构函数将被调用。然而，函数仅仅处理该函数放在栈中的对象（堆上创建的对象不会被释放，会引发内存泄漏），而throw语句则处理try块和throw块之间整个函数调用序列放在栈中的对象。如果没有栈解退这种特性，则引发异常后，对于中间函数调用放在栈中的自动类对象，其析构函数不会被调用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// error5.cpp - unwinding the stack</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;04_exc_mean.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">demo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string word;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">demo</span>(<span class="type">const</span> std::string &amp;str)</span><br><span class="line">    &#123;</span><br><span class="line">        word = str;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;demo &quot;</span> &lt;&lt; word &lt;&lt; <span class="string">&quot; created\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">demo</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;demo &quot;</span> &lt;&lt; word &lt;&lt; <span class="string">&quot; destroyed\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;demo &quot;</span> &lt;&lt; word &lt;&lt; <span class="string">&quot; lives!\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// function prototypes</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">hmean</span><span class="params">(<span class="type">double</span>, <span class="type">double</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">gmean</span><span class="params">(<span class="type">double</span>, <span class="type">double</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">means</span><span class="params">(<span class="type">double</span>, <span class="type">double</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::cout;</span><br><span class="line">    <span class="keyword">using</span> std::cin;</span><br><span class="line">    <span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> x, y, z;</span><br><span class="line">    <span class="function">demo <span class="title">d1</span><span class="params">(<span class="string">&quot;found in block in main()&quot;</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter two numbers: &quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; x &gt;&gt; y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;   <span class="comment">// start of try block</span></span><br><span class="line">            z = <span class="built_in">hmean</span>(x, y);</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;The mean mean of &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; z &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Enter next pair: &quot;</span>; </span><br><span class="line">        &#125;   <span class="comment">// end of try block</span></span><br><span class="line">        <span class="built_in">catch</span> (bad_hmean &amp;bg)   <span class="comment">// start of exception handler</span></span><br><span class="line">        &#123;</span><br><span class="line">            bg.<span class="built_in">mesg</span>();</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Try again.\n&quot;</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">catch</span> (bad_gmean &amp;hg)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; hg.<span class="built_in">mesg</span>();</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Values used: &quot;</span> &lt;&lt; hg.v1 &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; hg.v2 &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Sorry, you don&#x27;t get to try any more.\n&quot;</span>;</span><br><span class="line">        &#125;   <span class="comment">// end of exception handler</span></span><br><span class="line">        d1.<span class="built_in">show</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Bye!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">hmean</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == -b)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">bad_hmean</span>(a, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2.0</span> * a * b / (a + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">gmean</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; <span class="number">0</span> || b &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">bad_gmean</span>(a, b);</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">sqrt</span>(a * b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">means</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> am, hm, gm;</span><br><span class="line">    <span class="function">demo <span class="title">d2</span><span class="params">(<span class="string">&quot;found in means()&quot;</span>)</span></span>;</span><br><span class="line">    am = (a + b) / <span class="number">2.0</span>;     <span class="comment">// arithmetic mean</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        hm = <span class="built_in">hmean</span>(a, b);</span><br><span class="line">        gm = <span class="built_in">gmean</span>(a, b); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (bad_hmean &amp;bg)</span><br><span class="line">    &#123;</span><br><span class="line">        bg.<span class="built_in">mesg</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Caught in means()\n&quot;</span>;</span><br><span class="line">        <span class="keyword">throw</span>;  <span class="comment">// rethrows the exception   enabled the second catch in main()</span></span><br><span class="line">    &#125;</span><br><span class="line">    d2.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> (am + hm + gm) / <span class="number">3.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2023/03/25/NIypEaoxbHGe4iQ.png" alt="栈解退"> </p>
<blockquote>
<p>在第二次，d2.show() 并没有被执行，因为means()中没有处理bad_gmean异常的机制，所以异常被抛出到主函数中，由第二个catch块解决。</p>
</blockquote>
<h3 id="其他异常特性"><a href="#其他异常特性" class="headerlink" title="其他异常特性"></a>其他异常特性</h3><p>虽然throw-catch机制类似于函数参数和函数返回机制。倒是还是有不同之处。其中之一是函数fun()中的返回语句将控制权返回到调用fun()的函数，但throw语句将控制权向上返回到第一个这样的函数：包括能够捕获异常的try-catch组合。比如再上一个例子中，当函数hmean()引发异常时，控制权将传递给函数means()；然而，当gmean()引发异常时，控制权向上传递给main()。</p>
<p>另一个不同之处是，引发异常时编译器总是创建一个临时拷贝，即使异常规范和catch块中指定的是引用。</p>
<blockquote>
<p>一般情况下，在程序异常终止时程序应当将栈中保存的自动变量销毁，使用引用按理说应该会发生错误，但是实际上并没有。</p>
</blockquote>
<p>throw会为待抛出的变量创建副本，但是代码中能够使用引用的原因是：</p>
<ol>
<li>将引用作为返回值的通常原因是避免创建副本以提高效率</li>
<li>涉及引用的另一重要特征，基类引用能够hi行派生类对象。假设有一组通过继承关系关联起来的异常类型，则在异常规范中只需列出一个基类引用，它将与任何派生类对象匹配。</li>
</ol>
<p>假设有一个一场类层次结构，并要分别处理不同的异常类型，则使用基类引用将能够捕获任何异常对象；而使用派生类引用只能捕获它所属类及从这个类派生而来的对象。引发异常的对象将被第一个与之匹配的catch块捕获。这意味catch块的排列顺序应该与派生顺序相反。</p>
<blockquote>
<p>如果有一个异常类继承层次结构，应这样排列catch块：将捕捉位于层次结构最下面的异常类的catch语句放在最前面，将捕获积累一场额catch语句放在最后面。</p>
<p>因为如果将捕获基类的catch语句放在最前面，第一个catch语句将捕获所有异常类型。</p>
</blockquote>
<p>通过正确排列catch快的顺序，让程序员能够再如何处理异常方面有选择的余地。然而如果不知道将要捕获何种类型的异常，则在catch块后面的捕获类型使用省略号来表达捕获任何异常类型。</p>
<p>如果知道要捕获的异常是何种类型，则可以将捕获所有异常类型的catch块放在所有catch块的最后，类似switch语句中的default。</p>
<p>可以创建捕获对象而不是引用的处理程序。在catch语句中使用基类对象时，将捕获所有的派生类对象，但派生特性将被去除，因此将使用虚方法的基类版本。</p>
<h3 id="exception类"><a href="#exception类" class="headerlink" title="exception类"></a>exception类</h3><p>C++异常的主要目的是为设计容错程序提供语言级支持，即异常使得在程序中包含错误处理功能更容易，一面时候采取一些严格的错误处理方式。异常的灵活性和相对方便性激励着程序员在条件允许的情况下在程序设计中加入错误处理功能。总之，异常是这样一种特性：类似于类，可以改变程序员的编程方式。</p>
<p>较新的C++编译器将一场合并到语言中。例如，为支持该语言，exception头文件定义了exception类，C++可以把它用作其他异常类的基类。代码可以印发exception异常，也可以将exception类作为基类。有一个名为what()的虚拟成员函数，他返回一个字符串，该字符串的特征随实现而异。然而，由于这是一个虚方法，因此可以在从exception派生而来的类中重新定义它：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">bad_mean</span> : <span class="keyword">public</span> std::exception</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">what</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;bad arguments to hmean()&quot;</span>; &#125;</span><br><span class="line">	<span class="comment">// do something</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">bad_gmean</span> : <span class="keyword">public</span> std::exception</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">what</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;bad arguments to gmean()&quot;</span>; &#125;</span><br><span class="line">	<span class="comment">// do something</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果不想以不同的方式处理这些派生而来的一场，可以在同一个基类处理程序中捕获它们：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (std::rxception &amp;e)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面将介绍一些C++库基于exception定义的异常类型</p>
<ol>
<li><p>stdexcept 异常类</p>
<p>头文件 stdexcept定义了其他几个异常类。首先，该文件顶一个 logic_error 和 runtime_error 类，它们都是以公有方式从exception派生而来的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">logic_error</span> : <span class="keyword">public</span> exception</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">logic_error</span><span class="params">(<span class="type">const</span> string &amp;what_arg)</span></span>;</span><br><span class="line">	<span class="comment">// something else</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">demain_error</span> : <span class="keyword">public</span> logic_error</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">domain_error</span><span class="params">(<span class="type">const</span> string &amp;what_arg)</span></span>;</span><br><span class="line">	<span class="comment">// something else</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这些类的构造函数接受一个string对象作为参数，该参数提供了方法what()以C_style字符串方式返回的字符串数据。</p>
<p>这两个类被用作两个派生类系列的基类。异常类系列logic_error描述了典型的逻辑错误。总体而言，通过合理的编程可以避免这种错误，但实际上这些错误还是可能发生的。每个类的名称指出了它用于报告的错误类型。</p>
<ul>
<li>domain_error;</li>
<li>invalid_argument;</li>
<li>length_error;</li>
<li>out_of_bounds.</li>
</ul>
<p>常见的有定义域异常、参数异常（invalid_argument）、越界异常（out_of_bounds）等。</p>
<p>至于runtime_error异常系列，它们描述了可能在运行期间发生但难以预计和防范的错误。每个类的名称也指出了它用于报告的错误类型。</p>
<ul>
<li><p>range_error;</p>
</li>
<li><p>overflow_error;</p>
</li>
<li><p>underflow_error;</p>
</li>
</ul>
<p>逻辑错误系列表明程序存在可以通过编程修复的问题，而运行时错误则表明程序存在无法避免的问题。所有这些错误类有相同的常规特征，它们之间的主要区别在于：不同的类名让程序员能够分别处理每种异常。另一方面，继承关系使程序员能够一起处理它们。利用继承关系安排catch块，捕获相应的异常。先越界类对象、再逻辑类对象、最后是exception类对象。</p>
<ol start="2">
<li>bad_alloc 异常和 new</li>
</ol>
<p>对于使用new 导致的内存分配问题，C++的最新处理方式是让new 引发bad_alloc 异常头文件new 包含bad_alloc类的声明，它是从exception类共有派生而来的。但在以前，当无法分配请求的内存量时，new返回一个空指针（nullptr）。</p>
<p>   这程序没必要运行，负担较大。</p>
   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// newexcp.cpp - the bad_alloc exception</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;new&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span>  <span class="comment">// for exit(),EXIT FALURE</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Bid</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> stuff[<span class="number">20000</span>];</span><br><span class="line">&#125; Big;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Big *pb;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Trying to get a big block of memory:\n&quot;</span>;    </span><br><span class="line">        pb = <span class="keyword">new</span> Big[<span class="number">10000</span>];   <span class="comment">//  1600,000,000 bytes</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Got past the new request:\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(bad_alloc &amp;ba)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Caught the exception!\n&quot;</span>;</span><br><span class="line">        cout &lt;&lt; ba.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Memory successfully allocated\n&quot;</span>;</span><br><span class="line">    pb[<span class="number">0</span>].stuff[<span class="number">0</span>] = <span class="number">4</span>;</span><br><span class="line">    cout &lt;&lt; pb[<span class="number">0</span>].stuff[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span>[] pb;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>出现异常时，方法what() 返回字符串”std::bad_alloc” 。</p>
<ol start="3">
<li>空指针和new</li>
</ol>
<p>很多代码都是在new在失败时返回空指针时编写的。为处理new的变化，有些编译器提供了一个标记（开关），让用户选择所需的行为。当前，在C++ 标准提供了一种在失败时返回空指针的new，其用法如下：</p>
   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *pt = <span class="built_in">new</span> (std::nothrow) <span class="type">int</span>;</span><br><span class="line"><span class="type">int</span> *pa = <span class="built_in">new</span> (std::nothrow) <span class="type">int</span>[<span class="number">500</span>];</span><br></pre></td></tr></table></figure>

<p>使用这种new，可将上一个例子中的核心代码改为下面所示：</p>
   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Bid *pb;</span><br><span class="line"></span><br><span class="line">pb = <span class="built_in">new</span> (std::nothrow) Big[<span class="number">10000</span>]; 	<span class="comment">// 1600,000,000 bytes</span></span><br><span class="line"><span class="keyword">if</span> (pb == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Could not allocate memory Bye:\n&quot;</span>;</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="异常、类和继承"><a href="#异常、类和继承" class="headerlink" title="异常、类和继承"></a>异常、类和继承</h3><p>异常、类和继承以三种方式相关联。首先，可以向标准C++库所做的那样，从一个异常类派生出另一个；其次，可以在类定义中嵌套异常类声明来组合异常；第三，这种嵌套类声明本身可被继承，还可用作基类。</p>
<pre><code>下面这个头文件声明了一个Sales类，它用于存储一个年份以及一个包含12个月的销售数据的数组。LabeledSales类是从Sales派生而来的，新增了个用于存储数据标签的成员。
</code></pre>
<p><code>Sales.h</code> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="comment">// sales.h - exceptions and inheritance</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sales</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> &#123; MONTHS = <span class="number">12</span> &#125;;   <span class="comment">// could be a static const, can be accessedby LabeledSales</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">bad_index</span> : <span class="keyword">public</span> std::logic_error   <span class="comment">// class LabeledSales can be used in catch block, and only can be used like Sales::bad_index, store and report of out-of-bounds value </span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> bi;  <span class="comment">// bad index value</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">bad_index</span><span class="params">(<span class="type">int</span> ix, <span class="type">const</span> std::string &amp;s = <span class="string">&quot;Index error in Sales object\n&quot;</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">bi_val</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> bi; &#125;</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">bad_index</span>() <span class="keyword">throw</span>() &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Sales</span><span class="params">(<span class="type">int</span> yy = <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="built_in">Sales</span>(<span class="type">int</span> yy, <span class="type">const</span> <span class="type">double</span> *gr, <span class="type">int</span> n);</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Sales</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">year_val</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> year; &#125;</span><br><span class="line">    <span class="keyword">virtual</span> <span class="type">double</span> <span class="keyword">operator</span>[](<span class="type">int</span> i) <span class="type">const</span>;</span><br><span class="line">    <span class="keyword">virtual</span> <span class="type">double</span>&amp; <span class="keyword">operator</span>[](<span class="type">int</span> i);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> gross[MONTHS];</span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LabeledSales</span> : <span class="keyword">public</span> Sales</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">nbad_index</span> : <span class="keyword">public</span> bad_index <span class="comment">// client can access using LabeledSales::nbad_index, inheritor of  bad_index and can store and report LabeledSales&#x27;label</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        std::string lbl;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">nbad_index</span>(<span class="type">const</span> std::string &amp;lb, <span class="type">int</span> ix, <span class="type">const</span> std::string &amp;s = <span class="string">&quot;Index error in LabedledSales object\n&quot;</span>);</span><br><span class="line">        <span class="function"><span class="type">const</span> std::string&amp; <span class="title">label_val</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> lbl; &#125;</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">nbad_index</span>() <span class="keyword">throw</span>() &#123;&#125;    <span class="comment">// similar to throws in java</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">LabeledSales</span><span class="params">(<span class="type">const</span> std::string &amp;lb = <span class="string">&quot;none&quot;</span>, <span class="type">int</span> yy = <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="built_in">LabeledSales</span>(<span class="type">const</span> std::string&amp; lb, <span class="type">int</span> yy, <span class="type">const</span> <span class="type">double</span> *gr, <span class="type">int</span> n);</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">LabeledSales</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> std::string&amp; <span class="title">Label</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> label; &#125;</span><br><span class="line">    <span class="keyword">virtual</span> <span class="type">double</span> <span class="keyword">operator</span>[] (<span class="type">int</span> i) <span class="type">const</span>;</span><br><span class="line">    <span class="keyword">virtual</span> <span class="type">double</span>&amp; <span class="keyword">operator</span>[] (<span class="type">int</span> i);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string label;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in C++98, constructor of exception class used throw(), but not in C++11 </span></span><br></pre></td></tr></table></figure>

<p>对于被嵌套类的方法，需要使用多个作用域解析符。另外，如果数组索引越界，重载[]运算符的函数将引发异常。</p>
<p><code>Sales.cpp</code> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sales.cpp - Sales implementation</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Sales.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"></span><br><span class="line">Sales::bad_index::<span class="built_in">bad_index</span>(<span class="type">int</span> ix, <span class="type">const</span> string &amp;s) : std::<span class="built_in">logic_error</span>(s), <span class="built_in">bi</span>(ix) &#123;&#125;</span><br><span class="line"></span><br><span class="line">Sales::<span class="built_in">Sales</span>(<span class="type">int</span> yy)</span><br><span class="line">&#123;</span><br><span class="line">    year = yy;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MONTHS; ++i)</span><br><span class="line">        gross[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Sales::<span class="built_in">Sales</span>(<span class="type">int</span> yy, <span class="type">const</span> <span class="type">double</span> *gr, <span class="type">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    year = yy;</span><br><span class="line">    <span class="type">int</span> lim = (n &lt; MONTHS)? n: MONTHS;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; lim; ++i)</span><br><span class="line">        gross[i] = gr[i];</span><br><span class="line">    <span class="comment">//  for i &gt; n and i &lt; MONTHS</span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; MONTHS; ++i)</span><br><span class="line">        gross[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> Sales::<span class="keyword">operator</span>[] (<span class="type">int</span> i) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= MONTHS)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">bad_index</span>(i);    </span><br><span class="line">    <span class="keyword">return</span> gross[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span>&amp; Sales::<span class="keyword">operator</span>[] (<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= MONTHS)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">bad_index</span>(i);    </span><br><span class="line">    <span class="keyword">return</span> gross[i];</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">LabeledSales::nbad_index::<span class="built_in">nbad_index</span>(<span class="type">const</span> string &amp;lb, <span class="type">int</span> ix, <span class="type">const</span> string &amp;s) :Sales::<span class="built_in">bad_index</span>(ix, s) </span><br><span class="line">&#123;</span><br><span class="line">    lbl = lb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LabeledSales::<span class="built_in">LabeledSales</span>(<span class="type">const</span> string &amp;lb, <span class="type">int</span> yy) : <span class="built_in">Sales</span>(yy)</span><br><span class="line">&#123;</span><br><span class="line">    label = lb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LabeledSales::<span class="built_in">LabeledSales</span>(<span class="type">const</span> string &amp;lb, <span class="type">int</span> yy, <span class="type">const</span> <span class="type">double</span> *gr, <span class="type">int</span> n) : <span class="built_in">Sales</span>(yy, gr, n)</span><br><span class="line">&#123;</span><br><span class="line">    label = lb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> LabeledSales::<span class="keyword">operator</span>[] (<span class="type">int</span> i) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= MONTHS)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">nbad_index</span>(<span class="built_in">Label</span>(), i);</span><br><span class="line">    <span class="keyword">return</span> Sales::<span class="keyword">operator</span>[](i);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">double</span>&amp; LabeledSales::<span class="keyword">operator</span>[](<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= MONTHS)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">nbad_index</span>(<span class="built_in">Label</span>(), i);</span><br><span class="line">    <span class="keyword">return</span> Sales::<span class="keyword">operator</span>[](i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>use_sales.cpp</code> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// use_sales.cpp - nested exceptions</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;07_sales.cpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::cin;</span><br><span class="line">    <span class="keyword">using</span> std::cout;</span><br><span class="line">    <span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> vals1[<span class="number">12</span>] = </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="number">1220</span>, <span class="number">1100</span>, <span class="number">1122</span>, <span class="number">2212</span>, <span class="number">1232</span>, <span class="number">2334</span>, </span><br><span class="line">        <span class="number">2884</span>, <span class="number">2393</span>, <span class="number">3302</span>, <span class="number">2922</span>, <span class="number">3002</span>, <span class="number">3544</span></span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="type">double</span> vals2[<span class="number">12</span>] = </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="number">12</span>, <span class="number">11</span>, <span class="number">22</span>, <span class="number">21</span>, <span class="number">32</span>, <span class="number">34</span>,</span><br><span class="line">        <span class="number">28</span>, <span class="number">29</span>, <span class="number">33</span>, <span class="number">29</span>, <span class="number">32</span>, <span class="number">35</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Sales sales1 &#123; <span class="number">2011</span>, vals1, <span class="number">12</span> &#125;;</span><br><span class="line">    LabeledSales sales2 &#123;<span class="string">&quot;Blogstar&quot;</span>, <span class="number">2012</span>, vals2, <span class="number">12</span> &#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;First try block:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> i ;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Year = &quot;</span> &lt;&lt; sales1.<span class="built_in">year_val</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">12</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; sales1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">6</span> == <span class="number">5</span>)</span><br><span class="line">                cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Year = &quot;</span> &lt;&lt; sales2.<span class="built_in">year_val</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Label = &quot;</span> &lt;&lt; sales2.<span class="built_in">year_val</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= <span class="number">12</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; sales2[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">6</span> == <span class="number">5</span>)</span><br><span class="line">                cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;End of try block 1.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (LabeledSales::nbad_index &amp;bad)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; bad.<span class="built_in">what</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Company: &quot;</span> &lt;&lt; bad.<span class="built_in">label_val</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;bad index: &quot;</span> &lt;&lt; bad.<span class="built_in">bi_val</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (Sales::bad_index &amp;bad)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; bad.<span class="built_in">what</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;bad index: &quot;</span> &lt;&lt; bad.<span class="built_in">bi_val</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\nNext try block:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        sales2[<span class="number">2</span>] = <span class="number">37.5</span>;</span><br><span class="line">        sales1[<span class="number">20</span>] = <span class="number">23345</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;End of try block 2.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (LabeledSales::nbad_index &amp;bad)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; bad.<span class="built_in">what</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Company: &quot;</span> &lt;&lt; bad.<span class="built_in">label_val</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;bad index: &quot;</span> &lt;&lt; bad.<span class="built_in">bi_val</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (Sales::bad_index &amp;bad)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; bad.<span class="built_in">what</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;bad index: &quot;</span> &lt;&lt; bad.<span class="built_in">bi_val</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Done&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面程序在使用Sales和LabeledSales类时，首先尝试超越LabeledSales对象中数组的末尾，然后试图超越Sales对象在sales1中数组的末尾。这些常识实在两个try块中进行的，让程序员能够检测每种异常。</p>
<h3 id="异常何时会迷失方向"><a href="#异常何时会迷失方向" class="headerlink" title="异常何时会迷失方向"></a>异常何时会迷失方向</h3><pre><code>异常引发后，在两种情况下会导致问题。
</code></pre>
<blockquote>
<ul>
<li>异常在函数中引发，如果在继承层次结构中，catch块中的类类型与这个类及其派生类的对象不匹配，则将这种异常称为意外异常；</li>
<li>当异常不是在函数中引发的（或者函数没有异常规范），如果没有try块或者没有匹配的catch块则将这种异常称为未捕获异常。</li>
</ul>
<p>（这种区分方式非常抽象，难以理解）</p>
<p>C++11虽然摒弃了异常规范，但仍支持它，且现有代码使用了它。</p>
</blockquote>
<p>如果它是在带异常规范的函数中引发的，在默认情况下，它将导致程序异常终止，但是可以通过修改程序对意外异常和未捕获异常的反应。</p>
<ol>
<li>未捕获异常（没有设计捕获该种异常的catch块或者try块）</li>
</ol>
<p>未捕获异常不会导致程序立即异常终止。相反，程序将首先调用函数terminate()。 在默认情况下，terminate()调用abort()函数。可以指定terminate()应调用的函数（而不是abort()）来修改termonate()的这种行为。为此，可以调用set_terminate()函数。set_terminate()和terminate()都是在头文件exception中声明的：</p>
   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*terminate_handler)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">terminate_handler <span class="title">set_terminate</span><span class="params">(terminate_handler f)</span> <span class="title">throw</span><span class="params">()</span></span>;	<span class="comment">// C++98</span></span><br><span class="line"><span class="function">terminate_handler <span class="title">set_terminate</span><span class="params">(terminate_habdler f)</span> <span class="keyword">noexcept</span></span>;	<span class="comment">// C++11</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">terminate</span><span class="params">()</span></span>;	<span class="comment">// C++98</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">terminate</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;	<span class="comment">// C++11</span></span><br></pre></td></tr></table></figure>

<p>其中的typedef使terminate_handler成为这样一种类型的名称：指向没有参数和返回值的函数的指针。set_terminate()函数将不带任何参数且返回类型为void的名曾（地址）作为参数，并返回该函数的地址。如果调用了set_terminate()函数多次，则terminate()将调用最后一次set_terminate()调用设置的函数。</p>
<p>   例：</p>
   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myQuit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Terminating due to uncaught exception\n&quot;</span>;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">5</span>);	<span class="comment">// 将退出状态值设置为5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后在程序的开头，将终止操作指定为调用该函数。</p>
<p><code>set_terminate(myQuit)   // 这里是一个函数指针或者函数对象，并不是仿函数</code> </p>
<p>如果在这时出现了一个未捕获的异常，程序将调用terminate()，而后者将调用myQuit()。</p>
<ol>
<li>意外异常（有catch块，但是不能捕获该异常）</li>
</ol>
<p>通过给函数指定异常规范，可以让函数的用户知道要捕获哪些异常。假设函数的原型如下：</p>
<p>   <code>double Argh(double, double) throw(out_of_bounds);</code> </p>
<pre><code>   则可以这样使用函数：
</code></pre>
   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    x = <span class="built_in">Argh</span>(a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (out_of_bounds &amp;ex)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>知道应捕获哪些异常很有帮助，因为默认情况下，未捕获的一场将导致程序异常终止。</p>
<p>原则上，异常规范包括函数调用的其他函数引发的异常。例如，如果Argh()调用了其他函数，而在被Argh()调用的函数中引发了某对象异常 ，则这两个函数的异常规范中都应包含该对象。除非自己编写所有的函数，并且特别的仔细。否则无法保证上述工作都以正确完成。</p>
<p>在开发中使用的可能是老式商业库，而其中的函数没有异常规范。这表明应进一步探讨：如果函数引发了异常规范中没有的异常，情况将如何？这也表明异常规范机制处理起来比较麻烦，这也是C++11将其兵器的原因之一。</p>
<p>在这种情况下，行为与未捕获异常极其相似。如果遇到意外异常，程序将调用unexpected()函数（这是谁也想不到的函数）这个函数将调用terminate()，后者在默认情况下调用abort()。正如有一个可用于修改terminate()的行为的det_terminate()函数一样，也有一个可以用于修改unexpected()的行为的set_unexpected()函数。这些新函数也是在头文件exception中声明的：</p>
   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*unexpected_handler)</span> <span class="params">()</span></span>;</span><br><span class="line"><span class="function">unexpected_handler <span class="title">set_unexpected</span><span class="params">(unexpected_handler f)</span> <span class="title">throw</span><span class="params">()</span></span>;	<span class="comment">// C++98</span></span><br><span class="line"><span class="function">unexpected_handler <span class="title">set_unexpected</span><span class="params">(unexpected_handler f)</span> <span class="keyword">noexcept</span></span>;	<span class="comment">// C++11</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unexpected</span><span class="params">()</span></span>;	<span class="comment">// C++98</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unexpected</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;	<span class="comment">// C++11</span></span><br></pre></td></tr></table></figure>

<p>然而，与提供给set_ter,imate()的函数的行为相比，提供给set_unexpected()的函数的行为受到了更严格的限制。即unexpected_handler函数可以：</p>
<ul>
<li><p>通过调用terminate()（默认行为）、abort()或exit()来终止程序；</p>
</li>
<li><p>引发异常</p>
</li>
</ul>
<p>引发异常（第二种选择）的结果取决于unexpected_handler函数所引发的异常以及引发意外异常的函数的异常规范：</p>
<ul>
<li><p>如果新引发的异常与原来的异常规范匹配，则程序将从哪里开始进行正常处理，即寻找与新引发的异常匹配的catch块。基本上，这种方法将用于预期的异常取代意外异常；</p>
</li>
<li><p>如果新引发的异常与原来的异常规范不匹配，且原来的异常规范中包含了std::bad_exception类型，则不匹配的异常将被std::bad_exception异常所取代。</p>
</li>
</ul>
<p>总之，如果要捕获所有的异常（不管是预期的异常还是意外异常），则可以这样做：</p>
<pre><code> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 设计一个替代函数，将意外异常转换为bad_exception异常，该函数的原型如下：</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myUnexpected</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">bad_exception</span>();	<span class="comment">// or just throw</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 仅使用throw，而不指定异常将导致重新引发原来的异常。然而，如果异常规范中包含了这种类型，则该异常将被bad_exception对象所取代，因为std::exception是所有派生而来的异常类的基类。</span></span><br></pre></td></tr></table></figure>
</code></pre>
<p>再程序开始的位置，将意外异常操作指定为调用该函数：</p>
<pre><code>     `set_unexpected(myUnexpected());`  
      
     最后，将bad_exception类型包括在异常规范中，并添加如下catch块序列：

 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">Argh</span><span class="params">(<span class="type">double</span>, <span class="type">double</span>)</span> <span class="title">throw</span><span class="params">(out_of_bounds, bbad_exception)</span></span>;</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    x = <span class="built_in">Argh</span>(a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (out_of_bounds &amp;ex)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (bad_exception &amp;ex)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<p>如果要使用异常规范就是仿照上面的代码，在抛出异常时抛出基类std::exception类对象。</p>
<h3 id="有关异常的注意事项"><a href="#有关异常的注意事项" class="headerlink" title="有关异常的注意事项"></a>有关异常的注意事项</h3><p>从前面关于如何使用异常的讨论，应在设计程序时就加入异常处理功能而不是在以后再添加。这样做有一些缺点。例如，使用异常会增加程序的代码，降低程序的运行速度。异常规范不适用于模板，因为模板引发的异常可能随特定的具体化而异。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">string <span class="title">mesd</span><span class="params">(<span class="string">&quot;I&#x27; trapped in an endless loop&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">if</span> (oh_no)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">exception</span>();</span><br><span class="line">	<span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>string类采用动态内存分配。通常，当函数结束时，将为mesg调用string的析构函数。虽然throw语句过早地终止了函数，但它仍然使得析构函数被调用，这要归功于栈解退。因此在这里，内存被正确的管理。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> *ar = <span class="keyword">new</span> <span class="type">double</span>[n];</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">if</span> (oh_no)</span><br><span class="line">        	<span class="keyword">throw</span> <span class="built_in">exception</span>();</span><br><span class="line">   <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">delete</span>[] ar;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有个问题解退栈时，江山出战中变量ar。但函数过早的终止意味着函数末尾的delete[] 语句被忽略。指针消失了，但它指向的内村快并没有被释放，并且不可访问。总之，这个程序运行发生了内存泄漏。</p>
<p>这种内存泄漏是可以避免的。例如，可以在引发异常的函数中捕获该异常，在catch块中包含一些清理代码，然后重新引发异常。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test3</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> * ar = <span class="keyword">new</span> <span class="type">double</span>[];</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (oh_no)</span><br><span class="line">        	<span class="keyword">throw</span> <span class="built_in">exception</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (exception &amp;ex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> [] ar;</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">delete</span> [] ar;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>除了这种折中的方法，最好是使用智能指针模板。虽然一场对于某些项目极为重要，但它也会增加编程的工作量、增大程序、降低程序的速度。另一方面，不进行错误检查的代价可能非常高。

                    异常处理
</code></pre>
<p>在现代库中，异常处理的复杂程度可能再创新高——主要原因在于文档没有对异常处理例程进行解释或解释的很蹩脚。任何熟练现代操作系统的人都遇到过未处理的异常导致的错误和问题。这些错误背后的程序员通常面临一场艰难的战役，需要不断了解库的复杂性，什么异常将被引发，他们发生的原因和时间，如何处理它们等等。</p>
<pre><code>程序员新手很快将发现，理解库中异常处理像学习语言本身一样困难，现代录中包含的历程和模式可能像C++语法细节一样陌生而困难。要开发出优秀的软件，必须花时间了解库和类中的复杂内容，就像必须花时间学习C++本身一样。通过库文档和源代码了解的异常和错误处理细节将使程序员和他们的软件受益。
</code></pre>
<h2 id="RTTI"><a href="#RTTI" class="headerlink" title="RTTI"></a>RTTI</h2><p>RTTI是运行阶段类型识别（Runtime Type Identification）的简称。这是新添加到C++中的特性之一，很多老式实现不支持，另一些实现可能包含开关RTTI的编程设置。RTTI旨在为程序在运行阶段确定对象的类型提供一种标准方式。很多类库已经为其类对象实现这种功能的方式，但由于C++内部并不支持，因此各个厂商的机制互不兼容。创建一种RTTI语言标准将使得未来的库能够彼此兼容。</p>
<h3 id="RTTI的用途"><a href="#RTTI的用途" class="headerlink" title="RTTI的用途"></a>RTTI的用途</h3><ul>
<li>程序能够使用基类的指针或引用来检查着这些指针或引用所指的对象的实际派生类型。</li>
<li> RTTI这一机制的出现与C++语言本身有关系，和其他很多语言一样，C++是一种静态类型语言。其数据结构在编译期就确定了，在运行时不可更改。然而，由于面向对象中多态的要求，C++的指针或引用本身的类型可能与它实际代表的类型并不一致。有时我们需要将一个多态指针转换为其实际指向对象的类型，就需要知道运行时的类型信息，这就产生了运行时类型识别的要求。和Java相比，C++想要获得运行时类型信息，只能通过RTTI机制，并且C++最终生成的代码是直接与机器相关的。</li>
<li>需为何需要知道类型：<ol>
<li>可能希望调用类方法正确的版本；</li>
<li>被调函数是类层次结构中所有成员都拥有虚函数，则并不真正需要知道对象的类型。但派生类对象可能包含不是继承而来的方法；</li>
<li>只有某些类型的对象可以使用该方法，也可能是出于调试的目的，想追踪生成的对象的类型。</li>
</ol>
</li>
</ul>
<h3 id="RTTI的工作原理"><a href="#RTTI的工作原理" class="headerlink" title="RTTI的工作原理"></a>RTTI的工作原理</h3><ul>
<li><p>如果可能的话，dynamic_cast 运算符将使用一个指向基类的指针来生成一个指向派生类的最指针；否则，该运算符返回空指针</p>
</li>
<li><p>typeid运算符返回一个指出对象的类型的值</p>
</li>
<li><p>type_info结构存储了有关特定类型的信息</p>
</li>
</ul>
<p>只能将RTT i用于包含虚函数的类层次结构，原因在于只有对于这种类层次结果，才应该将派生对象的地址赋给基类指针。</p>
<p>警告：RTTI只适用于包含虚函数的类</p>
<ol>
<li>dynamic_cast 运算符</li>
</ol>
<p>dynamic_cast运算符是最常用的RTTI组件，它能够回答“是否可以安全地将对象的地址赋给特定的指针”这样的问题。假设有下面这样的类层次结构：</p>
   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Grand</span> &#123; <span class="comment">// has virtual mothods &#125;;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Superb</span> : <span class="keyword">public</span> Grand &#123; <span class="comment">// do something &#125;;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Magnificent</span> : <span class="keyword">public</span> Superb &#123; <span class="comment">// do something &#125;;</span></span><br><span class="line"><span class="comment">// 接下来假设有以下指针：</span></span><br><span class="line">Grand *pg = <span class="keyword">new</span> Grand;</span><br><span class="line">Grand *ps = <span class="keyword">new</span> Superb;</span><br><span class="line">Grand *pm = <span class="keyword">new</span> Magnificent;</span><br><span class="line"><span class="comment">// 最后假设有以下类型转换：</span></span><br><span class="line">Magnificent *p1 = (Magnificent *) pm;	<span class="comment">// #1</span></span><br><span class="line">Magnificent *p2 = (Magnificent *) pg;	<span class="comment">// #2</span></span><br><span class="line">Super *p3 = (Magnificent *) pm;		<span class="comment">// #3</span></span><br></pre></td></tr></table></figure>
<p>根据类声明，上述类型转换全都是安全的，但只有那些指针类型与对象类型（或对象的直接或间接基类的类型才一定是安全的。</p>
<blockquote>
<p>说明：<br>类型转换#1是安全的，他将Magnificent类型的指针转换成Magnificent类型的对象。类型转换#2是不安全的，下转型期望基类对象有派生类的特征，这通常是不可能的，Magnificent对象可能包含Grand对象没有的数据成员。#3这种类型转换也是安全的，因为它将派生类对象的地址赋给基类指针。即公有派生确保Magnificent对象同时也是一个Superb对象（直接积累）和一个Grand对象（间接基类）。因此，将Magnificent对象的地址赋给上述三种类型的指针都是安全的。虚函数确保了将这三种指针中的任何一种指向Magnificent对象时，都将调用Magnificent方法（多态的特性）。</p>
</blockquote>
<p>与问题“指针指向的是哪种类型的对象”相比，问题“类型转换是否安全”更为通用，也更有用。通常想知道类型的原因在于，知道类型后就知道调用特定方法是否安全。要调用方法，类型并不一定要完全匹配，而可以是定义了方法的虚拟版本的基类类型。且看下面的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先来了解一下dynamic_cast的语法，该运算符的用法如下，其中pg指向一个对象：</span></span><br><span class="line">Superb *pm = <span class="built_in">dynamic_cast</span>&lt;Superb *&gt;(pg);</span><br></pre></td></tr></table></figure>
<p>在这里提出了这样的问题：指针pg的类型是否可以被安全的转换为Superb* ？ 如果可以，运算符将返回对象的地址，否则将返回一个nullptr。</p>
<blockquote>
<p> 注意：通常，如果指向对象的（*pt）类型为 为Type或者是Type直接或间接派生而来的类型，则下面的表达式将指针pt转换为TYpe类型的指针：<code>dynamic_cast&lt;Type *&gt; (pt); </code> 否则将返回一个空指针</p>
</blockquote>
<p>RTTI.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RTTI.cpp - using the RTTI dynamic_cast operator</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Grand</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> hold;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Grand</span>(<span class="type">int</span> h = <span class="number">0</span>) : <span class="built_in">hold</span>(h) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Speak</span><span class="params">()</span> <span class="type">const</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;I am a grand class!\n&quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">Value</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> hold; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Superb</span> : <span class="keyword">public</span> Grand</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Superb</span>(<span class="type">int</span> h = <span class="number">0</span>) : <span class="built_in">Grand</span>(h) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Speak</span><span class="params">()</span> <span class="type">const</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;I am a superb class!\n&quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Say</span><span class="params">()</span> <span class="type">const</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;I hold the superb value of &quot;</span> &lt;&lt; <span class="built_in">Value</span>() &lt;&lt; <span class="string">&quot;!\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Magnificent</span> : <span class="keyword">public</span> Superb</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// call base constructor</span></span><br><span class="line">    <span class="built_in">Magnificent</span>(<span class="type">int</span> h = <span class="number">0</span>, <span class="type">char</span> c= <span class="string">&#x27;A&#x27;</span>) : <span class="built_in">Superb</span>(h), <span class="built_in">ch</span>(c) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Speak</span><span class="params">()</span> <span class="type">const</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Ian a magnificent class!\n&quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Say</span><span class="params">()</span> <span class="type">const</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;I hold the character &quot;</span> &lt;&lt; ch &lt;&lt; <span class="string">&quot; and the integer &quot;</span> &lt;&lt; <span class="built_in">Value</span>() &lt;&lt; <span class="string">&quot;!\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Grand * <span class="title">GetOne</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::<span class="built_in">srand</span>(std::<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">    Grand *pg;</span><br><span class="line">    Superb *ps;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pg = <span class="built_in">GetOne</span>();</span><br><span class="line">        pg-&gt;<span class="built_in">Speak</span>();</span><br><span class="line">        ps = <span class="built_in">dynamic_cast</span>&lt;Superb *&gt;(pg);</span><br><span class="line">        <span class="keyword">if</span> (ps)</span><br><span class="line">            ps-&gt;<span class="built_in">Say</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Grand* <span class="title">GetOne</span><span class="params">()</span> <span class="comment">// generate one of three kinds of objects randomly</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Grand *p;</span><br><span class="line">    <span class="keyword">switch</span> (std::<span class="built_in">rand</span>() % <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: p = <span class="keyword">new</span> <span class="built_in">Grand</span>(std::<span class="built_in">rand</span>() % <span class="number">100</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: p = <span class="keyword">new</span> <span class="built_in">Superb</span>(std::<span class="built_in">rand</span>() % <span class="number">100</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: p = <span class="keyword">new</span> <span class="built_in">Magnificent</span>(std::<span class="built_in">rand</span>() % <span class="number">100</span>, <span class="string">&#x27;A&#x27;</span> + std::<span class="built_in">rand</span>() % <span class="number">26</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>程序说明：<br>Grand定义了一个虚函数Speak()。而其它类都重写了这个虚函数。Superb类定义了一个虚函数Say()，而Magnificent也重新定义了它，程序定义了一个GetOne函数，该函数随机创建这三种类中某种类的对象，并对其进行初始化，然后将地址作为Grand* 指针返回（GetOne函数模拟用户做出决定）循环将该指针赋给Grand* 变量pg，让偶使用pg调用Speak()函数。因为这个函数是虚拟的，所以代码能够正确地调用指向的对象的Speak()版本。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">	pg = <span class="built_in">GetOne</span>();</span><br><span class="line">	pg-&gt;<span class="built_in">Speak</span>();</span><br><span class="line">	<span class="comment">// do something else </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>然而，不能用相同的方式（即使用指向Grand的指针）来调用Say函数。但是却可以使用dynamic_cast运算符来检查是否可将pg的类型安全转换到Superb指针。如果可以对象的类型为Superb或者Magnificent，则可以安全转换。在这两种情况下，都可以安全的调用Say函数</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps = <span class="built_in">dynamic_cast</span>&lt;Superb *&gt;(pg);</span><br><span class="line">        <span class="keyword">if</span> (ps)</span><br><span class="line">            ps-&gt;<span class="built_in">Say</span>();</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>typeid运算符和type_info类<br> typeid运算符使得能够确定两个对象是否为同种类型。它与sizeof有些像，可以接受两种参数</li>
</ol>
<ul>
<li>类名</li>
<li>结果为对象的表达式<br>typeid运算符返回一个对type_info对象的引用，其中，type_info是在头文件typeinfo中定义的一个类。type_info类重载了<code>==</code>和<code>!=</code>运算符，以便可以使用这些运算符来对类型进行比较。<br>例：pg是一个指向Magnificent对象的指针，则下面的表达式的结果为bool值或者false。<br><code>typeid(Magnificent) == typeid(*pg);</code><br>如果pg是一个空指针，程序将引发bad_typeid异常。该异常是从exception类派生而来的，是在头文件typeinfo中声明的。<br>type_info类的实现随厂商而异，但包含一个name()成员，该函数返回一个随实现而异的字符串：通常是类的名称。例：<br><code>cout &lt;&lt; &quot;Now processing type&quot; &lt;&lt; typeid(*pg).name() &lt;&lt; &quot;.\n&quot;;</code><br>下面是用typeid运算符和name()成员函数。注意：它们都适用于dynamic_cast和virtual函数不能处理的情况。typeid测试用来选择一种操作，因为操作不是类的方法，所以不能通过类指针调用。name()方法语句演示了如何将方法用于调试。注意，程序包含了头文件typeinfo。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RTTI2.cpp - using dynamic_cast, typeid, and type_info</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Grand</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> hold;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Grand</span>(<span class="type">int</span> h = <span class="number">0</span>) : <span class="built_in">hold</span>(h) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Speak</span><span class="params">()</span> <span class="type">const</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;I am a grand class!\n&quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">Value</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> hold; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Superb</span> : <span class="keyword">public</span> Grand</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Superb</span>(<span class="type">int</span> h = <span class="number">0</span>) : <span class="built_in">Grand</span>(h) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Speak</span><span class="params">()</span> <span class="type">const</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;I am a superb class!\n&quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Say</span><span class="params">()</span> <span class="type">const</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;I hold the superb value of &quot;</span> &lt;&lt; <span class="built_in">Value</span>() &lt;&lt; <span class="string">&quot;!\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Magnificent</span> : <span class="keyword">public</span> Superb</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// call base constructor</span></span><br><span class="line">    <span class="built_in">Magnificent</span>(<span class="type">int</span> h = <span class="number">0</span>, <span class="type">char</span> c= <span class="string">&#x27;A&#x27;</span>) : <span class="built_in">Superb</span>(h), <span class="built_in">ch</span>(c) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Speak</span><span class="params">()</span> <span class="type">const</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;I am a magnificent class!\n&quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Say</span><span class="params">()</span> <span class="type">const</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;I hold the character &quot;</span> &lt;&lt; ch &lt;&lt; <span class="string">&quot; and the integer &quot;</span> &lt;&lt; <span class="built_in">Value</span>() &lt;&lt; <span class="string">&quot;!\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Grand * <span class="title">GetOne</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">    Grand *pg;</span><br><span class="line">    Superb *ps;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pg = <span class="built_in">GetOne</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Now processing type &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(*pg).<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot;.\n&quot;</span>;</span><br><span class="line">        pg-&gt;<span class="built_in">Speak</span>();</span><br><span class="line">        ps = <span class="built_in">dynamic_cast</span>&lt;Superb *&gt;(pg);</span><br><span class="line">        <span class="keyword">if</span> (ps)</span><br><span class="line">            ps-&gt;<span class="built_in">Say</span>();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">typeid</span>(Magnificent) == <span class="built_in">typeid</span>(*pg))</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Yes, you&#x27;re really magnificent.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Grand* <span class="title">GetOne</span><span class="params">()</span> <span class="comment">// generate one of three kinds of objects randomly</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Grand *p;</span><br><span class="line">    <span class="keyword">switch</span> (std::<span class="built_in">rand</span>() % <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: p = <span class="keyword">new</span> <span class="built_in">Grand</span>(std::<span class="built_in">rand</span>() % <span class="number">100</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: p = <span class="keyword">new</span> <span class="built_in">Superb</span>(std::<span class="built_in">rand</span>() % <span class="number">100</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: p = <span class="keyword">new</span> <span class="built_in">Magnificent</span>(std::<span class="built_in">rand</span>() % <span class="number">100</span>, <span class="string">&#x27;A&#x27;</span> + std::<span class="built_in">rand</span>() % <span class="number">26</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  与上一个例子大体相同，区别只在主函数中使用了typeid运算符以及其中的name()方法。</li>
</ul>
<ol start="3">
<li>误用RTTI的例子<br> 应该避免的编程方式：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面是 RTTI.cpp 的核心代码</span></span><br><span class="line">Grand *pg;</span><br><span class="line">    Superb *ps;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pg = <span class="built_in">GetOne</span>();</span><br><span class="line">        pg-&gt;<span class="built_in">Speak</span>();</span><br><span class="line">        ps = <span class="built_in">dynamic_cast</span>&lt;Superb *&gt;(pg);</span><br><span class="line">        <span class="keyword">if</span> (ps)</span><br><span class="line">            ps-&gt;<span class="built_in">Say</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
通过放弃dynamic_cast和虚函数，而是用typeid运算符，可以将上述代码重新编写为<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Grand *pg;</span><br><span class="line">Superb *ps;</span><br><span class="line">Magnificent *pm;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">	pg = <span class="built_in">GetOne</span>();</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">typeid</span>(Magnificent) == <span class="built_in">typsid</span>(*pg))</span><br><span class="line">	&#123;</span><br><span class="line">		pm = (Magnificent *)pg;</span><br><span class="line">		pm-&gt;<span class="built_in">Speak</span>();</span><br><span class="line">		pm-&gt;<span class="built_in">Say</span>();</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">typeid</span>(Superb) == <span class="built_in">typeid</span>(*pg))</span><br><span class="line">	&#123;</span><br><span class="line">		ps = (Superb *)pg;</span><br><span class="line">		ps-&gt;<span class="built_in">Speak</span>();</span><br><span class="line">		ps-&gt;<span class="built_in">Say</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		pg-&gt;<span class="built_in">Speak</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
上述代码不仅比原来的更难看、更长，而且显式地指定各个类存在严重的缺陷。假设从Magnificent派生出另一个类，后者需要重新定义Speak()和Say()。使用typeid来显式地测试每个类型时，必须修改for循环的带啊吗，添加一个else-if语句，但无需修改原先的版本。下面语句适用于所有从Grand派生出来的类（就是说这种方式并不如使用dynamic_cast运算符判断是否能进行安全转换的方式来的快捷）。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps = <span class="built_in">dynamic_cast</span>&lt;Superb *&gt;(pg);</span><br><span class="line">       <span class="keyword">if</span> (ps)</span><br><span class="line">           ps-&gt;<span class="built_in">Say</span>();</span><br></pre></td></tr></table></figure>
如果发现在扩展的if-else语句系列中使用了typeid，则因考虑是否应该使用虚函数和dynamic_cast。</li>
</ol>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>在C语言中，有如下例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">double</span> data[<span class="number">200</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Junk</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> junk[<span class="number">100</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Data d = &#123;<span class="number">2.5e33</span>, <span class="number">3.5e-19</span>, <span class="number">20.2e32</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *pch = (<span class="type">char</span> *)(&amp;d); <span class="comment">// type cast #1 - convert to string bingo</span></span><br><span class="line"><span class="type">char</span> ch = <span class="type">char</span>(&amp;d);       <span class="comment">// type cast #2 - convert address to a char error</span></span><br><span class="line">Junk *pj = (Junk *)(&amp;d);  <span class="comment">// type cast #3 - convert to Junk pointer </span></span><br></pre></td></tr></table></figure>
<p>上述转换在C语言中都是允许的，但是是否有意义，这是不好说的。</p>
<p>C++中使用了更为严格地限制允许转换的类型，提供了四个类型转换运算符。</p>
<ul>
<li>dynamic_cast;</li>
<li>const_cast;</li>
<li>static_cast;</li>
<li>reinterpret_cast.<br>可以根据目的选择一个合适的运算符，而不是使用通用的类型转换。这指出了进行类型转换的原因，并让编译器能够检查程序的行为是否与设计者想法相吻合</li>
<li>dynamic_cast<br>  当且仅当两个类之间存在继承关系(直接或者间接继承)时,才可以进行上转型(类似于多态,将派生类指针转换为基类指针)。成功返回基类指针，不成则返回空指针。</li>
<li>const_cast<br>  很类似于mutable，但是mutable的作用是修饰成员变量，使常成员函数能够修改该成员变量的值，或者作用于lambda表达式。这里简单提一下lambda表达式，会在下一篇详细总结。<br>  至于const_cast的作用，它是用于改变值为 const 或者 volatile，语法与dynamic_cast相同，如果类型的其他方面也被修改，则下面的类型转换将出错，复制运算符左边的类型需要与模板类型相匹配：<br>  <code>const_cast &lt;type_name&gt; (expression);</code><br>  有一个例子：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// constcast.cpp - using const_cast&lt;&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">const</span> <span class="type">int</span> *pt, <span class="type">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> pop1 = <span class="number">38383</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> pop2= <span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pop1, pop2; &quot;</span> &lt;&lt; pop1 &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; pop2 &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">change</span>(&amp;pop1, <span class="number">-103</span>);</span><br><span class="line">    <span class="built_in">change</span>(&amp;pop2, <span class="number">-103</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pop1, pop2: &quot;</span> &lt;&lt; pop1 &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; pop2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">const</span> <span class="type">int</span> *pt, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *pc;</span><br><span class="line"></span><br><span class="line">    pc = <span class="built_in">const_cast</span>&lt;<span class="type">int</span> *&gt; (pt);</span><br><span class="line">    *pc += n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在上面的例子中，pop2的值始终不会被修改，这是因为const_cast只能修改传入时为const地参数的数据，但是不能改变声明为const的变量，尝试将参数中添加的const删除时，尝试传入const类型参数会报错。</li>
<li>static_cast<br>语法与前面两个运算符相同：<br><code>static_cast &lt;type-name&gt; (expression);</code><br>仅当type-name是可被隐式转换成expression所属类型或者expression类型可被隐式转换为type-name类型数据时，上述转换才是合法的，否则将报错。<br>派生类到基类的类型转换自不必说，使用这种方式可以完成，但也可以不使用这种方法，但是在不显式指定类型转换的时候，下转型不能实现，但是使用static_cast可以在不显显式指定转换函数的情况下实现下转型。<br>也可以使用static_cast完成枚举类型到整型、整型到浮点型等数值转换。</li>
<li>reinterpret_cast<br>  reinterpret_cast属于天生危险的运算符。它不允许删除const，但会执行其他令人生厌的操作。又是程序员必须做一些依赖于实现的、令人生厌的操作，使用reinterpret_cast运算符可以简化这种行为的跟踪工作。该运算符的语法与其他的转换运算符并无差异。<br>  例：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">dat</span> &#123; <span class="type">short</span> a; <span class="type">short</span> b; &#125;;</span><br><span class="line"><span class="type">long</span> value = <span class="number">0xA224B118</span>;</span><br><span class="line">dat *pd = <span class="built_in">reinterpret_cast</span>&lt;dat *&gt; (&amp;value);</span><br><span class="line">cout &lt;&lt; hex &lt;&lt; pd-&gt;a;	<span class="comment">// display first 2 bytes of value;</span></span><br></pre></td></tr></table></figure>
通常，这样的转换适用于以来底层实现的编程技术，是不可移植的（不同系统在存储多字节整型时，可能以不同的顺序存储其中的字节）。<br>然而，reinterpret_cast运算符并不支持所有的类型转换。支持宽转换但不支持窄转换，也不能将函数指针转换成数据指针，反之亦然。</li>
</ul>
<p>在C++中，普通类型转换也受到限制。基本上，可以执行其他类型转换可执行的操作，加上一些组合，但不能执行其他转换。因此，下面的转换在C语言中是允许的，但在C++中通常不允许，因为对于大多数C++实现，char类型都太小，不能存储指针（地址）：<br><code>char ch = char (&amp;d);    // 指针的大小一般是4个字节</code><br>这些限制是合理的，如果不能接受这些限制就只能去写C语言的程序。</p>
<h1 id="提高篇"><a href="#提高篇" class="headerlink" title="提高篇"></a>提高篇</h1><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><h3 id="函数模板的语法"><a href="#函数模板的语法" class="headerlink" title="函数模板的语法"></a>函数模板的语法</h3><ol>
<li>C++的一项基础思想就是泛型编程，而模板就是泛型编程中使用的主要技术</li>
<li>C++的提供了两类模板：函数模板和类模板</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap01</span><span class="params">(T &amp;a, T &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	T temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap02</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">swap01</span>(a, b);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第一次交换：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt;  <span class="string">&quot; b = &quot;</span> &lt;&lt; b &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">swap02</span>(a, b);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第二次交换：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模板的作用是在写的时候不指定数据类型，在调用的时候由编译器或者操作系统推导数据是什么类型。</p>
<p>人是懒惰的，我们总是想要对类似的问题进行归纳总结，找出他们的共同点之后，使用同一个手段解决尽可能多的问题，我觉得这就是模板诞生的意义，也是泛型编程产生的初衷。</p>
<h3 id="函数模板的用法"><a href="#函数模板的用法" class="headerlink" title="函数模板的用法"></a>函数模板的用法</h3><p>因为在模板的使用中又用到了引用，所以需要回去看看引用的使用规范以及注意事项。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function">T <span class="title">Add</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">	<span class="type">char</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//正常的整型数据相加</span></span><br><span class="line">	cout &lt;&lt; <span class="built_in">Sum</span>(a, b) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//整型数据与字符型数据相加，隐式转换：字符型转整型，直接相加</span></span><br><span class="line">	cout &lt;&lt; <span class="built_in">Sum</span>(a, c) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//所以这里就实锤不能使用引用，自己确定数据的类型，显式指定类型发生隐式类型转换，使用模板</span></span><br><span class="line">	cout &lt;&lt; <span class="built_in">Add</span>&lt;<span class="type">int</span>&gt;(a, c) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="函数模板与普通函数的区别"><a href="#函数模板与普通函数的区别" class="headerlink" title="函数模板与普通函数的区别"></a>函数模板与普通函数的区别</h3><p><strong>普通函数与函数模板区别：</strong> </p>
<ul>
<li>普通函数调用时可以发生自动类型转换（隐式类型转换）</li>
<li>函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换</li>
<li>如果利用显示指定类型的方式，可以发生隐式类型转换</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyPrint</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;调用普通函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyPrint</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;函数模板重载普通函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyPrint</span><span class="params">(T a, T b, T c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;重载函数模板&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>, c = <span class="number">30</span>;</span><br><span class="line">	<span class="type">char</span> ch =<span class="string">&#x27;a&#x27;</span>, op = <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//优先调用普通函数</span></span><br><span class="line">	<span class="built_in">MyPrint</span>(a, b);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//告诉编译器或者操作系统：我就要调用模板</span></span><br><span class="line">	MyPrint&lt;&gt;(a, b);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//模板也可以重载的</span></span><br><span class="line">	<span class="built_in">MyPrint</span>(a, b, c);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果函数模板是更提供更好的选择，则调用模板</span></span><br><span class="line">	<span class="built_in">MyPrint</span>(ch, op);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="函数模板的局限性"><a href="#函数模板的局限性" class="headerlink" title="函数模板的局限性"></a>函数模板的局限性</h3><ol>
<li>函数模板并不是万能的；</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="type">void</span> <span class="title">f</span><span class="params">(T a, T b)</span> </span>&#123; a = b; &#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中提供的赋值操作，如果传入的a和b是一个数组，就无法实现了</p>
<ol start="2">
<li>对于函数模板，如果使用自定义数据类型进行运算还需要重载赋值运算符、关系运算符等；</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="type">void</span> <span class="title">f</span><span class="params">(T a, T b)</span> </span>&#123; <span class="keyword">if</span>(a &gt; b) &#123; <span class="keyword">do</span> something &#125; &#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，如果T的数据类型传入的是像Person这样的自定义数据类型，也无法正常运行</p>
<p>因此C++为了解决这种问题，提供模板的重载，可以为这些 <strong>特定的类型</strong> 提供<strong>具体化的模板</strong> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span> -&gt; m_Name = name;</span><br><span class="line">		<span class="keyword">this</span> -&gt; m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//常规函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MyCompare</span><span class="params">(T &amp;a, T &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(a == b)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数模板具体化，显示具体化的原型和确定含义的template&lt;&gt;开头，并通过名称来指定类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="function"><span class="type">bool</span> <span class="title">MyCompare</span><span class="params">(Person &amp;p1, Person &amp;p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p1.m_Age == p2.m_Age &amp;&amp; p1.m_Name == p2.m_Name)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>, b =<span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//使用内置数据类型直接调用通用的函数模板</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">MyCompare</span>(a, b))</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a == b&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a != b&quot;</span> &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">MyCompare</span>(p1, p2))</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;p1 == p2&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;p1 != p2&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><p>类模板作用：</p>
<ul>
<li>建立一个通用类，类中的成员 数据类型可以不具体制定，用一个虚拟的类型来代表。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="comment">//类定义</span></span><br><span class="line"><span class="comment">/*或者</span></span><br><span class="line"><span class="comment">template&lt;class T&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong> </p>
<ol>
<li>template — 声明创建模板</li>
<li>typename — 表面其后面的符号是一种数据类型，可以用class代替</li>
<li>T — 通用的数据类型，名称可以替换，通常为大写字母</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">NameType</span>, <span class="keyword">class</span> <span class="title class_">AgeType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(NameType name, AgeType age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span> -&gt; m_Name = name;</span><br><span class="line">		<span class="keyword">this</span> -&gt; m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span> -&gt; m_Name &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; <span class="keyword">this</span> -&gt; m_Age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	NameType m_Name;</span><br><span class="line">	AgeType m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//指定 NameType 为 string 类型，AgeType 为整型</span></span><br><span class="line">	Person&lt;string, <span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;孙悟空&quot;</span>,<span class="number">999</span>);</span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong> 类模板和函数模板语法相似，在声明模板template后面加类，此类称为类模板</p>
<h3 id="类模板与函数模板的区别"><a href="#类模板与函数模板的区别" class="headerlink" title="类模板与函数模板的区别"></a>类模板与函数模板的区别</h3><p>类模板与函数模板区别主要有两点：</p>
<ol>
<li>类模板没有自动类型推导的使用方式</li>
</ol>
<ol start="2">
<li>类模板在模板参数列表中可以有默认参数</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">NameType</span>, <span class="keyword">class</span> <span class="title class_">AgeType</span> = <span class="type">int</span>&gt;</span><br><span class="line"><span class="keyword">class</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(NameType name, AgeType age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span> -&gt; m_Name = name;</span><br><span class="line">		<span class="keyword">this</span> -&gt; m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; m_Name &lt;&lt; <span class="string">&quot; Age: &quot;</span> &lt;&lt; m_Age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	NameType m_Name;</span><br><span class="line">	AgeType m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、类模板没有自动推导</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//	Person p(&quot;孙悟空&quot;, 999)//错误的原因是类模板没有推导，必须指定类型，目前应该是支持了</span></span><br><span class="line">	Person &lt;string, <span class="type">int</span>&gt; <span class="built_in">p</span>(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">999</span>);</span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、类模板在模板列表中可以有默认参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person &lt;string&gt; <span class="built_in">p</span>(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">888</span>);</span><br><span class="line">	<span class="comment">//在定义模板的时候说明 AgeType 是整型</span></span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong> </p>
<ul>
<li>类模板使用只能用显示指定类型方式</li>
<li>类模板中的模板参数列表可以有默认参数</li>
</ul>
<h3 id="类模板中成员函数的被创建时间"><a href="#类模板中成员函数的被创建时间" class="headerlink" title="类模板中成员函数的被创建时间"></a>类模板中成员函数的被创建时间</h3><p><strong>类模板中成员函数和普通类中成员函数创建时机是有区别的：</strong> </p>
<ul>
<li>普通类中的成员函数一开始就可以创建</li>
<li>类模板中的成员函数在调用时才创建</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">cat</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showCat</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;this is a cat.&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dog</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showDog</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;this is a dog.&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	T obj;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//成员函数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span>	</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span> -&gt; obj.<span class="built_in">showCat</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span> -&gt; obj.<span class="built_in">showDog</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Animal&lt;cat&gt; c;</span><br><span class="line">	c.<span class="built_in">func1</span>();</span><br><span class="line">	<span class="comment">//c.func2();//showDog()不是cat的成员。黑马说是因为在模板生成时没有立即生成成员函数，在调用的时候操作系统才会去创建。</span></span><br><span class="line"></span><br><span class="line">	Animal&lt;dog&gt; d;</span><br><span class="line">	d.<span class="built_in">func2</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>  类模板中的成员函数并不是一开始就创建的，在调用时才去创建</p>
<h3 id="类模板对象做函数参数"><a href="#类模板对象做函数参数" class="headerlink" title="类模板对象做函数参数"></a>类模板对象做函数参数</h3><p><strong>学习目标：</strong> </p>
<ul>
<li>类模板实例化出的对象，向函数传参的方式</li>
</ul>
<p>一共有三种传入方式：</p>
<ul>
<li> 指定传入的类型 — 直接显示对象的数据类型</li>
<li> 参数模板化 — 将对象中的参数变为模板进行传递</li>
<li> 整个类模板化 — 将这个对象类型 模板化进行传递</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">NameType</span>, <span class="keyword">class</span> <span class="title class_">AgeType</span> = <span class="type">int</span>&gt;</span><br><span class="line"><span class="keyword">class</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(NameType name, AgeType age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span> -&gt; m_Name = name;</span><br><span class="line">		<span class="keyword">this</span> -&gt; m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ShowPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; <span class="keyword">this</span> -&gt; m_Name &lt;&lt; <span class="string">&quot; Age: &quot;</span> &lt;&lt; <span class="keyword">this</span> -&gt; m_Age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	NameType m_Name;</span><br><span class="line">	AgeType m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、指定传入类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintPerson1</span><span class="params">(Person&lt;string, <span class="type">int</span>&gt; &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	p.<span class="built_in">ShowPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">999</span>)</span></span>;</span><br><span class="line">	<span class="built_in">PrintPerson1</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、参数模板化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintPeron2</span><span class="params">(Person&lt;T1, T2&gt; &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	p.<span class="built_in">ShowPerson</span>();</span><br><span class="line">	<span class="comment">//使用typeid(名).name()查看变量类型。</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;T1的类型为：&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T1).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;T2的类型为：&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T2).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">888</span>)</span></span>;</span><br><span class="line">	<span class="built_in">PrintPeron2</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、模板化整个类</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintPerson3</span><span class="params">(T &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;T的类型为：&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(p).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">	p.<span class="built_in">ShowPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;唐僧&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="built_in">PrintPerson3</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line">	<span class="built_in">test03</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>总结：</strong> </p>
<ul>
<li>过类模板创建的对象，可以有三种方式向函数中进行传参</li>
<li>使用比较广泛是第一种：指定传入的类型</li>
</ul>
<h3 id="类模板与继承"><a href="#类模板与继承" class="headerlink" title="类模板与继承"></a>类模板与继承</h3><p>当类模板遇到继承时，需要注意：</p>
<ol>
<li>当子类继承的父类是一个模板时，子类在声明时需要指出父类中T的类型</li>
<li>如果不指定，操作系统无法给子类分配空间</li>
<li>如果想灵活指定父类的类型，子类也需要变成类模板</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">	T m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//class inheritor : public Base  //C++编译器需要给子类分配空间，就必须知道父类中T的类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base&lt;<span class="type">int</span>&gt;<span class="comment">//必须指定类型，且指定的是模板基类中属性的类型</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Son</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Son构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类模板继承类模板，可以使用T2指定基类T的类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span> : <span class="keyword">public</span> Base&lt;T2&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Son2</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="built_in">typeid</span>(T1).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="built_in">typeid</span>(T2).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son2&lt;<span class="type">int</span>, <span class="type">char</span>&gt; child;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong> 如果父类是类模板，子类需要指定出父类中T的数据类型</p>
<h3 id="类模板成员函数类外实现"><a href="#类模板成员函数类外实现" class="headerlink" title="类模板成员函数类外实现"></a>类模板成员函数类外实现</h3><p>成员函数在类外进行书写时：</p>
<ol>
<li>先写模板声明（template&lt; class T&gt;；</li>
<li>再写修饰函数的关键字和返回值类型；</li>
<li>紧随其后的是带有作用域的函数名以及参数列表。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//掌握类模板成员函数的类外实现</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类模板中成员函数类外书写</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//成员函数类内声明</span></span><br><span class="line">	<span class="built_in">Person</span>(T1 name, T2 age);</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ShowPerson</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	T1 m_Name;</span><br><span class="line">	T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数类外实现</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line">Person&lt;T1, T2&gt;::<span class="built_in">Person</span>(T1 name, T2 age)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span> -&gt; m_Name = name;</span><br><span class="line">	<span class="keyword">this</span> -&gt; m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数类外实现</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="comment">//返回值类型写在最前面，随后是作用域加上函数名</span></span><br><span class="line"><span class="type">void</span> Person&lt;T1, T2&gt;::<span class="built_in">ShowPerson</span>()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; <span class="keyword">this</span> -&gt; m_Name &lt;&lt; <span class="string">&quot; Age: &quot;</span> &lt;&lt; <span class="keyword">this</span> -&gt; m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	p.<span class="built_in">ShowPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong> 类模板中成员函数类外实现时，需要加上模板参数列表</p>
<h3 id="类模板分文件编写"><a href="#类模板分文件编写" class="headerlink" title="类模板分文件编写"></a>类模板分文件编写</h3><p><strong>学习目标:</strong> </p>
<ul>
<li>掌握类模板成员函数分文件编写产生的问题以及解决方式</li>
</ul>
<p><strong>问题:</strong> </p>
<ul>
<li>类模板中成员函数是在调用的时候才被创建，分文件编写会发生链接不到的情况</li>
</ul>
<p><strong>解决方式:</strong> </p>
<ul>
<li>直接包含.cpp源文件</li>
<li>将声明和实现写在同一个文件中，并更改后缀名为.hpp，这是约定的名称，并不是强制的</li>
</ul>
<p>解决方式一：</p>
<p>声明放进 .h 文件，实现放进 .cpp 文件之后，包含实现所在的 .cpp 文件即可</p>
<p>“.h”文件内容：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(T1 name, T2 age);</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ShowPerson</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	T1 m_Name;</span><br><span class="line">	T2 m_Age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>“.cpp”文件内容：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//根据逻辑而言，写成员函数一定是指定类，所以包含头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Person.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数类外实现</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line">Person&lt;T1, T2&gt;::<span class="built_in">Person</span>(T1 name, T2 age)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数类外实现</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="type">void</span> Person&lt;T1, T2&gt;::<span class="built_in">ShowPerson</span>()</span><br><span class="line">&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot; Age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>解决方式二：</p>
<p>声明与实现写在同一个头文件里，后缀名改为 .hpp 约定俗成的类模板写法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(T1 name, T2 age);</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ShowPerson</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	T1 m_Name;</span><br><span class="line">	T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数类外实现</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line">Person&lt;T1, T2&gt;::<span class="built_in">Person</span>(T1 name, T2 age)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数类外实现</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="type">void</span> Person&lt;T1, T2&gt;::<span class="built_in">ShowPerson</span>()</span><br><span class="line">&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot; Age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>包含主函数的文件内容：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解决方法</span></span><br><span class="line"><span class="comment">// 1、声明放进 .h 文件，实现放进 .cpp 文件之后，包含 .cpp 文件即可</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Person.cpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、声明与实现写在同一个文件里，后缀名改为 .hpp 约定俗成的类模板写法</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Person.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;tom&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	p.<span class="built_in">ShowPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 主流办法是第二种，将声明和实现写到同一个头文件中，改后缀为.hpp，</p>
<p> 在boost库中使用最多的就是声明和实现写在一起并改文件后缀为“.hpp”。</p>
</blockquote>
<h3 id="类模板与友元"><a href="#类模板与友元" class="headerlink" title="类模板与友元"></a>类模板与友元</h3><p><strong>学习目标:</strong>  </p>
<ul>
<li>掌握类模板配合配合友元函数的类内和类外实现</li>
</ul>
<p><strong>主要内容：</strong> </p>
<ul>
<li>全局函数类内实现 —— 直接在函数内声明友元即可</li>
<li>全局函数类外实现 —— 需要提前让编译器知道全局函数存在</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数配合友元的类外实现需要先做函数声明</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt; <span class="keyword">class</span> <span class="title class_">Person</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果声明了函数模板，可以将实现写到后面，否则需要将实现体写到类的前面让编译器先看到</span></span><br><span class="line"><span class="comment">//template &lt;class T1, class T2&gt; void PrintPerson2(Person&lt;T1, T2&gt;&amp; p);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这里是将函数写到了类前面，所以不必提前说明</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintPerson2</span><span class="params">(Person&lt;T1, T2&gt;&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;类外实现 —— 姓名：&quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//1、全局函数配合友元——类内实现</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">PrintPerson</span><span class="params">(Person&lt;T1, T2&gt;&amp; p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//全局函数配合友元——类外实现，需要提前声明</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="type">void</span> PrintPerson2&lt;&gt;(Person&lt;T1, T2&gt;&amp; p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Person</span>(T1 name, T2 age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T1 m_Name;</span><br><span class="line">	T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、全局函数在类内实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="built_in">PrintPerson</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、全局函数在类外实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;Jerry&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="built_in">PrintPerson</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong> 建议全局函数做类内实现，用法简单，而且编译器可以直接识别</p>
<h3 id="模板综合案例"><a href="#模板综合案例" class="headerlink" title="模板综合案例"></a>模板综合案例</h3><p>案例描述: 实现一个通用的数组类，要求如下：</p>
<ul>
<li>可以对内置数据类型以及自定义数据类型的数据进行存储</li>
<li>将数组中的数据存储到堆区</li>
<li>构造函数中可以传入数组的容量</li>
<li>提供对应的拷贝构造函数以及operator=防止浅拷贝问题</li>
<li>提供尾插法和尾删法对数组中的数据进行增加和删除</li>
<li>可以通过下标的方式访问数组中的元素</li>
<li>可以获取数组中当前元素个数和数组的容量</li>
</ul>
<p>main.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyArray.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print_Int_Array</span><span class="params">(MyArray&lt;<span class="type">int</span>&gt; &amp;arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">Get_Cur</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//重载[]运算符的作用</span></span><br><span class="line">		cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//则是内置数据类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">MyArray&lt;<span class="type">int</span>&gt; <span class="title">array1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(i &lt; <span class="number">5</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		array1.<span class="built_in">Insert_tail</span>(i);</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; <span class="number">10</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		array1.<span class="built_in">Insert</span>(<span class="number">1</span>, i);</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;输出array1：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">Print_Int_Array</span>(array1);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;array1的最大容量：&quot;</span> &lt;&lt; array1.<span class="built_in">Get_MAX</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;array1的现有数据个数：&quot;</span> &lt;&lt; array1.<span class="built_in">Get_Cur</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;--------------------------------------------\t\t\t\t\t\n&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="function">MyArray&lt;<span class="type">int</span>&gt; <span class="title">array2</span><span class="params">(array1)</span></span>;</span><br><span class="line">	<span class="comment">//删除第一个和最后一个之后还剩下8个元素</span></span><br><span class="line">	array2.<span class="built_in">Delete</span>(<span class="number">0</span>);</span><br><span class="line">	array2.<span class="built_in">Delete_tail</span>();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;输出array2：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">Print_Int_Array</span>(array2);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;array2的最大容量：&quot;</span> &lt;&lt; array2.<span class="built_in">Get_MAX</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;array2的现有数据个数：&quot;</span> &lt;&lt; array2.<span class="built_in">Get_Cur</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;--------------------------------------------\t\t\t\t\t\n&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">Person</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span> -&gt; m_Name = name;</span><br><span class="line">		<span class="keyword">this</span> -&gt; m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintPerson</span><span class="params">(MyArray&lt;Person&gt;&amp; pArr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; pArr.<span class="built_in">Get_Cur</span>(); i++)</span><br><span class="line">		 cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; pArr[i].m_Name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; pArr[i].m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试自定义数据类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//创建数组</span></span><br><span class="line">	<span class="function">MyArray&lt;Person&gt; <span class="title">pArray</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;韩信&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;妲己&quot;</span>, <span class="number">18</span>)</span></span>; </span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;王昭君&quot;</span>, <span class="number">15</span>)</span></span>; </span><br><span class="line">	<span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">24</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//插入数据</span></span><br><span class="line">	pArray.<span class="built_in">Insert_tail</span>(p1);</span><br><span class="line">	pArray.<span class="built_in">Insert_tail</span>(p2);</span><br><span class="line">	pArray.<span class="built_in">Insert_tail</span>(p3);</span><br><span class="line">	pArray.<span class="built_in">Insert_tail</span>(p4);</span><br><span class="line">	pArray.<span class="built_in">Insert_tail</span>(p5);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">PrintPerson</span>(pArray);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;pArray的最大容量：&quot;</span> &lt;&lt; pArray.<span class="built_in">Get_MAX</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;pArray的现有数据个数:&quot;</span> &lt;&lt; pArray.<span class="built_in">Get_Cur</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MyArray.hpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyArray</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//构造函数，相当于顺序表初始化的操作</span></span><br><span class="line">	<span class="built_in">MyArray</span>(<span class="type">int</span> num)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span> -&gt; MAXNUM = num;</span><br><span class="line">		<span class="keyword">this</span> -&gt; CurNum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">this</span> -&gt; elem = <span class="keyword">new</span> T[<span class="keyword">this</span> -&gt; MAXNUM];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//拷贝构造函数，使用const是为了防止在函数中对传入的数据进行误操作</span></span><br><span class="line">	<span class="built_in">MyArray</span>(<span class="type">const</span> MyArray &amp; MyArray)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span> -&gt; MAXNUM = MyArray.MAXNUM;</span><br><span class="line">		<span class="keyword">this</span> -&gt; CurNum = MyArray.CurNum;</span><br><span class="line">		<span class="keyword">this</span> -&gt; elem = <span class="keyword">new</span> T[MyArray.MAXNUM];</span><br><span class="line">		<span class="comment">//挨个复制</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MyArray.CurNum; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//如果T是对象，而且还包含指针，就必须重载 = 运算符，因为 = 不是构造而是赋值</span></span><br><span class="line">			<span class="comment">//内置数据类型可以直接赋值，指针需要深拷贝</span></span><br><span class="line">			<span class="keyword">this</span> -&gt; elem[i] = MyArray.elem[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//重载 = 运算符，防止浅拷贝</span></span><br><span class="line">	MyArray&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyArray* MyArray)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="keyword">this</span> -&gt; elem)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span>[] <span class="keyword">this</span> -&gt; elem;</span><br><span class="line">			<span class="keyword">this</span> -&gt; MAXNUM = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">this</span> -&gt; CurNum = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span> -&gt; MAXNUM = MyArray -&gt; MAXNUM;</span><br><span class="line">		<span class="keyword">this</span> -&gt; CurNum = MyArray -&gt; CurNum;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MyArray.CurNum; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">this</span>-&gt;elem[i] = MyArray.elem[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//重载[]运算符，这样一步是蜜汁操作，提供访问elem域的接口</span></span><br><span class="line">	T&amp; <span class="keyword">operator</span>[](<span class="type">int</span> index)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//说是不考虑越界，然用户自己处理异常，但是如果index是负数会比较麻烦</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span> -&gt; elem[index];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//任意位置插入</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">const</span> <span class="type">int</span> pos, <span class="type">const</span> T &amp;InsData)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> -&gt; CurNum == <span class="keyword">this</span> -&gt; MAXNUM)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;空间不足，无法执行插入操作！&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (pos &gt; <span class="keyword">this</span> -&gt; CurNum - <span class="number">1</span> || pos &lt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;插入位置不合法！&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="keyword">this</span> -&gt; CurNum; i &gt; pos; i--)</span><br><span class="line">			<span class="keyword">this</span> -&gt; elem[i] = <span class="keyword">this</span> -&gt; elem[i - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">this</span> -&gt; elem[pos] = InsData;</span><br><span class="line">		<span class="keyword">this</span> -&gt; CurNum++;</span><br><span class="line">		<span class="comment">//cout &lt;&lt; &quot; &quot; &lt;&lt; InsData &lt;&lt; &quot; 插入成功！&quot; &lt;&lt; endl;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//尾插</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Insert_tail</span><span class="params">(<span class="type">const</span> T &amp; val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span> -&gt; CurNum == <span class="keyword">this</span> -&gt; MAXNUM)</span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		<span class="keyword">this</span> -&gt; elem[<span class="keyword">this</span> -&gt; CurNum] = val;</span><br><span class="line">		<span class="keyword">this</span> -&gt; CurNum++;</span><br><span class="line">		<span class="comment">//当匹配到自定义数据类型时，&lt;&lt; 运算符无法输出 val，所以会报错</span></span><br><span class="line">		<span class="comment">/*cout &lt;&lt; &quot; &quot; &lt;&lt; val &lt;&lt; &quot; 插入成功！&quot; &lt;&lt; endl;*/</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//任意位置删除</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; pos)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = pos; i &lt; <span class="keyword">this</span> -&gt; CurNum - <span class="number">1</span>; i++)</span><br><span class="line">			<span class="keyword">this</span> -&gt; elem[i] = <span class="keyword">this</span> -&gt; elem[i+<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">this</span> -&gt; CurNum--;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//尾删</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Delete_tail</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!<span class="keyword">this</span> -&gt; CurNum)</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">this</span> -&gt; CurNum--;</span><br><span class="line">	 &#125;</span><br><span class="line"></span><br><span class="line">	 <span class="comment">//提供获取 private 权限属性的接口</span></span><br><span class="line"></span><br><span class="line">	 <span class="comment">//最大容量</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Get_MAX</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span> -&gt; MAXNUM;</span><br><span class="line">	 &#125;</span><br><span class="line"></span><br><span class="line">	 <span class="comment">//当前数据个数</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Get_Cur</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span> -&gt; CurNum;</span><br><span class="line">	 &#125;</span><br><span class="line"></span><br><span class="line">	 <span class="comment">//析构函数</span></span><br><span class="line">	~<span class="built_in">MyArray</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span>[] <span class="keyword">this</span> -&gt; elem;</span><br><span class="line">		<span class="keyword">this</span> -&gt; elem = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">this</span> -&gt; MAXNUM = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">this</span> -&gt; CurNum = <span class="number">0</span>;</span><br><span class="line">	 &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//顺序表的结构，private权限类内可访问</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> MAXNUM;<span class="comment">//最大容量</span></span><br><span class="line">	<span class="type">int</span> CurNum;<span class="comment">//现有元素数量</span></span><br><span class="line">	T *elem;<span class="comment">//数据域</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>总结：能够利用所学知识点实现通用的数组</p>
<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p>智能指针是行为类似于指针的类对象，但这种对象还有其他功能。这一章主要想将智能指针梳理一遍。</p>
<h3 id="智能指针引入"><a href="#智能指针引入" class="headerlink" title="智能指针引入"></a>智能指针引入</h3><p>先来看一看指针的操作，示例如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">remodel</span><span class="params">(std::string &amp;str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string *ps = <span class="keyword">new</span> std::<span class="built_in">string</span>(str);</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    str = *ps;</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">// didn&#x27;t delete ps;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在每次调用上面的函数时，该函数都分配队中的内存，但从不回收，从而导致内存泄漏。解决办法是在return语句之前加上一句<code>delete ps;</code><br>然而，凡是涉及“别忘了”的解决办法，很少是最佳的。如果在函数中delete语句之前加上异常规范，在引发异常后，程序异常退出，栈解退会帮助清理栈上的内存，但是堆区的空间在函数结束之后不再可以访问，导致内存泄露。</p>
<p>这样，我们顺理成章地引出智能指针模板类。</p>
<ul>
<li>auto_ptr</li>
<li>unique_ptr</li>
<li>shared_ptr</li>
<li>weak_ptr</li>
</ul>
<p>auto_ptr、unique_ptr和shared_ptr都定义了类似指针的对象，可以将new获得（直接或间接）的地址赋给这种对象。当智能指针过期时，其析构函数将使用delete来释放内存。因此，如果将new返回的地址赋给这些对象，将无需记住稍后释放这些内存：在智能指针过期时，这些内存将自动释放（自动调用析构函数）。<br><img src="https://s2.loli.net/2023/03/25/g9TKF6aDUwfdMO7.png" alt="智能指针的行为"><br>上描述的是常规指针与智能指针行为上的差异。</p>
<p>要创建智能指针对象，必须包含头文件&lt; momory &gt;，该文件模板定义。然后通过常规的模板语法来实例化所需类型的指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">X</span>&gt; <span class="keyword">class</span> <span class="title class_">auto_ptr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">auto_ptr</span><span class="params">(X* p = <span class="number">0</span>)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// something else defined here</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>throw()意味着构造函数不会引发异常，与auto_ptr一样，throw()也被摒弃。因此，请求X类型的auto_ptr将获得一个指向X类型的auto_ptr：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">auto_pre&lt;<span class="type">double</span>&gt; <span class="title">pd</span><span class="params">(<span class="keyword">new</span> <span class="type">double</span>)</span></span>;    <span class="comment">// pd an auto_ptr to double (use in place of double *pd)</span></span><br><span class="line"><span class="function">auto_ptr&lt;string&gt; <span class="title">ps</span><span class="params">(<span class="keyword">new</span> string)</span></span>;    <span class="comment">// ps an auto_ptr to string (use in place of string *ps)</span></span><br></pre></td></tr></table></figure>

<p>new double 是new返回的指针，指向新分配的内存块。它是构造函数auto_ptr的参数，及对应模板形参中p的实参。其他两种智能指针的声明方式与之一致。<br>修改后的remodel()函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remodel</span><span class="params">(std::string &amp;str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::auto_ptr&lt;std::string&gt; <span class="title">ps</span> <span class="params">(<span class="keyword">new</span> std::string(str))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">weird_thing</span>())</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">exception</span>();</span><br><span class="line">    str = *ps;</span><br><span class="line">    <span class="comment">// delete ps; NO LONGER NEEDED</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到智能指针模板位于名称空间std中。下面的示例演示了如何使用这三种智能指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// smrtptrs.cpp - using three kinds of smart pointers</span></span><br><span class="line"><span class="comment">// requires support of C++11 shared_ptr and unique_ptr</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Report</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string str;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Report</span>(<span class="type">const</span> std::string s) : <span class="built_in">str</span>(s) &#123; std::cout &lt;&lt; <span class="string">&quot;Object create!\n&quot;</span>; &#125;</span><br><span class="line">    ~<span class="built_in">Report</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Object deleted!\n&quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">comment</span><span class="params">()</span> <span class="type">const</span> </span>&#123; std::cout &lt;&lt; str &lt;&lt; <span class="string">&quot;\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::auto_ptr&lt;Report&gt; <span class="title">ps</span> <span class="params">(<span class="keyword">new</span> Report(<span class="string">&quot;using auto_ptr&quot;</span>))</span></span>;</span><br><span class="line">        ps-&gt;<span class="built_in">comment</span>();	<span class="comment">// using -&gt; to invoke a member function </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="function">std::shared_ptr&lt;Report&gt; <span class="title">ps</span> <span class="params">(<span class="keyword">new</span> Report(<span class="string">&quot;using shared_ptr&quot;</span>))</span></span>;</span><br><span class="line">    	ps-&gt;<span class="built_in">comment</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">std::unique_ptr&lt;Report&gt; <span class="title">ps</span> <span class="params">(<span class="keyword">new</span> Report(<span class="string">&quot;using unique_ptr&quot;</span>))</span></span>;</span><br><span class="line">		ps-&gt;<span class="built_in">comment</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在vs code 中std成员里没有auto_ptr，因为C++11将其删除了，在Dev C++中没有shared_ptr和unique_ptr以及weak_ptr，这是因为它的编译器很老，不支持C++11。<br>拼凑出来的结果如下</p>
<blockquote>
<p>Object create!<br>using auto_ptr<br>Object deleted!<br>Object create!<br>using shared_ptr<br>Object deleted!<br>Object create!<br>using unique_ptr<br>Object deleted!</p>
</blockquote>
<p>所有的智能化指针类都有一个explicit构造函数，该构造函数将指针作为参数，因此不需要自动将指针转换为智能指针对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;<span class="type">double</span>&gt; pd;</span><br><span class="line"><span class="type">double</span> *p_reg = <span class="keyword">new</span> <span class="type">double</span>;</span><br><span class="line">pd = p_reg; <span class="comment">// not allowed (implicit conversion)</span></span><br><span class="line">pd = <span class="built_in">shared_ptr</span>&lt;<span class="type">double</span>&gt; (p_reg);    <span class="comment">// allowed (explicit conversion)</span></span><br><span class="line">shared_ptr&lt;<span class="type">double</span>&gt; pshared = p_reg; <span class="comment">// not allowed (implicit conversion)</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">double</span>&gt; <span class="title">pshared</span><span class="params">(p_reg)</span></span>;  <span class="comment">// allowed (explicit conversion)</span></span><br></pre></td></tr></table></figure>

<p>智能指针很多方面都类似与常规指针，通过解引用访问成员、将之付给相同类型的常规指针。还可以将智能指针付给相同类型的智能指针对象（将引发问题）。<br><font size=3 color=red>注意</font></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">vacation</span><span class="params">(<span class="string">&quot;I wondered lonely like a cloud.&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">shared_ptr&lt;string&gt; <span class="title">pvac</span><span class="params">(&amp;vacation)</span></span>; <span class="comment">// incorrect!</span></span><br></pre></td></tr></table></figure>

<p>当pvac过期时，delete将用于非堆区的内存，这是不正确的。</p>
<h3 id="有关智能指针的注意事项"><a href="#有关智能指针的注意事项" class="headerlink" title="有关智能指针的注意事项"></a>有关智能指针的注意事项</h3><p>在实践中发现，如果两个auto_ptr指向了同一块内存，在对象过期、函数结束或者程序结束时，会对同一块内存进行两两次delete操作，这是不能忍受的，这种情况与构造函数中使用了new，但是没有重载赋值运算符的情况极其相似。要避免这种问题，方法有多种：</p>
<ul>
<li>定义赋值运算符，使之执行深拷贝，还要避免自赋值（或者在重载赋值运算符的时候参数使用const修饰但是不使用引用）；</li>
<li>建立所有权，对于特定的对象，只能有一个智能指针可以拥有它，只有拥有对象的智能指针的析构函数会删除该对象，然后转让所有权，这是unique_ptr的策略，但是还要更严格；</li>
<li>创建只能更高的指针，跟踪引用特定对象的智能指针数，在shared_ptr中，这被称为引用计数，（reference counting），仅当最后一个指针过期时才调用delete。<br>  当然，同样的策略也适用于复制构造函数。</li>
</ul>
<h3 id="unique-ptr为何优于auto-ptr"><a href="#unique-ptr为何优于auto-ptr" class="headerlink" title="unique_ptr为何优于auto_ptr"></a>unique_ptr为何优于auto_ptr</h3><p>unique_ptr的拷贝构造函数以及unique_ptr同类型智能指针之间的相互赋值被禁用，但是可以作为函数的返回值，用于某个函数中返回动态申请内存的所有权。本质上是移动拷贝，就是使用std::move()，将对象的所有权转移。</p>
<p>对象所有权转移后，会留下悬挂指针，再尝试使用该悬挂指针会引发问题。</p>
<p>unique_ptr作为函数的返回值类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;string&gt; <span class="title">demo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;string&gt; <span class="title">temp</span><span class="params">(<span class="keyword">new</span> string(s))</span></span>;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// and other difinition here</span></span><br><span class="line">unique_ptr&lt;string&gt; ps = <span class="built_in">demo</span>(<span class="string">&quot;Uniquely special&quot;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>解释：demo()返回了一个临时的unique_ptr，然后ps接管了原本归返回的unique_ptr的所有对象，而返回的unique_ptr将被销毁（函数中的temp）这没有问题，所有权正常转让，并且在函数结束后，temp不在能够被访问，所以也没有悬挂指针留下。<br>总之，程序将阻止一个unique_ptr赋给另一个时，如果源unique_ptr是个临时右值，编译器允许这样做；如果源unique_ptr将存在一段时间，编译器将禁止这样做。</p>
</blockquote>
<p>仅当以非智能指针方式使用遗弃的智能指针（如解除引用时），这种赋值方式才不安全。要安全地重用这种指针，可给它赋新值。C++的std::move()，让程序员能够将一个unique_ptr赋给另一个。下面有一个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">unique_ptr&lt;string&gt; ps1, ps2;</span><br><span class="line">ps1 = <span class="built_in">demo</span>(<span class="string">&quot;uniquely special&quot;</span>);</span><br><span class="line">ps2 = <span class="built_in">demo</span>(<span class="string">&quot; and more&quot;</span>);</span><br><span class="line">cout &lt;&lt; *ps1 &lt;&lt; *ps2 &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用move()转让所有权，然后赋新值。</p>
</blockquote>
<table>
<thead>
<tr>
<th>智能指针类型</th>
<th>new</th>
<th>new[]</th>
<th>其他</th>
</tr>
</thead>
<tbody><tr>
<td>auto_ptr</td>
<td>可</td>
<td>不可</td>
<td>不可</td>
</tr>
<tr>
<td>unique_ptr</td>
<td>可</td>
<td>可</td>
<td>不可</td>
</tr>
<tr>
<td>shared_ptr</td>
<td>可</td>
<td>不可</td>
<td>不可</td>
</tr>
</tbody></table>
<h3 id="选择智能指针"><a href="#选择智能指针" class="headerlink" title="选择智能指针"></a>选择智能指针</h3><ul>
<li>如果要使用多个指向同一个对象的指针则使用shared_ptr；</li>
<li>如果不需要使用多个指向同一对象的指针则使用unique_ptr（使用new分配内存并返回指向该内存的指针）；</li>
</ul>
<p>可以将unique_ptr存储到STL容器中，只要不调用将一个unique_ptr赋值或赋给另一个方法或者算法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">make_int</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">unique_ptr</span>&lt;<span class="type">int</span>&gt; (<span class="keyword">new</span> <span class="built_in">int</span>(n));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(unique_ptr&lt;<span class="type">int</span>&gt; &amp;pt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; *pt &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="type">int</span> size = <span class="number">5</span>;</span><br><span class="line">    vector&lt;unique_ptr&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">vp</span>(size);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vp.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        vp[i] = <span class="built_in">make_int</span>(<span class="built_in">rand</span>() % <span class="number">1000</span>);	<span class="comment">// copy temporary unique_ptr</span></span><br><span class="line">    vp.<span class="built_in">push_back</span>(<span class="built_in">make_int</span>(<span class="built_in">rand</span>() % <span class="number">1000</span>));	<span class="comment">// ok because arg is temporary</span></span><br><span class="line">    for_each(vp.<span class="built_in">begin</span>(), vp.<span class="built_in">end</span>(), show);	<span class="comment">// use for_each()</span></span><br><span class="line">    <span class="comment">// do other things</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中的push_back()调用没有问题，因为它返回一个临时的unique_ptr，该unique_ptr被赋给vp中的一个unique_ptr。另外，如果按值而不是按引用给show()传递对象，for_each()语句将非法，因为这将导致使用一个来自vp非临时unique_ptr初始化pi，而这是不允许的。编译器会发现并报告unique_ptr的错误使用。<br>在unique_ptr为右值时，可将其赋给shared_ptr，这与将一个unique_ptr赋给另一个需要满足的条件相同。与前面一样，在下面代码中，make_int()的返回类型是unique_ptr&lt; int &gt;:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">pup</span><span class="params">(make_int(rand() % <span class="number">100</span>))</span></span>; <span class="comment">// ok</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">spp</span><span class="params">(pup)</span></span>;   <span class="comment">// not allowed, pup an lvalue</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">spr</span><span class="params">(make_int(rand() % <span class="number">100</span>))</span></span>;    <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

<p>模板shared_ptr包含一个显式构造函数，可用于将右值unique_ptr转换为shared_ptr。shared_ptr将接管原来归unique_ptr所有的对象。<br>在满足unique_ptr要求的条件时，也可以使用auto_tr，但unique_ptr是更好的选择（不用想了，auto_ptr已经被C++11删除了），或者可以考虑使用boost库中提供的scoped_ptr，其与unique_ptr类似。</p>
<p>博客auto_ptr与unique_ptr<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_40081916/article/details/79377564">https://blog.csdn.net/weixin_40081916/article/details/79377564</a></p>
<h2 id="STL初识"><a href="#STL初识" class="headerlink" title="STL初识"></a>STL初识</h2><h3 id="STL的诞生"><a href="#STL的诞生" class="headerlink" title="STL的诞生"></a>STL的诞生</h3><ul>
<li>长久以来，软件界一直希望建立一种可重复利用的东西</li>
<li>C++的面向对象和泛型编程思想，目的就是复用性的提升</li>
<li>大多情况下，数据结构和算法都未能有一套标准,导致被迫从事大量重复工作</li>
<li>为了建立数据结构和算法的一套标准,诞生了STL</li>
</ul>
<h3 id="STL基本概念"><a href="#STL基本概念" class="headerlink" title="STL基本概念"></a>STL基本概念</h3><ul>
<li>STL(Standard Template Library,标准模板库)</li>
<li>STL 从广义上分为: 容器(container) 算法(algorithm) 迭代器(iterator)</li>
<li>容器和算法之间通过迭代器进行无缝连接。</li>
<li>STL 几乎所有的代码都采用了模板类或者模板函数</li>
</ul>
<h3 id="STL六大组件"><a href="#STL六大组件" class="headerlink" title="STL六大组件"></a>STL六大组件</h3><p>STL大体分为六大组件，分别是:<strong>容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器</strong></p>
<ol>
<li> 容器：各种数据结构，如vector、list、deque、set、map等,用来存放数据。</li>
<li> 算法：各种常用的算法，如sort、find、copy、for_each等 </li>
<li> 迭代器：扮演了容器与算法之间的胶合剂。</li>
<li> 仿函数：行为类似函数，可作为算法的某种策略。</li>
<li> 适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。</li>
<li> 空间配置器：负责空间的配置与管理。</li>
</ol>
<h3 id="STL中容器、算法、迭代器"><a href="#STL中容器、算法、迭代器" class="headerlink" title="STL中容器、算法、迭代器"></a>STL中容器、算法、迭代器</h3><p><strong>容器：置物之所也</strong></p>
<p>STL<strong>容器</strong>就是将运用<strong>最广泛的一些数据结构</strong>实现出来</p>
<p>常用的数据结构：<strong>数组, 链表,树, 栈, 队列, 集合, 映射表 等</strong></p>
<p>这些容器分为<strong>序列式容器</strong>和<strong>关联式容器</strong>两种:</p>
<p><strong>序列式容器</strong>:强调值的排序，序列式容器中的每个元素均有固定的位置。 <strong>关联式容器</strong>:二叉树结构，各元素之间没有</p>
<p>严格的物理上的顺序关系</p>
<p><strong>算法：问题之解法也</strong></p>
<p>有限的步骤，解决逻辑或数学上的问题，这一门学科我们叫做算法(Algorithms)</p>
<p><strong>算法分为:质变算法和非质变算法。</strong></p>
<p>质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等</p>
<p>非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等</p>
<p>迭代器：容器和算法之间粘合剂</p>
<p>提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。</p>
<p>每个容器都有自己专属的迭代器</p>
<p>迭代器使用非常类似于指针，初学阶段我们可以先理解迭代器为指针</p>
<p>迭代器种类：</p>
<table>
<thead>
<tr>
<th>种类</th>
<th>功能</th>
<th>支持的运算</th>
</tr>
</thead>
<tbody><tr>
<td>输入迭代器</td>
<td>对数据的只读访问</td>
<td>只读，支持++、==、!=</td>
</tr>
<tr>
<td>输出迭代器</td>
<td>对数据的只写访问</td>
<td>只写，支持++</td>
</tr>
<tr>
<td>前向迭代器</td>
<td>读写操作，并能向前推进迭代器</td>
<td>读写，支持++、==、!=</td>
</tr>
<tr>
<td>双向迭代器</td>
<td>读写操作，并能向前或向后操作</td>
<td>读写，支持++、–</td>
</tr>
<tr>
<td>随机访问迭代器</td>
<td>读写操作，可以以跳跃的方式访问任意位置的数据，是功能最强的迭代器</td>
<td>读写，支持++， –， [n]、 -n、 &lt;、 &lt;=、 &gt;、 &gt;=</td>
</tr>
</tbody></table>
<p>常用的迭代器为双向迭代器和随机访问迭代器</p>
<p>迭代器性能</p>
<table>
<thead>
<tr>
<th align="center">迭代器功能</th>
<th align="center">随机</th>
<th align="center">输入</th>
<th align="center">输出</th>
<th align="center">正向</th>
<th align="center">双向</th>
</tr>
</thead>
<tbody><tr>
<td align="center">解除引用读取</td>
<td align="center">有</td>
<td align="center">有</td>
<td align="center">无</td>
<td align="center">有</td>
<td align="center">有</td>
</tr>
<tr>
<td align="center">解除引用写入</td>
<td align="center">有</td>
<td align="center">无</td>
<td align="center">有</td>
<td align="center">有</td>
<td align="center">有</td>
</tr>
<tr>
<td align="center">固定和可重复排序</td>
<td align="center">有</td>
<td align="center">无</td>
<td align="center">无</td>
<td align="center">有</td>
<td align="center">有</td>
</tr>
<tr>
<td align="center">++i  i++</td>
<td align="center">有</td>
<td align="center">有</td>
<td align="center">有</td>
<td align="center">有</td>
<td align="center">有</td>
</tr>
<tr>
<td align="center">–i  i–</td>
<td align="center">有</td>
<td align="center">无</td>
<td align="center">无</td>
<td align="center">无</td>
<td align="center">有</td>
</tr>
<tr>
<td align="center">i[n]</td>
<td align="center">有</td>
<td align="center">无</td>
<td align="center">无</td>
<td align="center">无</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">i + n</td>
<td align="center">有</td>
<td align="center">无</td>
<td align="center">无</td>
<td align="center">无</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">i - n</td>
<td align="center">有</td>
<td align="center">无</td>
<td align="center">无</td>
<td align="center">无</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">i += n</td>
<td align="center">有</td>
<td align="center">无</td>
<td align="center">无</td>
<td align="center">无</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">i -= n</td>
<td align="center">有</td>
<td align="center">无</td>
<td align="center">无</td>
<td align="center">无</td>
<td align="center">无</td>
</tr>
</tbody></table>
<h3 id="容器算法迭代器初识"><a href="#容器算法迭代器初识" class="headerlink" title="容器算法迭代器初识"></a>容器算法迭代器初识</h3><p>了解STL中容器、算法、迭代器概念之后，我们利用代码感受STL的魅力</p>
<p>STL中最常用的容器为Vector，可以理解为数组，下面我们将学习如何向这个容器中插入数据、并遍历这个容器</p>
<h4 id="vector存放内置数据类型"><a href="#vector存放内置数据类型" class="headerlink" title="vector存放内置数据类型"></a>vector存放内置数据类型</h4><p>容器：vector</p>
<p>算法：for_each</p>
<p>迭代器：</p>
<p>$vector<int>::iterator$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyPrint</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建vector容器对象，并且通过模板参数指定存放的数据类型</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="comment">// 向容器中放数据</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每一个容器都有自己的迭代器，迭代器就是用来遍历容器中元素的工具</span></span><br><span class="line">    <span class="comment">//v.begin()返回迭代器，这个迭代器指向容器中第一个数据 </span></span><br><span class="line">    <span class="comment">//v.end()返回迭代器，这个迭代器指向容器元素的最后一个元素的下一个位置</span></span><br><span class="line">    <span class="comment">// vector&lt;int&gt;::iterator 拿到vector&lt;int&gt; 这种容器类型的迭代器类型</span></span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator pBegin = v.<span class="built_in">begin</span>();</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator pEnd = v.<span class="built_in">end</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一种遍历方式：</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第一种遍历方式：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">while</span>(pBegin != pEnd)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *pBegin &lt;&lt; endl;</span><br><span class="line">        pBegin++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二种遍历方式</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第二种遍历方式：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it &lt; v.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三种遍历方式</span></span><br><span class="line">    <span class="comment">// STL提供的标准遍历算法，包含于头文件 algorithm</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第三种遍历方式：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), MyPrint);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="vector存放用户自定义数据类型"><a href="#vector存放用户自定义数据类型" class="headerlink" title="vector存放用户自定义数据类型"></a>vector存放用户自定义数据类型</h4><p><strong>vector中存放自定义数据类型，并打印输出</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> string &amp;name, <span class="type">int</span> age) : <span class="built_in">Name</span>(name), <span class="built_in">Age</span>(age) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    string Name;</span><br><span class="line">    <span class="type">int</span> Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存放对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建数据</span></span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;eee&quot;</span>, <span class="number">50</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p4);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p5);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历</span></span><br><span class="line">    <span class="keyword">for</span>(vector&lt;Person&gt;::iterator it = v.<span class="built_in">begin</span>(); it &lt; v.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; (*it).Name &lt;&lt; <span class="string">&quot; Age: &quot;</span> &lt;&lt; (*it).Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存放对象指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;Person*&gt; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建数据</span></span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;eee&quot;</span>, <span class="number">50</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    v.<span class="built_in">push_back</span>(&amp;p1);</span><br><span class="line">    v.<span class="built_in">push_back</span>(&amp;p2);</span><br><span class="line">    v.<span class="built_in">push_back</span>(&amp;p3);</span><br><span class="line">    v.<span class="built_in">push_back</span>(&amp;p4);</span><br><span class="line">    v.<span class="built_in">push_back</span>(&amp;p5);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// it即为迭代器，相当于指针</span></span><br><span class="line">    <span class="keyword">for</span>(vector&lt;Person*&gt;::iterator it = v.<span class="built_in">begin</span>(); it &lt; v.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; (*it)-&gt;Name &lt;&lt; <span class="string">&quot; Age: &quot;</span> &lt;&lt; (*it)-&gt;Age &lt;&lt; endl;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// test01();</span></span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="vector嵌套vector"><a href="#vector嵌套vector" class="headerlink" title="vector嵌套vector"></a>vector嵌套vector</h4><p>容器中嵌套容器，我们将所有数据进行遍历输出</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 容器嵌套容器</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; v;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v3;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v4;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">            </span><br><span class="line">            v1.<span class="built_in">push_back</span>(i + <span class="number">1</span>); <span class="comment">// 1 2 3 4</span></span><br><span class="line">            v2.<span class="built_in">push_back</span>(i + <span class="number">2</span>); <span class="comment">// 2 3 4 5</span></span><br><span class="line">            v3.<span class="built_in">push_back</span>(i + <span class="number">3</span>); <span class="comment">// 3 4 5 6</span></span><br><span class="line">            v4.<span class="built_in">push_back</span>(i + <span class="number">4</span>); <span class="comment">// 4 5 6 7</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将容器元素插入到容器中</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(v1);</span><br><span class="line">    v.<span class="built_in">push_back</span>(v2);</span><br><span class="line">    v.<span class="built_in">push_back</span>(v3);</span><br><span class="line">    v.<span class="built_in">push_back</span>(v4);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;::iterator it = v.<span class="built_in">begin</span>(); it &lt; v.<span class="built_in">end</span>(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::iterator vit = (*it).<span class="built_in">begin</span>(); vit &lt; (*it).<span class="built_in">end</span>(); vit++)</span><br><span class="line">            cout &lt;&lt; *vit &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;            </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="STL-–-常用容器"><a href="#STL-–-常用容器" class="headerlink" title="STL – 常用容器"></a>STL – 常用容器</h2><p>在很多方面，使用string对象的方式与使用字符数组相同</p>
<ul>
<li>可以使用C-style 的字符串来初始化string对象</li>
<li>可以使用cin来将键盘输入存储到string对象中</li>
<li>可以使用cout来显示string对象</li>
<li>可以使用数组表示法来访问存储在string对象中的字符（提供了 operator[] 重载函数）</li>
</ul>
<p><strong>与字符数组之间的主要区别是：可以将string对象声明为简单变量，而不是数组</strong> </p>
<p>​    string无法使用strlen、strcat、strcpy之类的函数，因为C对C++不兼容，string类本身提供了这些方法所以也不需要再回去使用C封装的函数。</p>
<p>​    对于C-style的字符串，未经初始化时，’\0’出现在数组中的任何位置都不稀奇，所以执行strlen操作得到的数据也不尽相同，但是string不一样，未经初始化的string对象，长度为0。</p>
<p><strong>这里简单说一下C++11支持的字符串：</strong> </p>
<p>​    除了char类型以外，C++还有类型wchar_t；而C++11新增了类型char16_t 和 char32_t 。可以创建这些类型的数组和这些类型的字符串字面值，C++分别使用前缀L、u和U表示，下面是一个如何使用这些前缀的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">wchar_t</span> title[] = <span class="string">L&quot;Chief Astrogator&quot;</span>;	<span class="comment">// wchar_t string</span></span><br><span class="line"><span class="type">char16_t</span> name[] = <span class="string">u&quot;Felonia Ripova&quot;</span>;	<span class="comment">// char6_t string</span></span><br><span class="line"><span class="type">char32_t</span> car[] = <span class="string">U&quot;Humber Super Snipe&quot;</span>;	<span class="comment">// char32_t string</span></span><br></pre></td></tr></table></figure>

<p>​    C++1还支持Unicode字符编码方案UTF-8。在这种方案中，根据编码的数字值，字符可能存储为1~4个八位组。C++使用前缀u8来表示这种类型的字符串字面值。</p>
<p>​    C++11新增的ing一种类型是元三年hi（raw）字符串。在原始字符串中，字符表示的就是自己，例如，序列 \n 不表示换行符，而表示两个常规字符——斜杠和n，因此在屏幕上显示时，将显示这两个字符。另一个例子是，可在字符串中使用”，而无需再使用繁琐的 &quot;（转义字符）。当然，既然可以在字符串字面量中包含”，就不能再使用它来表示字符串的开头和结尾。因此，原始字符串将 “( 和 )” 用作界定符，并使用前缀R来表示原始字符串：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">R&quot;(Jim &quot;king&quot; Tutt uses &quot;\n&quot; instead of endl.)&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="comment">//上述代码将显示如下内容：</span></span><br><span class="line">Jim <span class="string">&quot;king&quot;</span> Tutt uses <span class="string">&quot;\n&quot;</span> instead of endl.</span><br></pre></td></tr></table></figure>

<p>​    如果使用标准字符串字面值，将需编写如下代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;Jim \&quot;king\&quot; Tutt uses \&quot;\\n\&quot; instead of endl.&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>​    在上述代码中使用了 \ \ 来显示 \，因为单个 \ 表示转义序列的第一个字符。</p>
<p>​    <strong>如何在原始字符串中包含 )”</strong> ，（编译器在见到第一个 )” 就会认为字符串到此结束），但是原始字符串语法允许在表示字符串开头的 “ 和 ( 之间添加其他字符，这意味着表示字符串结尾的 “ 和 ) 之间也必须包含这些字符。因此，使用 R”+( 表示原始字符串的开头时，必须使用 )+*” 标识原始字符串的结尾：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">R&quot;+*(&quot;(Who wouldn&#x27;t?)&quot;, she whispered.)+*&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 将显示以下内容：</span></span><br><span class="line"><span class="string">&quot;(Who wouldn&#x27;t?), she whispered.&quot;</span></span><br></pre></td></tr></table></figure>

<p>​    总之，这使用”+* ( 和 )+ *” 替代了默认界定符 “( 和 )” 。自定义界定符时，在默认界定符之间添加任意数量的基本字符，但空格、左括号、右括号、斜杠和控制字符（如制表符和换行符）除外。</p>
<p>​    可将前缀R与其它字符前缀组合使用，以标识wchar_t等类型的原始字符串。可将R放在前面，也可将其放在后面，如Ru、UR等。</p>
<h3 id="string容器"><a href="#string容器" class="headerlink" title="string容器"></a>string容器</h3><h4 id="string基本概念"><a href="#string基本概念" class="headerlink" title="string基本概念"></a>string基本概念</h4><p><strong>本质</strong>：</p>
<p>​    string是C++风格的字符串，本质上是一个类</p>
<p>*<em>string和char <em>的区别</em></em></p>
<p>​    char *定义的是指针</p>
<p>​    string是一个类，实例化的是对象，string的类内封装了char *，管理这个字符串，是char *类型的容器</p>
<p><strong>特点</strong></p>
<p>​    string类内封装了很多成员方法， 例如：查找find， 复制/拷贝copy， 删除delete， 替换replace， 插入insert等</p>
<p>​    string管理char *所分配的空间，不用担心赋值越界和取值越界等情况，由类内部负责处理。</p>
<h4 id="string构造函数"><a href="#string构造函数" class="headerlink" title="string构造函数"></a>string构造函数</h4><table>
<thead>
<tr>
<th align="left">构造函数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">string(char *s)</td>
<td align="left">将string初始化为s指向的NBTS</td>
</tr>
<tr>
<td align="left">string(size_type n, char c)</td>
<td align="left">创建一个包含n个元素的string对象，其中每个字符都初始化为字符c</td>
</tr>
<tr>
<td align="left">string(const string &amp;str)</td>
<td align="left">将一个string对象初始化为str（复制构造函数）</td>
</tr>
<tr>
<td align="left">string()</td>
<td align="left">创建一个string对象，长度为0（默认构造函数）</td>
</tr>
<tr>
<td align="left">string(const char *s, size_type n)</td>
<td align="left">将string对象初始化为s指向的NBTS的前n个字符，即使长度超过了NBTS结尾</td>
</tr>
<tr>
<td align="left">template&lt; class Iter &gt; string(Iter beg, Iter end)</td>
<td align="left">将string对象初始化为区间[begin, end)内的字符，其中begin和end的行为就像指针，用于指定位置，范围包括begin在内，但不包括end</td>
</tr>
<tr>
<td align="left">string(const string &amp;str, size_type pos = 0, size_type n = npos)</td>
<td align="left">将一个string对象初始化为对象str中从位置pos开始到结尾的字符，或从位置pos开始的n个字符</td>
</tr>
<tr>
<td align="left">string(string &amp;&amp;str) noexcept</td>
<td align="left">这是C++11新增的，它将一个string对象初始化为string对象str，并可能修改对象str（移动构造函数）</td>
</tr>
<tr>
<td align="left">string(initializer_lisr<char> il)</td>
<td align="left">这是C++11新增的，它将一个string对象初始化为初始化列表il中的字符</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<p><strong>构造函数原型：</strong></p>
<ul>
<li>string(); //创建一个空的字符串 例如: string str;</li>
<li>string(const char* s); //使用字符串s初始化</li>
<li>string(const string&amp; str); //使用一个string对象初始化另一个string对象</li>
<li>string(int n, char c); //使用n个字符c初始化</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">string();   // 创建一个空的字符串</span></span><br><span class="line"><span class="comment">string(const char *s);   // 使用一个C-style的字符串初始化string</span></span><br><span class="line"><span class="comment">string(const string &amp;str);  // 使用一个string初始化string</span></span><br><span class="line"><span class="comment">string(int n, char c);  // 将string对象初始化为n个字符c</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// string构造</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str1;  <span class="comment">// 创建空串，调用无参构造</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *str = <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line">    <span class="function">string <span class="title">str2</span><span class="params">(str)</span></span>;   <span class="comment">// 将C-style字符串转换为string对象</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str2 = &quot;</span> &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">str3</span><span class="params">(str2)</span></span>;  <span class="comment">// 拷贝构造函数调用</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">str4</span><span class="params">(<span class="number">20</span>, <span class="string">&#x27;a&#x27;</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str4 = &quot;</span> &lt;&lt; str4 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="string赋值操作"><a href="#string赋值操作" class="headerlink" title="string赋值操作"></a>string赋值操作</h4><p><strong>功能：</strong></p>
<ul>
<li>给string字符串赋值</li>
</ul>
<p><strong>赋值的函数原型：</strong></p>
<p>运算符重载：</p>
<ul>
<li>string&amp; operator=(const char *s);    // 将char＊类型的字符串赋给当前string对象</li>
<li>string&amp; operator=(const string &amp;s);    //  将string对象s赋值给当前string对象</li>
<li>string&amp; operator=(char c);    //将字符c赋值给当前string对象</li>
</ul>
<p>string类内方法：</p>
<ul>
<li>string&amp; assign(const char *s);    // 将C-style字符串赋值给当前string对象</li>
<li>string&amp; assign(const char *s, int n);    // 将字符串s的前n个字符赋值给当前string对象</li>
<li>string&amp; assign(const string &amp;s);    // 将字符串对象s赋值给当前string对象</li>
<li>string&amp; assign(int n, char c);    // 用n个字符c初始化当前string对象</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运算符重载：</span></span><br><span class="line"><span class="comment">- string&amp; operator=(const char *s);	// 将char＊类型的字符串赋给当前string对象</span></span><br><span class="line"><span class="comment">- string&amp; operator=(const string &amp;s);    //  将string对象s赋值给当前string对象</span></span><br><span class="line"><span class="comment">- string&amp; operator=(char c);    //将字符c赋值给当前string对象</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">string提供的方法：</span></span><br><span class="line"><span class="comment">- string&amp; assign(const char *s);    // 将C-style字符串赋值给当前string对象</span></span><br><span class="line"><span class="comment">- string&amp; assign(const char *s, int n);    // 将字符串s的前n个字符赋值给当前string对象</span></span><br><span class="line"><span class="comment">- string&amp; assign(const string &amp;s);    // 将字符串对象s赋值给当前string对象</span></span><br><span class="line"><span class="comment">- string&amp; assign(int n, char c);    // 用n个字符c初始化当前string对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// string&amp; operator=(const char *s);</span></span><br><span class="line">    string str1;</span><br><span class="line">    str1 = <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// string&amp; operator=(const string &amp;s);</span></span><br><span class="line">    string str2 = str1; <span class="comment">// string str2; str2 = str1;</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str2 = &quot;</span> &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// string&amp; operator=(const char c);</span></span><br><span class="line">    string str3;</span><br><span class="line">    str3 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// string&amp; assign(const char *s);</span></span><br><span class="line">    string str4;</span><br><span class="line">    str4.<span class="built_in">assign</span>(<span class="string">&quot;Hello C++&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str4 = &quot;</span> &lt;&lt; str4 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// string&amp; assign(const char *s, int n);</span></span><br><span class="line">    string str5;</span><br><span class="line">    str5.<span class="built_in">assign</span>(<span class="string">&quot;Hello C++&quot;</span>, <span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str5 = &quot;</span> &lt;&lt; str5 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// string&amp; assign(const string &amp;s);</span></span><br><span class="line">    string str6;</span><br><span class="line">    str6.<span class="built_in">assign</span>(str5);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str6 = &quot;</span> &lt;&lt; str6 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// string&amp; assign(int n, char c);</span></span><br><span class="line">    string str7;</span><br><span class="line">    str7.<span class="built_in">assign</span>(<span class="number">5</span>, <span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str7 = &quot;</span> &lt;&lt; str7 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// string 类内提供的赋值方法有很多，但是直接使用 operator=() 的方式是最常用最实用的。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="string字符串拼接"><a href="#string字符串拼接" class="headerlink" title="string字符串拼接"></a>string字符串拼接</h4><p><strong>功能描述：</strong></p>
<ul>
<li>实现在字符串末尾拼接字符串</li>
</ul>
<p><strong>函数原型：</strong></p>
<p>运算符重载：</p>
<ul>
<li>string&amp; operator+=(const char *str);    // 重载 += 操作符</li>
<li>string&amp; operator+=(const char c);    // 重载 += 操作符</li>
<li>string&amp; operator+=(const string &amp;str);    // 重载 += 操作符</li>
</ul>
<p>string类内方法：</p>
<ul>
<li>string&amp; append(const char *s);    // 将字符串s连接到当前string对象的末尾</li>
<li>string&amp; append(const char *s, int n);    // 将字符串s的前n个字符连接到当前string对象的末尾</li>
<li>string&amp; append(const string &amp;s);    // 与operator+(const string &amp;str);</li>
<li>string&amp; append(const string &amp;s, int pos, int n);    // 从C-style字符串的pos位置开始的n个字符连接到当前string对象的末尾</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运算符重载：</span></span><br><span class="line"><span class="comment">- string&amp; operator+=(const char *str);    // 重载 += 操作符</span></span><br><span class="line"><span class="comment">- string&amp; operator+=(const char c);    // 重载 += 操作符</span></span><br><span class="line"><span class="comment">- string&amp; operator+=(const string &amp;str);    // 重载 += 操作符</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">string类内方法：</span></span><br><span class="line"><span class="comment">- string&amp; append(const char *s);    // 将字符串s连接到当前string对象的末尾</span></span><br><span class="line"><span class="comment">- string&amp; append(const char *s, int n);    // 将字符串s的前n个字符连接到当前string对象的末尾</span></span><br><span class="line"><span class="comment">- string&amp; append(const string &amp;s);    // 与operator+(const string &amp;str);</span></span><br><span class="line"><span class="comment">- string&amp; append(const string &amp;s, int pos, int n);    // 从C-style字符串的pos位置开始的n个字符连接到当前string对象的末尾</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 拼接</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// string&amp; operator=(const char *s);</span></span><br><span class="line">    <span class="comment">// string&amp; operator+=(const char *s);</span></span><br><span class="line">    string str1 = <span class="string">&quot;我&quot;</span>;</span><br><span class="line">    str1 += <span class="string">&quot;爱玩游戏&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// string&amp; operator+=(const char c)</span></span><br><span class="line">    str1 += <span class="string">&#x27;:&#x27;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// string&amp; operator+=(const string &amp;str);</span></span><br><span class="line">    string str2 = <span class="string">&quot;LOL DNF&quot;</span>;</span><br><span class="line">    str1 += str2;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    string str3 = <span class="string">&quot;I&quot;</span>;</span><br><span class="line">    str3.<span class="built_in">append</span>(<span class="string">&quot; Love &quot;</span>);</span><br><span class="line">    str3.<span class="built_in">append</span>(<span class="string">&quot;game abcde&quot;</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="comment">// str3.append(str2);   // 在str3之后追加str2</span></span><br><span class="line">    str3.<span class="built_in">append</span>(str2, <span class="number">4</span>, <span class="number">3</span>);    <span class="comment">// 从下标4位置开始，截取3个字符，拼接到字符串str3末尾</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="string查找和替换"><a href="#string查找和替换" class="headerlink" title="string查找和替换"></a>string查找和替换</h4><p>**功能描述： **</p>
<ul>
<li>查找： 查找指定字符串是否存在</li>
<li>替换： 在指定位置替换字符串</li>
</ul>
<p><strong>函数原型：</strong> </p>
<ul>
<li>int find(const string&amp; str, int pos = 0) const; //查找str第一次出现位置,从pos开始查找</li>
<li>int find(const char* s, int pos = 0) const; //查找s第一次出现位置,从pos开始查找</li>
<li>int find(const char* s, int pos, int n) const; //从pos位置查找s的前n个字符第一次位置</li>
<li>int find(const char c, int pos = 0) const; //查找字符c第一次出现位置</li>
<li>int rfind(const string&amp; str, int pos = npos) const; //查找str最后一次位置,从pos开始查找</li>
<li>int rfind(const char* s, int pos = npos) const; //查找s最后一次出现位置,从pos开始查找</li>
<li>int rfind(const char* s, int pos, int n) const; //从pos查找s的前n个字符最后一次位置</li>
<li>int rfind(const char c, int pos = 0) const; //查找字符c最后一次出现位置</li>
<li>string&amp; replace(int pos, int n, const string&amp; str); //替换从pos开始n个字符为字符串str</li>
<li>string&amp; replace(int pos, int n,const char* s); //替换从pos开始的n个字符为字符串s</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int find(const string&amp; str, int pos = 0) const; //查找str第一次出现位置,从pos开始查找</span></span><br><span class="line"><span class="comment">int find(const char* s, int pos = 0) const; //查找s第一次出现位置,从pos开始查找</span></span><br><span class="line"><span class="comment">int find(const char* s, int pos, int n) const; //从pos位置查找s的前n个字符第一次位置</span></span><br><span class="line"><span class="comment">int find(const char c, int pos = 0) const; //查找字符c第一次出现位置</span></span><br><span class="line"><span class="comment">int rfind(const string&amp; str, int pos = npos) const; //查找str最后一次位置,从pos开始查找</span></span><br><span class="line"><span class="comment">int rfind(const char* s, int pos = npos) const; //查找s最后一次出现位置,从pos开始查找</span></span><br><span class="line"><span class="comment">int rfind(const char* s, int pos, int n) const; //从pos查找s的前n个字符最后一次位置</span></span><br><span class="line"><span class="comment">int rfind(const char c, int pos = 0) const; //查找字符c最后一次出现位置</span></span><br><span class="line"><span class="comment">string&amp; replace(int pos, int n, const string&amp; str); //替换从pos开始n个字符为字符串str</span></span><br><span class="line"><span class="comment">string&amp; replace(int pos, int n,const char* s); //替换从pos开始的n个字符为字符串s</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找和替换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 查找</span></span><br><span class="line">    string str1 = <span class="string">&quot;abcdefgde&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pos = str1.<span class="built_in">find</span>(<span class="string">&quot;de&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pos == <span class="number">-1</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;未找到&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;pos = &quot;</span> &lt;&lt; pos &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    pos = str1.<span class="built_in">rfind</span>(<span class="string">&quot;de&quot;</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pos = &quot;</span> &lt;&lt; pos &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 替换</span></span><br><span class="line">    string str1 = <span class="string">&quot;abcdefgde&quot;</span>;</span><br><span class="line">    str1.<span class="built_in">replace</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="string">&quot;1111&quot;</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">find查找是从左往后，rfind从右往左</span></span><br><span class="line"><span class="comment">find找到字符串后返回查找的第一个字符位置，找不到返回-1</span></span><br><span class="line"><span class="comment">replace在替换时，要指定从哪个位置起，多少个字符，替换成什么样的字符串</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>find查找是从左往后，rfind从右往左</li>
<li>find找到字符串后返回查找的第一个字符位置，找不到返回-1</li>
<li>replace在替换时，要指定从哪个位置起，多少个字符，替换成什么样的字符串</li>
</ul>
<h4 id="string字符串比较"><a href="#string字符串比较" class="headerlink" title="string字符串比较"></a>string字符串比较</h4><p><strong>功能描述：</strong></p>
<ul>
<li>字符串之间的比较</li>
</ul>
<p><strong>比较方式：</strong></p>
<ul>
<li>比较字符串ASCII码</li>
</ul>
<blockquote>
<p>&gt; 返回 1， = 返回 0，&lt; 返回 -1 </p>
</blockquote>
<p><strong>函数原型：</strong></p>
<ul>
<li>int compare(const string &amp;s) const; //与字符串s比较</li>
<li>int compare(const char *s) const; //与字符串s比较</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int compare(const string &amp;s) const; //与字符串s比较</span></span><br><span class="line"><span class="comment">int compare(const char *s) const; //与字符串s比较</span></span><br><span class="line"><span class="comment"> &gt; 返回 1， = 返回 0，&lt; 返回 -1 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    string str2 = <span class="string">&quot;Aello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = str1.<span class="built_in">compare</span>(str2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;str1 = str2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">1</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;str1 &gt; str2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;str1 &lt; str2&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：字符串对比主要是用于比较两个字符串是否相等，判断谁大谁小的意义并不是很大</p>
<h4 id="string字符存取"><a href="#string字符存取" class="headerlink" title="string字符存取"></a>string字符存取</h4><p>string中单个字符存取方式有两种</p>
<ul>
<li>char&amp; operator[](int n); //通过[]方式取字符</li>
<li>char&amp; at(int n); //通过at方法获取字符</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运算符重载：</span></span><br><span class="line"><span class="comment">char&amp; operator[](int n); //通过[]方式取字符</span></span><br><span class="line"><span class="comment">方法：</span></span><br><span class="line"><span class="comment">char&amp; at(int n); //通过at方法获取字符</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str = <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)</span><br><span class="line">        cout &lt;&lt; str[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)</span><br><span class="line">        cout &lt;&lt; str.<span class="built_in">at</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字符修改</span></span><br><span class="line">    str[<span class="number">0</span>] = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    str.<span class="built_in">at</span>(<span class="number">0</span>) = <span class="string">&#x27;H&#x27;</span>;</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：string字符串中单个字符存取有两种方式，利用 [ ] 或 at</p>
<h4 id="string插入和删除"><a href="#string插入和删除" class="headerlink" title="string插入和删除"></a>string插入和删除</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对字符串进行字符的插入和删除操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li>string&amp; insert(int pos, const char* s); //插入字符串</li>
<li>string&amp; insert(int pos, const string&amp; str); //插入字符串</li>
<li>string&amp; insert(int pos, int n, char c); //在指定位置插入n个字符c </li>
<li>string&amp; erase(int pos, int n = npos); //删除从Pos开始的n个字符</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">string&amp; insert(int pos, const char* s); //插入字符串</span></span><br><span class="line"><span class="comment">string&amp; insert(int pos, const string&amp; str); //插入字符串</span></span><br><span class="line"><span class="comment">string&amp; insert(int pos, int n, char c); //在指定位置插入n个字符c </span></span><br><span class="line"><span class="comment">string&amp; erase(int pos, int n = npos); //删除从Pos开始的n个字符</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串插入和删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str = <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line">    str.<span class="built_in">insert</span>(<span class="number">1</span>, <span class="string">&quot;111&quot;</span>);</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    str.<span class="built_in">erase</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：插入和删除的起始下标都是从0开始</p>
<h4 id="string子串"><a href="#string子串" class="headerlink" title="string子串"></a>string子串</h4><p><strong>功能描述：</strong> </p>
<ul>
<li>从字符串中获取目标子串</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li>string substr(int pos = 0, int n = npos) const; //返回由pos开始的n个字符组成的字符串</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// string substr(int pos = 0, int n = npos) const; //返回由pos开始的n个字符组成的字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子串</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">    string substr = str.<span class="built_in">substr</span>(<span class="number">1</span>, <span class="number">3</span>);   <span class="comment">// bcd</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;substr = &quot;</span> &lt;&lt; substr &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    string email = <span class="string">&quot;hello@sina.com&quot;</span>;</span><br><span class="line">    <span class="type">int</span> pos = email.<span class="built_in">find</span>(<span class="string">&#x27;@&#x27;</span>);</span><br><span class="line">    string username = email.<span class="built_in">substr</span>(<span class="number">0</span>, pos);     <span class="comment">// hello </span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;username = &quot;</span> &lt;&lt; username &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>总结：灵活的运用求子串功能，可以在实际开发中获取有效的信息</p>
<p><img src="https://s2.loli.net/2023/03/25/raPLKIQUW3MEfqx.png" alt="string思维导图">  </p>
<h3 id="verctor容器"><a href="#verctor容器" class="headerlink" title="verctor容器"></a>verctor容器</h3><h4 id="vector基本概念"><a href="#vector基本概念" class="headerlink" title="vector基本概念"></a>vector基本概念</h4><p><strong>功能：</strong></p>
<ul>
<li>vector数据类型与<strong>数组</strong>非常<strong>相似</strong>，也被称为<strong>单端数组</strong></li>
</ul>
<p><strong>vector与普通数组的区别：</strong></p>
<ul>
<li>数组是静态空间，vector可以<strong>动态扩展</strong></li>
</ul>
<p><strong>动态扩展：</strong> </p>
<ul>
<li>并不是在原有空间的基础上续接新空间，而是寻找更大的空间，然后将数据拷贝到新空间中，释放原有空间</li>
</ul>
<p><img src="https://s2.loli.net/2023/03/25/chNIpJa7zAKlkML.png" alt="vector动态扩展"> </p>
<ul>
<li>vector容器的迭代器是支持随机访问的迭代器</li>
</ul>
<h4 id="4-2-2-vector构造函数"><a href="#4-2-2-vector构造函数" class="headerlink" title="4.2.2 vector构造函数"></a>4.2.2 vector构造函数</h4><p><strong>功能描述：</strong></p>
<ul>
<li>创建vector容器</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li>vector<T> v; //采用模板实现类实现，默认构造函数</li>
<li>vector(v.begin(), v.end()); //将v[begin(), end())区间中的元素拷贝给本身。</li>
<li>vector(n, elem); //构造函数将n个elem拷贝给本身。</li>
<li>vector(const vector &amp;vec); //拷贝构造函数。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">vector&lt;T&gt; v; //采用模板实现类实现，默认构造函数</span></span><br><span class="line"><span class="comment">vector(v.begin(), v.end()); //将v[begin(), end())区间中的元素拷贝给本身。</span></span><br><span class="line"><span class="comment">vector(n, elem); //构造函数将n个elem拷贝给本身。</span></span><br><span class="line"><span class="comment">vector(const vector &amp;vec); //拷贝构造函数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建容器</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it &lt; v.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 无参构造</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="built_in">PrintVector</span>(v1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 区间拷贝</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v2</span><span class="params">(v1.begin(), v1.end())</span></span>;</span><br><span class="line">    <span class="built_in">PrintVector</span>(v2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单次多赋值</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">10</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="built_in">PrintVector</span>(v3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v4</span><span class="params">(v3)</span></span>;</span><br><span class="line">    <span class="built_in">PrintVector</span>(v4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>vector的多种构造方式没有可比性，灵活使用即可</p>
<h4 id="4-2-3-vector赋值操作"><a href="#4-2-3-vector赋值操作" class="headerlink" title="4.2.3 vector赋值操作"></a>4.2.3 vector赋值操作</h4><p><strong>功能描述：</strong></p>
<ul>
<li>给vector容器赋值</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li>vector&amp; operator=(const vector *vec);    // 重载赋值运算符</li>
<li>assign(vector.begin(), vector.end());    // 将另一vector对象中[begin(), end())区间中的数据拷贝给当前对象</li>
<li>assign(n, elem);    // 将n个elem值赋值给当前对象</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">vector&amp; operator=(const vector &amp;vec); //重载等号操作符</span></span><br><span class="line"><span class="comment">assign(beg, end); //将[beg, end)区间中的数据拷贝赋值给本身。</span></span><br><span class="line"><span class="comment">assign(n, elem); //将n个elem拷贝赋值给本身。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it &lt; v.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="built_in">PrintVector</span>(v1);</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">    v2 = v1;</span><br><span class="line">    <span class="built_in">PrintVector</span>(v2);</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v3;</span><br><span class="line">    v3.<span class="built_in">assign</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">PrintVector</span>(v3);</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v4;</span><br><span class="line">    v4.<span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="built_in">PrintVector</span>(v4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong> vector赋值方式比较简单，使用operator=，或者assign都可以</p>
<h4 id="4-2-4-vector容量和大小"><a href="#4-2-4-vector容量和大小" class="headerlink" title="4.2.4 vector容量和大小"></a>4.2.4 vector容量和大小</h4><p><strong>功能描述：</strong> </p>
<ul>
<li>对vector容器的容量和大小进行操作</li>
</ul>
<p><strong>函数原型：</strong> </p>
<ul>
<li>empty(); //判断容器是否为空</li>
<li>capacity(); //容器的容量</li>
<li>size(); //返回容器中元素的个数</li>
<li>resize(int num); //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。</li>
<li>//如果容器变短，则末尾超出容器长度的元素被删除。</li>
<li>resize(int num, elem); //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。</li>
<li>//如果容器变短，则末尾超出容器长度的元素被删除</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">empty(); //判断容器是否为空</span></span><br><span class="line"><span class="comment">capacity(); //容器的容量</span></span><br><span class="line"><span class="comment">size(); //返回容器中元素的个数</span></span><br><span class="line"><span class="comment">resize(int num); //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。</span></span><br><span class="line"><span class="comment">//如果容器变短，则末尾超出容器长度的元素被删除。</span></span><br><span class="line"><span class="comment">resize(int num, elem); //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。</span></span><br><span class="line"><span class="comment">//如果容器变短，则末尾超出容器长度的元素被删除</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">    for_each(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), Print);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(v1.<span class="built_in">empty</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;v1为空。&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;v1不为空，&quot;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; v1的容量为： &quot;</span> &lt;&lt; v1.<span class="built_in">capacity</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; v1的大小为： &quot;</span> &lt;&lt; v1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// resize 重新指定大小， 若若指定的更大，则使用0填充新位置，可以使用重载版本替换默认填充</span></span><br><span class="line">    v1.<span class="built_in">resize</span>(<span class="number">15</span>, <span class="number">10</span>);</span><br><span class="line">    for_each(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), Print);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// resize 重新指定大小，若指定的更小，超出部分将被删除</span></span><br><span class="line">    v1.<span class="built_in">resize</span>(<span class="number">5</span>);</span><br><span class="line">    for_each(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(),Print); </span><br><span class="line">    cout &lt;&lt; endl;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<ul>
<li>判断是否为空 — empty </li>
<li>返回元素个数 — size </li>
<li>返回容器容量 — capacity </li>
<li>重新指定大小 — resize</li>
</ul>
<h4 id="4-2-5-vector插入和删除"><a href="#4-2-5-vector插入和删除" class="headerlink" title="4.2.5 vector插入和删除"></a>4.2.5 vector插入和删除</h4><p><strong>功能描述：</strong> </p>
<ul>
<li>对vector容器进行插入、删除操作</li>
</ul>
<p><strong>函数原型：</strong> </p>
<ul>
<li>push_back(elem); //尾部插入元素elem</li>
<li>pop_back(); //删除最后一个元素</li>
<li>insert(const_iterator pos, ele); //迭代器指向位置pos插入元素ele</li>
<li>insert(const_iterator pos, int count,ele); //迭代器指向位置pos插入count个元素ele</li>
<li>erase(const_iterator pos); //删除迭代器指向的元素</li>
<li>erase(const_iterator start, const_iterator end); //删除迭代器从start到end之间的元素</li>
<li>clear(); //删除容器中所有元素</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">push_back(ele); //尾部插入元素ele</span></span><br><span class="line"><span class="comment">pop_back(); //删除最后一个元素</span></span><br><span class="line"><span class="comment">insert(const_iterator pos, ele); //迭代器指向位置pos插入元素ele</span></span><br><span class="line"><span class="comment">insert(const_iterator pos, int count,ele); //迭代器指向位置pos插入count个元素ele</span></span><br><span class="line"><span class="comment">erase(const_iterator pos); //删除迭代器指向的元素</span></span><br><span class="line"><span class="comment">erase(const_iterator start, const_iterator end); //删除迭代器从start到end之间的元素</span></span><br><span class="line"><span class="comment">clear(); //删除容器中所有元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="comment">// 尾插</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">    </span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), Print);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v是否为空：&quot;</span> &lt;&lt; v.<span class="built_in">empty</span>() &lt;&lt; <span class="string">&quot; v的大小： &quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尾删</span></span><br><span class="line">    v.<span class="built_in">pop_back</span>();</span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), Print);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v是否为空：&quot;</span> &lt;&lt; v.<span class="built_in">empty</span>() &lt;&lt; <span class="string">&quot; v的大小： &quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入</span></span><br><span class="line">    v.<span class="built_in">insert</span>(v.<span class="built_in">begin</span>(), <span class="number">100</span>);</span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), Print);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v是否为空：&quot;</span> &lt;&lt; v.<span class="built_in">empty</span>() &lt;&lt; <span class="string">&quot; v的大小： &quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    v.<span class="built_in">insert</span>(v.<span class="built_in">begin</span>(), <span class="number">2</span>, <span class="number">1000</span>);</span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), Print);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v是否为空：&quot;</span> &lt;&lt; v.<span class="built_in">empty</span>() &lt;&lt; <span class="string">&quot; v的大小： &quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除</span></span><br><span class="line">    v.<span class="built_in">erase</span>(v.<span class="built_in">begin</span>());</span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), Print);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v是否为空：&quot;</span> &lt;&lt; v.<span class="built_in">empty</span>() &lt;&lt; <span class="string">&quot; v的大小： &quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空</span></span><br><span class="line">    v.<span class="built_in">erase</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), Print);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v是否为空：&quot;</span> &lt;&lt; v.<span class="built_in">empty</span>() &lt;&lt; <span class="string">&quot; v的大小： &quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    v.<span class="built_in">clear</span>();</span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), Print);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v是否为空：&quot;</span> &lt;&lt; v.<span class="built_in">empty</span>() &lt;&lt; <span class="string">&quot; v的大小： &quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<ul>
<li>尾插 — push_back</li>
<li>尾删 — pop_back</li>
<li>插入 — insert (位置迭代器)</li>
<li>删除 — erase （位置迭代器）</li>
<li>清空 — clear</li>
</ul>
<h4 id="4-2-6-vector数据存取"><a href="#4-2-6-vector数据存取" class="headerlink" title="4.2.6 vector数据存取"></a>4.2.6 vector数据存取</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对vector中的数据的存取操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li>at(int index);    // 返回索引index所指的数据</li>
<li>operator[]    // 返回索引index所指的数据</li>
<li>front();    // 返回容器中第一个数据元素</li>
<li>back();    // 返回容器中最后一个数据元素</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">at(int indx); // 返回索引index所指的数据</span></span><br><span class="line"><span class="comment">operator[]; // 返回索引index所指的数据</span></span><br><span class="line"><span class="comment">front(); // 返回容器中第一个数据元素</span></span><br><span class="line"><span class="comment">back(); // 返回容器中最后一个数据元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++)</span><br><span class="line">        v.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++)</span><br><span class="line">        cout &lt;&lt; v[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        cout &lt;&lt; v.<span class="built_in">at</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第一个元素：&quot;</span> &lt;&lt; v.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;最后一个元素：&quot;</span> &lt;&lt; v.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<ul>
<li>除了用迭代器获取vector容器中元素，[ ]和at也可以</li>
<li>front返回容器第一个元素</li>
<li>back返回容器最后一个元素</li>
</ul>
<h4 id="4-2-7-vector互换容器"><a href="#4-2-7-vector互换容器" class="headerlink" title="4.2.7 vector互换容器"></a>4.2.7 vector互换容器</h4><p><strong>功能描述：</strong> </p>
<ul>
<li>实现两个容器中全部元素互换</li>
</ul>
<p><strong>函数原型：</strong> </p>
<ul>
<li>swap(vec)    // 将vec中数据与本身交换</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it &lt; v.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;交换前：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        v.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="built_in">PrintVector</span>(v);</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">10</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">        v2.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="built_in">PrintVector</span>(v2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 互换容器</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;互换后：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    v.<span class="built_in">swap</span>(v2);</span><br><span class="line">    <span class="built_in">PrintVector</span>(v);</span><br><span class="line">    <span class="built_in">PrintVector</span>(v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 巧用swap方法可以收缩内存空间</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i ++)</span><br><span class="line">        v.<span class="built_in">push_back</span>(i);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v的容量：&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v的大小：&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    v.<span class="built_in">resize</span>(<span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v的容量：&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v的大小：&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 收缩内存</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (v).<span class="built_in">swap</span>(v);  </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    vector&lt;int&gt; (v);  调用vector的拷贝构造函数，复制v创建匿名对象，匿名对象的容量和大小都跟v的大小一致；</span></span><br><span class="line"><span class="comment">    再做容器交换操作，匿名对象的空间和容量都给了v，v原有的空间和容量交给了匿名对象，而匿名对象将在此语句执行后之后被销毁。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v的容量：&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v的大小：&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// test01();</span></span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>swap可以使两个容器互换，可以达到实用的收缩内存效果</p>
<h4 id="4-2-8-预留空间"><a href="#4-2-8-预留空间" class="headerlink" title="4.2.8 预留空间"></a>4.2.8 预留空间</h4><p><strong>功能描述：</strong></p>
<ul>
<li>减少vector在所需空间很大时，动态扩展容量的次数</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li>reserve(int len);    // 容器预留len个元素长度，预留空间不初始化，不可访问</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数原型：</span></span><br><span class="line"><span class="comment">reserve(int len);   // 容器预留len个元素长度，预留位置空间不做初始化，不可访问</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reserved space</span></span><br><span class="line">    v.<span class="built_in">reserve</span>(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 一次性给预留空间赋值，使用num统计重新分配空间的次数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        v.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(p != &amp;v[<span class="number">0</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            p = &amp;v[<span class="number">0</span>];</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 如果预留空间则是1，如果没有预留空间则可能会重新分配多次。使用预留空间可以节约时间提高效率。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>如果数据量较大，可以一开始利用reserve预留空间</p>
<p><img src="https://s2.loli.net/2023/03/25/q1uzfw9noRrjkLv.png" alt="Vector思维导图">  </p>
<h4 id="4-2-9-模板类array"><a href="#4-2-9-模板类array" class="headerlink" title="4.2.9 模板类array"></a>4.2.9 模板类array</h4><p>​    vector类的功能强大，但付出的代价是效率较低。如果需要的是长度固定的数组，使用数组是最佳的选，但代价是不那么方便和安全。有鉴于此，C++11新增了模板类array，让也位于名称空间std中。与数组一样，array对象的长度也是固定的，也使用栈（静态内存分配），而不是在自由存储区，因此其效率和数组一样，但更方便和安全。要创建array对象，需要包含头文件array。array对象的创建语法与vector稍有不同：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;array&gt;</span><br><span class="line">......</span><br><span class="line">using namespace std;</span><br><span class="line">array&lt;int, 5&gt; ai;	// create array obj of 5 ints</span><br><span class="line">array&lt;double, 4&gt; ad = &#123; 1.2, 2.1, 3.43, 4.3 &#125;;</span><br><span class="line">// 推而广之，下面创建一个名为arr的array对象，它包含n_elem个类型为typename的元素：</span><br><span class="line">array&lt;typename, n_elem&gt; arr;</span><br></pre></td></tr></table></figure>

<p>​    与创建vector对象不同的是，n_elem不能是变量。在C++11中，可以对vector和array对象使用初始化列表，在C++14中可以对vector使用初始化列表。</p>
<p>​    无论是数组、vector对象还是array对象，都可以使用标准数组表示法来访问各个元素。其次，从地址可知，array对象和数组存储在相同的内存区域（即栈）中，而vector对象储存在另一个区域（自由存储区或堆）中。第三，注意到可以将一个array对象赋值给另一个array对象；而对于数组，必须逐元素复制数据。</p>
<p>​    标准数组表示法访问数组是不安全的，使用了错误的下标值会导致程序错误中断，在vector对象中或者在array对象中使用成员函数at()可以作为另一种选择，起降在运行期间捕捉非法索引，而程序默认将中断。这种额外检查的代价是运行时间更长，这就是C++允许程序员使用任何一种表示法的原因所在。另外，这些类还能让程序员能够降低意外越界操作（包含begin()和end()，能够尽量避免越界。</p>
<h3 id="deque容器"><a href="#deque容器" class="headerlink" title="deque容器"></a>deque容器</h3><h4 id="deque基本概念"><a href="#deque基本概念" class="headerlink" title="deque基本概念"></a>deque基本概念</h4><p><strong>功能描述：</strong></p>
<ul>
<li>双端数组，可以对表头进行插入删除操作</li>
</ul>
<p><strong>deque和vector的区别：</strong> </p>
<ul>
<li>vector对头部的插入删除效率低，数据量越大，效率越低（时间复杂度为O(n)）</li>
<li>deque相对vector而言，对头部的插入删除速度更快</li>
<li>vector相较于deque访问元素的速度更快，这与两者的内部实现有关</li>
</ul>
<p><img src="https://s2.loli.net/2023/03/25/tR3cgkduYaj6zwA.png" alt="deque工作原理"></p>
<p><strong>deque内部工作原理：</strong> </p>
<ul>
<li>deque内部有个<strong>中控器</strong>，维护每段缓冲区中的内容，缓冲区中存放真实的数据，中控器维护的是每段缓冲区的地址，使deque在使用时就像一段连续的空间。</li>
</ul>
<p><img src="https://s2.loli.net/2023/03/25/lkRwuvCVMPz3nj5.png" alt="deque中控器"> </p>
<ul>
<li>deque容器的迭代器也是支持随机访问的</li>
</ul>
<h4 id="deque构造函数"><a href="#deque构造函数" class="headerlink" title="deque构造函数"></a>deque构造函数</h4><p><strong>功能描述：</strong></p>
<ul>
<li>deque容器构造</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li>deque<T> deqT; //默认构造形式</li>
<li>deque(beg, end); //构造函数将[beg, end)区间中的元素拷贝给本身。</li>
<li>deque(n, elem); //构造函数将n个elem拷贝给本身。</li>
<li>deque(const deque &amp;deq); //拷贝构造函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用赋值运算符将现有deque容器赋值给目标deque</span></span><br><span class="line"><span class="comment">deque&lt;T&gt; deqT; //默认构造形式</span></span><br><span class="line"><span class="comment">deque(Deque_NAme.beg(), Deque_Nmae.end()); //构造函数将[beg, end)区间中的元素拷贝给本身。</span></span><br><span class="line"><span class="comment">deque(n, elem); //构造函数将n个elem拷贝给本身。</span></span><br><span class="line"><span class="comment">deque(const deque &amp;deq); //拷贝构造函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintDeque</span><span class="params">(<span class="type">const</span> deque&lt;<span class="type">int</span>&gt; d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(deque&lt;<span class="type">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it &lt; d.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// deque&lt;T&gt; Deque_Name; // 无参构造</span></span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; d1;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        d1.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">PrintDeque</span>(d1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// deque&lt;T&gt; Deque2_Name(Deque1_Name.begin(), Deque1_Name.end());    // 拷贝构造</span></span><br><span class="line">    <span class="function">deque&lt;<span class="type">int</span>&gt; <span class="title">d2</span><span class="params">(d1.begin(), d1.end())</span></span>;</span><br><span class="line">    <span class="built_in">PrintDeque</span>(d2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// deque&lt;T&gt; Deque2_Name(const deque&lt;T&gt; &amp;Deque1_Name);   // 拷贝构造</span></span><br><span class="line">    <span class="function">deque&lt;<span class="type">int</span>&gt; <span class="title">d3</span><span class="params">(d2)</span></span>;</span><br><span class="line">    <span class="built_in">PrintDeque</span>(d3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// deque(n, elem); //构造函数将n个elem拷贝给本身。</span></span><br><span class="line">    <span class="function">deque&lt;<span class="type">int</span>&gt; <span class="title">d4</span><span class="params">(<span class="number">10</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="built_in">PrintDeque</span>(d4);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// deque&lt;T&gt;&amp; operator=(const deque&lt;T&gt; &amp;Deque1_Name);    // 赋值运算符</span></span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; d5 = d4;</span><br><span class="line">    <span class="built_in">PrintDeque</span>(d5);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>deque容器和vector容器的构造方式几乎一致，灵活使用即可</p>
<h4 id="deque赋值操作"><a href="#deque赋值操作" class="headerlink" title="deque赋值操作"></a>deque赋值操作</h4><p><strong>功能描述：</strong></p>
<ul>
<li>给deque容器进行赋值</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li>deque&amp; operator=(const deque &amp;deq); //重载等号操作符</li>
<li>assign(beg, end); //将[beg, end)区间中的数据拷贝赋值给本身。</li>
<li>assign(n, elem); //将n个elem拷贝赋值给本身。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运算符重载：</span></span><br><span class="line"><span class="comment">deque&lt;T&gt;&amp; operator=(const deque&lt;T&gt; &amp;deq);   // 重载赋值运算符</span></span><br><span class="line"><span class="comment">方法：</span></span><br><span class="line"><span class="comment">assign(deq.begin(), deq.end()); // 将deq[begin(), end())区间中的数据拷贝给当前对象</span></span><br><span class="line"><span class="comment">assign(n, val);    // 将deque中n个数赋值为val</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintDeque</span><span class="params">(<span class="type">const</span> deque&lt;<span class="type">int</span>&gt; &amp;d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(deque&lt;<span class="type">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it &lt; d.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; d1;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        d1.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="built_in">PrintDeque</span>(d1);</span><br><span class="line"></span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; d2 = d1;</span><br><span class="line">    <span class="built_in">PrintDeque</span>(d2);</span><br><span class="line"></span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; d3;</span><br><span class="line">    d3.<span class="built_in">assign</span>(d2.<span class="built_in">begin</span>(), d2.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">PrintDeque</span>(d3);</span><br><span class="line"></span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; d4;</span><br><span class="line">    d4.<span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="built_in">PrintDeque</span>(d4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>deque赋值操作也与vector相同，需熟练掌握</p>
<h4 id="deque大小操作"><a href="#deque大小操作" class="headerlink" title="deque大小操作"></a>deque大小操作</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对deque容器的大小进行操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li>deque.empty(); //判断容器是否为空</li>
<li>deque.size(); //返回容器中元素的个数</li>
<li>deque.resize(num); //重新指定容器的长度为num,若容器变长，则以默认值填充新位置。</li>
<li>//如果容器变短，则末尾超出容器长度的元素被删除。</li>
<li>deque.resize(num, elem); //重新指定容器的长度为num,若容器变长，则以elem值填充新位置。</li>
<li>//如果容器变短，则末尾超出容器长度的元素被删除。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">deque没有容量的概念，所以没有capacity()方法</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">deque.empty(); //判断容器是否为空//赋值操作 deque.size(); //返回容器中元素的个数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">deque.resize(num); //重新指定容器的长度为num,若容器变长，则以默认值填充新位置。</span></span><br><span class="line"><span class="comment">//如果容器变短，则末尾超出容器长度的元素被删除。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">deque.resize(num, elem); //重新指定容器的长度为num,若容器变长，则以elem值填充新位置。</span></span><br><span class="line"><span class="comment">//如果容器变短，则末尾超出容器长度的元素被删除。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintDeque</span><span class="params">(<span class="type">const</span> deque&lt;<span class="type">int</span>&gt; &amp;d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(deque&lt;<span class="type">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it &lt; d.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大小操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; d1;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        d1.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="built_in">PrintDeque</span>(d1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断deque容器是否为空，1是空，0是不为空</span></span><br><span class="line">    <span class="keyword">if</span>(!d1.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;容器不为空！&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 容器大小</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;容器大小为：&quot;</span> &lt;&lt; d1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;容器为空！&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新指定大小，大于原有空间的部分指定为val</span></span><br><span class="line">    d1.<span class="built_in">resize</span>(<span class="number">15</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">PrintDeque</span>(d1);</span><br><span class="line"></span><br><span class="line">    d1.<span class="built_in">resize</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">PrintDeque</span>(d1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<ul>
<li>deque没有容量的概念，没有 capacity() 方法</li>
<li>判断是否为空 — empty()</li>
<li>返回元素个数 — size()</li>
<li>重新指定个数 — resize()</li>
</ul>
<h4 id="deque插入和删除"><a href="#deque插入和删除" class="headerlink" title="deque插入和删除"></a>deque插入和删除</h4><p><strong>功能描述：</strong> </p>
<ul>
<li>向deque容器中插入和删除数据</li>
</ul>
<p><strong>函数原型：</strong></p>
<p>两端插入操作：</p>
<ul>
<li>push_back(elem); //在容器尾部添加一个数据</li>
<li>push_front(elem); //在容器头部插入一个数据</li>
<li>pop_back(); //删除容器最后一个数据</li>
<li>pop_front(); //删除容器第一个数据</li>
</ul>
<p>指定位置操作：</p>
<ul>
<li>insert(pos,elem); //在pos位置插入一个elem元素的拷贝，返回新数据的位置。</li>
<li>insert(pos,n,elem); //在pos位置插入n个elem数据，无返回值。</li>
<li>insert(pos,beg,end); //在pos位置插入[beg,end)区间的数据，无返回值。</li>
<li>clear(); //清空容器的所有数据</li>
<li>erase(beg,end); //删除[beg,end)区间的数据，返回下一个数据的位置。</li>
<li>erase(pos); //删除pos位置的数据，返回下一个数据的位置。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数原型：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">两端插入操作：</span></span><br><span class="line"><span class="comment">push_back(elem); //在容器尾部添加一个数据</span></span><br><span class="line"><span class="comment">push_front(elem); //在容器头部插入一个数据</span></span><br><span class="line"><span class="comment">pop_back(); //删除容器最后一个数据</span></span><br><span class="line"><span class="comment">pop_front(); //删除容器第一个数据</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">指定位置操作：</span></span><br><span class="line"><span class="comment">insert(pos,elem); //在pos位置插入一个elem元素的拷贝，返回新数据的位置。</span></span><br><span class="line"><span class="comment">insert(pos,n,elem); //在pos位置插入n个elem数据，无返回值。</span></span><br><span class="line"><span class="comment">insert(pos,beg,end); //在pos位置插入[beg,end)区间的数据，无返回值。</span></span><br><span class="line"><span class="comment">clear(); //清空容器的所有数据</span></span><br><span class="line"><span class="comment">erase(beg,end); //删除[beg,end)区间的数据，返回下一个数据的位置。</span></span><br><span class="line"><span class="comment">erase(pos); //删除pos位置的数据，返回下一个数据的位置。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintDeque</span><span class="params">(<span class="type">const</span> deque&lt;<span class="type">int</span>&gt; &amp;d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(deque&lt;<span class="type">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it &lt; d.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test01&quot;</span> &lt;&lt; endl;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; d1;</span><br><span class="line">    <span class="comment">// 尾插</span></span><br><span class="line">    d1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    d1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="comment">// 头插</span></span><br><span class="line">    d1.<span class="built_in">push_front</span>(<span class="number">30</span>);</span><br><span class="line">    d1.<span class="built_in">push_front</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PrintDeque</span>(d1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尾删</span></span><br><span class="line">    d1.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 头删</span></span><br><span class="line">    d1.<span class="built_in">pop_front</span>();</span><br><span class="line">    <span class="built_in">PrintDeque</span>(d1);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test02&quot;</span> &lt;&lt; endl;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; d2;</span><br><span class="line">    d2.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    d2.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    d2.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">    d2.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PrintDeque</span>(d2);</span><br><span class="line"></span><br><span class="line">    d2.<span class="built_in">erase</span>(d2.<span class="built_in">begin</span>(), d2.<span class="built_in">end</span>());</span><br><span class="line">    d2.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">PrintDeque</span>(d2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test03&quot;</span> &lt;&lt; endl;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; d3;</span><br><span class="line">    d3.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    d3.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    d3.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">    d3.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PrintDeque</span>(d3);</span><br><span class="line"></span><br><span class="line">    d3.<span class="built_in">erase</span>(d3.<span class="built_in">begin</span>());</span><br><span class="line">    <span class="built_in">PrintDeque</span>(d3);</span><br><span class="line"></span><br><span class="line">    d3.<span class="built_in">erase</span>(d3.<span class="built_in">begin</span>(), d3.<span class="built_in">end</span>());</span><br><span class="line">    d3.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">PrintDeque</span>(d3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="built_in">test03</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<ul>
<li>插入和删除提供的位置是迭代器！</li>
<li>尾插 — push_back</li>
<li>尾删 — pop_back</li>
<li>头插 — push_front</li>
<li>头删 — pop_front</li>
</ul>
<h4 id="deque数据存取"><a href="#deque数据存取" class="headerlink" title="deque数据存取"></a>deque数据存取</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对deque 中的数据的存取操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li>at(int idx); //返回索引idx所指的数据</li>
<li>operator[ ]; //返回索引idx所指的数据</li>
<li>front(); //返回容器中第一个数据元素</li>
<li>back(); //返回容器中最后一个数据元素</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">at(int idx); //返回索引idx所指的数据</span></span><br><span class="line"><span class="comment">operator[]; //返回索引idx所指的数据</span></span><br><span class="line"><span class="comment">front(); //返回容器中第一个数据元素</span></span><br><span class="line"><span class="comment">back(); //返回容器中最后一个数据元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintDeque</span><span class="params">(<span class="type">const</span> deque&lt;<span class="type">int</span>&gt; &amp;d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(deque&lt;<span class="type">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it &lt; d.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; *it&lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据存取</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">    d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">    d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PrintDeque</span>(d);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; d.<span class="built_in">size</span>(); i++)</span><br><span class="line">        cout &lt;&lt; d[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; d.<span class="built_in">size</span>(); i++)</span><br><span class="line">        cout &lt;&lt; d.<span class="built_in">at</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;front: &quot;</span> &lt;&lt; d.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;back: &quot;</span> &lt;&lt; d.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<ul>
<li>除了用迭代器获取deque容器中元素，[ ]和at也可以</li>
<li>front返回容器第一个元素</li>
<li>back返回容器最后一个元素</li>
</ul>
<h4 id="deque排序"><a href="#deque排序" class="headerlink" title="deque排序"></a>deque排序</h4><p><strong>功能描述：</strong></p>
<ul>
<li>利用算法对deque进行排序</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li>sort(iterator beg, iterator end)    // 对[begin(), end())区间内的数据进行排序，可以自行制定排序策略</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintDeque</span><span class="params">(<span class="type">const</span> deque&lt;<span class="type">int</span>&gt; &amp;d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(deque&lt;<span class="type">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it &lt; d.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">    d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">    d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PrintDeque</span>(d);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">PrintDeque</span>(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<ul>
<li>只说了 sort() 算法的实用性，并没有强调排序算法理念，以及算法思想</li>
</ul>
<p><img src="https://s2.loli.net/2023/03/25/4jVBRUNqd7SmbOT.png" alt="Deque思维导图"> </p>
<h3 id="案例-评委打分"><a href="#案例-评委打分" class="headerlink" title="案例-评委打分"></a>案例-评委打分</h3><p><strong>描述：</strong></p>
<ul>
<li>有5名选手：选手ABCDE，10个评委分别对每一名选手打分，去除最高分，去除评委中最低分，取平均分。</li>
</ul>
<p><strong>步骤：</strong></p>
<ol>
<li>创建五名选手，放到vector中 </li>
<li>遍历vector容器，取出来每一个选手，执行for循环，可以把10个评分打分存到deque容器中</li>
<li>sort算法对deque容器中分数排序，去除最高和最低分</li>
<li>deque容器遍历一遍，累加总分</li>
<li>获取平均分</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>(string name, <span class="type">float</span> scores) : <span class="built_in">Name</span>(name), <span class="built_in">FinalScores</span>(scores) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    string Name;</span><br><span class="line">    <span class="type">float</span> FinalScores;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreatPlayers</span><span class="params">(vector&lt;Person&gt; &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string NameSeed = <span class="string">&quot;ABCDE&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        string name = <span class="string">&quot;选手&quot;</span>;</span><br><span class="line">        name += NameSeed[i];</span><br><span class="line"></span><br><span class="line">        <span class="type">float</span> score = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">Person <span class="title">p</span><span class="params">(name, score)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将创建的Person对象放进vector中</span></span><br><span class="line">        v.<span class="built_in">push_back</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetScores</span><span class="params">(vector&lt;Person&gt; &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(vector&lt;Person&gt;::iterator it = v.<span class="built_in">begin</span>(); it &lt; v.<span class="built_in">end</span>(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 遍历vector模拟评委打分</span></span><br><span class="line">        deque&lt;<span class="type">float</span>&gt; d;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">float</span> score = <span class="built_in">rand</span>() % <span class="number">41</span> + <span class="number">60</span>; <span class="comment">// 60 ~ 100</span></span><br><span class="line">            d.<span class="built_in">push_back</span>(score);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; it -&gt; Name &lt;&lt; <span class="string">&quot;得分： &quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span>(deque&lt;<span class="type">float</span>&gt;::const_iterator dit = d.<span class="built_in">begin</span>(); dit &lt; d.<span class="built_in">end</span>(); dit ++)</span><br><span class="line">            cout &lt;&lt; *dit &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 排序</span></span><br><span class="line">        <span class="built_in">sort</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 去除最高分和最低分</span></span><br><span class="line">        d.<span class="built_in">pop_back</span>();</span><br><span class="line">        d.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加权平均分</span></span><br><span class="line">        <span class="type">float</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(deque&lt;<span class="type">float</span>&gt;::const_iterator dit = d.<span class="built_in">begin</span>(); dit &lt; d.<span class="built_in">end</span>(); dit++)</span><br><span class="line">            sum += *dit;</span><br><span class="line">        it -&gt; FinalScores = sum / d.<span class="built_in">size</span>();</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShowPerson</span><span class="params">(vector&lt;Person&gt; &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(vector&lt;Person&gt;::iterator it = v.<span class="built_in">begin</span>(); it &lt; v.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;Name &lt;&lt; <span class="string">&quot;\t得分： &quot;</span> &lt;&lt; it-&gt;FinalScores &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 随机数种子</span></span><br><span class="line">    <span class="built_in">srand</span>((<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、创建选手数组</span></span><br><span class="line">    vector&lt;Person&gt; v;</span><br><span class="line">    <span class="built_in">CreatPlayers</span>(v);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试</span></span><br><span class="line">    <span class="built_in">ShowPerson</span>(v);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、打分</span></span><br><span class="line">    <span class="built_in">SetScores</span>(v);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最终结果</span></span><br><span class="line">    <span class="built_in">ShowPerson</span>(v);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Version2:</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Player</span>() &#123; &#125;</span><br><span class="line">    <span class="comment">// 列表初始化</span></span><br><span class="line">    <span class="built_in">Player</span>(string name, <span class="type">float</span> score) : <span class="built_in">Name</span>(name), <span class="built_in">FinalScore</span>(score) &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    string Name;</span><br><span class="line">    deque&lt;<span class="type">float</span>&gt; scores;</span><br><span class="line">    <span class="type">float</span> FinalScore;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreatPlayers</span><span class="params">(vector&lt;Player&gt; &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string NameSeed = <span class="string">&quot;ABCDE&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        string name = <span class="string">&quot;选手&quot;</span>;</span><br><span class="line">        name += NameSeed[i];</span><br><span class="line"></span><br><span class="line">        <span class="type">float</span> score = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">Player <span class="title">p</span><span class="params">(name, score)</span></span>;</span><br><span class="line"></span><br><span class="line">        v.<span class="built_in">push_back</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetScores</span><span class="params">(vector&lt;Player&gt; &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(vector&lt;Player&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 打分</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;Name &lt;&lt; <span class="string">&quot;\t得分： &quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">float</span> score = <span class="built_in">rand</span>() % <span class="number">41</span> + <span class="number">60</span>;</span><br><span class="line">            it-&gt;scores.<span class="built_in">push_back</span>(score);</span><br><span class="line">            cout &lt;&lt; score &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">sort</span>(it-&gt;scores.<span class="built_in">begin</span>(), it-&gt;scores.<span class="built_in">end</span>());</span><br><span class="line">        it-&gt;scores.<span class="built_in">pop_front</span>();</span><br><span class="line">        it-&gt;scores.<span class="built_in">pop_back</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="type">float</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(deque&lt;<span class="type">float</span>&gt;::const_iterator dit = it-&gt;scores.<span class="built_in">begin</span>(); dit &lt; it-&gt;scores.<span class="built_in">end</span>(); dit++)</span><br><span class="line">            sum += *dit;</span><br><span class="line">        it-&gt;FinalScore = sum / it-&gt;scores.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShowPlayer</span><span class="params">(vector&lt;Player&gt; &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(vector&lt;Player&gt;::iterator it = v.<span class="built_in">begin</span>(); it &lt; v.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;Name &lt;&lt; <span class="string">&quot; 得分： &quot;</span> &lt;&lt; it-&gt;FinalScore &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>((<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));	<span class="comment">// 随机数种子</span></span><br><span class="line">    vector&lt;Player&gt; v;	</span><br><span class="line">    <span class="built_in">CreatPlayers</span>(v);</span><br><span class="line">    <span class="built_in">SetScores</span>(v);</span><br><span class="line">    <span class="built_in">ShowPlayer</span>(v);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>选择不同的容器操作数据，能够提高效率</p>
<h3 id="stack容器"><a href="#stack容器" class="headerlink" title="stack容器"></a>stack容器</h3><h4 id="stack容器基本概念"><a href="#stack容器基本概念" class="headerlink" title="stack容器基本概念"></a>stack容器基本概念</h4><p><strong>概念：</strong> stack是一种<strong>先进后出</strong>（FILO）的数据结构，只有一个出口：栈顶（top）</p>
<p><img src="https://s2.loli.net/2023/03/25/E46TpVzULltqv2h.png" alt="Stack结构"> </p>
<p>在STL内置的容器中，栈（stack）不允许<strong>遍历</strong>，数据进出被称为<strong>压栈（入栈）</strong>和<strong>弹栈（出栈）</strong></p>
<h4 id="stack常用接口"><a href="#stack常用接口" class="headerlink" title="stack常用接口"></a>stack常用接口</h4><p><strong>功能描述：</strong> </p>
<ul>
<li>栈常用的对外接口</li>
</ul>
<p>构造函数：</p>
<ul>
<li>stack<T> stk; //stack采用模板类实现， stack对象的默认构造形式</li>
<li>stack(const stack &amp;stk); //拷贝构造函数</li>
</ul>
<p>赋值操作：</p>
<ul>
<li>stack&amp; operator=(const stack &amp;stk); //重载等号操作符</li>
</ul>
<p>数据存取：</p>
<ul>
<li>push(elem); //向栈顶添加元素</li>
<li>pop(); //从栈顶移除第一个元素</li>
<li>top(); //返回栈顶元素</li>
</ul>
<p>大小操作：</p>
<ul>
<li>empty(); //判断堆栈是否为空</li>
<li>size(); //返回栈的大小</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">构造函数：</span></span><br><span class="line"><span class="comment">stack&lt;T&gt; stk; //stack采用模板类实现， stack对象的默认构造形式</span></span><br><span class="line"><span class="comment">stack(const stack &amp;stk); //拷贝构造函数</span></span><br><span class="line"><span class="comment">赋值操作：</span></span><br><span class="line"><span class="comment">stack&amp; operator=(const stack &amp;stk); //重载等号操作符</span></span><br><span class="line"><span class="comment">数据存取：</span></span><br><span class="line"><span class="comment">push(elem); //向栈顶添加元素</span></span><br><span class="line"><span class="comment">pop(); //从栈顶移除第一个元素</span></span><br><span class="line"><span class="comment">top(); //返回栈顶元素</span></span><br><span class="line"><span class="comment">大小操作：</span></span><br><span class="line"><span class="comment">empty(); //判断堆栈是否为空</span></span><br><span class="line"><span class="comment">size(); //返回栈的大小</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 常用接口</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建栈容器，FILO</span></span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 压栈</span></span><br><span class="line">    s.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line">    s.<span class="built_in">push</span>(<span class="number">20</span>);</span><br><span class="line">    s.<span class="built_in">push</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;栈顶元素为：&quot;</span> &lt;&lt; s.<span class="built_in">top</span>() &lt;&lt; endl;</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;        </span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;栈的大小为： &quot;</span> &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<ul>
<li>入栈 — push</li>
<li>出栈 — pop</li>
<li>返回栈顶 — top</li>
<li>判断栈是否为空 — empty</li>
<li>返回栈大小 — size</li>
</ul>
<p><img src="https://s2.loli.net/2023/03/25/dBRAZuWt17NgF68.png" alt="Stack">  </p>
<h3 id="queue容器"><a href="#queue容器" class="headerlink" title="queue容器"></a>queue容器</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p><strong>概念：</strong> Queue是一种<strong>先进先出</strong>(First In First Out,FIFO)的数据结构，它有两个出</p>
<p><img src="https://s2.loli.net/2023/03/25/YL73IA8qSmvOjpQ.png" alt="queue结构">  </p>
<ul>
<li>队列容器允许从一端新增元素，从另一端移除元素</li>
<li>队列中只有队头和队尾才可以被外界使用，因此队列不允许有遍历行为</li>
<li>队列中进数据称为 — 入队 push</li>
<li>队列中出数据称为 — 出队 pop</li>
</ul>
<h4 id="queue常用接口"><a href="#queue常用接口" class="headerlink" title="queue常用接口"></a>queue常用接口</h4><p><strong>构造函数：</strong>  </p>
<ul>
<li>queue<T> que; //queue采用模板类实现，queue对象的默认构造形式</li>
<li>queue(const queue &amp;que); //拷贝构造函数</li>
</ul>
<p><strong>赋值操作：</strong> </p>
<ul>
<li>queue&amp; operator=(const queue &amp;que); //重载等号操作符</li>
</ul>
<p><strong>数据存取：</strong></p>
<ul>
<li>push(elem); //往队尾添加元素</li>
<li>pop(); //从队头移除第一个元素</li>
<li>back(); //返回最后一个元素</li>
<li>front(); //返回第一个元素</li>
</ul>
<p><strong>大小操作：</strong></p>
<ul>
<li>empty(); //判断堆栈是否为空</li>
<li>size(); //返回栈的大小</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">构造函数：</span></span><br><span class="line"><span class="comment">queue&lt;T&gt; que; //queue采用模板类实现，queue对象的默认构造形式</span></span><br><span class="line"><span class="comment">queue(const queue &amp;que); //拷贝构造函数</span></span><br><span class="line"><span class="comment">赋值操作：</span></span><br><span class="line"><span class="comment">queue&amp; operator=(const queue &amp;que); //重载等号操作符</span></span><br><span class="line"><span class="comment">数据存取：</span></span><br><span class="line"><span class="comment">push(elem); //往队尾添加元素</span></span><br><span class="line"><span class="comment">pop(); //从队头移除第一个元素</span></span><br><span class="line"><span class="comment">back(); //返回最后一个元素</span></span><br><span class="line"><span class="comment">front(); //返回第一个元素</span></span><br><span class="line"><span class="comment">大小操作：</span></span><br><span class="line"><span class="comment">empty(); //判断堆栈是否为空</span></span><br><span class="line"><span class="comment">size(); //返回栈的大小</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string name, <span class="type">int</span> age) :  <span class="built_in">Name</span>(name), <span class="built_in">Age</span>(age) &#123; &#125;</span><br><span class="line">    string Name;</span><br><span class="line">    <span class="type">int</span> Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建队列</span></span><br><span class="line">    queue&lt;Person&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据</span></span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;唐僧&quot;</span>, <span class="number">30</span>)</span>, <span class="title">p2</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">500</span>)</span>, <span class="title">p3</span><span class="params">(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">1000</span>)</span>, <span class="title">p4</span><span class="params">(<span class="string">&quot;沙僧&quot;</span>, <span class="number">1000</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进队</span></span><br><span class="line">    q.<span class="built_in">push</span>(p1);</span><br><span class="line">    q.<span class="built_in">push</span>(p2);</span><br><span class="line">    q.<span class="built_in">push</span>(p3);</span><br><span class="line">    q.<span class="built_in">push</span>(p4);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列没有迭代器，也不支持随机存取</span></span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;队头元素： 姓名： &quot;</span> &lt;&lt; q.<span class="built_in">front</span>().Name &lt;&lt; <span class="string">&quot;年龄： &quot;</span> &lt;&lt; q.<span class="built_in">front</span>().Age &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;队尾元素： 姓名： &quot;</span> &lt;&lt; q.<span class="built_in">back</span>().Name &lt;&lt; <span class="string">&quot;年龄： &quot;</span> &lt;&lt; q.<span class="built_in">back</span>().Age &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;队列大小： &quot;</span> &lt;&lt; q.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<ul>
<li>入队 — push</li>
<li>出队 — pop</li>
<li>返回队头元素 — front</li>
<li>返回队尾元素 — back</li>
<li>判断队是否为空 — empty</li>
<li>返回队列大小 — size</li>
</ul>
<p><img src="https://s2.loli.net/2023/03/25/aEqgLcIpvsR1JdY.png" alt="Queue">  </p>
<h3 id="list容器"><a href="#list容器" class="headerlink" title="list容器"></a>list容器</h3><h4 id="list基本概念"><a href="#list基本概念" class="headerlink" title="list基本概念"></a>list基本概念</h4><p><strong>功能：</strong></p>
<ul>
<li>链式存储数据</li>
</ul>
<p><strong>链表：</strong></p>
<ul>
<li>逻辑上连续，但是物理上不一定连续的存储结构，使用指针存取</li>
</ul>
<p><strong>链表组成：</strong></p>
<ul>
<li>数据域+指针域</li>
</ul>
<p>STL里的 list 是双向循环链表，但是在实际使用时似乎并没有体现出它是循环链表，</p>
<p>优点：</p>
<ul>
<li>动态申请，不需要关心容量够不够（链表）</li>
<li>插入数据不需要大量移动元素（链表）</li>
</ul>
<ul>
<li>插入数据时，无论是头插还是尾插，时间复杂度都是O(1)（循环链表）</li>
</ul>
<p>缺点：</p>
<ul>
<li>遍历成本高，时间复杂度为O(n)</li>
<li>插入操作和删除操作都不会造成原有 list 迭代器的失效，这在vector是不成立的</li>
<li>不能随机存取</li>
</ul>
<p>总结：STL中<strong>List和vector是两个最常被使用的容器</strong>，各有优缺点</p>
<h4 id="list构造函数"><a href="#list构造函数" class="headerlink" title="list构造函数"></a>list构造函数</h4><p><strong>功能描述：</strong></p>
<ul>
<li>创建list容器</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li>list<T> lst; //list采用采用模板类实现,对象的默认构造形式：</li>
<li>list(beg,end); //构造函数将[beg, end)区间中的元素拷贝给本身。</li>
<li>list(n,elem); //构造函数将n个elem拷贝给本身。</li>
<li>list(const list &amp;lst); //拷贝构造函数。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">list&lt;T&gt; lst; //list采用采用模板类实现,对象的默认构造形式：</span></span><br><span class="line"><span class="comment">list(beg,end); //构造函数将[beg, end)区间中的元素拷贝给本身。</span></span><br><span class="line"><span class="comment">list(n,elem); //构造函数将n个elem拷贝给本身。</span></span><br><span class="line"><span class="comment">list(const list &amp;lst); //拷贝构造函数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintList</span><span class="params">(<span class="type">const</span> list&lt;<span class="type">int</span>&gt; &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (list&lt;<span class="type">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) </span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>; </span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; L1;</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PrintList</span>(L1);</span><br><span class="line"></span><br><span class="line">    <span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">L2</span><span class="params">(L1.begin(), L1.end())</span></span>;</span><br><span class="line">    <span class="built_in">PrintList</span>(L2);</span><br><span class="line"></span><br><span class="line">    <span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">L3</span><span class="params">(L2)</span></span>;</span><br><span class="line">    <span class="built_in">PrintList</span>(L3);</span><br><span class="line"></span><br><span class="line">    <span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">L4</span><span class="params">(<span class="number">10</span>, <span class="number">1000</span>)</span></span>;</span><br><span class="line">    <span class="built_in">PrintList</span>(L4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong> list构造方式同其他几个STL常用容器，熟练掌握即可</p>
<h4 id="list赋值和交换"><a href="#list赋值和交换" class="headerlink" title="list赋值和交换"></a>list赋值和交换</h4><p><strong>功能描述：</strong></p>
<ul>
<li>给list容器赋值，交换容器</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li>assign(beg, end); //将[beg, end)区间中的数据拷贝赋值给本身。</li>
<li>assign(n, elem); //将n个elem拷贝赋值给本身。</li>
<li>list&amp; operator=(const list &amp;lst); //重载等号操作符</li>
<li>swap(lst); //将lst与本身的元素互换。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">assign(beg, end); //将[beg, end)区间中的数据拷贝赋值给本身。</span></span><br><span class="line"><span class="comment">assign(n, elem); //将n个elem拷贝赋值给本身。</span></span><br><span class="line"><span class="comment">list&amp; operator=(const list &amp;lst); //重载等号操作符</span></span><br><span class="line"><span class="comment">swap(lst); //将lst与本身的元素互换。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintList</span><span class="params">(<span class="type">const</span> list&lt;<span class="type">int</span>&gt; &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// list不支持 关系运算符 &lt; 和 &gt;</span></span><br><span class="line">    <span class="keyword">for</span>(list&lt;<span class="type">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; L1;</span><br><span class="line">    <span class="comment">// 尾插</span></span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PrintList</span>(L1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值</span></span><br><span class="line">    list&lt;<span class="type">int</span>&gt; L2;</span><br><span class="line">    L2 = L1;</span><br><span class="line">    <span class="built_in">PrintList</span>(L2);</span><br><span class="line"></span><br><span class="line">    list&lt;<span class="type">int</span>&gt; L3;</span><br><span class="line">    L3.<span class="built_in">assign</span>(L2.<span class="built_in">begin</span>(), L2.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">PrintList</span>(L3);</span><br><span class="line"></span><br><span class="line">    list&lt;<span class="type">int</span>&gt; L4;</span><br><span class="line">    L4.<span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="built_in">PrintList</span>(L4);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; L1;</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    list&lt;<span class="type">int</span>&gt; L2;</span><br><span class="line">    L2.<span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;交换前： &quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">PrintList</span>(L1);</span><br><span class="line">    <span class="built_in">PrintList</span>(L2);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    L1.<span class="built_in">swap</span>(L2);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;交换后： &quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PrintList</span>(L1);</span><br><span class="line">    <span class="built_in">PrintList</span>(L2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="list大小操作"><a href="#list大小操作" class="headerlink" title="list大小操作"></a>list大小操作</h4><p><strong>功能描述：</strong></p>
<ul>
<li>list容器容量以及重新指定容器容量</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li>size(); //返回容器中元素的个数</li>
<li>empty(); //判断容器是否为空</li>
<li>resize(num); //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。</li>
<li>//如果容器变短，则末尾超出容器长度的元素被删除。</li>
<li>resize(num, elem); //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。</li>
<li>//如果容器变短，则末尾超出容器长度的元素被删除。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">size(); //返回容器中元素的个数</span></span><br><span class="line"><span class="comment">empty(); //判断容器是否为空</span></span><br><span class="line"><span class="comment">resize(num); //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。</span></span><br><span class="line"><span class="comment">//如果容器变短，则末尾超出容器长度的元素被删除。</span></span><br><span class="line"><span class="comment">resize(num, elem); //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。</span></span><br><span class="line"><span class="comment">//如果容器变短，则末尾超出容器长度的元素被删除。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintList</span><span class="params">(<span class="type">const</span> list&lt;<span class="type">int</span>&gt; &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(list&lt;<span class="type">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大小操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; L1;</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PrintList</span>(L1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(L1.<span class="built_in">empty</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;L1为空！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;L1不为空;&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;L1的大小为： &quot;</span> &lt;&lt; L1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新指定大小</span></span><br><span class="line">    L1.<span class="built_in">resize</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">PrintList</span>(L1);</span><br><span class="line"></span><br><span class="line">    L1.<span class="built_in">resize</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">PrintList</span>(L1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="list插入与删除"><a href="#list插入与删除" class="headerlink" title="list插入与删除"></a>list插入与删除</h4><p><strong>功能描述：</strong></p>
<ul>
<li>向list容器中插入元素与删除list容器中的元素</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li>push_back(elem);//在容器尾部加入一个元素</li>
<li>pop_back();//删除容器中最后一个元素</li>
<li>push_front(elem);//在容器开头插入一个元素</li>
<li>pop_front();//从容器开头移除第一个元素</li>
<li>insert(pos,elem);//在pos位置插elem元素的拷贝，返回新数据的位置。</li>
<li>insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。</li>
<li>insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。</li>
<li>clear();//移除容器的所有数据</li>
<li>erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。</li>
<li>erase(pos);//删除pos位置的数据，返回下一个数据的位置。</li>
<li>remove(elem);//删除容器中所有与elem值匹配的元素。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">push_back(elem);//在容器尾部加入一个元素</span></span><br><span class="line"><span class="comment">pop_back();//删除容器中最后一个元素</span></span><br><span class="line"><span class="comment">push_front(elem);//在容器开头插入一个元素</span></span><br><span class="line"><span class="comment">pop_front();//从容器开头移除第一个元素</span></span><br><span class="line"><span class="comment">insert(pos,elem);//在pos位置插elem元素的拷贝，返回新数据的位置。</span></span><br><span class="line"><span class="comment">if (L1.empty()) &#123; cout &lt;&lt; &quot;L1为空&quot; &lt;&lt; endl; &#125;else &#123; cout &lt;&lt; &quot;L1不为空&quot; &lt;&lt; endl; cout &lt;&lt; &quot;L1的大小为： &quot; &lt;&lt; L1.size() &lt;&lt; endl; &#125;//重新指定大小 L1.resize(10); printList(L1); L1.resize(2); printList(L1); &#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 192021222324252627282930313233343536373839404142434445</span></span><br><span class="line"><span class="comment">insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。</span></span><br><span class="line"><span class="comment">insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。</span></span><br><span class="line"><span class="comment">clear();//移除容器的所有数据</span></span><br><span class="line"><span class="comment">erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。</span></span><br><span class="line"><span class="comment">erase(pos);//删除pos位置的数据，返回下一个数据的位置。</span></span><br><span class="line"><span class="comment">remove(elem);//删除容器中所有与elem值匹配的元素。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintList</span><span class="params">(<span class="type">const</span> list&lt;<span class="type">int</span>&gt; &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(list&lt;<span class="type">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; L1;</span><br><span class="line">    <span class="comment">// 尾插</span></span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">    <span class="comment">// 头插</span></span><br><span class="line">    L1.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">    L1.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line">    L1.<span class="built_in">push_front</span>(<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PrintList</span>(L1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尾删</span></span><br><span class="line">    L1.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="built_in">PrintList</span>(L1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 头删</span></span><br><span class="line">    L1.<span class="built_in">pop_front</span>();</span><br><span class="line">    <span class="built_in">PrintList</span>(L1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入</span></span><br><span class="line">    list&lt;<span class="type">int</span>&gt;::iterator it = L1.<span class="built_in">begin</span>();</span><br><span class="line">    L1.<span class="built_in">insert</span>(++it, <span class="number">100</span>);</span><br><span class="line">    <span class="built_in">PrintList</span>(L1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除</span></span><br><span class="line">    it = L1.<span class="built_in">begin</span>();</span><br><span class="line">    L1.<span class="built_in">erase</span>(++it);</span><br><span class="line">    <span class="built_in">PrintList</span>(L1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除</span></span><br><span class="line">    L1.<span class="built_in">push_front</span>(<span class="number">1000</span>);</span><br><span class="line">    L1.<span class="built_in">push_front</span>(<span class="number">1000</span>);</span><br><span class="line">    L1.<span class="built_in">push_front</span>(<span class="number">1000</span>);</span><br><span class="line">    L1.<span class="built_in">remove</span>(<span class="number">1000</span>);</span><br><span class="line">    <span class="built_in">PrintList</span>(L1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空</span></span><br><span class="line">    L1.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">PrintList</span>(L1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="list数据存取"><a href="#list数据存取" class="headerlink" title="list数据存取"></a>list数据存取</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对list容器执行存取操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li>front(); //返回第一个元素。</li>
<li>back(); //返回最后一个元素。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">front(); //返回第一个元素。</span></span><br><span class="line"><span class="comment">back(); //返回最后一个元素。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; L1;</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 链表不支持随机存取，不能使用 at() 方法，也不支持使用 [] 访问容器内的成员</span></span><br><span class="line">    <span class="comment">// 只能访问得到链表头尾元素，因为list是双向循环链表，表头元素访问时间复杂度为O(1)，表尾元素访问的时间复杂度也是O(1)</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第一个元素： &quot;</span> &lt;&lt; L1.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;最后一个元素： &quot;</span> &lt;&lt; L1.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// list的迭代器是双向迭代器，不支持随机访问</span></span><br><span class="line">    list&lt;<span class="type">int</span>&gt;::iterator it = L1.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="comment">// 不支持 it += 1; 不能跳跃</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="list反转与排序"><a href="#list反转与排序" class="headerlink" title="list反转与排序"></a>list反转与排序</h4><p><strong>功能描述：</strong></p>
<ul>
<li>将list容器中的数据反转与排序</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li>reverse(); //反转链表</li>
<li>sort(); //链表排序</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">reverse(); //反转链表</span></span><br><span class="line"><span class="comment">sort(); //链表排序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintList</span><span class="params">(<span class="type">const</span> list&lt;<span class="type">int</span>&gt; &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(list&lt;<span class="type">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MyCompare</span><span class="params">(<span class="type">int</span> val1, <span class="type">int</span> val2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> val1 &gt; val2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l</span><br></pre></td></tr></table></figure>



<h4 id="排序案例"><a href="#排序案例" class="headerlink" title="排序案例"></a>排序案例</h4><ul>
<li>案例描述：将Person自定义数据类型进行排序，Person中属性有姓名、年龄、身高</li>
<li>排序规则：按照年龄进行升序，如果年龄相同按照身高进行降序（使用仿函数指定排序策略）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    按照年龄进行升序，如果年龄相同按照身高进行降序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>() &#123; &#125;</span><br><span class="line">    <span class="built_in">Person</span>(string name, <span class="type">int</span> age, <span class="type">int</span> height) : <span class="built_in">Name</span>(name), <span class="built_in">Age</span>(age), <span class="built_in">Height</span>(height) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    string Name;</span><br><span class="line">    <span class="type">int</span> Age;</span><br><span class="line">    <span class="type">int</span> Height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 排序策略</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MyCompare</span><span class="params">(Person &amp;p1, Person &amp;p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p1.Age == p2.Age)</span><br><span class="line">        <span class="keyword">return</span> p1.Height &gt; p2.Height;   <span class="comment">// 身高降序</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> p1.Age &lt; p2.Age; <span class="comment">// 年龄升序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintList</span><span class="params">(<span class="type">const</span> list&lt;Person&gt; &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(list&lt;Person&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; it-&gt;Age &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; it -&gt;Height &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    list&lt;Person&gt; L;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">35</span>, <span class="number">175</span>)</span>, <span class="title">p2</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">35</span>, <span class="number">200</span>)</span>, <span class="title">p3</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">35</span>, <span class="number">160</span>)</span>, <span class="title">p4</span><span class="params">(<span class="string">&quot;曹操&quot;</span>, <span class="number">45</span>, <span class="number">178</span>)</span>, <span class="title">p5</span><span class="params">(<span class="string">&quot;孙权&quot;</span>, <span class="number">40</span>, <span class="number">170</span>)</span>, <span class="title">p6</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">25</span>, <span class="number">190</span>)</span></span>;</span><br><span class="line">    L.<span class="built_in">push_back</span>(p1);</span><br><span class="line">    L.<span class="built_in">push_back</span>(p2);</span><br><span class="line">    L.<span class="built_in">push_back</span>(p3);</span><br><span class="line">    L.<span class="built_in">push_back</span>(p4);</span><br><span class="line">    L.<span class="built_in">push_back</span>(p5);</span><br><span class="line">    L.<span class="built_in">push_back</span>(p6);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;排序前：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">PrintList</span>(L);</span><br><span class="line"></span><br><span class="line">    L.<span class="built_in">sort</span>(MyCompare);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;排序后：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">PrintList</span>(L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong> </p>
<ul>
<li>对于自定义数据类型，必须要指定排序规则，否则编译器不知道如何进行排序</li>
<li>高级排序只是在排序规则上再进行一次逻辑规则制定，并不复杂</li>
</ul>
<p><img src="https://s2.loli.net/2023/03/25/Pqde6wMWcO3F2yj.png" alt="List"> </p>
<h3 id="set-multiset-容器（集合）"><a href="#set-multiset-容器（集合）" class="headerlink" title="set/ multiset 容器（集合）"></a>set/ multiset 容器（集合）</h3><h4 id="set-multiset基本概念"><a href="#set-multiset基本概念" class="headerlink" title="set/multiset基本概念"></a>set/multiset基本概念</h4><p><strong>简介：</strong> </p>
<ul>
<li>所有元素都会在插入时自动被排序</li>
</ul>
<p><strong>本质：</strong> </p>
<ul>
<li>set/multiset属于关联式容器，底层结构是用二叉树实现。</li>
</ul>
<p><strong>set和multiset区别：</strong> </p>
<ul>
<li>set不允许容器中有重复的元素</li>
<li>multiset允许容器中有重复的元素</li>
</ul>
<h4 id="set构造和赋值"><a href="#set构造和赋值" class="headerlink" title="set构造和赋值"></a>set构造和赋值</h4><p><strong>构造：</strong> </p>
<ul>
<li>set<T> st; //默认构造函数：</li>
<li>set(const set &amp;st); //拷贝构造函数</li>
</ul>
<p><strong>赋值：</strong> </p>
<ul>
<li>set&amp; operator=(const set &amp;st); //重载等号操作符</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">构造：</span></span><br><span class="line"><span class="comment">set&lt;T&gt; st; //默认构造函数：</span></span><br><span class="line"><span class="comment">set(const set &amp;st); //拷贝构造函数</span></span><br><span class="line"><span class="comment">赋值：</span></span><br><span class="line"><span class="comment">set&amp; operator=(const set &amp;st); //重载等号操作符</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintSet</span><span class="params">(<span class="type">const</span> set&lt;<span class="type">int</span>&gt; &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(set&lt;<span class="type">int</span>&gt;::const_iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Constructor and assignment</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 自动排序</span></span><br><span class="line">    set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">80</span>);</span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">90</span>);</span><br><span class="line">    <span class="built_in">PrintSet</span>(s1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造</span></span><br><span class="line">    <span class="function">set&lt;<span class="type">int</span>&gt; <span class="title">s2</span><span class="params">(s1)</span></span>;</span><br><span class="line">    <span class="built_in">PrintSet</span>(s2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 运算符重载</span></span><br><span class="line">    set&lt;<span class="type">int</span>&gt; s3;</span><br><span class="line">    s3 = s2;</span><br><span class="line">    <span class="built_in">PrintSet</span>(s3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<ul>
<li>set容器插入数据时用insert</li>
<li>set容器插入数据的数据会自动排序（自定义类型除外）</li>
</ul>
<h4 id="set大小和交换"><a href="#set大小和交换" class="headerlink" title="set大小和交换"></a>set大小和交换</h4><p><strong>功能描述：</strong> </p>
<ul>
<li>统计set容器大小以及交换set容器</li>
</ul>
<p><strong>函数原型：</strong> </p>
<ul>
<li>size(); //返回容器中元素的数目</li>
<li>empty(); //判断容器是否为空</li>
<li>swap(st); //交换两个集合容器</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintSet</span><span class="params">(<span class="type">const</span> set&lt;<span class="type">int</span>&gt; &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(set&lt;<span class="type">int</span>&gt;::const_iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PrintSet</span>(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(s.<span class="built_in">empty</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;set容器为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;容器不为空且大小为：&quot;</span> &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; s1, s2;</span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">400</span>);</span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">200</span>);</span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    s2.<span class="built_in">insert</span>(<span class="number">100</span>);</span><br><span class="line">    s2.<span class="built_in">insert</span>(<span class="number">300</span>);</span><br><span class="line">    s2.<span class="built_in">insert</span>(<span class="number">200</span>);</span><br><span class="line">    s2.<span class="built_in">insert</span>(<span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;交换前：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">PrintSet</span>(s1);</span><br><span class="line">    <span class="built_in">PrintSet</span>(s2);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;交换后：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">PrintSet</span>(s1);</span><br><span class="line">    <span class="built_in">PrintSet</span>(s2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong> </p>
<ul>
<li>统计大小 — size</li>
<li>判断是否为空 — empty</li>
<li>交换容器 — swap</li>
</ul>
<h4 id="set插入和删除"><a href="#set插入和删除" class="headerlink" title="set插入和删除"></a>set插入和删除</h4><p><strong>功能描述：</strong> </p>
<ul>
<li>set容器进行插入数据和删除数据</li>
</ul>
<p><strong>函数原型：</strong> </p>
<ul>
<li>insert(elem); //在容器中插入元素。</li>
<li>clear(); //清除所有元素</li>
<li>erase(pos); //删除pos迭代器所指的元素，返回下一个元素的迭代器。</li>
<li>erase(beg, end); //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</li>
<li>erase(elem); //删除容器中值为elem的元素。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">insert(elem); //在容器中插入元素。</span></span><br><span class="line"><span class="comment">clear(); //清除所有元素</span></span><br><span class="line"><span class="comment">erase(pos); //删除pos迭代器所指的元素，返回下一个元素的迭代器。</span></span><br><span class="line"><span class="comment">erase(beg, end); //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</span></span><br><span class="line"><span class="comment">erase(elem); //删除容器中值为elem的元素。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintSet</span><span class="params">(<span class="type">const</span> set&lt;<span class="type">int</span>&gt; &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(set&lt;<span class="type">int</span>&gt;::const_iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入和删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Insert data</span></span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PrintSet</span>(s);</span><br><span class="line"></span><br><span class="line">    s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>());</span><br><span class="line">    <span class="built_in">PrintSet</span>(s);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载版本，删除容器中所有相同元素</span></span><br><span class="line">    s.<span class="built_in">erase</span>(<span class="number">30</span>);</span><br><span class="line">    <span class="built_in">PrintSet</span>(s);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空</span></span><br><span class="line">    <span class="comment">// s.erase(s.begin(), s.end()); // 提供迭代器区间</span></span><br><span class="line">    s.<span class="built_in">clear</span>();  <span class="comment">// 不需要提供参数</span></span><br><span class="line">    <span class="built_in">PrintSet</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong> </p>
<ul>
<li>插入 — insert</li>
<li>删除 — erase</li>
<li>清空 — clear</li>
</ul>
<h4 id="set查找和统计"><a href="#set查找和统计" class="headerlink" title="set查找和统计"></a>set查找和统计</h4><p><strong>功能描述：</strong> </p>
<ul>
<li>对set容器进行查找数据以及统计数据</li>
</ul>
<p><strong>函数原型：</strong> </p>
<ul>
<li>find(key); //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</li>
<li>count(key); //统计key的元素个数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">find(key); //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</span></span><br><span class="line"><span class="comment">count(key); //统计key的元素个数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    set&lt;<span class="type">int</span>&gt;::iterator pos = s.<span class="built_in">find</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pos != s.<span class="built_in">end</span>())  <span class="comment">// end()位置不存储数据</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;找到了该元素&quot;</span> &lt;&lt; *pos &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;未找到该元素&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = s.<span class="built_in">count</span>(<span class="number">30</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong> </p>
<ul>
<li>查找 — find （返回的是迭代器）</li>
<li>统计 — count （对于set，结果为0或者1）</li>
</ul>
<h4 id="set和multiset的区别"><a href="#set和multiset的区别" class="headerlink" title="set和multiset的区别"></a>set和multiset的区别</h4><p><strong>学习目标：</strong> </p>
<ul>
<li>掌握set和multiset的区别</li>
</ul>
<p><strong>区别：</strong> </p>
<ul>
<li>set不可以插入重复数据，而multiset可以</li>
<li>set插入数据的同时会返回插入结果，表示插入是否成功</li>
<li>multiset不会检测数据，因此可以插入重复数据</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintSet</span><span class="params">(<span class="type">const</span> set&lt;<span class="type">int</span>&gt; &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(set&lt;<span class="type">int</span>&gt;::const_iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set 和 multiset 的区别</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// set</span></span><br><span class="line">    set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    pair&lt;set&lt;<span class="type">int</span>&gt;::iterator,<span class="type">bool</span>&gt; ret = s.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret.second) </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;第一次插入成功&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;第一次插入失败&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    ret = s.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret.second) </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;第二次插入成功&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;第二次插入失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//只有第一次插入成功</span></span><br><span class="line">    <span class="built_in">PrintSet</span>(s);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// multiset</span></span><br><span class="line">    multiset&lt;<span class="type">int</span>&gt; ms;</span><br><span class="line">    ms.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    ms.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(multiset&lt;<span class="type">int</span>&gt;::iterator it = ms.<span class="built_in">begin</span>(); it != ms.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set 与二叉排序树相似，不能有相同的元素，如果需要有相同的元素，可以使用multiset</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong> </p>
<p>如果不允许插入重复数据可以利用set</p>
<p>如果需要插入重复数据利用multiset</p>
<h4 id="pair队组创建"><a href="#pair队组创建" class="headerlink" title="pair队组创建"></a>pair队组创建</h4><p><strong>简介：</strong> </p>
<ul>
<li><p>pair是将2个数据组合成一组数据，如stl中的map就是将key和value放在一起来保存，或者当一个函数需要返回2个数据的时候，也可以选择pair</p>
</li>
<li><p>pair的实现是一个结构体，主要的两个成员变量first和second，分别存储两个数据， 因为是使用struct不是class，所以可以直接使用pair的成员变量。</p>
</li>
<li><p>pair类型定义在#include 头文件中，也可以使用std命名空间引入对组std::pair</p>
</li>
</ul>
<p><strong>定义如下：</strong> </p>
<ul>
<li>类模板：<ul>
<li>template&lt;class T1,class T2&gt; struct pair</li>
<li>T1是第一个值的数据类型，T2是第二个值的数据类型。</li>
</ul>
</li>
<li>功能：<ul>
<li>pair将一对值(T1和T2)组合成一个值，这一对值可以具有不同的数据类型（T1和T2），两个值可以分别用pair的两个成员first和second访问。</li>
</ul>
</li>
</ul>
<p><strong>功能描述：</strong> </p>
<ul>
<li>成对出现的数据，利用对组可以返回两个数据</li>
</ul>
<p><strong>两种创建方式：</strong> </p>
<ul>
<li>pair&lt;type, type&gt; p ( value1, value2 ); </li>
<li>pair&lt;type, type&gt; p = make_pair( value1, value2 ); </li>
<li>make_pair函数生成pair时接受隐式的类型转换（pair&lt;string, int&gt;p2 = make_pair(“Jerry”, 200);）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    使用pair创建对组，利用对组可以返回两个数据</span></span><br><span class="line"><span class="comment">    创建方式：</span></span><br><span class="line"><span class="comment">    pair&lt;type, type&gt; p ( value1, value2 ); </span></span><br><span class="line"><span class="comment">    pair&lt;type, type&gt; p = make_pair( value1, value2 );</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">pair&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; p.first &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p.second &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    pair&lt;string, <span class="type">int</span>&gt; p2 = <span class="built_in">make_pair</span>(<span class="string">&quot;Jerry&quot;</span>, <span class="number">30</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; p2.first &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p2.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong> </p>
<ul>
<li>两种方式都可以创建对组，记住一种即可</li>
</ul>
<h4 id="set容器排序"><a href="#set容器排序" class="headerlink" title="set容器排序"></a>set容器排序</h4><p><strong>学习目标：</strong> </p>
<ul>
<li>set容器默认排序规则为从小到大，掌握如何改变排序规则</li>
</ul>
<p><strong>主要技术点：</strong> </p>
<ul>
<li>利用仿函数，可以改变排序规则</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set排序原则默认从小到大</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 仿函数，本质是类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCompare</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="comment">// 重载 () 运算符</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> v1 &gt; v2; <span class="comment">// 降序，大数先返回</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内置数据类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; s1; </span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">10</span>); </span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">40</span>); </span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">20</span>); </span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">30</span>); </span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(set&lt;<span class="type">int</span>&gt;::iterator it = s1.<span class="built_in">begin</span>(); it != s1.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 改变排序规则需要在插入之前，利用仿函数修改</span></span><br><span class="line">    set&lt;<span class="type">int</span>, MyCompare&gt; s2;</span><br><span class="line">    s2.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    s2.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">    s2.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">    s2.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(set&lt;<span class="type">int</span>, MyCompare&gt;::iterator it = s2.<span class="built_in">begin</span>(); it != s2.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string name, <span class="type">int</span> age) : <span class="built_in">Name</span>(name), <span class="built_in">Age</span>(age) &#123; &#125;</span><br><span class="line">    string Name;</span><br><span class="line">    <span class="type">int</span> Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ComparePerson</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 函数必须使用括号将语句括起来</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Person &amp;p1, <span class="type">const</span> Person &amp;p2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1.Age &gt; p2.Age; <span class="comment">// 降序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义数据类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set&lt;Person, ComparePerson&gt; s;</span><br><span class="line">    <span class="comment">// 年龄必须不同，这是 set 的特性，根据comparePerson判断元素相同。</span></span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">23</span>)</span>, <span class="title">p2</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">35</span>)</span>, <span class="title">p3</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">35</span>)</span>, <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line">    s.<span class="built_in">insert</span>(p1);</span><br><span class="line">    s.<span class="built_in">insert</span>(p2);</span><br><span class="line">    s.<span class="built_in">insert</span>(p3);</span><br><span class="line">    s.<span class="built_in">insert</span>(p4);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(set&lt;Person, ComparePerson&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; it-&gt;Name &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; it-&gt;Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// test01();</span></span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong> 利用仿函数可以指定set容器的排序规则， 对于自定义数据类型，set必须指定排序规则才可以插入数据</p>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>若要用set或者multiset存放自定义类型数据，需要重载关系运算符 &lt;、&gt;和==，可以选择重载 &lt;&lt; 运算符用于自定义类型数据，或者通过使用仿函数指定排序策略（必须在声明中写清楚）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 友元</span></span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;cout, <span class="type">const</span> Person &amp;p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Person &amp;p1, <span class="type">const</span> Person &amp;p2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> p1.Age &lt; p2.Age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Person</span>() &#123; &#125;</span><br><span class="line">    <span class="built_in">Person</span>(string name, <span class="type">int</span> age) : <span class="built_in">Name</span>(name), <span class="built_in">Age</span>(age) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    string Name;</span><br><span class="line">    <span class="type">int</span> Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, <span class="type">const</span> Person &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; p.Name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p.Age &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintSet</span><span class="params">(<span class="type">const</span> set&lt;Person&gt; &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(set&lt;Person&gt;::const_iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; *it;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set&lt;Person&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;s1&quot;</span>, <span class="number">23</span>)</span>, <span class="title">p2</span><span class="params">(<span class="string">&quot;s2&quot;</span>, <span class="number">24</span>)</span>, <span class="title">p3</span><span class="params">(<span class="string">&quot;s3&quot;</span>, <span class="number">25</span>)</span>, <span class="title">p4</span><span class="params">(<span class="string">&quot;s4&quot;</span>,<span class="number">26</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    s.<span class="built_in">insert</span>(p1);</span><br><span class="line">    s.<span class="built_in">insert</span>(p2);</span><br><span class="line">    s.<span class="built_in">insert</span>(p3);</span><br><span class="line">    s.<span class="built_in">insert</span>(p4);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PrintSet</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong> 对于自定义数据类型，set必须指定排序规则才可以插入数据</p>
<p><img src="https://s2.loli.net/2023/03/25/gkNR37TcOqYiUuV.png" alt="Set"> </p>
<h3 id="map-multimap容器"><a href="#map-multimap容器" class="headerlink" title="map/ multimap容器"></a>map/ multimap容器</h3><h4 id="map-基本概念"><a href="#map-基本概念" class="headerlink" title="map 基本概念"></a>map 基本概念</h4><p><strong>简介：</strong> </p>
<ul>
<li>map中所有元素都是pair</li>
<li>pair中第一个元素为key（键值），起到索引作用，第二个元素为value（实值）</li>
<li>所有元素都会根据元素的键值自动排序</li>
</ul>
<p><strong>本质：</strong> </p>
<ul>
<li>map/multimap属于关联式容器，底层结构是用二叉树实现。</li>
</ul>
<p><strong>优点：</strong> </p>
<ul>
<li>可以根据key值快速找到value值</li>
</ul>
<p><strong>map和multimap区别：</strong> </p>
<ul>
<li>map不允许容器中有重复key值元素</li>
<li>multimap允许容器中有重复key值元素</li>
</ul>
<h4 id="map-构造和赋值"><a href="#map-构造和赋值" class="headerlink" title="map 构造和赋值"></a>map 构造和赋值</h4><p><strong>功能描述：</strong> </p>
<ul>
<li>对map容器进行构造和赋值操作</li>
</ul>
<p><strong>函数原型：</strong> </p>
<ul>
<li>构造：<ul>
<li>map&lt;T1, T2&gt; mp; //map默认构造函数: </li>
<li>map(const map &amp;mp); //拷贝构造函数</li>
</ul>
</li>
<li>赋值：<ul>
<li>map&amp; operator=(const map &amp;mp); //重载等号操作符</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">构造：</span></span><br><span class="line"><span class="comment">map&lt;T1, T2&gt; mp; //map默认构造函数: map(const map &amp;mp); //拷贝构造函数</span></span><br><span class="line"><span class="comment">赋值：</span></span><br><span class="line"><span class="comment">map&amp; operator=(const map &amp;mp); //重载等号操作符</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 属于关联式容器，底层实现用的是二叉树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintMap</span><span class="params">(<span class="type">const</span> map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::const_iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 插入后自动排序</span></span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">    m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">    m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">    m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line">    <span class="built_in">PrintMap</span>(m);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">m2</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="built_in">PrintMap</span>(m2);</span><br><span class="line"></span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m3;</span><br><span class="line">    m3 = m2;</span><br><span class="line">    <span class="built_in">PrintMap</span>(m3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong> map中所有元素都是成对出现，插入数据时候要使用对组</p>
<h4 id="map大小和交换"><a href="#map大小和交换" class="headerlink" title="map大小和交换"></a>map大小和交换</h4><p><strong>功能描述：</strong> </p>
<ul>
<li>统计map容器大小以及交换map容器</li>
</ul>
<p><strong>函数原型：</strong> </p>
<ul>
<li>size(); //返回容器中元素的数目</li>
<li>empty(); //判断容器是否为空</li>
<li>swap(st); //交换两个集合容器</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintMap</span><span class="params">(<span class="type">const</span> map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::const_iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 大小</span></span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m1;</span><br><span class="line">    m1.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">    m1.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">    m1.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PrintMap</span>(m1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(m1.<span class="built_in">empty</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;m1为空！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;m1不为空且m1的大小为：&quot;</span> &lt;&lt; m1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换</span></span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m2;</span><br><span class="line">    m2.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">4</span>, <span class="number">400</span>));</span><br><span class="line">    m2.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">5</span>, <span class="number">500</span>));</span><br><span class="line">    m2.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">6</span>, <span class="number">600</span>));</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;交换前：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">PrintMap</span>(m1);</span><br><span class="line">    <span class="built_in">PrintMap</span>(m2);</span><br><span class="line"></span><br><span class="line">    m1.<span class="built_in">swap</span>(m2);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;交换后：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">PrintMap</span>(m1);</span><br><span class="line">    <span class="built_in">PrintMap</span>(m2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong> </p>
<ul>
<li>统计大小 — size</li>
<li>判断是否为空 — empty</li>
<li>交换容器 — swap</li>
</ul>
<h4 id="map-插入和删除"><a href="#map-插入和删除" class="headerlink" title="map 插入和删除"></a>map 插入和删除</h4><p><strong>功能描述：</strong> </p>
<ul>
<li>map容器进行插入数据和删除数据</li>
</ul>
<p><strong>函数原型：</strong> </p>
<ul>
<li>insert(elem); //在容器中插入元素。</li>
<li>clear(); //清除所有元素</li>
<li>erase(pos); //删除pos迭代器所指的元素，返回下一个元素的迭代器。</li>
<li>erase(beg, end); //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</li>
<li>erase(key); //删除容器中值为key的元素。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintMap</span><span class="params">(<span class="type">const</span> map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::const_iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 插入</span></span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">    <span class="comment">// 第一种</span></span><br><span class="line">    m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二种</span></span><br><span class="line">    m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三种</span></span><br><span class="line">    m.<span class="built_in">insert</span>(map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::<span class="built_in">value_type</span>(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第四种</span></span><br><span class="line">    m[<span class="number">4</span>] = <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PrintMap</span>(m);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除</span></span><br><span class="line">    <span class="comment">// 提供迭代器作为索引</span></span><br><span class="line">    m.<span class="built_in">erase</span>(m.<span class="built_in">begin</span>());</span><br><span class="line">    <span class="built_in">PrintMap</span>(m);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供 key 值作为索引</span></span><br><span class="line">    m.<span class="built_in">erase</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">PrintMap</span>(m);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空</span></span><br><span class="line">    m.<span class="built_in">erase</span>(m.<span class="built_in">begin</span>(), m.<span class="built_in">end</span>());    <span class="comment">// 清空</span></span><br><span class="line">    m.<span class="built_in">clear</span>();  <span class="comment">// 清空</span></span><br><span class="line">    <span class="built_in">PrintMap</span>(m); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong> </p>
<ul>
<li>map插入方式很多，记住其一即可</li>
<li>插入 — insert</li>
<li>删除 — erase</li>
<li>清空 — clear</li>
</ul>
<h4 id="map-查找和统计"><a href="#map-查找和统计" class="headerlink" title="map 查找和统计"></a>map 查找和统计</h4><p><strong>功能描述：</strong> </p>
<ul>
<li>对map容器进行查找数据以及统计数据</li>
</ul>
<p><strong>函数原型：</strong> </p>
<ul>
<li>find(key); //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</li>
<li>count(key); //统计key的元素个数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数原型：</span></span><br><span class="line"><span class="comment">find(key); //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</span></span><br><span class="line"><span class="comment">count(key); //统计key的元素个数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">    m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">    m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">    m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找</span></span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator pos = m.<span class="built_in">find</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pos != m.<span class="built_in">end</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;找到了元素 key = &quot;</span> &lt;&lt; (*pos).first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; (*pos).second &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;未找到该元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 统计</span></span><br><span class="line">    <span class="type">int</span> num = m.<span class="built_in">count</span>(<span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong> </p>
<ul>
<li>查找 — find （返回的是迭代器）</li>
<li>统计 — count （对于map，结果为0或者1）</li>
</ul>
<h4 id="map-容器排序"><a href="#map-容器排序" class="headerlink" title="map 容器排序"></a>map 容器排序</h4><p><strong>学习目标：</strong> </p>
<ul>
<li>map容器默认排序规则为 按照key值进行 从小到大排序，掌握如何改变排序规则</li>
</ul>
<p><strong>主要技术点:</strong> </p>
<ul>
<li>利用仿函数，可以改变排序规则</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改默认从小到大的升序原则</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCompare</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v1 &gt; v2; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Compare_by_value</span><span class="params">(<span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &amp;p1, <span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &amp;p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p1.second &gt; p2.second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 利用仿函数实现降序排序，插入时会判断插入的队组的second值，以此为依据确定两对组是否相等</span></span><br><span class="line">    multimap&lt;<span class="type">int</span>, <span class="type">int</span>, MyCompare&gt; m;</span><br><span class="line">    m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">    m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">    m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line">    m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">3</span>, <span class="number">60</span>));</span><br><span class="line">    m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">4</span>, <span class="number">40</span>));</span><br><span class="line">    m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">5</span>, <span class="number">50</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;按值排序:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 按照value进行排序</span></span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">v</span>(m.<span class="built_in">begin</span>(), m.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), Compare_by_value);</span><br><span class="line">    <span class="comment">// 将map中的数据存到vector中，并没有解决我的问题</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt;  <span class="string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 还有将排序依据作为key值的，这是很好的想法，但是投机取巧</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong> </p>
<ul>
<li>利用仿函数可以指定map容器的排序规则</li>
<li>对于自定义数据类型，map必须要指定排序规则,同set容器</li>
</ul>
<p><img src="https://s2.loli.net/2023/03/25/Z8KqJljfDmNSiut.png" alt="Map"> </p>
<h4 id="案例-员工分组"><a href="#案例-员工分组" class="headerlink" title="案例-员工分组"></a>案例-员工分组</h4><p><strong>案例描述：</strong> </p>
<p>公司今天招聘了10个员工（ABCDEFGHIJ），10名员工进入公司之后，需要指派员工在那个部门工作</p>
<ul>
<li>员工信息有: 姓名 工资组成；部门分为：策划、美术、研发</li>
<li>随机给10名员工分配部门和工资</li>
<li>通过multimap进行信息的插入 key(部门编号) value(员工)</li>
<li>分部门显示员工信息</li>
</ul>
<p><strong>实现步骤：</strong> </p>
<ol>
<li>创建10名员工，放到vector中 </li>
<li>遍历vector容器，取出每个员工，进行随机分组</li>
<li>分组后，将员工部门编号作为key，具体员工作为value，放入到multimap容器中</li>
<li>分部门显示员工信息</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">公司今天招聘了10个员工（ABCDEFGHIJ），10名员工进入公司之后，需要指派员工在那个部门工作</span></span><br><span class="line"><span class="comment">员工信息有: 姓名 工资组成；部门分为：策划、美术、研发</span></span><br><span class="line"><span class="comment">随机给10名员工分配部门和工资</span></span><br><span class="line"><span class="comment">通过multimap进行信息的插入 key(部门编号) value(员工)</span></span><br><span class="line"><span class="comment">分部门显示员工信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESIGN 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ART 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEV 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Worker</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string Name;</span><br><span class="line">    <span class="type">int</span> Salary;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateWorker</span><span class="params">(vector&lt;Worker&gt; &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string NameSeed = <span class="string">&quot;ABCDEFGHIJ&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Worker w;</span><br><span class="line">        w.Name = <span class="string">&quot;员工&quot;</span>;</span><br><span class="line">        w.Name += NameSeed[i];</span><br><span class="line"></span><br><span class="line">        w.Salary = <span class="built_in">rand</span>() % <span class="number">10000</span> + <span class="number">10000</span>;  <span class="comment">// 10000 ~ 19999</span></span><br><span class="line">        <span class="comment">// 将员工放进容器</span></span><br><span class="line">        v.<span class="built_in">push_back</span>(w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 员工分组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetGroup</span><span class="params">(multimap&lt;<span class="type">int</span>, Worker&gt; &amp;m, vector&lt;Worker&gt; &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(vector&lt;Worker&gt;::const_iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 随机产生员工编号</span></span><br><span class="line">        <span class="type">int</span> deptID = <span class="built_in">rand</span>() % <span class="number">3</span>; <span class="comment">// 0 1 2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将员工插入到分组中，即将员工从 vector 中取出放到 map 中</span></span><br><span class="line">        m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(deptID, *it));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShowWorkerGroup</span><span class="params">(<span class="type">const</span> multimap&lt;<span class="type">int</span>, Worker&gt; &amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 0 A B C  1 D E   2 F G ...</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;策划部门&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 可以将 pos 视为 it，每次自增都是指向 key 都是一样的</span></span><br><span class="line">    multimap&lt;<span class="type">int</span>, Worker&gt;::const_iterator pos = m.<span class="built_in">find</span>(DESIGN);</span><br><span class="line">    <span class="type">int</span> count = m.<span class="built_in">count</span>(DESIGN);</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; pos != m.<span class="built_in">end</span>() &amp;&amp; index &lt; count; pos++, index++)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; pos-&gt;second.Name &lt;&lt; <span class="string">&quot; 薪水：&quot;</span> &lt;&lt; pos-&gt;second.Salary &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;美术部门：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    pos = m.<span class="built_in">find</span>(ART);</span><br><span class="line">    count = m.<span class="built_in">count</span>(ART);</span><br><span class="line">    <span class="keyword">for</span>(index = <span class="number">0</span>; pos != m.<span class="built_in">end</span>() &amp;&amp; index &lt; count; pos++, index++)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; pos-&gt;second.Name &lt;&lt; <span class="string">&quot; 薪水：&quot;</span> &lt;&lt; pos-&gt;second.Salary &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;开发部门：&quot;</span> &lt;&lt; endl;    </span><br><span class="line">    pos = m.<span class="built_in">find</span>(DEV);</span><br><span class="line">    count = m.<span class="built_in">count</span>(DEV);</span><br><span class="line">    <span class="keyword">for</span>(index = <span class="number">0</span>; pos != m.<span class="built_in">end</span>() &amp;&amp; index &lt; count; pos ++, index++)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; pos-&gt;second.Name &lt;&lt; <span class="string">&quot; 薪水：&quot;</span> &lt;&lt; pos-&gt;second.Salary &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 随机数种子</span></span><br><span class="line">    <span class="built_in">srand</span>((<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">    multimap&lt;<span class="type">int</span>, Worker&gt; m;</span><br><span class="line">    vector&lt;Worker&gt; v;</span><br><span class="line">    <span class="built_in">CreateWorker</span>(v);</span><br><span class="line">    <span class="built_in">SetGroup</span>(m, v);</span><br><span class="line">    <span class="built_in">ShowWorkerGroup</span>(m);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong> 当数据以键值对形式存在，可以考虑用map 或 multimap</p>
<h4 id="其他库"><a href="#其他库" class="headerlink" title="其他库"></a>其他库</h4><ul>
<li>vector模板类是一个容器类和算法系统的一部分，它支持面向容器的操作；</li>
<li>valarrsy类模板是面向数值计算的，不是STL的一部分；</li>
<li>array是为替代内置数组而设计的，它通过提供更好、更安全的接口，让数组更紧凑，效率更高。array表示长度固定的数组，因此不支持push_back()和insert()，但是提供了多个STL方法，包括begin()、end()、rbegin()、rend()。</li>
</ul>
<p>valarray类重载了所有算术运算符，使其能够用于valarray对象。对valarray对象的每一个成员进行操作可以使用：</p>
<p><code>target = before op obj;</code> target表示想要得到的结果；before表示之前的valarray对象；obj可以是实数，也可以是valarray对象</p>
<p><code>vad3 *= 2.5     // 将每个元素扩大到原先的2.5倍</code> </p>
<p><code>vad3 = vad1 + vad2;    // vad3中元素是其余两数组对应位置元素之和 </code>  </p>
<h4 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h4><p><code>std::vector&lt; double &gt; payments &#123; 45.99, 39.23, 19.95, 89.01 &#125;;</code> </p>
<p><code>shared_ptr&lt; double &gt; pd = &#123; new double &#125;;</code> </p>
<p><code>std::vector&lt; int &gt; vi(&#123;10&#125;)    // set 1 element to 10</code> </p>
<p>大括号初始化的语法对于数据类型转换的要求更严格，初始化列表的语法不允许隐式的窄化转换（double -&gt; int）。</p>
<p>头文件：    &lt; initializer_list &gt;</p>
<p>这个模板类支持对象按值传递，但是其迭代器为const类型，对元素只能读而不能更改。</p>
<h2 id="STL-–-函数对象"><a href="#STL-–-函数对象" class="headerlink" title="STL – 函数对象"></a>STL – 函数对象</h2><h3 id="5-1-函数对象的概念及使用方式"><a href="#5-1-函数对象的概念及使用方式" class="headerlink" title="5.1 函数对象的概念及使用方式"></a>5.1 函数对象的概念及使用方式</h3><p><strong>概念：</strong> </p>
<ul>
<li>重载函数调用操作符的类，其对象常称为函数对象</li>
<li>函数对象使用重载的()时，行为类似函数调用，也叫仿函数</li>
</ul>
<p><strong>本质：</strong> </p>
<ul>
<li>函数对象(仿函数)是一个类，不是一个函数</li>
</ul>
<p><strong>使用：</strong> </p>
<p><strong>特点：</strong> </p>
<ul>
<li>函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值</li>
<li>函数对象超出普通函数的概念，函数对象可以有自己的状态</li>
<li>函数对象可以作为参数传递</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、函数对象在使用时，可以像普通函数一样，可以有参数、返回值</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyAdd</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val1, <span class="type">int</span> val2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val1 + val2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyAdd myAdd;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">myAdd</span>(<span class="number">10</span>, <span class="number">10</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、函数对象可以有自己的状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyPrint</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string test)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; test &lt;&lt; endl;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyPrint myPrint;</span><br><span class="line">    <span class="built_in">myPrint</span>(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">    <span class="built_in">myPrint</span>(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">    <span class="built_in">myPrint</span>(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;MyPrint调用次数：&quot;</span> &lt;&lt; myPrint.count &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、函数对象可以作为参数传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoPrint</span><span class="params">(MyPrint &amp;mp, string test)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 调用仿函数</span></span><br><span class="line">    <span class="built_in">mp</span>(test);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyPrint myPrint;</span><br><span class="line">    <span class="comment">// 函数对象做实参</span></span><br><span class="line">    <span class="built_in">DoPrint</span>(myPrint, <span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// test01();</span></span><br><span class="line">    <span class="comment">// test02();</span></span><br><span class="line">    <span class="built_in">test03</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong> 仿函数写法非常灵活，可以作为参数进行传递。</p>
<h3 id="谓词"><a href="#谓词" class="headerlink" title="谓词"></a>谓词</h3><ul>
<li><p>返回bool类型的仿函数称为<strong>谓词</strong> </p>
</li>
<li><p>一元谓词：如果operator()接受一个参数，那么叫做<strong>一元谓词</strong> </p>
</li>
<li><p>二元谓词：如果operator()接受两个参数，那么叫做<strong>二元谓词</strong> </p>
</li>
</ul>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仿函数   返回值是bool类型，称为谓词</span></span><br><span class="line"><span class="comment">// 一元谓词</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GreaterThanFive</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val &gt; <span class="number">5</span>; <span class="comment">// 大于5为真</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        v.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 查找容器中有没有大于5的数字</span></span><br><span class="line">    <span class="comment">// 算法：find_if    找到的是 vector 中第一个符合要求的数据，并返回指向它的迭代器</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::const_iterator pos = <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">GreaterThanFive</span>());   </span><br><span class="line">    <span class="comment">// GreaterThanFive() 创建匿名函数对象</span></span><br><span class="line">    <span class="keyword">if</span>(pos == v.<span class="built_in">end</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;未找到&quot;</span> &lt;&lt; endl; </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;找到了大于5的数字：&quot;</span> &lt;&lt; *pos &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二元谓词，即参数是两个，返回值为 bool 类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyCompare</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val1, <span class="type">int</span> val2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val1 &gt; val2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::const_iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sort 默认从小到大，升序，所需为降序则需要以下操作</span></span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">MyCompare</span>());  <span class="comment">// 还是匿名函数对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong> 有几个参数就是几元谓词</p>
<h3 id="内建函数对象"><a href="#内建函数对象" class="headerlink" title="内建函数对象"></a>内建函数对象</h3><p><strong>概念：</strong> </p>
<ul>
<li>STL内建了一些函数对象</li>
</ul>
<p><strong>分类:</strong> </p>
<ul>
<li>算术仿函数</li>
<li>关系仿函数</li>
<li>逻辑仿函数</li>
</ul>
<p><strong>用法：</strong> </p>
<p>这些仿函数所产生的对象，用法和一般函数完全相同</p>
<p>使用内建函数对象，需要引入头文件 #include<functional></p>
<h4 id="算数函数对象"><a href="#算数函数对象" class="headerlink" title="算数函数对象"></a>算数函数对象</h4><p><strong>功能描述：</strong> </p>
<ul>
<li>实现四则运算</li>
<li>其中negate是一元运算，其他都是二元运算</li>
</ul>
<p><strong>仿函数原型：</strong> </p>
<ul>
<li>template<class T> T plus<T> //加法仿函数</li>
<li>template<class T> T minus<T> //减法仿函数</li>
<li>template<class T> T multiplies<T> //乘法仿函数</li>
<li>template<class T> T divides<T> //除法仿函数</li>
<li>template<class T> T modulus<T> //取模仿函数</li>
<li>template<class T> T negate<T> //取反仿函数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">仿函数原型：</span><br><span class="line">template&lt;class T&gt; T plus&lt;T&gt; //加法仿函数</span><br><span class="line">template&lt;class T&gt; T minus&lt;T&gt; //减法仿函数</span><br><span class="line">template&lt;class T&gt; T multiplies&lt;T&gt; //乘法仿函数</span><br><span class="line">template&lt;class T&gt; T divides&lt;T&gt; //除法仿函数</span><br><span class="line">template&lt;class T&gt; T modulus&lt;T&gt; //取模仿函数</span><br><span class="line">template&lt;class T&gt; T negate&lt;T&gt; //取反仿函数</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">// negate</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">    negate&lt;int&gt; n;  // 加负号</span><br><span class="line">    cout &lt;&lt; n(50) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">    plus&lt;int&gt; p;</span><br><span class="line">    cout &lt;&lt; p(10, 20) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    test01();</span><br><span class="line">    test02();</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong> 使用内建函数对象时，需要引入头文件 #include <functional></p>
<h4 id="关系仿函数"><a href="#关系仿函数" class="headerlink" title="关系仿函数"></a>关系仿函数</h4><p><strong>功能描述：</strong> </p>
<ul>
<li>实现关系对比</li>
</ul>
<p><strong>仿函数原型：</strong> </p>
<ul>
<li>template<class T> bool equal_to<T> //等于</li>
<li>template<class T> bool not_equal_to<T> //不等于</li>
<li>template<class T> bool greater<T> //大于</li>
<li>template<class T> bool greater_equal<T> //大于等于</li>
<li>template<class T> bool less<T> //小于</li>
<li>template<class T> bool less_equal<T> //小于等于</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">仿函数原型：</span></span><br><span class="line"><span class="comment">template&lt;class T&gt; bool equal_to&lt;T&gt; //等于</span></span><br><span class="line"><span class="comment">template&lt;class T&gt; bool not_equal_to&lt;T&gt; //不等于</span></span><br><span class="line"><span class="comment">template&lt;class T&gt; bool greater&lt;T&gt; //大于</span></span><br><span class="line"><span class="comment">template&lt;class T&gt; bool greater_equal&lt;T&gt; //大于等于</span></span><br><span class="line"><span class="comment">template&lt;class T&gt; bool less&lt;T&gt; //小于</span></span><br><span class="line"><span class="comment">template&lt;class T&gt; bool less_equal&lt;T&gt; //小于等于</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内建函数对象——关系仿函数</span></span><br><span class="line"><span class="comment">// 大于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyCompare</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T val1, T val2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val1 &gt; val2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::const_iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Print</span>(v);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());   <span class="comment">// 从小到大的顺序</span></span><br><span class="line">    <span class="built_in">Print</span>(v);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从大到小的顺序，这里使用的是自己实现的 模板 类型数据的</span></span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">MyCompare</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    <span class="built_in">Print</span>(v);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用</span></span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    <span class="built_in">Print</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong> 关系仿函数中最常用的就是greater&lt;&gt;大于</p>
<h4 id="逻辑仿函数"><a href="#逻辑仿函数" class="headerlink" title="逻辑仿函数"></a>逻辑仿函数</h4><p><strong>功能描述：</strong> </p>
<ul>
<li>实现逻辑运算</li>
</ul>
<p><strong>函数原型：</strong> </p>
<ul>
<li>template<class T> bool logical_and<T> //逻辑与</li>
<li>template<class T> bool logical_or<T> //逻辑或</li>
<li>template<class T> bool logical_not<T> //逻辑非</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">仿函数原型：</span></span><br><span class="line"><span class="comment">template&lt;class T&gt; bool logical_and&lt;T&gt; //逻辑与</span></span><br><span class="line"><span class="comment">template&lt;class T&gt; bool logical_or&lt;T&gt; //逻辑或</span></span><br><span class="line"><span class="comment">template&lt;class T&gt; bool logical_not&lt;T&gt; //逻辑非</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">bool</span>&gt; &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(vector&lt;<span class="type">bool</span>&gt;::const_iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;   <span class="comment">// 只支持内置数据类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt; v;</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="literal">true</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="literal">false</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="literal">true</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Print</span>(v);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逻辑非   将容器 v 搬运到 v2中， 并执行逻辑非操作</span></span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt; v2;</span><br><span class="line">    v2.<span class="built_in">resize</span>(v.<span class="built_in">size</span>());</span><br><span class="line">    <span class="built_in">transform</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), <span class="built_in">logical_not</span>&lt;<span class="type">bool</span>&gt;());</span><br><span class="line">    <span class="built_in">Print</span>(v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong> 逻辑仿函数实际应用较少，了解即可</p>
<h2 id="STL-–-常用算法"><a href="#STL-–-常用算法" class="headerlink" title="STL – 常用算法"></a>STL – 常用算法</h2><p><strong>概述:</strong> </p>
<ul>
<li>算法主要是由头文件 <algorithm> <functional> <numeric> 组成。</li>
<li><algorithm> 是所有STL头文件中最大的一个，范围涉及到比较、 交换、查找、遍历操作、复制、修改等等</li>
<li><numeric> 体积很小，只包括几个在序列上面进行简单数学运算的模板函数</li>
<li><functional> 定义了一些模板类,用以声明函数对象。</li>
</ul>
<h3 id="常用遍历算法"><a href="#常用遍历算法" class="headerlink" title="常用遍历算法"></a>常用遍历算法</h3><p><strong>学习目标：</strong> </p>
<ul>
<li>掌握常用的遍历算法</li>
</ul>
<p><strong>算法简介：</strong> </p>
<ul>
<li>for_each(iterator beg, iterator end, _func);  //遍历容器</li>
<li>transform(iterator beg1, iterator end1, iterator beg2, _func);  //搬运容器到另一个容器中</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for_each(iterator beg, iterator end, _func);</span></span><br><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print01</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数对象</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Print02</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for_each() 基本用法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v = &#123; <span class="number">10</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span> &#125;;     <span class="comment">// 列表初始化</span></span><br><span class="line"></span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), Print01);  <span class="comment">// // 可能是为了区分匿名对象和普通函数，这里的函数调用不需要加括号</span></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">Print02</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常用遍历算法，搬运 transform()</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Transform</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Print</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        v.<span class="built_in">push_back</span>(i);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vTarget;</span><br><span class="line">    <span class="comment">// 预先分配空间</span></span><br><span class="line">    vTarget.<span class="built_in">resize</span>(v.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">transform</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>(), <span class="built_in">Transform</span>());    <span class="comment">// 将 v 中数据复制到 vTarget</span></span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">Print</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    for_each(vTarget.<span class="built_in">begin</span>(), vTarget.<span class="built_in">end</span>(), <span class="built_in">Print</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// for_each(iterator beg, iterator end, _func);</span></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// transform(iterator beg1, iterator end1, iterator beg2, _func);</span></span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**总结： ** </p>
<ul>
<li>for_each在实际开发中是最常用遍历算法，需要熟练掌握</li>
<li>搬运的目标容器必须要提前开辟空间，否则无法正常搬运</li>
</ul>
<h3 id="常用查找算法"><a href="#常用查找算法" class="headerlink" title="常用查找算法"></a>常用查找算法</h3><p><strong>学习目标：</strong> </p>
<ul>
<li>掌握常用的查找算法</li>
</ul>
<p><strong>算法简介：</strong></p>
<ul>
<li>查找具体元素，找到则返回该元素的第一个位置，找不到则返回end()：find(iterator beg, iterator end, value);</li>
<li>查找满足条件的元素，找到则返回该元素的第一个位置，找不到则返回end()：find_if(iterator beg, iterator end, _Pred);</li>
<li>查找相邻重复元素：adjacent_find(iterator beg, iterator end); 返回两个中靠前的那个</li>
<li>二分查找：bool binary_search(iterator beg, iterator end, value);</li>
<li>// count(iterator beg, iterator end, value);    </li>
<li>// 用于自定义数据类型的案例比较简单，差别在于查找的元素类型，还需要重载 == 运算符，不再写。</li>
<li>统计满足条件的元素的个数：count_if(iterator beg, iterator end, _Pred);</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">iterator beg    初始位置迭代器</span></span><br><span class="line"><span class="comment">iterator end    末尾位置迭代器</span></span><br><span class="line"><span class="comment">_Pred   谓词</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找具体元素：find(iterator beg, iterator end, value);</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        v.<span class="built_in">push_back</span>(i+<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找容器中是否有 5 </span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::const_iterator pos = <span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span>(pos == v.<span class="built_in">end</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;查无此项&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;找到了&quot;</span> &lt;&lt; *pos &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 友元</span></span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, <span class="type">const</span> Person *p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造</span></span><br><span class="line">    <span class="built_in">Person</span>() &#123; &#125;</span><br><span class="line">    <span class="built_in">Person</span>(string name, <span class="type">int</span> age) : <span class="built_in">Name</span>(name), <span class="built_in">Age</span>(age) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Person &amp;p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;Name == p.Name &amp;&amp; <span class="keyword">this</span>-&gt;Age == p.Age)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    string Name;</span><br><span class="line">    <span class="type">int</span> Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, <span class="type">const</span> Person &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; p.Name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p.Age &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建数据</span></span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span>, <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">15</span>)</span>, <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">20</span>)</span>, <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 放进 vector</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p4);</span><br><span class="line"></span><br><span class="line">    vector&lt;Person&gt;::const_iterator pos = <span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), p2);</span><br><span class="line">    <span class="keyword">if</span>(pos == v.<span class="built_in">end</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;查无此项&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;找到了&quot;</span> &lt;&lt; *pos &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找满足条件的第一个元素：find_if(iterator beg, iterator end, _Pred);</span></span><br><span class="line"><span class="comment">// 内置数据类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GreaterThanFive</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val &gt; <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        v.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 需要一个一元谓词</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::const_iterator pos = <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">GreaterThanFive</span>());</span><br><span class="line">    <span class="keyword">if</span>(pos == v.<span class="built_in">end</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;查无此项&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span>    </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;找到了：&quot;</span> &lt;&lt; *pos &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义数据类型，这部分不需要重载 == 运算符</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">OlderThan20</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Person &amp;p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p.Age &gt; <span class="number">20</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test04</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建数据</span></span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">15</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 放进 vector</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p4);</span><br><span class="line"></span><br><span class="line">    vector&lt;Person&gt;::const_iterator pos = <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">OlderThan20</span>());</span><br><span class="line">    <span class="keyword">if</span>(pos == v.<span class="built_in">end</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;查无此项&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;找到了：&quot;</span> &lt;&lt; *pos &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找相邻重复元素：adjacent_find(iterator beg, iterator end); 返回两个中靠前的那个</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test05</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::const_iterator pos = <span class="built_in">adjacent_find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">if</span>(pos == v.<span class="built_in">end</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;查无此项&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;找到了：&quot;</span> &lt;&lt; *pos &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分查找：bool binary_search(iterator beg, iterator end, value);</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test06</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        v.<span class="built_in">push_back</span>(i);</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> ret = <span class="built_in">binary_search</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;在序列中找到了目标元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;查无此项&quot;</span> &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// count(iterator beg, iterator end, value);    </span></span><br><span class="line"><span class="comment">// 用于自定义数据类型的案例比较简单，差别在于查找的元素类型，还需要重载 == 运算符，不再写。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test07</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = <span class="built_in">count</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;num of 4 = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 统计满足条件的元素的个数：count_if(iterator beg, iterator end, _Pred);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GreaterThan4</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val &gt; <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test08</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">7</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = <span class="built_in">count_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">GreaterThan4</span>());</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;比4大的数有：&quot;</span> &lt;&lt; num &lt;&lt; <span class="string">&quot;个&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义数据类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">YoungerThan35</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Person &amp;p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p.Age &lt; <span class="number">35</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test09</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备数据</span></span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">35</span>)</span>, <span class="title">p2</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">35</span>)</span>, <span class="title">p3</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">35</span>)</span>, <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">25</span>)</span>, <span class="title">p5</span><span class="params">(<span class="string">&quot;小乔&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 放进 vector</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p4);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p5);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = <span class="built_in">count_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">YoungerThan35</span>());</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;列表中年龄小于35岁的有：&quot;</span> &lt;&lt; num &lt;&lt; <span class="string">&quot;个&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// find(iterator beg, iterator end, value);</span></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find_if(iterator beg, iterator end, _Pred);</span></span><br><span class="line">    <span class="built_in">test03</span>();</span><br><span class="line">    <span class="built_in">test04</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// adjacent_find(iterator beg, iterator end);</span></span><br><span class="line">    <span class="built_in">test05</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二分查找指定元素是否存在：bool binary_search(iterator beg, iterator end, value); 不可用于无序序列</span></span><br><span class="line">    <span class="built_in">test06</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// count(iterator beg, iterator end, value);</span></span><br><span class="line">    <span class="built_in">test07</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// count_if(iterator beg, iterator end, _Pred);</span></span><br><span class="line">    <span class="built_in">test08</span>();</span><br><span class="line">    <span class="built_in">test09</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong> </p>
<ul>
<li>利用find可以在容器中找指定的元素，返回值是迭代器</li>
<li>find_if按条件查找使查找更加灵活，提供的仿函数可以改变不同的策略</li>
<li>面试题中如果出现查找相邻重复元素，记得用STL中的adjacent_find算法</li>
<li>二分查找法查找效率很高，值得注意的是查找的容器中元素必须的有序序列</li>
</ul>
<ul>
<li>按值统计用count，按条件统计用count_if</li>
</ul>
<h3 id="常用排序算法"><a href="#常用排序算法" class="headerlink" title="常用排序算法"></a>常用排序算法</h3><p><strong>学习目标：</strong> </p>
<ul>
<li>掌握常用的排序算法</li>
</ul>
<p><strong>算法简介：</strong> </p>
<ul>
<li>排序：sort(iterator beg, iterator end, _Pred);   // 默认从小到大</li>
<li>洗牌：random_shuffle(iterator beg, iterator end);</li>
<li>合并容器：merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</li>
<li>反转：reverse(iterator beg, iterator end);</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 排序：sort(iterator beg, iterator end, _Pred);   // 默认从小到大</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::const_iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Descending</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val1, <span class="type">int</span> val2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val1 &gt; val2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v = &#123; <span class="number">10</span>, <span class="number">30</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">20</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sort 默认 升序</span></span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Print</span>(v);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 降序</span></span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">Descending</span>());</span><br><span class="line">    <span class="built_in">Print</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 洗牌：random_shuffle(iterator beg, iterator end);</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>((<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        v.<span class="built_in">push_back</span>(i);</span><br><span class="line"></span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">MyPrint</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打乱顺序</span></span><br><span class="line">    <span class="comment">// random_shuffle(v.begin(), v.end()); // 在 VS 里没问题</span></span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">MyPrint</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 3 8 5 2 1 7 0 9 4 6</span></span><br><span class="line">    <span class="comment">// 5 3 9 8 0 7 2 6 1 4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并容器：merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v1, v2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">        v2.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vTarget;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目标容器需要提前开辟空间</span></span><br><span class="line">    vTarget.<span class="built_in">resize</span>(v1.<span class="built_in">size</span>() + v2.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并 需要两个有序序列</span></span><br><span class="line">    <span class="built_in">sort</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">sort</span>(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">merge</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(),vTarget.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">    for_each(vTarget.<span class="built_in">begin</span>(), vTarget.<span class="built_in">end</span>(), <span class="built_in">MyPrint</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 翻转：reverse(iterator beg, iterator end);</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test04</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v = &#123; <span class="number">10</span>, <span class="number">30</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">20</span> &#125;;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;翻转前：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">MyPrint</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;翻转后：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">reverse</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">MyPrint</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// sort(iterator beg, iterator end, _Pred);</span></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// random_shuffle(iterator beg, iterator end);</span></span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</span></span><br><span class="line">    <span class="built_in">test03</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reverse(iterator beg, iterator end);</span></span><br><span class="line">    <span class="built_in">test04</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong> </p>
<ul>
<li>sort属于开发中最常用的算法之一，需熟练掌握</li>
<li>random_shuffle洗牌算法比较实用，使用时记得加随机数种子</li>
<li>merge合并的两个容器必须是有序序列</li>
<li>reverse反转区间内元素，面试题可能涉及到</li>
</ul>
<h3 id="常用拷贝和替换算法"><a href="#常用拷贝和替换算法" class="headerlink" title="常用拷贝和替换算法"></a>常用拷贝和替换算法</h3><p><strong>学习目标：</strong> </p>
<ul>
<li>掌握常用的拷贝和替换算法</li>
</ul>
<p><strong>算法简介：</strong> </p>
<ul>
<li>copy(iterator beg, iterator end, iterator dest);  // 容器内指定范围的元素拷贝到另一容器中</li>
<li>replace(iterator beg, iterator end, oldvalue, newvalue);  // 将容器内指定范围的旧元素修改为新元素</li>
<li>replace_if(iterator beg, iterator end, _pred, newvalue); // 按条件替换元素，满足条件的替换成指定元素</li>
<li>swap(container c1, container c2);  // 互换两个容器的元素</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyPrint</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// copy(iterator beg, iterator end, iterator dest);</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v1, v2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">    </span><br><span class="line">    v2.<span class="built_in">resize</span>(v1.<span class="built_in">size</span>());   <span class="comment">// 提前申请空间</span></span><br><span class="line">    <span class="built_in">copy</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">    for_each(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), <span class="built_in">MyPrint</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v = &#123; <span class="number">20</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">10</span>, <span class="number">20</span> &#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;替换前：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">MyPrint</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将容器中的 20 替换成 2000</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;替换后：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">replace</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">20</span>, <span class="number">2000</span>);</span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">MyPrint</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// replace_if(iterator beg, iterator end, _pred, newvalue);</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Greater_equal30</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val &gt; <span class="number">30</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v = &#123; <span class="number">20</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">10</span>, <span class="number">20</span> &#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;替换前：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">MyPrint</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将容器中 大于等于 30 的数 替换成 3000</span></span><br><span class="line">    <span class="built_in">replace_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">Greater_equal30</span>(), <span class="number">3000</span>);</span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">MyPrint</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// swap(container c1, container c2);</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test04</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v1, v2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        v1.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">        v2.<span class="built_in">push_back</span>(i + <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;交换前：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    for_each(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), <span class="built_in">MyPrint</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    for_each(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), <span class="built_in">MyPrint</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">swap</span>(v1, v2);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;交换后：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    for_each(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), <span class="built_in">MyPrint</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    for_each(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), <span class="built_in">MyPrint</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// copy(iterator beg, iterator end, iterator dest);</span></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// replace(iterator beg, iterator end, oldvalue, newvalue);</span></span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// replace_if(iterator beg, iterator end, _pred, newvalue);</span></span><br><span class="line">    <span class="built_in">test03</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// swap(container c1, container c2);</span></span><br><span class="line">    <span class="built_in">test04</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong> </p>
<ul>
<li>利用copy算法在拷贝时，目标容器记得提前开辟空间</li>
<li>replace会替换区间内满足条件的元素</li>
<li>replace_if按条件查找，可以利用仿函数灵活筛选满足的条件</li>
</ul>
<h3 id="常用算术生成算法"><a href="#常用算术生成算法" class="headerlink" title="常用算术生成算法"></a>常用算术生成算法</h3><p><strong>学习目标：</strong> </p>
<ul>
<li>掌握常用的算术生成算法</li>
</ul>
<p><strong>注意：</strong> </p>
<ul>
<li>算术生成算法属于小型算法，使用时包含的头文件为 #include <numeric></li>
</ul>
<p><strong>算法简介：</strong></p>
<ul>
<li>accumulate(iterator beg, iterator end, value);   // 计算容器元素累计总和</li>
<li>fill(iterator beg, iterator end, value);    向容器中添加元素 </li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// accumulate(iterator beg, iterator end, value);</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++)</span><br><span class="line">        v.<span class="built_in">push_back</span>(i);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第三个参数是 算术运算开始前 total 的初始值</span></span><br><span class="line">    <span class="type">int</span> total = <span class="built_in">accumulate</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;total = &quot;</span> &lt;&lt; total &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fill(iterator beg, iterator end, value);</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyPrint</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line">    v.<span class="built_in">resize</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fill</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">MyPrint</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// accumulate(iterator beg, iterator end, value);</span></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fill(iterator beg, iterator end, value);</span></span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong> </p>
<ul>
<li><p>accumulate使用时头文件注意是 numeric，这个算法很实用</p>
</li>
<li><p>利用fill可以将容器区间内元素填充为 指定的值</p>
</li>
</ul>
<h3 id="常用集合算法"><a href="#常用集合算法" class="headerlink" title="常用集合算法"></a>常用集合算法</h3><p><strong>学习目标：</strong> </p>
<ul>
<li>掌握常用的集合算法</li>
</ul>
<p><strong>算法简介：</strong> </p>
<ul>
<li>set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);    // 求两个集合的交集</li>
<li>set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);    // 求两个集合的并集</li>
<li>set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);    // 求两个集合的差集</li>
<li><strong>注意:两个集合必须是有序序列</strong> </li>
</ul>
<p><strong>总结：</strong> </p>
<ul>
<li>使用集合算法的前提是两个目标集合必须是有序集合；</li>
<li>求交集时，vTarget.resize(min(v1.size(),v2.size()))，求并集时，vTarget.resize(v1.size() + v2.size())，求差集时，vTarget.resize(max(v1.size(), v2.size()))；</li>
<li>常用集合算法的返回值都是结果中最后一个元素的位置。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyPrint</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交集：set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v1, v2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">        v2.<span class="built_in">push_back</span>(i + <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vTarget;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取两个 容器中容量最小的那个 为基准开辟空间</span></span><br><span class="line">    v1.<span class="built_in">size</span>() &gt; v2.<span class="built_in">size</span>() ? vTarget.<span class="built_in">resize</span>(v2.<span class="built_in">size</span>()): vTarget.<span class="built_in">resize</span>(v1.<span class="built_in">size</span>());</span><br><span class="line">    <span class="comment">// vTarget(min(v1.size(), v2.size()));</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回目标容器的最后一个元素的迭代器地址，这里其实不需要接收迭代器</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::const_iterator itEnd = </span><br><span class="line">            <span class="built_in">set_intersection</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line">    for_each(vTarget.<span class="built_in">begin</span>(), vTarget.<span class="built_in">end</span>(), <span class="built_in">MyPrint</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并集：set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v1, v2, vTarget;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">        v2.<span class="built_in">push_back</span>(i + <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取两容器容量之和给目标容器开辟空间</span></span><br><span class="line">    vTarget.<span class="built_in">resize</span>(v1.<span class="built_in">size</span>() + v2.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回目标容器的最后一个元素的迭代器地址，这里其实也不需要接收迭代器</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::const_iterator itEnd = </span><br><span class="line">            <span class="built_in">set_union</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line">    for_each(vTarget.<span class="built_in">begin</span>(), vTarget.<span class="built_in">end</span>(), <span class="built_in">MyPrint</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v1, v2, vTarget;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">        v2.<span class="built_in">push_back</span>(i + <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取两个容器中容量较大的那个为基准开辟空间</span></span><br><span class="line">    <span class="comment">// vTarget.resize(max(v1.size(), v2.size()));</span></span><br><span class="line">    v1.<span class="built_in">size</span>() &gt; v2.<span class="built_in">size</span>() ? vTarget.<span class="built_in">resize</span>(v1.<span class="built_in">size</span>()) : vTarget.<span class="built_in">resize</span>(v2.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回目标容器的最后一个元素的迭代器地址，这里其实还是不需要接收迭代器</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::const_iterator itEnd =</span><br><span class="line">            <span class="built_in">set_difference</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v1 与 v2 的差集：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    for_each(vTarget.<span class="built_in">begin</span>(), vTarget.<span class="built_in">end</span>(), <span class="built_in">MyPrint</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    itEnd = <span class="built_in">set_difference</span>(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v2 与 v1 的差集：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    for_each(vTarget.<span class="built_in">begin</span>(), vTarget.<span class="built_in">end</span>(), <span class="built_in">MyPrint</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</span></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</span></span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</span></span><br><span class="line">    <span class="built_in">test03</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="输出、输出和文件"><a href="#输出、输出和文件" class="headerlink" title="输出、输出和文件"></a>输出、输出和文件</h2><p>目前为止，接触得最多的是cin和cout对象，但是对于iostream中定义的输入方法以及输出格式化等相关内容现有涉猎，因此，这一张便是为了细细揣摩C++中输入输出流的一些内容</p>
<h3 id="流和缓冲区"><a href="#流和缓冲区" class="headerlink" title="流和缓冲区"></a>流和缓冲区</h3><p>C++程序将输入和输出看作字节流。输入时，程序从输入流中截取字节；输出时，将字节插入到输出流中。对面向文本的程序，每个字节代表一个字符，更通俗的说，字节可以构成字符或数字数据的二进制表示。C++程序只是检查字节流，而不需要知道字节来自何方。同理，通过使用流，C++程序处理输出的方式将独立于其去向。因此，管理输入包含两步：</p>
<ul>
<li>将流与输入去向的程序关联起来</li>
<li>将流与文件连接</li>
</ul>
<p>就像灌溉农田时，需要使用管道将水原与稻田连接。通常，通过缓冲区可以更高效地处理输入和输出。缓冲区是用做中介的内存块，它是将信息从设备传输到程序或者反过程的临时存储工具。缓冲区的大小一般为512个字节或者这个数据的整数倍。每次输出时都会刷新输出缓冲区，以备下一批输出使用。</p>
<p>定义在iostream中专门设计用来实现管理流和缓冲区的类</p>
<table>
<thead>
<tr>
<th>类</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>streambuf</td>
<td>为缓冲区提供方法，并提供了用于填充缓冲区、访问缓冲区内容、刷新缓冲区和管理缓冲区的类方法</td>
</tr>
<tr>
<td>ios_base</td>
<td>表示流的一般特征，如是否可读取、是二进制还是文本流等</td>
</tr>
<tr>
<td>ios</td>
<td>基于ios_base，其中包含一个指向streambuf对象的指针成员</td>
</tr>
<tr>
<td>ostream</td>
<td>从ios类派生而来的，提供输出方法</td>
</tr>
<tr>
<td>istream</td>
<td>从ios类派生而来，提供输入方法</td>
</tr>
<tr>
<td>iostream</td>
<td>基于istream和ostream类，继承了输入和输出方法</td>
</tr>
</tbody></table>
<ul>
<li>cin对象对应标准输入流。在默认情况下，这个流被关联到标准输入设备（一般为键盘），wcin对象与此类似但处理的是wchar_t类型</li>
<li>cout对象与输出标准流对应。在默认情况下，这个流被关联到标准输出设备（一般为显示器），wcout对象与此类似，但处理的是wchar_t类型</li>
<li>cerr对象与标准错误流相对应，可用于显示错误消息。默认被关联到标准输出设备。没有缓冲，wcerr对象与此类似但处理的是wchar_t类型</li>
<li>clog对象也对应标准错误流，默认标准输出设备。wclog对象与此类似，但处理的是wchar_t类型</li>
<li>对象代表流iostream文件为程序声明一个cout对象时，该对象包含存储了与输出有关的信息的数据成员</li>
</ul>
<h3 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h3><p>没怎么看懂</p>
<h3 id="关于输出"><a href="#关于输出" class="headerlink" title="关于输出"></a>关于输出</h3><p>ostream中重新定义的 &lt;&lt; 运算符称为 插入运算符，而不是左移运算符。插入运算符被重载使得 &lt;&lt; 能够识别C++中所有基本数据类型。<br>另外，由于插入运算符重载函数的返回值是 ostream&amp; 即输出流的引用，使得输出可以连续起来，被称为链式编程。</p>
<p><strong>其他ostream方法</strong><br>除了各种 operator&lt;&lt;() 函数外，ostream类还提供了put()方法和write()方法前者用于显示字符，后者用于显示字符串。<br>我觉得put()方法的参数应当为 int 或者 是一个字符型，即传入浮点型会发生窄化转换，向下取整。</p>
<p>write()方法传入一个字符串以及一个整型数据，表示输出该字符串中的前多少个字符，该方法不会在遇到空字符串时停止打印，而是一定会打印指定数目的字符。</p>
<p><strong>刷新输出缓冲区</strong><br><code>cout &lt;&lt; endl;</code> 会将缓冲区的内容显示到显示器，在最后添加换行符并刷新缓冲区。<br>或者使用其他刷新方式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">flush</span>(cout);</span><br><span class="line">cout &lt;&lt; flush;</span><br></pre></td></tr></table></figure>

<p><strong>使用cout进行格式化</strong><br>对于浮点数，默认被显示为六位，末尾0不显示（显示的数字位数与数字被存储时的位数没有任何关系，党支书大于等于6或者小于等于-5时，将使用科学计数法表示数字。另外，字段宽度恰好容纳数字和负号（如果有的话）</p>
<p>控制进制：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; hex;</span><br><span class="line">cout &lt;&lt; dec;</span><br><span class="line">cout &lt;&lt; oct;</span><br></pre></td></tr></table></figure>

<p>控制字段宽度：</p>
<p><code>cout.width(12);</code> 设置字段宽度为12，默认右对齐。注意width()方法成员函数，必须使用对象（这里是cout）来调用它。并且在输出一个“项目”之后，字符宽度恢复为默认值。<br>C++不会截断数据，在数据位数大于位宽时，会自动提升位宽。</p>
<p><strong>填充字符</strong><br><code>cout.fill(&#39;*&#39;);</code> 将字段中未使用的部分填充为’*’。新填充的内容将一直有效，直到被更改。</p>
<p><strong>设置浮点数的显示精度</strong><br>浮点数京都的含义取决于输出模式。在默认模式下，指的是显示的总位数，即<code>cout.precision(2);</code> 是将显示的总位数设置为2，而不是保留两位小数。精度设置之后，将一直有效直到被修改。</p>
<p><strong>打印末尾的和小数点</strong><br><code>cout.setf(ios_base::showpoint);</code> 默认精度为6位。</p>
<p><strong>再谈setf</strong> </p>
<table>
<thead>
<tr>
<th>常量</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ios_base::boolalpha</td>
<td>输入和输出bool值。可以为true或false</td>
</tr>
<tr>
<td>ios_base::showbase</td>
<td>对于输出，使用C++基数前缀（0，0x）</td>
</tr>
<tr>
<td>ios_base::showpoint</td>
<td>显示末尾小数点</td>
</tr>
<tr>
<td>ios_base::uppercase</td>
<td>对于十六进制，使用大写字母E，表示法</td>
</tr>
<tr>
<td>ios_base::showpos</td>
<td>显示正号</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>第二个参数</th>
<th>第一个参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ioos_base::basefield</td>
<td>ios_base::dec</td>
<td>使用基数10</td>
</tr>
<tr>
<td></td>
<td>ios_base::oct</td>
<td>使用基数8</td>
</tr>
<tr>
<td></td>
<td>ios_base::hex</td>
<td>使用基数16</td>
</tr>
<tr>
<td>ios_base::floatfield</td>
<td>ios_base::fixed</td>
<td>定点计数法</td>
</tr>
<tr>
<td></td>
<td>ios_base::scientific</td>
<td>科学计数法</td>
</tr>
<tr>
<td>ios_base::adjustfield</td>
<td>ios_base::left</td>
<td>左对齐</td>
</tr>
<tr>
<td></td>
<td>ios_base::right</td>
<td>右对齐</td>
</tr>
<tr>
<td></td>
<td>ios_base::internal</td>
<td>符号或基数前缀左对齐，值右对齐</td>
</tr>
</tbody></table>
<p><strong>标准控制符</strong><br>使用setf不是进行格式化的、对用户最友好的方式。C++提供了多个控制符，能够调用setf（），不能改自动提供正确的参数。<br><code>cout &lt;&lt; left &lt;&lt; fixed;</code><br>左对齐、定点小数模式</p>
<p><strong>iomanip头文件</strong><br>使用iostream工具来设置一些格式值（如字段宽度，每次使用都要着重新设置），为了简化工作，C++在iomanip头文件中提供了其他一些口感支付，能够提供前面讨论过的功能，而且使用起来更为方便。</p>
<ul>
<li>setprecisio()、stefill(char)和stew()，分别用于设置精度、填充字符和设置字段宽度。</li>
</ul>
<p><code>cout &lt;&lt; stew(6) &lt;&lt; setprecision(4) &lt;&lt; setfill(&#39;.&#39;);</code> </p>
<p>​                                                                                                     <font size=3 color=red>一些标准控制符：</font></p>
<table>
<thead>
<tr>
<th>操纵符</th>
<th>调用</th>
<th>操纵符</th>
<th>调用</th>
</tr>
</thead>
<tbody><tr>
<td>boolalpha</td>
<td>setf(ios_base::boolalpha)</td>
<td>nouppercase</td>
<td>unsetf(ios_base::nouppercase)</td>
</tr>
<tr>
<td>noboolalpha</td>
<td>unsetf(ios_base::noboolalpha)</td>
<td>iternal</td>
<td>setf(ios_base::iternal, ios_base::adjustfield)</td>
</tr>
<tr>
<td>showbase</td>
<td>setf(ios_base::showbase</td>
<td>left</td>
<td>setf(ios_base::left, ios_base::adjustfield)</td>
</tr>
<tr>
<td>noshowbase</td>
<td>unsetf(ios_base::showbase)</td>
<td>right</td>
<td>setf(ios_base::right, ios_base::adjustfield)</td>
</tr>
<tr>
<td>showpoint</td>
<td>setf(ios_base::showpoint)</td>
<td>dec</td>
<td>setf(ios-base::dec, ios_base::basefield)</td>
</tr>
<tr>
<td>noshowpoint</td>
<td>unsetf(ios_base::showpoint)</td>
<td>hex</td>
<td>set(ios_base::hex,ios_base::basefield)</td>
</tr>
<tr>
<td>showpos</td>
<td>setf(ios_base::showpos)</td>
<td>oct</td>
<td>stf(ios_base::oct, ios_base::oct)</td>
</tr>
<tr>
<td>unshowpos</td>
<td>unsetf(ios_base::showpos)</td>
<td>fixed</td>
<td>setf(ios_base::fixed,ios_base::floatfield)</td>
</tr>
<tr>
<td>uppercase</td>
<td>setf(ios_base::uppercase)</td>
<td>scientific</td>
<td>setf(ios_base::scientific, ios_base::floatfield)</td>
</tr>
</tbody></table>
<p>​                                                                                           <font size=3 color=red>格式方面的变化</font> </p>
<table>
<thead>
<tr>
<th>特性</th>
<th>老式C++</th>
<th>当前C++</th>
</tr>
</thead>
<tbody><tr>
<td>precision(n)</td>
<td>显示n位小数</td>
<td>在默认模式下，显示的总位数为n，在定点数模式和科学技术模式下，显示n位小数</td>
</tr>
<tr>
<td>ios_base::showpoint</td>
<td>显示末尾的小数点和末尾的0</td>
<td>显示末尾的小数点</td>
</tr>
<tr>
<td>ios_base::fixed,ios::base::scientific</td>
<td></td>
<td>显示末尾的0（参见关于precision的说明）</td>
</tr>
</tbody></table>
<h3 id="关于输入"><a href="#关于输入" class="headerlink" title="关于输入"></a>关于输入</h3><p>​                                                                                                    <font size=3 color=red>流状态</font></p>
<table>
<thead>
<tr>
<th>成员</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>eofbit</td>
<td>如果达到文件尾则设置为1</td>
</tr>
<tr>
<td>badbit</td>
<td>流被破坏时设置为1，例如：文件读取错误</td>
</tr>
<tr>
<td>failbit</td>
<td>输入操作未能读取预期的字符或输出操作没有写入预期的字符，则设置为1</td>
</tr>
<tr>
<td>goodbit</td>
<td>另一种表示0的方法</td>
</tr>
<tr>
<td>good()</td>
<td>如果流可以使用（所有的位置都被清除），则返回true</td>
</tr>
<tr>
<td>eof()</td>
<td>如果eofbit被设置，则返回true</td>
</tr>
<tr>
<td>bad()</td>
<td>如果badbit被设置，则返回true</td>
</tr>
<tr>
<td>fail()</td>
<td>如果badbit或者failbit被设置，则返回true</td>
</tr>
<tr>
<td>rdstate()</td>
<td>返回流状态</td>
</tr>
<tr>
<td>exceptions()</td>
<td>返回一个掩码，指出哪些标记导致异常被触发</td>
</tr>
<tr>
<td>exceptions(iostate ex)</td>
<td>设置哪些状态将导致clear()引发异常，例如：如果ex时eofbit，则如果eofbit被设置，clear()将引发异常</td>
</tr>
<tr>
<td>clear(iostate s)</td>
<td>将流状态设置为s，s的默认值为0（goodbit）：如果（restate() &amp; exception()) != 0)，则将引发异常basic_ios::failure</td>
</tr>
<tr>
<td>setstate(iostate s)</td>
<td>调用clear(rdstate() | s)。这将设置与s中位置的为相对应的流状态位，其他流状态位保持不变</td>
</tr>
</tbody></table>
<p>重新设置流状态的理由：最常见的理由是，在输入不匹配或者达到文件尾时，需要使用不带参的clear()重新打开输入。</p>
<p><strong>I/O异常</strong><br>主要说使用exceptions()函数，默认值为goodbit，即没有触发异常，如果设置为其他状态，则在输入流被置为相同状态时会触发异常，函数中可以使用按位或来设置两种状态。</p>
<p>设置状态位有一个严重的后果，在流状态为eofbit或者faibit时，无法读取流中数据，必须将流状态设置为良好，可以使用不带参的clear()。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (cin &gt;&gt; input)</span><br><span class="line">    sum += input;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Last value entered = &quot;</span> &lt;&lt; input &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Sum = &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (cin.<span class="built_in">fail</span>() &amp;&amp; !cin.<span class="built_in">eof</span>())</span><br><span class="line">&#123;</span><br><span class="line">    cin.<span class="built_in">clear</span>();    <span class="comment">// fail not eof</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isspace</span>(cin.<span class="built_in">get</span>())) </span><br><span class="line">        <span class="keyword">continue</span>;   <span class="comment">// throw away &quot;bad input&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>    <span class="comment">// else failure</span></span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;I cannot go on!\n&quot;</span>;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Now enter a new number: &quot;</span>;</span><br><span class="line">cin &gt;&gt; input;   <span class="comment">// works</span></span><br></pre></td></tr></table></figure>

<p><strong>其他输入方法</strong> </p>
<ol>
<li>单字符输入 <code>cin.get(char &amp;ch);</code> 可以获取空格（空白字符），直接使用<code>cin &gt;&gt;</code> 则达不到目的，而且除非输入类型不匹配才会停止输入。cin.get(char &amp;ch)不会将eof赋给ch，还将调用setstate(failbit)，导致cin的测试结果为false。<br> <code>get(void)</code> 将返回一个int或更大的整型，可以将其赋给char类型数据，但是不允许链式输入。</li>
</ol>
<table>
<thead>
<tr>
<th>特征</th>
<th>cin.get(ch)</th>
<th>ch = cin.get()</th>
</tr>
</thead>
<tbody><tr>
<td>传输输入字符的方法</td>
<td>赋给默认参数ch</td>
<td>将函数返回值赋给ch</td>
</tr>
<tr>
<td>字符输入时函数的返回值</td>
<td>指向istream对象的引用</td>
<td>字符编码（int值）</td>
</tr>
<tr>
<td>到达文件尾是函数的返回值</td>
<td>转换为false</td>
<td>EOF</td>
</tr>
</tbody></table>
<ol start="2">
<li>采用哪种但字符输入形式<br> 如果希望检查每个字符，使用get()，其中，get(char &amp;)更佳，get(void)的优点是与C语言中getchar()函数极其类似，可以用来代替getchar()，并且使用cout.put()代替putchar()。</li>
<li>字符串输入<br> <code>getline()  // 丢弃流中分界字符</code><br> <code>get()  // 保留流中分界字符</code><br> <code>ignore()   // 第一个参数指定要读取的最大字符数默认为1，第二个字符用作分界字符默认为EOF，导致读取指定数目的字符或读取到文件尾，函数返回值为istream &amp;</code> </li>
<li>意外字符串输入<pre><code>  **输入行为**
</code></pre>
</li>
</ol>
<table>
<thead>
<tr>
<th>方法</th>
<th>行为</th>
</tr>
</thead>
<tbody><tr>
<td>getline(char *, int)</td>
<td>如果没有读取任何字符（但换行符被视为读取了一个字符），则设置failbit，如果读取了最大数目的字符，但行中还有其它字符，则设置failbit</td>
</tr>
<tr>
<td>get(char *, int)</td>
<td>如果没有读取任何字符，则设置failbit</td>
</tr>
</tbody></table>
<ol start="5">
<li>其他istream方法</li>
</ol>
<p>read()不会在输入后加上空值字符，因此不能将输入转换为字符串，最常与ostream&amp; write()结合使用，用于完成文件输入和输出。read()方法返回的是istream&amp;，所以有以下代码成立：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> gros[<span class="number">144</span>];</span><br><span class="line"><span class="type">char</span> score[<span class="number">20</span>];</span><br><span class="line">cin.<span class="built_in">read</span>(gross, <span class="number">144</span>).<span class="built_in">read</span>(score, <span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<p>peek()函数返回输入中的下一个字符，但不抽取输入流中的字符。也就是说“只看不取”，用于判断是否进行读取操作。</p>
<p>gcount()方法返回最后一个非格式化抽泣方法读取的字符数。意味着字符是使用get()、getline()、ignore()或read()方法读取的，而不是由**抽取运算符&lt;&lt;**读取的，抽取运算符对输入进行格式化，使之与特定的数据类型匹配。</p>
<p>putback()函数将一个字符插入到输入字符串中，被插入的字符将是下一条输入语句读取的第一个字符。接受一个char类型的参数，返回istream&amp;，说明可与其他istream方法拼接起来使用。peek()就相当于使用get()读取一个字符，然后使用putback()放回去。另外，putback()函数允许将字符放在不是上一次读取操作的位置。</p>
<h3 id="文件-1"><a href="#文件-1" class="headerlink" title="文件"></a>文件</h3><p><code>is_open()   // member function of ifstream</code> </p>
<p>用来判断是否成功打开了文件</p>
<h2 id="C-11"><a href="#C-11" class="headerlink" title="C ++ 11"></a>C ++ 11</h2><h3 id="新类型"><a href="#新类型" class="headerlink" title="新类型"></a>新类型</h3><p>C++11 新增了类型long long 和unsigned long long 以支持64位或更宽的整型；新增了char16_t和char32_t，以支持16位或32位的字符表示；还新增了“原始”字符串。</p>
<h3 id="统一的初始化"><a href="#统一的初始化" class="headerlink" title="统一的初始化"></a>统一的初始化</h3><p>使用大括号括起的列表（初始化列表）的适用范围，使其可以用于所有内置类型和用户自定义类型（即类对象）。使用初始化列表时，可以使用赋值运算符也可以不使用。</p>
<p><font size=3 color=5>列表初始化的语法也可用于new表达式中</font></p>
<p><font size=3 color=5>创建对象时，也可使用大括号（而不是圆括号）括起的列表来调用构造函数。</font></p>
<p><font size=3 color=5>如果类有将模板std::initializer_list作为参数的构造函数，则只有构造函数可任意使用初始化列表形式。</font></p>
<p><strong>使用新式初始化方法的优点</strong> </p>
<ul>
<li>防止窄化操作</li>
<li>STL容器提供了将initializer_list作为参数模板的构造函数，除此之外，还可以将std::initializer_list用作常规函数的参数</li>
</ul>
<h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><ol>
<li><h4 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h4></li>
</ol>
<p>C++11 将auto关键字用于实现自动类型推断。并要求显式初始化，让编译器能够变量的类型设置为初始值的类型。</p>
<p>可以简化模板声明（vector<int>::iterator）。</p>
<ol start="2">
<li><h4 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h4></li>
</ol>
<p>decltype关键字将变量的类型声明为表达式指定的类型。</p>
<p><code>decltype(x) y;    // 将y的类型设置为与x的一样</code> </p>
<p>功能比auto更复杂，根据使用的表达式，指定的类型可以是引用和const。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> j = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> &amp;k = j;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;n = j;</span><br><span class="line"><span class="keyword">decltype</span>(n) i1;	<span class="comment">// i1 type const int&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(j) i2;	<span class="comment">// i2 type int</span></span><br><span class="line"><span class="keyword">decltype</span>((j)) i3;	<span class="comment">// i3 type int&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(k + <span class="number">1</span>) i4;	<span class="comment">// i5 type int</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><h4 id="新增返回类型后置"><a href="#新增返回类型后置" class="headerlink" title="新增返回类型后置"></a>新增返回类型后置</h4></li>
</ol>
<p>C++11 新增了一种函数声明的语法：在函数名和参数列表后面（而不是前面）指定返回类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">f1</span><span class="params">(<span class="type">double</span>, <span class="type">int</span>)</span></span>;		<span class="comment">// traditional syntax</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f2</span><span class="params">(<span class="type">double</span>, <span class="type">int</span>)</span> -&gt; <span class="type">double</span></span>;		<span class="comment">// new syntax, return type is double</span></span><br></pre></td></tr></table></figure>

<p>这种语法使程序员使用decltype关键字来制定模板函数的返回类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ef</span><span class="params">(T t, U u)</span> -&gt; <span class="title">deltype</span><span class="params">(T * U)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// so something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里解决的问题是，在编译器遇到eff的参数列表前，T和U还不在作用域内，因此必须在参数列表后使用decltype。</p>
<p>可能是为了兼容lambda表达式</p>
<ol start="4">
<li><h4 id="模板别名"><a href="#模板别名" class="headerlink" title="模板别名"></a>模板别名</h4></li>
</ol>
<p>对于冗长或复杂的标识符，如果能够创建其别名将很方便。以前C++为此提供了typedef：</p>
<p><code>typedef std::vector&lt;std::string&gt;::iterator itType;</code> </p>
<p>C++11提供了另一种创建别名的语法：</p>
<p><code>using itType = std::vector&lt;std::string&gt;::iterator;</code> </p>
<p>差别在于，新语法有也可以用于模板部分具体化，但是typedef不能：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">using</span> arr12 = std::array&lt;T, <span class="number">12</span>&gt;;	<span class="comment">// template for multiple aliases</span></span><br></pre></td></tr></table></figure>

<p>上述语句具体化模板array&lt;T, int&gt; （将参数int设置为12）。则有下面语句成立：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr12&lt;<span class="type">double</span>&gt; a1;</span><br><span class="line">arr12&lt;std::string&gt; a2;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><h4 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a>nullptr</h4></li>
</ol>
<p>安全性更高的空指针。</p>
<h3 id="智能指针-1"><a href="#智能指针-1" class="headerlink" title="智能指针"></a>智能指针</h3><p>C++11摒弃了auto_ptr，并且所有新增的智能指针都可以与STL以及移动语义协同工作。</p>
<h3 id="异常方面做出的修改"><a href="#异常方面做出的修改" class="headerlink" title="异常方面做出的修改"></a>异常方面做出的修改</h3><p>新增noexcept关键字指出方法不会出现问题。</p>
<h3 id="作用域内枚举"><a href="#作用域内枚举" class="headerlink" title="作用域内枚举"></a>作用域内枚举</h3><p>传统的C++枚举类型提供了一种创建名称常量的方式，缺点：</p>
<ul>
<li>类型检查相当低级。</li>
<li>枚举名的作用域为枚举类型定义所属的作用域，这意味着如果在同一个作用域内定义两个枚举，他们的枚举成员不能同名。</li>
<li>枚举可能不是可完全移植的，因为不同的实现可能选择不同的底层类型。</li>
</ul>
<p>为解决这些问题，C++11新增一种使用class或者struct定义的枚举：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">old1</span> &#123; yes, no, maybe &#125;;;	<span class="comment">// traditional form</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">New1</span> &#123; never, sometimes, often, always &#125;;	<span class="comment">// new form</span></span><br><span class="line"><span class="keyword">enum struct</span> <span class="title class_">New2</span> &#123; never, lever, server &#125;;	<span class="comment">// new form</span></span><br></pre></td></tr></table></figure>

<p>新枚举类型要求显式限定，以免发生名称冲突。因此，引用特定枚举时，需要定义New1::never和New2::never等。</p>
<h3 id="对类的修改"><a href="#对类的修改" class="headerlink" title="对类的修改"></a>对类的修改</h3><ol>
<li><p>显式转换运算符</p>
<p> 自动类型转换可能导致意外转换的情况，为了解决这种问题，C++引入了explicit关键字，以禁止单参构造函数导致的自动转换：</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Plebe</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Plebe</span>()	&#123;&#125;	<span class="comment">// default constructor</span></span><br><span class="line">    <span class="built_in">Plebe</span>(<span class="type">int</span>);	<span class="comment">// automatic int-to-Plebe conversion</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Plebe</span><span class="params">(<span class="type">double</span>)</span></span>;	<span class="comment">// require explicit use</span></span><br><span class="line">    <span class="comment">// something else</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// something else</span></span><br><span class="line">Plebe a, b;</span><br><span class="line">a = <span class="number">5</span>;	<span class="comment">// implicit conversion call Plebe(5)</span></span><br><span class="line">b = <span class="number">0.5</span>;	<span class="comment">// forbiden with use of explicit</span></span><br><span class="line">b = <span class="built_in">Plebe</span>(<span class="number">0.5</span>);	<span class="comment">// 使用匿名对象进行赋值（注意new的使用）</span></span><br></pre></td></tr></table></figure>

<p> C++11拓展了explicit的这种用法，使得可对转换函数做类似的处理：</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Plebe</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// something </span></span><br><span class="line">    <span class="comment">// conversion functions</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">// something else</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// something else</span></span><br><span class="line">Plebe a, b;</span><br><span class="line"><span class="type">int</span> n = a;	<span class="comment">// int-to-PLebe automatic conversion</span></span><br><span class="line"><span class="type">double</span> x = b;	<span class="comment">// explicit makes it forbiden</span></span><br><span class="line">x = <span class="built_in">double</span>(b);	<span class="comment">// explicit conversion, allowed</span></span><br></pre></td></tr></table></figure></li>
<li><p>类内成员初始化</p>
</li>
</ol>
<p>可以在类内成员定义时使用赋值或大括号版本的初始化，但是不能使用圆括号版本的初始化。</p>
<p>可以使用传递参数覆盖默认参数。</p>
<ol start="3">
<li>模板和STL方面的修改</li>
</ol>
<ul>
<li>带范围的for循环；</li>
<li>新的STL容器（STL效率不高）</li>
</ul>
<p>​    forward_list、unordered_map、unordered_multimap、unordered_set、unordered_multiset。forward_list是一种单向链表，只能沿一个方向遍历；与list相比，更简单并且占用空间更小；</p>
<ul>
<li>新的STL方法（cbegin()、cend()返回指向容器的第一个元素和最后一个元素的迭代器。新方法视元素为const）；</li>
<li>valarray升级，添加两个函数（begin()、end()），都接受valarray作为参数，并返回迭代器，指向第一个元素和超尾元素；</li>
<li>摒弃export</li>
</ul>
<p>C++98新增export，旨在提供一种途径，让程序员能够将模板定义在接口文件和实现文件中，其中接口文件包含原型和模板声明，而实现文件包含模板函数方法和方法的定义。实践证明这并不现实，因此C++11终止这种用法并保留关键字export；</p>
<ul>
<li>尖括号（以前要求在使用嵌套模板时使用空格将结束时的尖括号隔开）</li>
</ul>
<h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><p>学习左值和右值主要是为了理解std::move()等一系列C++11之后的新语义。</p>
<ul>
<li>左值：<br>  即能出现在赋值号左边也能出现在赋值号右边的变量类型；<br>  左值是可寻址的变量，具有持久性。</li>
<li>右值<br>  只能出现在赋值号右边的变量类型，右值是不可寻址的变量（临时变量，匿名对象)，但是右值引用支持给临时变量位置分配一个名称，这种操作使得重复访问这块内存成为可能，并且将该内存变成一个对象。</li>
</ul>
<p>左值引用：<br>    常规方式声明的引用；<br>右值引用：<br>    与左值引用的声明方式相似但是使用的是两个&amp;&amp;符号，并且引用的是临时变量，比如：x * 6这种值又或者是没有赋值给某个变量的字符串（char *类型）。右值引用不能约束到左值上，比如使用右值引用的声明引用一个长期变量，并且，给一个临时变量以右值引用时，它就成了左值，不能再被另一个右值引用。</p>
<h3 id="移动语义与右值引用"><a href="#移动语义与右值引用" class="headerlink" title="移动语义与右值引用"></a>移动语义与右值引用</h3><p>C++11之前的复制过程：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; vstr;</span><br><span class="line"><span class="comment">// build up a vector fo 200,000 strings, each of 1000 characters</span></span><br><span class="line"><span class="comment">// something</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">vstr_copy1</span><span class="params">(vstr)</span></span>;	<span class="comment">// make vstr_copy1 a copy of vstr</span></span><br></pre></td></tr></table></figure>

<p>vstr 和 string 类都是用动态内存分配，因此它们必须定义使用某种new 版本复制构造函数。为初始化对象vstr_copy1，复制构造函数vector<string>将使用呢哇给20000个string对象分配内存，而每个string对象又将调用string的复制构造函数，该构造函数使用new为1000个字符分配内存。接下来，全部200，000，000个字符都将从vstr控制的内存中复制到vstr_copy1控制的内存中。这里的工作量很大，但是只要使用适当的操作即可。（这里是说，只要操作方式得当，并且得到了预期的结果即可）</p>
<p><strong>操作是否妥当</strong> </p>
<p>有时候这样的操作是不妥当的，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">allcaps</span><span class="params">(<span class="type">const</span> vector&lt;string&gt; &amp;vs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;string&gt; temp;</span><br><span class="line">    <span class="comment">// code that stores all-uppercagse version of vs in temp</span></span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// asume this function is invoked as bellow</span></span><br><span class="line">vector&lt;string&gt; vstr;</span><br><span class="line"><span class="comment">// build up a vector of 20,000 strings, each of 1000 characters</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">vstr_copy1</span><span class="params">(vstr)</span></span>;			<span class="comment">// #1</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">vstr_copy2</span><span class="params">(allcaps(vstr))</span></span>;	 <span class="comment">// #2</span></span><br></pre></td></tr></table></figure>



<p>上面两条初始化语句似乎是一样的，都是用一个现有的对象初始化一个vector<string>对象。如果深入探索这些代码，将发现allcaps()创建了对象temp，该对象管理着200，000，000个字符；vector和string的复制构造函数创建这么多个字符，然后程序将删除函数返回的对象副本（迟钝的编译器甚至可能将temp赋值给一个临时返回对象，删除temp，再删除临时返回对象）。这里的要点是，做了大量的无用功。考虑到临时对象被删除了，如果编译器将数据的所有权直接转让给vstr_copy2，这样其实是更好的。也即是说直接将temp管理的空间交给vstr_copy2。这类似于在计算机中移动文件的情形；实际文件还留在原来的地方，只修改记录（改变文件地址映射）。这种方法被称为移动语义（move semantics）。有点悖论的是。移动语义实际上避免了移动原始数据，而只是修改了记录。</p>
<p>要实现移动语义，需要采取某种方式，让编译器知道什么时候需要复制，什么时候不需要。这就是右值引用发挥作用的地方。可定义两个构造函数。其中哦一个是常规复制构造函数，它使用const左值引用作为参数，这个引用关联到左值实参，如语句#1中的vstr；另一个是移动构造函数，它使用const右值引用作为参数，该引用关联到左值实参，如语句#2中sllcaps(vstr)的返回值。复制构造函数可执行深拷贝操作，而移动构造函数只调整记录。再将所有权转移给新对象的过程中，移动构造函数可能修改其实参，这意味着右值引用参数不应是const</p>
<h4 id="移动示例"><a href="#移动示例" class="headerlink" title="移动示例"></a>移动示例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Useless.cpp - an otherwise useless class with move semantics</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// interface</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Useless</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n;          <span class="comment">// number of elements</span></span><br><span class="line">    <span class="type">char</span> *pc;       <span class="comment">// pointer to data</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> ct;  <span class="comment">// number of data</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showObject</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Useless</span>();</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Useless</span><span class="params">(<span class="type">int</span> k)</span></span>;</span><br><span class="line">    <span class="built_in">Useless</span>(<span class="type">int</span> k, <span class="type">char</span> ch);</span><br><span class="line">    <span class="built_in">Useless</span>(<span class="type">const</span> Useless &amp;f);  <span class="comment">// regular copy constructor</span></span><br><span class="line">    <span class="built_in">Useless</span>(Useless &amp;&amp;f);       <span class="comment">// move constructor</span></span><br><span class="line">    ~<span class="built_in">Useless</span>();</span><br><span class="line">    Useless <span class="keyword">operator</span>+(<span class="type">const</span> Useless &amp;f)<span class="type">const</span>;</span><br><span class="line">    <span class="comment">// need operator=() in copy and move versions</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showData</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// implementation</span></span><br><span class="line"><span class="type">int</span> Useless::ct = <span class="number">0</span>;    <span class="comment">// only way to initialize static member virable</span></span><br><span class="line"></span><br><span class="line">Useless::<span class="built_in">Useless</span>()</span><br><span class="line">&#123;</span><br><span class="line">    ++ct;</span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line">    pc = <span class="literal">nullptr</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;defalut constructor called; number of objects: &quot;</span> &lt;&lt; ct &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">showObject</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Useless::<span class="built_in">Useless</span>(<span class="type">int</span> k) : <span class="built_in">n</span>(k)</span><br><span class="line">&#123;</span><br><span class="line">    ++ct;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;int constructor called; number of objects: &quot;</span> &lt;&lt; ct &lt;&lt; endl;</span><br><span class="line">    pc = <span class="keyword">new</span> <span class="built_in">char</span>(n);</span><br><span class="line">    <span class="built_in">showObject</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Useless::<span class="built_in">Useless</span>(<span class="type">int</span> k , <span class="type">char</span> ch) : <span class="built_in">n</span>(k)</span><br><span class="line">&#123;</span><br><span class="line">    ++ct;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;int, char constructor called; number of objects: &quot;</span> &lt;&lt; ct &lt;&lt; endl;</span><br><span class="line">    pc = <span class="keyword">new</span> <span class="built_in">char</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        pc[i] = ch;</span><br><span class="line">    <span class="built_in">showObject</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Useless::<span class="built_in">Useless</span>(<span class="type">const</span> Useless &amp;f) : <span class="built_in">n</span>(f.n)</span><br><span class="line">&#123;</span><br><span class="line">    ++ct;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;copy const called; number of objects: &quot;</span> &lt;&lt; ct &lt;&lt; endl;</span><br><span class="line">    pc = <span class="keyword">new</span> <span class="built_in">char</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        pc[i] = f.pc[i];</span><br><span class="line">    <span class="built_in">showObject</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Useless::<span class="built_in">Useless</span>(Useless &amp;&amp;f) : <span class="built_in">n</span>(f.n)</span><br><span class="line">&#123;</span><br><span class="line">    ++ct;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;move constructore called; number of objects: &quot;</span> &lt;&lt; ct &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span>[] pc;</span><br><span class="line">    pc = f.pc;</span><br><span class="line">    f.pc = <span class="literal">nullptr</span>;</span><br><span class="line">    f.n = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">showObject</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Useless::~<span class="built_in">Useless</span>()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;destructor called; objects left: &quot;</span> &lt;&lt; --ct &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;deleted object:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">showObject</span>();</span><br><span class="line">    <span class="keyword">delete</span>[] pc;</span><br><span class="line">    pc = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Useless Useless::<span class="keyword">operator</span>+(<span class="type">const</span> Useless &amp;f) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Entering operator+()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    Useless temp = <span class="built_in">Useless</span>(n + f.n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        temp.pc[i] = pc[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &lt; temp.n; ++i)</span><br><span class="line">        temp.pc[i] = f.pc[i - n];</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;temp object: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Leaving operator+()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Useless::showObject</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Number of elements: &quot;</span> &lt;&lt; n;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; Data address: &quot;</span> &lt;&lt; (<span class="type">void</span>*) pc &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Useless::showData</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;(Object empty)&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            cout &lt;&lt; pc[i];</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// application</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Useless <span class="title">one</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;x&#x27;</span>)</span></span>;</span><br><span class="line">    Useless two = one;  <span class="comment">// calls copy constructor</span></span><br><span class="line">    <span class="function">Useless <span class="title">three</span><span class="params">(<span class="number">20</span>, <span class="string">&#x27;o&#x27;</span>)</span></span>;</span><br><span class="line">    <span class="function">Useless <span class="title">four</span> <span class="params">(one + three)</span></span>; <span class="comment">// calls operator+(), move constructor, one + three is temporary</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;object one: &quot;</span>;</span><br><span class="line">    one.<span class="built_in">showData</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;object two: &quot;</span>;</span><br><span class="line">    two.<span class="built_in">showData</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;object three: &quot;</span>;</span><br><span class="line">    three.<span class="built_in">showData</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;object four: &quot;</span>;</span><br><span class="line">    four.<span class="built_in">showData</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>程序输出：</p>
<p>int, char constructor called; number of objects: 1<br>Number of elements: 10 Data address: 0x9120d0<br>copy const called; number of objects: 2<br>Number of elements: 10 Data address: 0x916b60<br>int, char constructor called; number of objects: 3<br>Number of elements: 20 Data address: 0x916bb0<br>Entering operator+()<br>int constructor called; number of objects: 4<br>Number of elements: 30 Data address: 0x916c00<br>temp object:<br>Leaving operator+()<br>object one: xxxxxxxxxx<br>object two: xxxxxxxxxx<br>object three: oooooooooooooooooooo<br>object four: xxxxxxxxxxoooooooooooooooooooo<br>请按任意键继续. . .<br>destructor called; objects left: 3<br>deleted object:<br>Number of elements: 30 Data address: 0x916c00<br>destructor called; objects left: 2<br>deleted object:<br>Number of elements: 20 Data address: 0x916bb0<br>destructor called; objects left: 1<br>deleted object:<br>Number of elements: 10 Data address: 0x916b60<br>destructor called; objects left: 0<br>deleted object:<br>Number of elements: 10 Data address: 0x9120d0</p>
</blockquote>
<p>VS说这里程序触发了断点，但是对于空指针使用delete[] 并不会产生问题，所以断点位置并不清晰。在vscode中没有断点提示但是只有在<code>return 0;</code> 前添加断点，才能输出全部内容。</p>
<h4 id="8-10-2-解释"><a href="#8-10-2-解释" class="headerlink" title="8.10.2 解释"></a>8.10.2 解释</h4><p>这里没有调用移动构造函数，书中的解释是，在创建对象four时，编译器推断出对象four时operator+()所做工作的受益者，因此将operator+()创建的对象转到four的名下。一般而言，编译器完全可以进行优化，只要结果与未优化时相同。即使忽略程序中移动构造函数，并使用g++进行编译，结果也将相同。</p>
<h4 id="8-10-3-赋值"><a href="#8-10-3-赋值" class="headerlink" title="8.10.3 赋值"></a>8.10.3 赋值</h4><p>赋值运算符：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Useless&amp; Useless::<span class="keyword">operator</span>=(<span class="type">const</span> Useless &amp;f) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;f)	<span class="comment">// self assignment</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">   	<span class="keyword">delete</span>[] pc;</span><br><span class="line">    n = f.n;</span><br><span class="line">    pc = <span class="keyword">new</span> <span class="built_in">char</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        pc[i] = f.pc[i];</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>移动赋值运算符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Useless&amp; Useless::<span class="keyword">operator</span>=(Useless &amp;&amp;f)	<span class="comment">// move assignment</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;f)</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">delete</span>[] pc;</span><br><span class="line">    n = f.n;</span><br><span class="line">    f.n = <span class="number">0</span>;</span><br><span class="line">    f.pc = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>移动赋值运算符删除目标对象中的原始数据，并将原对象的所有权转让给目标。不能让多个指针指向相同的数据（地址）。</p>
<p>与移动构造函数一样，移动赋值运算符的参数也不能是const引用，因为这个方法修改了原对象。</p>
<h4 id="8-10-4-强制移动"><a href="#8-10-4-强制移动" class="headerlink" title="8.10.4 强制移动"></a>8.10.4 强制移动</h4><p>移动构造函数和移动赋值运算符使用右值。如果要让它们使用左值（程序可能分析一个包含候选对象的数组，选择其中一个对象供以后使用，并丢弃数组）。如果可以使用移动构造函数或者移动赋值运算符来保留选定的对象，自然是极好的。</p>
<p>如此便有下面的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Useless choices[<span class="number">20</span>];</span><br><span class="line">Useless best;</span><br><span class="line"><span class="type">int</span> pick;</span><br><span class="line"><span class="comment">// select one object, set pick to index</span></span><br><span class="line">best = choices[pick];</span><br></pre></td></tr></table></figure>

<p>由于choices[pick] 是左值，因此上面的赋值语句将使用赋值构造函数，而不是移动赋值运算符。如果能使choices[pick]看起来更像右值，就可以使用移动赋值运算符。为此，可以使用强制类型转换运算符static_cast&lt;&gt;将对象的类型转换为Useless &amp;&amp;，但是C++11提供了一种更简单的方式——使用头文件utility中声明的函数std::move()。下面的例子演示了这种用法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stdmove.cpp -- using std::move()</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// interface</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Useless</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n;			<span class="comment">// number of elements</span></span><br><span class="line">    <span class="type">char</span> *pc;		<span class="comment">// pointer to data</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> ct;	<span class="comment">// number of objects</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showObject</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Useless</span>();</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Useless</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line">    <span class="built_in">Useless</span>(<span class="type">int</span> k, <span class="type">char</span> ch);</span><br><span class="line">    <span class="built_in">Useless</span>(<span class="type">const</span> Useless &amp;f);	<span class="comment">// copy assignment</span></span><br><span class="line">    <span class="built_in">Useless</span>(Useless &amp;&amp;f);		<span class="comment">// move assignment</span></span><br><span class="line">    ~<span class="built_in">Useless</span>();</span><br><span class="line">    Useless <span class="keyword">operator</span>+(<span class="type">const</span> Useless &amp;f) <span class="type">const</span>;</span><br><span class="line">    Useless&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Useless &amp;f);	<span class="comment">// copy assignment;</span></span><br><span class="line">    Useless&amp; <span class="keyword">operator</span>=(Useless &amp;&amp;f);		<span class="comment">// move assignment</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showData</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// implementation</span></span><br><span class="line"><span class="type">int</span> Useless::ct = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Useless::<span class="built_in">Useless</span>()</span><br><span class="line">&#123;</span><br><span class="line">    ++ct;</span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line">    pc = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Useless::<span class="built_in">Useless</span>(<span class="type">int</span> k) : <span class="built_in">n</span>(k)</span><br><span class="line">&#123;</span><br><span class="line">    ++ct;</span><br><span class="line">    pc = <span class="keyword">new</span> <span class="built_in">char</span>(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Useless::<span class="built_in">Useless</span>(<span class="type">int</span> k, <span class="type">char</span> ch) : <span class="built_in">n</span>(k)</span><br><span class="line">&#123;</span><br><span class="line">    ++ct;</span><br><span class="line">    pc = <span class="keyword">new</span> <span class="built_in">char</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        pc[i] = ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Useless::<span class="built_in">Useless</span>(<span class="type">const</span> Useless &amp;f) : <span class="built_in">n</span>(f.n)</span><br><span class="line">&#123;</span><br><span class="line">    ++ct;</span><br><span class="line">    pc = <span class="keyword">new</span> <span class="built_in">char</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        pc[i] = f.pc[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Useless::<span class="built_in">Useless</span>(Useless &amp;&amp;f)</span><br><span class="line">&#123;</span><br><span class="line">    ++ct;</span><br><span class="line">    pc = f.pc;</span><br><span class="line">    f.pc = <span class="literal">nullptr</span>;</span><br><span class="line">    f.n = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Useless::~<span class="built_in">Useless</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] pc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Useless Useless::<span class="keyword">operator</span>+(<span class="type">const</span> Useless &amp;f) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    Useless temp = <span class="built_in">Useless</span>(n + f.n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        temp.pc[i] = pc[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &lt; temp.n; ++i)</span><br><span class="line">        temp.pc[i] = f.pc[i - n];</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Useless&amp; Useless::<span class="keyword">operator</span>=(<span class="type">const</span> Useless &amp;f)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;copy assignement operator called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;f)</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    n = f.n;</span><br><span class="line">    <span class="keyword">delete</span>[] pc;</span><br><span class="line">    pc = <span class="keyword">new</span> <span class="built_in">char</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        pc[i] = f.pc[i];</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Useless&amp; Useless::<span class="keyword">operator</span>=(Useless &amp;&amp;f)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;move assignement operator called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;f)</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    n = f.n;</span><br><span class="line">    <span class="keyword">delete</span>[] pc;</span><br><span class="line">    pc = f.pc;</span><br><span class="line">    f.n = <span class="number">0</span>;</span><br><span class="line">    f.pc = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Useless::showObject</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Number of elements: &quot;</span> &lt;&lt; n;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; Data address: &quot;</span> &lt;&lt; (<span class="type">void</span>*) pc &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Useless::showData</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;(Object empty)&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            std::cout &lt;&lt; pc[i];</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// application</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Useless <span class="title">one</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;x&#x27;</span>)</span></span>;</span><br><span class="line">    Useless two = one + one;  <span class="comment">// calls copy constructor</span></span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;object one: &quot;</span>;</span><br><span class="line">    one.<span class="built_in">showData</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;object two: &quot;</span>;</span><br><span class="line">    two.<span class="built_in">showData</span>();</span><br><span class="line"></span><br><span class="line">    Useless three, four; </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;three = one&quot;</span> &lt;&lt; std::endl;;</span><br><span class="line">    three = one;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;now object three = &quot;</span>; </span><br><span class="line">    three.<span class="built_in">showData</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; and object one = &quot;</span>;</span><br><span class="line">    one.<span class="built_in">showData</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;object four = one + two&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    four = one + two;   <span class="comment">// automatic move assignment</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;now object four = &quot;</span>;</span><br><span class="line">    four.<span class="built_in">showData</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;four = move(one)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    four = std::<span class="built_in">move</span>(one);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;now object four = &quot;</span>;</span><br><span class="line">    four.<span class="built_in">showData</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; and object one = &quot;</span>;</span><br><span class="line">    one.<span class="built_in">showData</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="新的类功能"><a href="#新的类功能" class="headerlink" title="新的类功能"></a>新的类功能</h3><p>在原有4个特殊成员函数（默认构造函数、复制构造函数、赋值运算符和析构函数）的基础上，C++11新增了两个：移动构造函数和移动赋值运算符。这些成员函数是在编译器在各种情况下自动提供的。</p>
<p>假设类型为Someclass，则默认移动构造函数和默认移动赋值运算符的原型为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Someclass::<span class="built_in">Someclass</span>(<span class="type">const</span> Someclass &amp;);	<span class="comment">// default copy constructor</span></span><br><span class="line">Someclass::<span class="built_in">Someclass</span>(Someclass &amp;&amp;);			<span class="comment">// default move constructor</span></span><br></pre></td></tr></table></figure>



<h4 id="默认地方法和禁用的方法"><a href="#默认地方法和禁用的方法" class="headerlink" title="默认地方法和禁用的方法"></a>默认地方法和禁用的方法</h4><p>在函数定义之后加<code>=default</code> 将函数设为默认，加<code>=delete</code> 将函数禁用</p>
<h4 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h4><p>如果类提供了多个构造函数，程序员可能会重复编写相同的代码，也就是说，有些构造函数可能需要包含其他构造函数中已有的代码。为了让编码工作过更简单、更可靠，C++11允许程序员在一个构造函数的定义中使用另一个构造函数。这被称为委托，因为构造函数暂时将创建对象的工作委托给另一个构造函数。委托将使用成员初始化列表语法的变种：</p>
<p>即在初始化列表中调用同一类中的其它构造函数（与之同名，参数个数不同或者参数类型不同），执行其他构造函数之后再执行自身函数体。</p>
<h4 id="继承构造函数"><a href="#继承构造函数" class="headerlink" title="继承构造函数"></a>继承构造函数</h4><p>面向对象的主要思想或者主要工作就是代码复用，所以为了进一步简化编码工作，C++11提供了一种让派生类能够继承基类构造函数的机制。C++98则提供过一种让命名空间中函数可用的语法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Box</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fn</span><span class="params">(<span class="type">int</span>)</span> </span>&#123; <span class="comment">/* do something */</span> &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">(<span class="type">double</span>)</span> </span>&#123; <span class="comment">/* do something */</span> &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *)</span> </span>&#123; <span class="comment">/* do something */</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> Box::fn;	<span class="comment">// 让函数fn的所有重载版本都可用。也可使用这种方法让基类的所有非特殊成员函数对派生类可用</span></span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C1</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// define something</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fn</span><span class="params">(<span class="type">int</span>)</span> </span>&#123; <span class="comment">/* do something */</span> &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">(<span class="type">double</span>)</span> </span>&#123; <span class="comment">/* do something */</span> &#125;	</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *)</span> </span>&#123; <span class="comment">/* do something */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C2</span> : <span class="keyword">public</span> C1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// define something else</span></span><br><span class="line">    <span class="function"><span class="keyword">using</span> <span class="title">C1::fn</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">(<span class="type">double</span>)</span> </span>&#123; <span class="comment">/* do something else */</span> &#125;;	<span class="comment">// =default</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>类C2中的using声明让C2对象可以使用C1的所有fn方法，但将选择C2而不是C1定义的方法fn(double)。</p>
<p>C++11将这种方法用与构造函数。这让派生类继承基类的所有构造函数（默认构造函数、复制构造函数和移动构造函数除外），但不会使用与派生类构造函数的 <font size=3 color=5>特征标</font> 相匹配的构造函数（如果有参数相同的函数，优先调用子类自定义的版本），应该说是提供了下转型对象的方法，继承的基类构造函数只能初始化基类成员，如果还要初始化派生类新增成员，还需要使用初始化列表的语法（感觉有点鸡肋，因为不适用using声明也可以使用基类构造函数加初始化列表初始化派生类对象）。</p>
<h4 id="管理虚方法：override-和-final"><a href="#管理虚方法：override-和-final" class="headerlink" title="管理虚方法：override 和 final"></a>管理虚方法：override 和 final</h4><p>前者用于指明，成员函数重写了基类中声明的虚函数。</p>
<p>后者则与Java中的final关键字作用相同，用于标识函数不允许重写。</p>
<p>这两个说明符并非关键字，而是具有特殊含义的标识符。</p>
<h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><h4 id="比较函数指针、函数对象和lambda表达式"><a href="#比较函数指针、函数对象和lambda表达式" class="headerlink" title="比较函数指针、函数对象和lambda表达式"></a>比较函数指针、函数对象和lambda表达式</h4><p>假设要生成一个随机整数列表，并判断其中有多少整数能够可以被3整除，多少个整数能够可被13整除。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">numbers</span><span class="params">(<span class="number">1000</span>)</span></span>;</span><br><span class="line">std::<span class="built_in">generate</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), std::rand);<span class="comment">// 指向标准函数rand的指针</span></span><br></pre></td></tr></table></figure>

<p>通过使用count_if函数可以轻松计算出有多少个能够被3整除的元素。与generate函数一样，前两个参数指定容器的区间，第三个参数应当是一个返回true或者false的函数对象（仿函数）。函数count_if计算这样的元素数，即它使得指定的函数对象返回true。为判断元素能否被3整除，可以使用下面的定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">f3</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x % <span class="number">3</span> == <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure>

<p>同样，为判断元素是否能够被13整除，可以使用下面的定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">f13</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x % <span class="number">13</span> == <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure>

<p>定义上述函数后，便可计算符合条件的元素数目了，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> count3 = std::<span class="built_in">count_if</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), f3);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Count of numbers division by 3: &quot;</span> &lt;&lt; count3 &lt;&lt; std::endl;</span><br><span class="line"><span class="type">int</span> count13 = std::<span class="built_in">count_if</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), f13);</span><br><span class="line">std::count &lt;&lt; <span class="string">&quot;Count of numbers division by 13: &quot;</span> &lt;&lt; count13 &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p>函数指针：函数名不加函数调用符；函数对象：类内重载的函数调用符，类名加函数调用符。</p>
<p>最后是使用了lambda表达式的情况，名称来源于λ演算——一种定义和应用函数的数学系统。这个系统让程序员能够使用匿名函数——即无需给函数明明。在C++11中，对于接收函数指针或函数符的函数，可使用吗匿名函数定义lambda作为其参数。与前面函数f3对应的lambda如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[] (<span class="type">int</span> x) &#123; <span class="keyword">return</span> x % <span class="number">3</span> == <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure>

<p>再看一看f3()的定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">f3</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x % <span class="number">3</span> == <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure>

<p>差别：</p>
<ul>
<li>使用了[]代替函数名（这就是匿名的由来）；</li>
<li>没有生命返回类型</li>
</ul>
<p>返回类型相当于使用decltyp根据返回值推断得到的，这里为bool，如果lambda不返回语句，推断出的返回类型将为void，就这个示例而言，程序员将以如下方式使用该lambda：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> count3 = std::<span class="built_in">count_if</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), </span><br><span class="line">                           [] (<span class="type">int</span> x) &#123; <span class="keyword">return</span> x % <span class="number">3</span> == <span class="number">0</span>; &#125;);</span><br></pre></td></tr></table></figure>

<p>也就是说，使用整个lambda表达式替换函数指针或函数符构造函数。</p>
<p>仅当lambda表达式完全由一条返回语句组成时，自动类型推断才有用；否则，需要使用新增的返回值后置的语法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[] (<span class="type">double</span> x) -&gt; <span class="type">double</span> &#123; <span class="type">int</span> y = x; <span class="keyword">return</span> x - y; &#125;	<span class="comment">// reuturn type is double</span></span><br></pre></td></tr></table></figure>



<h4 id="为何使用lambda"><a href="#为何使用lambda" class="headerlink" title="为何使用lambda"></a>为何使用lambda</h4><ol>
<li>距离</li>
</ol>
<p>让定义位于使用的地方附近很有用。这样就无需翻阅多余代码，再修改代码的使用也会因为内容大多在附近而更方便；</p>
<ol start="2">
<li>简洁</li>
</ol>
<p>从简洁的角度看，函数符代码比函数和lambda表达式更为繁琐。函数和lambda的简洁程度相当，一个显而易见的例外是，重复使用lambda时，可以选择复写代码或者给予lambda一个名字，并重复使用该名字：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> mod3 = [] (<span class="type">int</span> x) &#123; <span class="keyword">return</span> x % <span class="number">3</span> == <span class="number">0</span>; &#125;	<span class="comment">// mod3 a name for the lambda</span></span><br><span class="line">count1 = std::<span class="built_in">count_if</span>(n1.<span class="built_in">begin</span>(), n1.<span class="built_in">end</span>(), mod3);</span><br><span class="line">count2 = std::<span class="built_in">count_id</span>(n2.<span class="built_in">begin</span>(), n3.<span class="built_in">end</span>(), mod3);</span><br><span class="line"><span class="comment">// 甚至可以像使用常规函数一样使用有名称的lambda</span></span><br><span class="line"><span class="type">bool</span> result = <span class="built_in">mod3</span>(z);	<span class="comment">// result is true if z % 3 == 0</span></span><br></pre></td></tr></table></figure>

<p>然而，不同于常规函数，可在函数内部定义有名称的lambda。mod3的实际类型随实现而异，它取决于编译器使用什么类型来追踪lambda。</p>
<ol start="3">
<li>效率</li>
</ol>
<p>这三种方法的效率取决于编译器内联的那些东西。函数指针方法阻止了内联，有因为编译器传统上不会内联其地址被获取的函数，因为函数的地址的概念意味着非内联函数（类的封装特性决定了类不会将开放的函数作为内联函数）。而函数符和lambda通常不会组织内联。</p>
<ol start="4">
<li>功能</li>
</ol>
<p>lambda额外的功能：</p>
<ul>
<li>可访问作用域内的任何动态变量；</li>
<li>要捕获要使用的变量，可将其名称放在中括号内。如果只指定了变量名，如[Z]，将按值访问变量；如果在名称之前加上&amp;，如[&amp;count]，将按引用访问变量。（[&amp;]让程序员能够访问作用域内所有的动态变量，而[=]让程序员能够安置访问所有动态变量，甚至可以混合使用这两种方式）；</li>
<li>如果捕获列表中出现[=, &amp;ted]，则说明只有ted可以按引用访问，其余动态变量只能是按值访问。</li>
</ul>
<p>​                                                                                                <font size=3 color=5><strong>总结</strong></font></p>
<p>在C++中引入lambda的主要目的是，让程序员能够将类似于函数的表达式用作接收函数指针或函数符的函数的参数。因此，典型的lambda是测试表达式或比较表达式，可变写一条返回语句。这使得lambda简洁而易于理解，且可自动推断返回类型。然而，有创意的C++程序员可能开发出其他用法。</p>
<h3 id="包装器"><a href="#包装器" class="headerlink" title="包装器"></a>包装器</h3><p>C++提供了多个包装器（也叫适配器），这些对象用于给其他编程接口提供更一致或更合适的接口。</p>
<p><code>answer = ef(q);</code> </p>
<p>这里的ef可以是函数、函数指针、函数对象甚至是带有名称的lambda表达式。所有这些都是可调用的类型。鉴于可调用的类型如此之多，这可能导致模板低效。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> F&gt;</span></span><br><span class="line"><span class="function">T <span class="title">use_f</span><span class="params">(T t, F f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    ++count;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; use_f count = &quot;</span> &lt;&lt; count &lt;&lt; <span class="string">&quot;, &amp;count = &quot;</span> &lt;&lt; &amp;count &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">f</span>(t);    <span class="comment">// 返回计算值</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fp</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> z_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Fp</span>(<span class="type">double</span> z = <span class="number">1.0</span>) : <span class="built_in">z_</span>(z) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">double</span> p)</span> </span>&#123; <span class="keyword">return</span> z_ * p; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fq</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> z_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Fq</span>(<span class="type">double</span> z = <span class="number">1.0</span>) : <span class="built_in">z_</span>(z) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">double</span> p)</span> </span>&#123; <span class="keyword">return</span> z_ + p; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;somedefs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">dub</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="number">2.0</span> * x; &#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">sqware</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123; <span class="keyword">return</span> x * x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出的六个count皆不同，大致分为三类，函数指针、函数对象、lambda，但是推导出的F的类型是一致的</span></span><br><span class="line"></span><br><span class="line">std::function&lt;<span class="type">double</span>(<span class="type">double</span>)&gt; ef = dub;</span><br><span class="line">std::function&lt;<span class="type">double</span>(<span class="type">double</span>)&gt; ef2 = sqware;</span><br><span class="line">std::function&lt;<span class="type">double</span>(<span class="type">double</span>)&gt; ef3 = <span class="built_in">Fp</span>(<span class="number">5.0</span>);</span><br><span class="line">std::function&lt;<span class="type">double</span>(<span class="type">double</span>)&gt; ef4 = <span class="built_in">Fq</span>(<span class="number">5.0</span>);</span><br><span class="line">std::function&lt;<span class="type">double</span>(<span class="type">double</span>)&gt; ef5 = [](<span class="type">double</span> u) &#123; <span class="keyword">return</span> u * u; &#125;;</span><br><span class="line">std::function&lt;<span class="type">double</span>(<span class="type">double</span>)&gt; ef6 = [](<span class="type">double</span> u) &#123; <span class="keyword">return</span> <span class="number">2.0</span> * u; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改之后输出的count完全一致，说明只执行另外一次类型推导</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::cout;</span><br><span class="line">    <span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; std::fixed;</span><br><span class="line">    cout.<span class="built_in">precision</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> y = <span class="number">1.21</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Function pointer dub: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; use_f(y, dub) &lt;&lt; endl;</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">use_f</span>(y, ef) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Function pointer sqware: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; use_f(y, sqware) &lt;&lt; endl;</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">use_f</span>(y, ef2) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Function object Fp: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; use_f(y, Fp(5.0)) &lt;&lt; endl;</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">use_f</span>(y, ef3) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Function object Fq: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; use_f(y, Fq(5.0));</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">use_f</span>(y, ef4) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Lambda expression 1:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; use_f(y, [] (double u) -&gt; double &#123; return u * u; &#125;) &lt;&lt; endl;</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">use_f</span>(y, ef5) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Lambda expression 2:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; use_f(y, [] (double u) -&gt; double &#123; return 2.0 * u; &#125;) &lt;&lt; endl;</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">use_f</span>(y, ef6) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他改良方式：</p>
<p>上面的例子中使用了六个function&lt;double(double)&gt;对象，现在，只使用了一个临时的function&lt;double(double)&gt;对象，将其用作函数use_f()的参数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> function&lt;<span class="type">double</span>(<span class="type">double</span>)&gt; fdd;	<span class="comment">// simplify the type declaration</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">use_f</span>(y, <span class="built_in">fdd</span>(dub)) &lt;&lt; endl;		<span class="comment">// create and initlize object to dub</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">use_f</span>(y, <span class="built_in">fdd</span>(sqware)) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>在此基础上，将上面的例子改为如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">use_f</span><span class="params">(T t, std::function&lt;T(T) f)</span>	<span class="comment">// f call signature is T(T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    ++count;</span><br><span class="line"> 	std::cout &lt;&lt; <span class="string">&quot; use_f count = &quot;</span> &lt;&lt; count &lt;&lt; <span class="string">&quot;, &amp;count = &quot;</span> &lt;&lt; &amp;count &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">f</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">use_f</span>&lt;<span class="type">double</span>&gt;(y, dub) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">use_f</span>&lt;<span class="type">double</span>&gt;(y, <span class="built_in">Fq</span>(<span class="number">5.0</span>)) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">use_f</span>&lt;<span class="type">double</span>&gt;(y, [](<span class="type">double</span> u)&#123; <span class="keyword">return</span> u * u; &#125;) &lt;&lt; endl; </span><br></pre></td></tr></table></figure>

<p>参数dub、Fp(5.0)等本身的类型并不是function&lt;double(double)&gt;，因此在use_f后面使用了<double>来指出所需的具体化。这样，T被设置为double，而是std::function&lt;T(T)&gt;变成了std::function&lt;double(double)&gt;。</p>
<h3 id="可变参数模板"><a href="#可变参数模板" class="headerlink" title="可变参数模板"></a>可变参数模板</h3><p>递归展开参数包可能会出现传递全部参数导致程序无穷递归没有终止的情况，所以做出下面更改：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// definition for 0 parameter</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// deginition for 1 parameter</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(T value)</span> </span>&#123; cout &lt;&lt; T &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// definition for 2 or more parameters</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span> value, <span class="keyword">class</span>... args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; T &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">	<span class="built_in">show</span>(args...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在参数列表中还有多个参数的情况下，调用参数包版本；在只剩下最后一个参数的时候调用单参数模板输出并换行；在没有参数时，调用无参版本。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://Zuowanghang.github.io">含光</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zuowanghang.github.io/2022/04/11/C-Plus-Plus/">https://zuowanghang.github.io/2022/04/11/C-Plus-Plus/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://Zuowanghang.github.io" target="_blank">清辉 の Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C-C/">C/C++</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2022/11/30/bla2mxhQ9jwJMGO.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/11/11/Java-Web/" title="Java Web"><img class="cover" src="https://s2.loli.net/2023/03/08/KtyIJoiUDauNTjb.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java Web</div></div></a></div><div class="next-post pull-right"><a href="/2022/04/08/hello-world/" title="Hello World"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Hello World</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s2.loli.net/2022/11/30/m3onYl1iO4ZuwT8.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">含光</div><div class="author-info__description">Hexo Butterfly 博客</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Zuowanghang"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Zuowanghang" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">技术小栈</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%AF%87"><span class="toc-number">1.</span> <span class="toc-text">核心篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#The-Basics"><span class="toc-number">1.1.</span> <span class="toc-text">The Basics</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Scope-and-Lifetime"><span class="toc-number">1.1.1.</span> <span class="toc-text">Scope and Lifetime</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%A0%E4%B8%AA%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.2.</span> <span class="toc-text">几个关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Constants"><span class="toc-number">1.2.1.</span> <span class="toc-text">Constants</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2 类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-User-defined-data-type"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.3 User_defined data type</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E6%8C%87%E9%92%88%E4%B8%8EOOP%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.4.</span> <span class="toc-text">2.4 指针与OOP原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.3.</span> <span class="toc-text">程序的内存模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E5%89%8D"><span class="toc-number">1.3.1.</span> <span class="toc-text">程序执行前</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E5%90%8E"><span class="toc-number">1.3.2.</span> <span class="toc-text">代码执行过程后</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8new%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">1.3.3.</span> <span class="toc-text">使用new操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%AD%98%E5%82%A8%E3%80%81%E9%9D%99%E6%80%81%E5%AD%98%E5%82%A8%E5%92%8C%E5%8A%A8%E6%80%81%E5%AD%98%E5%82%A8"><span class="toc-number">1.3.4.</span> <span class="toc-text">自动存储、静态存储和动态存储</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cin-get-ch-%E4%B8%8Ecin-get"><span class="toc-number">1.4.</span> <span class="toc-text">cin.get(ch)与cin.get()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8"><span class="toc-number">1.5.</span> <span class="toc-text">引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%9A%84%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="toc-number">1.5.1.</span> <span class="toc-text">引用的基础语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.5.2.</span> <span class="toc-text">引用的注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%EF%BC%88%E5%BD%A2%E5%8F%82%EF%BC%89"><span class="toc-number">1.5.3.</span> <span class="toc-text">引用作为函数的参数（形参）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E5%81%9A%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">1.5.4.</span> <span class="toc-text">引用做函数的返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">1.5.5.</span> <span class="toc-text">引用的本质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CV-%E9%99%90%E5%AE%9A%E7%AC%A6"><span class="toc-number">1.5.6.</span> <span class="toc-text">CV-限定符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E5%BC%95%E7%94%A8"><span class="toc-number">1.5.7.</span> <span class="toc-text">常量引用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Classes-and-Objects"><span class="toc-number">1.6.</span> <span class="toc-text">Classes and Objects</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-number">1.6.1.</span> <span class="toc-text">封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="toc-number">1.6.2.</span> <span class="toc-text">C++内联函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="toc-number">1.6.3.</span> <span class="toc-text">访问权限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Structures-and-Classes"><span class="toc-number">1.6.4.</span> <span class="toc-text">Structures and Classes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E8%AE%BE%E7%BD%AE%E4%B8%BA%E7%A7%81%E6%9C%89"><span class="toc-number">1.6.5.</span> <span class="toc-text">类设置为私有</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-%E6%A1%88%E4%BE%8B"><span class="toc-number">1.6.6.</span> <span class="toc-text">5.5 案例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-1-%E7%AB%8B%E6%96%B9%E4%BD%93"><span class="toc-number">1.6.6.1.</span> <span class="toc-text">5.5.1 立方体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-2-%E7%82%B9%E5%92%8C%E5%9C%86%E7%9A%84%E4%BD%8D%E7%BD%AE%E5%85%B3%E7%B3%BB"><span class="toc-number">1.6.6.2.</span> <span class="toc-text">5.5.2 点和圆的位置关系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-%E5%AF%B9%E8%B1%A1%E7%89%B9%E6%80%A7"><span class="toc-number">1.6.7.</span> <span class="toc-text">5.6 对象特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-6-1-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">1.6.7.1.</span> <span class="toc-text">5.6.1 构造函数和析构函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%86%E7%B1%BB%E5%8F%8A%E8%B0%83%E7%94%A8"><span class="toc-number">1.6.7.2.</span> <span class="toc-text">构造函数的分类及调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8%E6%97%B6%E6%9C%BA"><span class="toc-number">1.6.7.3.</span> <span class="toc-text">拷贝构造函数的使用时机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%A7%84%E5%88%99"><span class="toc-number">1.6.7.4.</span> <span class="toc-text">构造函数调用规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-6-5-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.6.7.5.</span> <span class="toc-text">5.6.5 深拷贝与浅拷贝</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="toc-number">1.6.7.6.</span> <span class="toc-text">构造函数初始化列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-6-7-%E7%B1%BB%E4%BD%9C%E4%B8%BA%E5%85%B6%E5%AE%83%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98"><span class="toc-number">1.6.7.7.</span> <span class="toc-text">5.6.7 类作为其它类的成员</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-6-8-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">1.6.7.8.</span> <span class="toc-text">5.6.8 静态成员变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-6-9-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">1.6.7.9.</span> <span class="toc-text">5.6.9 静态成员函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-6-10-C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.6.7.10.</span> <span class="toc-text">5.6.10 C++对象模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-6-11-this%E6%8C%87%E9%92%88"><span class="toc-number">1.6.7.11.</span> <span class="toc-text">5.6.11 this指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-6-12-%E7%A9%BA%E6%8C%87%E9%92%88%E8%B0%83%E7%94%A8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">1.6.7.12.</span> <span class="toc-text">5.6.12  空指针调用成员函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-6-13-const%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">1.6.7.13.</span> <span class="toc-text">5.6.13 const修饰成员函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD"><span class="toc-number">1.7.</span> <span class="toc-text">重载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">1.7.1.</span> <span class="toc-text">函数重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">1.7.2.</span> <span class="toc-text">运算符重载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">重载 + 运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD-lt-lt-%E5%92%8C-gt-gt-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.7.2.2.</span> <span class="toc-text">重载 &lt;&lt; 和 &gt;&gt; 运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD-%E8%BF%90%E7%AE%97%E7%AC%A6-1"><span class="toc-number">1.7.2.3.</span> <span class="toc-text">重载 ++ 运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD-%E2%80%93-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.7.2.4.</span> <span class="toc-text">重载 – 运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD-%E8%BF%90%E7%AE%97%E7%AC%A6-2"><span class="toc-number">1.7.2.5.</span> <span class="toc-text">重载 &#x3D; 运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD-%E8%BF%90%E7%AE%97%E7%AC%A6-3"><span class="toc-number">1.7.2.6.</span> <span class="toc-text">重载 &#x3D;&#x3D; 运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">1.7.2.7.</span> <span class="toc-text">函数调用 () 运算符重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8B%E6%A0%87%E8%BF%90%E7%AE%97%E7%AC%A6-%E9%87%8D%E8%BD%BD"><span class="toc-number">1.7.2.8.</span> <span class="toc-text">下标运算符 [] 重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE-gt-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.7.2.9.</span> <span class="toc-text">成员访问 -&gt; 运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%88%E9%80%82%E7%9A%84%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E6%97%B6%E6%9C%BA"><span class="toc-number">1.7.2.10.</span> <span class="toc-text">合适的重载运算符的时机</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">1.8.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="toc-number">1.8.1.</span> <span class="toc-text">继承的基础语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F"><span class="toc-number">1.8.2.</span> <span class="toc-text">继承方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.8.3.</span> <span class="toc-text">继承中的对象模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%AD%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.8.4.</span> <span class="toc-text">继承中构造和析构顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%AD%E5%90%8C%E5%90%8D%E6%88%90%E5%91%98%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">1.8.5.</span> <span class="toc-text">继承中同名成员的处理方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E5%90%8C%E5%90%8D%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">1.8.6.</span> <span class="toc-text">继承同名静态成员的处理方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BB%A7%E6%89%BF"><span class="toc-number">1.8.7.</span> <span class="toc-text">多继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF%EF%BC%88Diamond-inheritance%EF%BC%89"><span class="toc-number">1.8.8.</span> <span class="toc-text">菱形继承（Diamond inheritance）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">1.9.</span> <span class="toc-text">多态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="toc-number">1.9.1.</span> <span class="toc-text">基础语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%85%83%E8%BF%90%E7%AE%97%E8%AE%A1%E7%AE%97%E5%99%A8%E7%B1%BB"><span class="toc-number">1.9.2.</span> <span class="toc-text">二元运算计算器类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%85%B3%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.9.3.</span> <span class="toc-text">有关虚函数的注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB"><span class="toc-number">1.9.4.</span> <span class="toc-text">纯虚函数和抽象基类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%B6%E4%BD%9Cdrinks"><span class="toc-number">1.9.5.</span> <span class="toc-text">制作drinks</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%9E%90%E6%9E%84%E5%92%8C%E7%BA%AF%E8%99%9A%E6%9E%90%E6%9E%84"><span class="toc-number">1.9.6.</span> <span class="toc-text">虚析构和纯虚析构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E8%A3%85"><span class="toc-number">1.9.7.</span> <span class="toc-text">计算机组装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E8%AE%BE%E8%AE%A1%E5%9B%9E%E9%A1%BE"><span class="toc-number">1.9.8.</span> <span class="toc-text">类设计回顾</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E7%94%9F%E6%88%90%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">1.9.8.1.</span> <span class="toc-text">编译器生成的成员函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E5%AE%83%E7%9A%84%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-number">1.9.8.2.</span> <span class="toc-text">其它的类方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%AC%E6%9C%89%E7%BB%A7%E6%89%BF%E7%9A%84%E8%80%83%E8%99%91%E5%9B%A0%E7%B4%A0"><span class="toc-number">1.9.8.3.</span> <span class="toc-text">公有继承的考虑因素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%B1%9E%E6%80%A7"><span class="toc-number">1.9.8.4.</span> <span class="toc-text">成员函数属性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6"><span class="toc-number">1.10.</span> <span class="toc-text">文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA"><span class="toc-number">1.10.1.</span> <span class="toc-text">简单文件输入&#x2F;输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%96%87%E4%BB%B6"><span class="toc-number">1.10.2.</span> <span class="toc-text">写文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E6%96%87%E4%BB%B6"><span class="toc-number">1.10.3.</span> <span class="toc-text">读文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%86%99%E6%96%87%E4%BB%B6"><span class="toc-number">1.10.4.</span> <span class="toc-text">二进制写文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%AF%BB%E6%96%87%E4%BB%B6"><span class="toc-number">1.10.5.</span> <span class="toc-text">二进制读文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">1.11.</span> <span class="toc-text">异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E7%94%A8abort"><span class="toc-number">1.11.1.</span> <span class="toc-text">调用abort ()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E9%94%99%E8%AF%AF%E7%A0%81"><span class="toc-number">1.11.2.</span> <span class="toc-text">返回错误码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6"><span class="toc-number">1.11.3.</span> <span class="toc-text">异常机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BA%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.11.4.</span> <span class="toc-text">将对象作为异常类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E8%A7%84%E8%8C%83%E4%B8%8EC-11"><span class="toc-number">1.11.5.</span> <span class="toc-text">异常规范与C++11</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E8%A7%A3%E9%80%80"><span class="toc-number">1.11.6.</span> <span class="toc-text">栈解退</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%BC%82%E5%B8%B8%E7%89%B9%E6%80%A7"><span class="toc-number">1.11.7.</span> <span class="toc-text">其他异常特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#exception%E7%B1%BB"><span class="toc-number">1.11.8.</span> <span class="toc-text">exception类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E3%80%81%E7%B1%BB%E5%92%8C%E7%BB%A7%E6%89%BF"><span class="toc-number">1.11.9.</span> <span class="toc-text">异常、类和继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E4%BD%95%E6%97%B6%E4%BC%9A%E8%BF%B7%E5%A4%B1%E6%96%B9%E5%90%91"><span class="toc-number">1.11.10.</span> <span class="toc-text">异常何时会迷失方向</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%85%B3%E5%BC%82%E5%B8%B8%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.11.11.</span> <span class="toc-text">有关异常的注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RTTI"><span class="toc-number">1.12.</span> <span class="toc-text">RTTI</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RTTI%E7%9A%84%E7%94%A8%E9%80%94"><span class="toc-number">1.12.1.</span> <span class="toc-text">RTTI的用途</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RTTI%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.12.2.</span> <span class="toc-text">RTTI的工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.12.3.</span> <span class="toc-text">类型转换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8F%90%E9%AB%98%E7%AF%87"><span class="toc-number">2.</span> <span class="toc-text">提高篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF"><span class="toc-number">2.1.</span> <span class="toc-text">模板</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="toc-number">2.1.1.</span> <span class="toc-text">函数模板的语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">2.1.2.</span> <span class="toc-text">函数模板的用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.1.3.</span> <span class="toc-text">函数模板与普通函数的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-number">2.1.4.</span> <span class="toc-text">函数模板的局限性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="toc-number">2.1.5.</span> <span class="toc-text">类模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%8E%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.1.6.</span> <span class="toc-text">类模板与函数模板的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%AD%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E8%A2%AB%E5%88%9B%E5%BB%BA%E6%97%B6%E9%97%B4"><span class="toc-number">2.1.7.</span> <span class="toc-text">类模板中成员函数的被创建时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%AF%B9%E8%B1%A1%E5%81%9A%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-number">2.1.8.</span> <span class="toc-text">类模板对象做函数参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="toc-number">2.1.9.</span> <span class="toc-text">类模板与继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%B1%BB%E5%A4%96%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.1.10.</span> <span class="toc-text">类模板成员函数类外实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%88%86%E6%96%87%E4%BB%B6%E7%BC%96%E5%86%99"><span class="toc-number">2.1.11.</span> <span class="toc-text">类模板分文件编写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%8E%E5%8F%8B%E5%85%83"><span class="toc-number">2.1.12.</span> <span class="toc-text">类模板与友元</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B"><span class="toc-number">2.1.13.</span> <span class="toc-text">模板综合案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">2.2.</span> <span class="toc-text">智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%BC%95%E5%85%A5"><span class="toc-number">2.2.1.</span> <span class="toc-text">智能指针引入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%85%B3%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">2.2.2.</span> <span class="toc-text">有关智能指针的注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unique-ptr%E4%B8%BA%E4%BD%95%E4%BC%98%E4%BA%8Eauto-ptr"><span class="toc-number">2.2.3.</span> <span class="toc-text">unique_ptr为何优于auto_ptr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">2.2.4.</span> <span class="toc-text">选择智能指针</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STL%E5%88%9D%E8%AF%86"><span class="toc-number">2.3.</span> <span class="toc-text">STL初识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#STL%E7%9A%84%E8%AF%9E%E7%94%9F"><span class="toc-number">2.3.1.</span> <span class="toc-text">STL的诞生</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#STL%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.3.2.</span> <span class="toc-text">STL基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#STL%E5%85%AD%E5%A4%A7%E7%BB%84%E4%BB%B6"><span class="toc-number">2.3.3.</span> <span class="toc-text">STL六大组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#STL%E4%B8%AD%E5%AE%B9%E5%99%A8%E3%80%81%E7%AE%97%E6%B3%95%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">2.3.4.</span> <span class="toc-text">STL中容器、算法、迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E7%AE%97%E6%B3%95%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%88%9D%E8%AF%86"><span class="toc-number">2.3.5.</span> <span class="toc-text">容器算法迭代器初识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#vector%E5%AD%98%E6%94%BE%E5%86%85%E7%BD%AE%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.3.5.1.</span> <span class="toc-text">vector存放内置数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vector%E5%AD%98%E6%94%BE%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.3.5.2.</span> <span class="toc-text">vector存放用户自定义数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vector%E5%B5%8C%E5%A5%97vector"><span class="toc-number">2.3.5.3.</span> <span class="toc-text">vector嵌套vector</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STL-%E2%80%93-%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8"><span class="toc-number">2.4.</span> <span class="toc-text">STL – 常用容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#string%E5%AE%B9%E5%99%A8"><span class="toc-number">2.4.1.</span> <span class="toc-text">string容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#string%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.4.1.1.</span> <span class="toc-text">string基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#string%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">2.4.1.2.</span> <span class="toc-text">string构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#string%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C"><span class="toc-number">2.4.1.3.</span> <span class="toc-text">string赋值操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#string%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5"><span class="toc-number">2.4.1.4.</span> <span class="toc-text">string字符串拼接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#string%E6%9F%A5%E6%89%BE%E5%92%8C%E6%9B%BF%E6%8D%A2"><span class="toc-number">2.4.1.5.</span> <span class="toc-text">string查找和替换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#string%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83"><span class="toc-number">2.4.1.6.</span> <span class="toc-text">string字符串比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#string%E5%AD%97%E7%AC%A6%E5%AD%98%E5%8F%96"><span class="toc-number">2.4.1.7.</span> <span class="toc-text">string字符存取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#string%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4"><span class="toc-number">2.4.1.8.</span> <span class="toc-text">string插入和删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#string%E5%AD%90%E4%B8%B2"><span class="toc-number">2.4.1.9.</span> <span class="toc-text">string子串</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#verctor%E5%AE%B9%E5%99%A8"><span class="toc-number">2.4.2.</span> <span class="toc-text">verctor容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#vector%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.4.2.1.</span> <span class="toc-text">vector基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-vector%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">2.4.2.2.</span> <span class="toc-text">4.2.2 vector构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-3-vector%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C"><span class="toc-number">2.4.2.3.</span> <span class="toc-text">4.2.3 vector赋值操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-4-vector%E5%AE%B9%E9%87%8F%E5%92%8C%E5%A4%A7%E5%B0%8F"><span class="toc-number">2.4.2.4.</span> <span class="toc-text">4.2.4 vector容量和大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-5-vector%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4"><span class="toc-number">2.4.2.5.</span> <span class="toc-text">4.2.5 vector插入和删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-6-vector%E6%95%B0%E6%8D%AE%E5%AD%98%E5%8F%96"><span class="toc-number">2.4.2.6.</span> <span class="toc-text">4.2.6 vector数据存取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-7-vector%E4%BA%92%E6%8D%A2%E5%AE%B9%E5%99%A8"><span class="toc-number">2.4.2.7.</span> <span class="toc-text">4.2.7 vector互换容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-8-%E9%A2%84%E7%95%99%E7%A9%BA%E9%97%B4"><span class="toc-number">2.4.2.8.</span> <span class="toc-text">4.2.8 预留空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-9-%E6%A8%A1%E6%9D%BF%E7%B1%BBarray"><span class="toc-number">2.4.2.9.</span> <span class="toc-text">4.2.9 模板类array</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#deque%E5%AE%B9%E5%99%A8"><span class="toc-number">2.4.3.</span> <span class="toc-text">deque容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#deque%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.4.3.1.</span> <span class="toc-text">deque基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#deque%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">2.4.3.2.</span> <span class="toc-text">deque构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#deque%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C"><span class="toc-number">2.4.3.3.</span> <span class="toc-text">deque赋值操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#deque%E5%A4%A7%E5%B0%8F%E6%93%8D%E4%BD%9C"><span class="toc-number">2.4.3.4.</span> <span class="toc-text">deque大小操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#deque%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4"><span class="toc-number">2.4.3.5.</span> <span class="toc-text">deque插入和删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#deque%E6%95%B0%E6%8D%AE%E5%AD%98%E5%8F%96"><span class="toc-number">2.4.3.6.</span> <span class="toc-text">deque数据存取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#deque%E6%8E%92%E5%BA%8F"><span class="toc-number">2.4.3.7.</span> <span class="toc-text">deque排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-%E8%AF%84%E5%A7%94%E6%89%93%E5%88%86"><span class="toc-number">2.4.4.</span> <span class="toc-text">案例-评委打分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stack%E5%AE%B9%E5%99%A8"><span class="toc-number">2.4.5.</span> <span class="toc-text">stack容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#stack%E5%AE%B9%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.4.5.1.</span> <span class="toc-text">stack容器基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#stack%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.4.5.2.</span> <span class="toc-text">stack常用接口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#queue%E5%AE%B9%E5%99%A8"><span class="toc-number">2.4.6.</span> <span class="toc-text">queue容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.4.6.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#queue%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.4.6.2.</span> <span class="toc-text">queue常用接口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#list%E5%AE%B9%E5%99%A8"><span class="toc-number">2.4.7.</span> <span class="toc-text">list容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#list%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.4.7.1.</span> <span class="toc-text">list基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#list%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">2.4.7.2.</span> <span class="toc-text">list构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#list%E8%B5%8B%E5%80%BC%E5%92%8C%E4%BA%A4%E6%8D%A2"><span class="toc-number">2.4.7.3.</span> <span class="toc-text">list赋值和交换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#list%E5%A4%A7%E5%B0%8F%E6%93%8D%E4%BD%9C"><span class="toc-number">2.4.7.4.</span> <span class="toc-text">list大小操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#list%E6%8F%92%E5%85%A5%E4%B8%8E%E5%88%A0%E9%99%A4"><span class="toc-number">2.4.7.5.</span> <span class="toc-text">list插入与删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#list%E6%95%B0%E6%8D%AE%E5%AD%98%E5%8F%96"><span class="toc-number">2.4.7.6.</span> <span class="toc-text">list数据存取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#list%E5%8F%8D%E8%BD%AC%E4%B8%8E%E6%8E%92%E5%BA%8F"><span class="toc-number">2.4.7.7.</span> <span class="toc-text">list反转与排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E6%A1%88%E4%BE%8B"><span class="toc-number">2.4.7.8.</span> <span class="toc-text">排序案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#set-multiset-%E5%AE%B9%E5%99%A8%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%89"><span class="toc-number">2.4.8.</span> <span class="toc-text">set&#x2F; multiset 容器（集合）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#set-multiset%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.4.8.1.</span> <span class="toc-text">set&#x2F;multiset基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#set%E6%9E%84%E9%80%A0%E5%92%8C%E8%B5%8B%E5%80%BC"><span class="toc-number">2.4.8.2.</span> <span class="toc-text">set构造和赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#set%E5%A4%A7%E5%B0%8F%E5%92%8C%E4%BA%A4%E6%8D%A2"><span class="toc-number">2.4.8.3.</span> <span class="toc-text">set大小和交换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#set%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4"><span class="toc-number">2.4.8.4.</span> <span class="toc-text">set插入和删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#set%E6%9F%A5%E6%89%BE%E5%92%8C%E7%BB%9F%E8%AE%A1"><span class="toc-number">2.4.8.5.</span> <span class="toc-text">set查找和统计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#set%E5%92%8Cmultiset%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.4.8.6.</span> <span class="toc-text">set和multiset的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pair%E9%98%9F%E7%BB%84%E5%88%9B%E5%BB%BA"><span class="toc-number">2.4.8.7.</span> <span class="toc-text">pair队组创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#set%E5%AE%B9%E5%99%A8%E6%8E%92%E5%BA%8F"><span class="toc-number">2.4.8.8.</span> <span class="toc-text">set容器排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">2.4.8.9.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map-multimap%E5%AE%B9%E5%99%A8"><span class="toc-number">2.4.9.</span> <span class="toc-text">map&#x2F; multimap容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#map-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.4.9.1.</span> <span class="toc-text">map 基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#map-%E6%9E%84%E9%80%A0%E5%92%8C%E8%B5%8B%E5%80%BC"><span class="toc-number">2.4.9.2.</span> <span class="toc-text">map 构造和赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#map%E5%A4%A7%E5%B0%8F%E5%92%8C%E4%BA%A4%E6%8D%A2"><span class="toc-number">2.4.9.3.</span> <span class="toc-text">map大小和交换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#map-%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4"><span class="toc-number">2.4.9.4.</span> <span class="toc-text">map 插入和删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#map-%E6%9F%A5%E6%89%BE%E5%92%8C%E7%BB%9F%E8%AE%A1"><span class="toc-number">2.4.9.5.</span> <span class="toc-text">map 查找和统计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#map-%E5%AE%B9%E5%99%A8%E6%8E%92%E5%BA%8F"><span class="toc-number">2.4.9.6.</span> <span class="toc-text">map 容器排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-%E5%91%98%E5%B7%A5%E5%88%86%E7%BB%84"><span class="toc-number">2.4.9.7.</span> <span class="toc-text">案例-员工分组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%BA%93"><span class="toc-number">2.4.9.8.</span> <span class="toc-text">其他库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="toc-number">2.4.9.9.</span> <span class="toc-text">初始化列表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STL-%E2%80%93-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.5.</span> <span class="toc-text">STL – 函数对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">2.5.1.</span> <span class="toc-text">5.1 函数对象的概念及使用方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%93%E8%AF%8D"><span class="toc-number">2.5.2.</span> <span class="toc-text">谓词</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.5.3.</span> <span class="toc-text">内建函数对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%95%B0%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.5.3.1.</span> <span class="toc-text">算数函数对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E4%BB%BF%E5%87%BD%E6%95%B0"><span class="toc-number">2.5.3.2.</span> <span class="toc-text">关系仿函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E4%BB%BF%E5%87%BD%E6%95%B0"><span class="toc-number">2.5.3.3.</span> <span class="toc-text">逻辑仿函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STL-%E2%80%93-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95"><span class="toc-number">2.6.</span> <span class="toc-text">STL – 常用算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95"><span class="toc-number">2.6.1.</span> <span class="toc-text">常用遍历算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95"><span class="toc-number">2.6.2.</span> <span class="toc-text">常用查找算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">2.6.3.</span> <span class="toc-text">常用排序算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">2.6.4.</span> <span class="toc-text">常用拷贝和替换算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%AE%97%E6%9C%AF%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95"><span class="toc-number">2.6.5.</span> <span class="toc-text">常用算术生成算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88%E7%AE%97%E6%B3%95"><span class="toc-number">2.6.6.</span> <span class="toc-text">常用集合算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E3%80%81%E8%BE%93%E5%87%BA%E5%92%8C%E6%96%87%E4%BB%B6"><span class="toc-number">2.7.</span> <span class="toc-text">输出、输出和文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E5%92%8C%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">2.7.1.</span> <span class="toc-text">流和缓冲区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-number">2.7.2.</span> <span class="toc-text">输出重定向</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E8%BE%93%E5%87%BA"><span class="toc-number">2.7.3.</span> <span class="toc-text">关于输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E8%BE%93%E5%85%A5"><span class="toc-number">2.7.4.</span> <span class="toc-text">关于输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6-1"><span class="toc-number">2.7.5.</span> <span class="toc-text">文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-11"><span class="toc-number">2.8.</span> <span class="toc-text">C ++ 11</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.8.1.</span> <span class="toc-text">新类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9F%E4%B8%80%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.8.2.</span> <span class="toc-text">统一的初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E"><span class="toc-number">2.8.3.</span> <span class="toc-text">声明</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#auto"><span class="toc-number">2.8.3.1.</span> <span class="toc-text">auto</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#decltype"><span class="toc-number">2.8.3.2.</span> <span class="toc-text">decltype</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B0%E5%A2%9E%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E5%90%8E%E7%BD%AE"><span class="toc-number">2.8.3.3.</span> <span class="toc-text">新增返回类型后置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E5%88%AB%E5%90%8D"><span class="toc-number">2.8.3.4.</span> <span class="toc-text">模板别名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nullptr"><span class="toc-number">2.8.3.5.</span> <span class="toc-text">nullptr</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88-1"><span class="toc-number">2.8.4.</span> <span class="toc-text">智能指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E6%96%B9%E9%9D%A2%E5%81%9A%E5%87%BA%E7%9A%84%E4%BF%AE%E6%94%B9"><span class="toc-number">2.8.5.</span> <span class="toc-text">异常方面做出的修改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%86%85%E6%9E%9A%E4%B8%BE"><span class="toc-number">2.8.6.</span> <span class="toc-text">作用域内枚举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E7%B1%BB%E7%9A%84%E4%BF%AE%E6%94%B9"><span class="toc-number">2.8.7.</span> <span class="toc-text">对类的修改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-number">2.8.8.</span> <span class="toc-text">右值引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E4%B8%8E%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-number">2.8.9.</span> <span class="toc-text">移动语义与右值引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.8.9.1.</span> <span class="toc-text">移动示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-10-2-%E8%A7%A3%E9%87%8A"><span class="toc-number">2.8.9.2.</span> <span class="toc-text">8.10.2 解释</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-10-3-%E8%B5%8B%E5%80%BC"><span class="toc-number">2.8.9.3.</span> <span class="toc-text">8.10.3 赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-10-4-%E5%BC%BA%E5%88%B6%E7%A7%BB%E5%8A%A8"><span class="toc-number">2.8.9.4.</span> <span class="toc-text">8.10.4 强制移动</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E7%9A%84%E7%B1%BB%E5%8A%9F%E8%83%BD"><span class="toc-number">2.8.10.</span> <span class="toc-text">新的类功能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%9C%B0%E6%96%B9%E6%B3%95%E5%92%8C%E7%A6%81%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">2.8.10.1.</span> <span class="toc-text">默认地方法和禁用的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A7%94%E6%89%98%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">2.8.10.2.</span> <span class="toc-text">委托构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">2.8.10.3.</span> <span class="toc-text">继承构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E7%90%86%E8%99%9A%E6%96%B9%E6%B3%95%EF%BC%9Aoverride-%E5%92%8C-final"><span class="toc-number">2.8.10.4.</span> <span class="toc-text">管理虚方法：override 和 final</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">2.8.11.</span> <span class="toc-text">lambda表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E3%80%81%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E5%92%8Clambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">2.8.11.1.</span> <span class="toc-text">比较函数指针、函数对象和lambda表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BD%95%E4%BD%BF%E7%94%A8lambda"><span class="toc-number">2.8.11.2.</span> <span class="toc-text">为何使用lambda</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E5%99%A8"><span class="toc-number">2.8.12.</span> <span class="toc-text">包装器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="toc-number">2.8.13.</span> <span class="toc-text">可变参数模板</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/03/25/Docker-%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/" title="Docker 安装使用"><img src="https://s2.loli.net/2023/03/08/uGwMa9pFQIkbYRe.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Docker 安装使用"/></a><div class="content"><a class="title" href="/2023/03/25/Docker-%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/" title="Docker 安装使用">Docker 安装使用</a><time datetime="2023-03-25T14:11:38.000Z" title="发表于 2023-03-25 22:11:38">2023-03-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/19/MySQL%E6%9B%B4%E6%94%B9%E8%AE%B0/" title="MySQL更改记"><img src="https://s2.loli.net/2023/03/08/9waDWSj7yLAhNnX.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL更改记"/></a><div class="content"><a class="title" href="/2023/02/19/MySQL%E6%9B%B4%E6%94%B9%E8%AE%B0/" title="MySQL更改记">MySQL更改记</a><time datetime="2023-02-19T08:05:57.000Z" title="发表于 2023-02-19 16:05:57">2023-02-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/05/Spring/" title="Spring"><img src="https://s2.loli.net/2023/03/08/7Y9Z5zTQL4UFX1S.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring"/></a><div class="content"><a class="title" href="/2022/12/05/Spring/" title="Spring">Spring</a><time datetime="2022-12-05T06:51:15.000Z" title="发表于 2022-12-05 14:51:15">2022-12-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/11/Java-Web/" title="Java Web"><img src="https://s2.loli.net/2023/03/08/KtyIJoiUDauNTjb.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java Web"/></a><div class="content"><a class="title" href="/2022/11/11/Java-Web/" title="Java Web">Java Web</a><time datetime="2022-11-11T11:44:02.000Z" title="发表于 2022-11-11 19:44:02">2022-11-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/11/C-Plus-Plus/" title="C Plus Plus"><img src="https://s2.loli.net/2022/11/30/bla2mxhQ9jwJMGO.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C Plus Plus"/></a><div class="content"><a class="title" href="/2022/04/11/C-Plus-Plus/" title="C Plus Plus">C Plus Plus</a><time datetime="2022-04-11T04:07:50.000Z" title="发表于 2022-04-11 12:07:50">2022-04-11</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 含光</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"left"},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>