<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Manjaro</title>
      <link href="/2026/01/16/Manjaro/"/>
      <url>/2026/01/16/Manjaro/</url>
      
        <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol><li>iso 镜像 – <a href="https://manjaro.org/products/download/x86">https://manjaro.org/products/download/x86</a> 选择 KDE Plasma</li><li>启动盘制作 – rufus</li><li>Dell 笔记本 F2 进入 BIOS 关闭安全启动</li><li>Boot with open source drivers</li><li>Manjaro Hello -&gt; Launch installer</li><li>用户界面中接入网络</li><li>时区 Asia&#x2F;Shanghai，输入法 default</li><li>分区 –&gt; Erase Disk -&gt; ext4 16GB 交换分区</li><li>设置用户名，暂时不配置 office 选项</li><li>安装</li></ol><h2 id="安装后配置"><a href="#安装后配置" class="headerlink" title="安装后配置"></a>安装后配置</h2><p>更新软件源（有没有UI都行）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman-mirrors -i -c China -m rank</span><br></pre></td></tr></table></figure><p>在弹出的界面中选择速度比较快的加入到镜像文件中</p><p>更新软件源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -Syu</span><br></pre></td></tr></table></figure><p>使用 AUR</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -Sy yay</span><br></pre></td></tr></table></figure><p><code>/etc/pacman.conf</code> 中配置 Archlinux 镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Server = https://mirrors.ustc.edu.cn/archlinuxcn/$arch</span><br><span class="line">Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch</span><br><span class="line">Server = https://mirrors.hit.edu.cn/archlinuxcn/$arch</span><br><span class="line">Server = https://repo.huaweicloud.com/archlinuxcn/$arch</span><br></pre></td></tr></table></figure><h2 id="yay-教程"><a href="#yay-教程" class="headerlink" title="yay 教程"></a>yay 教程</h2><p>搜索：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay packageName</span><br></pre></td></tr></table></figure><p>安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S packageName</span><br></pre></td></tr></table></figure><p>查看已安装软件包的信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -Qi packageName</span><br></pre></td></tr></table></figure><p>查看已安装软件包的文件安装路径：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -Ql packageName</span><br></pre></td></tr></table></figure><p>清理构建缓存：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -Sc</span><br></pre></td></tr></table></figure><p>删除无用软件包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -Yc</span><br></pre></td></tr></table></figure><h2 id="安装SSH"><a href="#安装SSH" class="headerlink" title="安装SSH"></a>安装SSH</h2><p>习惯使用远程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S openssh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动一次</span></span><br><span class="line">sudo systemctl start sshd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置开机自启</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> sshd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证 SSH 是否正常运行</span></span><br><span class="line">systemctl status sshd</span><br></pre></td></tr></table></figure><h2 id="安装-V2rayA"><a href="#安装-V2rayA" class="headerlink" title="安装 V2rayA"></a>安装 V2rayA</h2><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S v2raya</span><br></pre></td></tr></table></figure><p>启动服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start v2raya.service</span><br></pre></td></tr></table></figure><p>设置开机自启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> v2raya.service</span><br></pre></td></tr></table></figure><p>随后通过浏览器管理代理配置</p><h2 id="截图工具"><a href="#截图工具" class="headerlink" title="截图工具"></a>截图工具</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S flameshot</span><br></pre></td></tr></table></figure><p>系统设置中新增快捷键 -&gt; 命令 <code>flameshot gui</code> -&gt; 名称为截图，快捷键为 F1</p><p>配置 flameshot 使它的操作方式更贴近 snipaste，应用内快捷键：在桌面上固定图像 -&gt; F3</p><p>主要的配置就这么多。</p><h2 id="输入法"><a href="#输入法" class="headerlink" title="输入法"></a>输入法</h2><p>所需按安装的软件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S fcitx5 </span><br><span class="line">sudo pacman -S fcitx5-configtool  </span><br><span class="line">sudo pacman -S fcitx5-qt</span><br><span class="line">sudo pacman -S fcitx5-gtk</span><br><span class="line">sudo pacman -S fcitx5-chinese-addons</span><br><span class="line">sudo pacman -S kcm-fcitx5</span><br><span class="line">sudo pacman -S fcitx5-lua</span><br></pre></td></tr></table></figure><p>将以下配置写入 <code>/etc/environment</code> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GTK_IM_MODULE=fcitx5</span><br><span class="line">QT_IM_MODULE=fcitx5</span><br><span class="line">XMODIFIERS=&quot;@im=fcitx&quot;</span><br><span class="line">INPUT_METHOD=fcitx5</span><br></pre></td></tr></table></figure><p>将以下配置写入 <code>~/.profile</code> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export GTK_IM_MODULE=fcitx5</span><br><span class="line">export QT_IM_MODULE=fcitx5</span><br><span class="line">export XMODIFIERS=&quot;@im=fcitx&quot;</span><br><span class="line">export INPUT_METHOD=fcitx5</span><br></pre></td></tr></table></figure><p>重启或者至少注销后再登入</p><p>打开设置，选择 语言与时间 -&gt; 输入法，添加拼音和英语（美国）</p><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>全局主题：Layan</p><p>应用程序外观样式：kvtanum</p><p>Plasma外观样式：Layan</p><p>窗口装饰元素：Summaculate Day Blur</p><p>图标：Papirus</p><p>光标：默认</p><p>欢迎屏幕：Layan</p><p>SDDM：WhiteSur-Dark + 自定义背景（Plasma 6 设置Layan 不成功）</p><p>启动屏幕：默认 Manjaro</p><h2 id="美化"><a href="#美化" class="headerlink" title="美化"></a>美化</h2><h4 id="neofetch"><a href="#neofetch" class="headerlink" title="neofetch"></a>neofetch</h4><p>Manjaro 默认安装了 neofetch 和 lolcat</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> neofetch=<span class="string">&#x27;neofetch --ascii_distro Arch | lolcat&#x27;</span></span><br></pre></td></tr></table></figure><p>前半句将图标修改为 Arch 发行版的图标，通过管道将结果交给 lolcat 进行色彩条调整</p><h4 id="p10k"><a href="#p10k" class="headerlink" title="p10k"></a>p10k</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p10k configure</span><br></pre></td></tr></table></figure><p>按照提示选择喜欢的样式即可</p><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>与 Ubuntu 相比，Manjaro 下安装 Docker 要简单得多</p><p>更新软件源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -Syu</span><br></pre></td></tr></table></figure><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S Docker</span><br></pre></td></tr></table></figure><p>安装后的操作都可以按照先前文章《Docker 安装使用》配置</p><h2 id="微信"><a href="#微信" class="headerlink" title="微信"></a>微信</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S wechat</span><br></pre></td></tr></table></figure><p>建议启用沙箱环境</p><blockquote><p>将语言改成英文后，微信无法启动，待确认微信的运行是否与语言设置有相关性。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Token刷新方案</title>
      <link href="/2024/03/10/Token%E5%88%B7%E6%96%B0%E6%96%B9%E6%A1%88/"/>
      <url>/2024/03/10/Token%E5%88%B7%E6%96%B0%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h1 id="Token-刷新方案"><a href="#Token-刷新方案" class="headerlink" title="Token 刷新方案"></a>Token 刷新方案</h1><p>在这篇文章中，我想写最近在做项目的时候使用的 token 刷新机制。</p><p>在上一篇 Spring Security 的文章中，在 login 中我使用 id 作为 key 来创建 token，token 最大生存周期为 7 天，将 token 和用户信息存入 Redis 的时候并没有设置过期时间，这意味着除非用户 logout，用户信息将在 Redis 中持续存在，若 token 过期则用户必须重新登录，此过程中需要删除原有 token（在 Redis 中以<code>&quot;login:&quot; + current.getId()</code>为 key 存储了 token，以<code>&quot;token:&quot;</code>为 key 存储了用户信息），导致不必要的开销，并且 token 刷新做的比较粗糙。</p><h2 id="Token-生存期"><a href="#Token-生存期" class="headerlink" title="Token 生存期"></a>Token 生存期</h2><p>翻阅资料得知，创建 token 时如果不指定过期时间，则 token 永久有效，可以通过给 Redis 中存储的用户信息设置过期时间，在用户长时间无操作的情况下，强制用户下线。</p><p>经过他人点拨和头脑风暴之后，我重新整理了 Redis 存储用户信息的方式。以 token 作为 key 存储用户信息，将 Redis 中用户信息过期时间设置为 24 小时，用户访问资源时，在过滤器中实现 token 续签（若 token 有效期在 30 分钟以内，则将 token 过期时间向后推一天）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不指定 token 过期时间，Redis中 token 过期则无法访问资源</span></span><br><span class="line"><span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> JwtTokenUtil.createToken(Integer.toString(currentUser.getId()), <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 redis 中存储方式改为如下方案，过期时间设置为一天</span></span><br><span class="line">redisUtil.set(token, loginUser, <span class="number">3600</span> * <span class="number">24</span>);</span><br></pre></td></tr></table></figure><p>这种情况下，用户需要途径得知自己手中的 token 是否可用，即 token 是否已经过期:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redisUtil.getExpire(token)</span><br></pre></td></tr></table></figure><p>上面一行代码可用于查询 token 过期时间，得到的值为  -2 说明已经过期， -1 说明永久有效，大于 0 表示再过多长时间（时间单位可以自定义）。</p><p>过滤器中续签 token：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (redisUtil.getExpire(token) &lt; <span class="number">30</span> * <span class="number">60</span>) &#123;</span><br><span class="line">    <span class="comment">// 将过期时间延长一天</span></span><br><span class="line">    redisUtil.expire(token, <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将用户信息存进 securityContextHolder 中</span></span><br><span class="line"><span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authenticationToken</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(loginUser, <span class="literal">null</span>, loginUser.getAuthorities());</span><br><span class="line">SecurityContextHolder.getContext().setAuthentication(authenticationToken);</span><br></pre></td></tr></table></figure><p>token 过期的情况下，一定要重新登录。</p><h2 id="再遇问题"><a href="#再遇问题" class="headerlink" title="再遇问题"></a>再遇问题</h2><p>按照上面方法在 Redis 中存储数据确实较为方便，但是也带来了一些问题。</p><p>当用户需要修改用户名、密码等账户信息的时候，需要传入 token 以达到更新 Redis 中用户信息的目的。但是传入 token 是让我不能够容忍的，因此，需要重新考虑用户信息在 Redis 中的存储方式。</p><p>采用以用户 id 为 key 存储用户信息的方式，在 User 实体中加入 token 字段，用于校验 token 可用性。</p>]]></content>
      
      
      <categories>
          
          <category> 问题解决 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
            <tag> Redis </tag>
            
            <tag> Spring Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Security</title>
      <link href="/2024/03/05/Spring-Security/"/>
      <url>/2024/03/05/Spring-Security/</url>
      
        <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><h2 id="认证方式"><a href="#认证方式" class="headerlink" title="认证方式"></a>认证方式</h2><p>首先介绍基于 session 的认证流程：在用户登录成功之后，在服务端生成用户相关的数据保存在session 中， 发送给客户端请求时带上 session_id 就可以验证服务器是不是存在 session 的数据，以此完成用户的合法校验，当用户退出系统或者 session 过期销毁时，客户端的 session 就失效（session 是存在 tomcat 服务器中的）。</p><p>而基于 token 的认证方式，交互流程是：在用户认证成功之后，服务器僧成一个 token，发送给客户端，客户算可以将 token 放在 cookie 或者 localStorage 中存储，每次请求的时候带上这个 token，服务器收到 token 通过验证即可确认用户身份（不强制要求 token 存储在哪里）。</p><p>基于 session 的认证方式由 Servlet 规范定制服务端存储 session，服务端存储 session Cincinnati需要占用内存资源，客户端需要支持 cookie；而基于 token 的方式一般不需要在服务端存储 token，并且不限制客户端的存储方式。（token 方式更为合适）</p><h2 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h2><p>已登录的用户和未登录的用户能够访问的权限未必是一样的 ，而根据用户的权限来控制用户使用资源的过程就是授权。</p><p>认证是为了保护用户身份的合法性，授权是为了更细粒度地对隐私数据进行划分，授权是在认证通过之后发生的，控制不同用户访问不同的资源。</p><p>授权则是用户认证通过之后，根据用户的权限来控制及用户访问资源的过程，拥有资源的访问权限则正常访问，否则拒绝访问。</p><p>授权的实现需要结合数据库表，构建角色。</p><h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><p>创建 Maven 工程（不使用骨架），创建包和启动类（好像2023版本的IDEA一定要使用骨架创建项目）</p><p>打开 pom.xml 文件，添加父工程依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><p>必须的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>编写启动类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringSecurityDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(SpringSecurityDemo.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写一个 controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Controller</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引入 SpringSecurity 之后启动项目，访问 localhost:port&#x2F;hello，会先跳转到默认的 login 页面。默认的用户名为 user，密码在控制台中。</p><p>默认退出登录页：localhost:port&#x2F;logout</p><h1 id="SpringSecurity原理"><a href="#SpringSecurity原理" class="headerlink" title="SpringSecurity原理"></a>SpringSecurity原理</h1><p>SpringSecurity的原理是实现了一个过滤器链，包括各种功能的过滤器。</p><p>入门案例中使用到的过滤器：</p><p>前端发请求到被接口捕获过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[请求]--&gt;B[...]--&gt;C[UsernamePasswordAuthenticationFilter]--&gt;D[...]--&gt;E[ExceptionTranslationFilter]--&gt;F[FilterSecurityInterceptor]--&gt;G[API]</span><br></pre></td></tr></table></figure><p>后端响应前端请求的过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph  RL</span><br><span class="line">A[API]--&gt;B[FilterSecurityInterceptor]--&gt;C[ExceptionTranslationFilter]--&gt;D[...]--&gt;E[UsernamePasswordAuthenticationFilter]--&gt;F[...]--&gt;G[响应]</span><br></pre></td></tr></table></figure><p>上述流程中只展示了比较核心的几个过滤器，非核心的部分没有在图中显示。</p><p>各过滤器的作用：</p><ul><li>UsernamePasswordAuthenticationFilter：负责处理登录请求；</li><li>ExceptionTranslationFilter：处理过滤器链中抛出的任何 AccessDeniedException 和 AuthenticationException；</li><li>FilterSecurityInterceptor：负责权限校验的过滤器。</li></ul><p>如何查看过滤器链：</p><ul><li>接收启动类 SpringSecurityDemo 中 SpringApplication.run() 的返回值 run，打印一点东西，然后在输出语句上设置断点；</li><li>启动 debug，在 Evaluate Expression 窗口中输入：run.getBean(DefaultSecurityFilterChain.class)；</li><li>展开 filter 可以看到入门案例中用到了那些过滤器</li></ul><p> 如图所示： <img src="https://s2.loli.net/2024/03/05/nrfeRhPlvsxAyTq.png" style="zoom: 60%"/> </p><h1 id="认证流程"><a href="#认证流程" class="headerlink" title="认证流程"></a>认证流程</h1><p>认证流程在引入部分已经谈到一些，用户发起登录请求 -&gt; 后端返回 jwt 生成的 token -&gt; 前端携带 token 发起请求 -&gt; 后端校验 token 有效性 -&gt; 响应前端请求</p><p>这里说的认证流程不再完全是逻辑上的流程，而是 Security 的具体实现：</p><img src="https://s2.loli.net/2024/03/05/m4res5MuzUZwSO7.png"><ul><li>Authentication实现类表示当前访问系统的用户，封装了用户相关信息；</li><li>AuthenticationManager接口：定义了认证 Authentication 的方法；</li><li>UserDetailsService接口：加载用户特定数据的核心接口，其中定义了一个根据用户名查询用户信息的方法；</li><li>UserDetails接口：提供核心用户信息，通过USerDetailsService根据用户名获取用户信息，封装成UserDetails对象返回。再将这些信息封装到Authentication对象中。</li></ul><h1 id="SpringBoot-项目实现认证的解决方案"><a href="#SpringBoot-项目实现认证的解决方案" class="headerlink" title="SpringBoot 项目实现认证的解决方案"></a>SpringBoot 项目实现认证的解决方案</h1><h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><ol><li>自定义登录接口，调用 ProviderManager 方法进行认证，认证通过则生成 token</li><li>自定义 UserDetailsService（重写 loadUserByUsername方法）</li></ol><h2 id="校验"><a href="#校验" class="headerlink" title="校验"></a>校验</h2><ol><li>定义 jwt 认证过滤器</li><li>解析 token，从redis中获取用户信息并存入 securityContext</li></ol><h1 id="认证实现"><a href="#认证实现" class="headerlink" title="认证实现"></a>认证实现</h1><ol><li>数据库</li></ol><p>创建用户信息表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">use db1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> tb_account;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tb_account (</span><br><span class="line">    id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">    username <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> <span class="string">&#x27;null&#x27;</span>,</span><br><span class="line">    nickname <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> <span class="string">&#x27;null&#x27;</span>,</span><br><span class="line">    password <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> <span class="string">&#x27;null&#x27;</span>,</span><br><span class="line">    status <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>,</span><br><span class="line">    email <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">telephone <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="keyword">null</span>,</span><br><span class="line">sex <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">default</span> <span class="keyword">null</span> comment <span class="string">&#x27;用户性别（0男，1女，2未知&#x27;</span>,</span><br><span class="line">avatar <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">default</span> <span class="keyword">null</span>,</span><br><span class="line">    user_type <span class="type">char</span>(<span class="number">1</span>) COMMENT <span class="string">&#x27;用户类型（0管理员，1普通用户）&#x27;</span>,</span><br><span class="line">    create_by <span class="type">int</span> <span class="keyword">default</span> <span class="keyword">null</span>,</span><br><span class="line">    create_time DATETIME <span class="keyword">default</span> <span class="keyword">null</span>,</span><br><span class="line">    update_by <span class="type">int</span> <span class="keyword">default</span> <span class="keyword">null</span>,</span><br><span class="line">    update_time DATETIME <span class="keyword">default</span> <span class="keyword">null</span>,</span><br><span class="line">    del_flag <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span> comment <span class="string">&#x27;删除标志位（0为未删除，1代表已经删除）&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>创建一个保存用户个人信息的表，存入一条用户信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_account(id, username, password) <span class="keyword">values</span>(<span class="keyword">null</span>, <span class="string">&#x27;test&#x27;</span>, <span class="string">&#x27;&#123;noop&#125;password&#x27;</span>);</span><br></pre></td></tr></table></figure><p>Spring Security 默认数据库中的密码已被加密，密码数据保存规则：{id}password，根据 id 判断加密方式，{noop} 表示使用明文存储密码。</p><p>一般情况下，使用自己指定 PasswordEncoder，并将 PasswordEncoder 对象注册到 Spring 容器中，Spring Security 就会使用其来进行密码校验（实现时通常使用 BCryptPasswordEncoder 来进行加密）。</p><ol start="2"><li>实现 UserDetailsService</li></ol><p>创建 UserDetailsServiceImpl 并令其 implements UserDetailsService，重写 LoadUserByUsername 方法，实现从数据库中按用户名（不一定是用户名，可以是其他能够唯一标识用户的字段）查询用户信息。 </p><ul><li><p>查询失败：抛出 UsernameNotFoundException，提示信息可以是“用户不存在”</p></li><li><p>查询成功：将用户信息封装成 UserDetails 的实现类进行返回（包括用户信息、用户权限）</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDetailsServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 1. 查询用户信息</span></span><br><span class="line">        QueryWrapper&lt;Account&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">        wrapper.lambda().eq(username != <span class="literal">null</span>, Account::getUsername, username);</span><br><span class="line">        <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> accountDao.selectOne(wrapper);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(account)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UsernameNotFoundException</span>(<span class="string">&quot;用户不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 查询用户权限</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LoginUser</span>(account);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不要忘记将 UserDetailsServiceImpl 交由 Spring 容器管理。</p><ol start="3"><li>实现 UserDetails</li></ol><p>创建 LoginUser 类并令其实现 UserDetails 类，重写 getAuthorities() 、getPassword()、getUsername()、isAccountNonExipred()、isAccountNonlocked()、 isCredentialsNonExpired()、isEnabled()方法。</p><p>这些方法名标注了认证过程需要的参数，登陆状态是否过期、账户是否被锁定、是否可用等。</p><p>重写 getUsername() 方法和 getPassword() 方法的意义是目的是使用从数据库中查询出来的信息与前端传入信息做比对。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginUser</span> <span class="keyword">implements</span> <span class="title class_">UserDetails</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 授权</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回权限信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; getAuthorities() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取用户密码</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 数据库查出来的密码（默认加密方式），将用于与前端传入的密码进行比对</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> user.getPassword();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取用户名</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 用户名字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> user.getUsername();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAccountNonExpired</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAccountNonLocked</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCredentialsNonExpired</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEnabled</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>实现密码加密存储</li></ol><p>网上说 BcryptPasswordEncoder 使用的加密算法是一种 Hash 算法，使用随机生成的盐值和密钥对密码进行加密，这个过程是不可逆的（同样的密码每次得到的密文也不一样）。</p><p>通过将原文与密文进行比对可以得出两者是否匹配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> BCryptPasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">passwordEncoderTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">encode</span> <span class="operator">=</span> encoder.encode(<span class="string">&quot;1234&quot;</span>);</span><br><span class="line">    System.out.println(encode);</span><br><span class="line">    System.out.println(encoder.matches(<span class="string">&quot;1234&quot;</span>, encode));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$2a$10$eA1DmXQWuoRpVx38o4Zqge.QZ2VokD8Qj5OXeJKcyjU.5.V4pzJbi</span><br><span class="line">true</span><br></pre></td></tr></table></figure><ol start="3"><li>token 认证过滤器</li></ol><p>使用自定义过滤器校验 token 是否有效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtAuthenticationTokenFilter</span> <span class="keyword">extends</span> <span class="title class_">OncePerRequestFilter</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisUtil redisUtil;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 1. 获取 token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNullOrEmpty(token)) &#123;</span><br><span class="line">            <span class="comment">// 如果请求头中没有 token 的话，对请求放行，后续过滤器会对不包含认证信息的请求进行拦截</span></span><br><span class="line">            filterChain.doFilter(request, response);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 防止响应过程解析 token</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 解析 token</span></span><br><span class="line">        String idString;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            idString = JwtTokenUtil.resolveToken(token);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 无法解析 token 的情况下，抛出 token 错误异常</span></span><br><span class="line">            ResultUtil.toResp(response, SystemException.TOKEN_ERROR);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 从 redis 中获取用户信息</span></span><br><span class="line">        <span class="type">LoginUser</span> <span class="variable">loginUser</span> <span class="operator">=</span> (LoginUser) redisUtil.get(<span class="string">&quot;login:&quot;</span> + idString);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(loginUser)) &#123;</span><br><span class="line">            <span class="comment">//  token 过期的情况下，是获取不到用户信息的</span></span><br><span class="line">            ResultUtil.toResp(response, SystemException.USER_UNLOGIN);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 将用户信息存进 securityContextHolder 中</span></span><br><span class="line">        <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authenticationToken</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(loginUser.getUser().getId(), <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// TODO 获取权限信息，封装到 Authentication</span></span><br><span class="line">        SecurityContextHolder.getContext().setAuthentication(authenticationToken);</span><br><span class="line"></span><br><span class="line">        filterChain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>security配置</li></ol><p>有一些基础配置：认证管理器、加密器、接口放行规则和添加自定义过滤器等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将 BCryptPasswordEncoder 交给 Spring 容器管理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 加密器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> BCryptPasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取认证管理器，登录认证时使用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> authenticationConfiguration 认证配置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回认证管理器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception 可能抛出的异常类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> AuthenticationManager <span class="title function_">authenticationManager</span><span class="params">(AuthenticationConfiguration authenticationConfiguration)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> authenticationConfiguration.getAuthenticationManager();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">securityFilterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http</span><br><span class="line">                <span class="comment">// 使用 jwt 生成 token 进行认证，不使用 csrf 也不用从 session 中获取 token</span></span><br><span class="line">                .csrf().disable()</span><br><span class="line">                <span class="comment">// 不通过 Session 获取 securitySession</span></span><br><span class="line">                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)</span><br><span class="line">                .and()</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                <span class="comment">// 接口放行</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/api/login&quot;</span>, <span class="string">&quot;/api/register&quot;</span>, <span class="string">&quot;api/upload&quot;</span>, <span class="string">&quot;/api/index&quot;</span>).anonymous()</span><br><span class="line">                <span class="comment">// 其他接口均需要认证</span></span><br><span class="line">                .anyRequest().authenticated();</span><br><span class="line">        </span><br><span class="line">        http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 允许跨域</span></span><br><span class="line">        http.cors();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>根据业务逻辑实现认证</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;AccountDao, User&gt; <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationManager authenticationManager;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisUtil redisUtil;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户登录认证</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> user 接收用户名和密码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回 token 和用户信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">login</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. AuthenticationManager 身份认证</span></span><br><span class="line">        <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authenticationToken</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(user.getUsername(), user.getPassword());</span><br><span class="line"></span><br><span class="line">        Authentication authentication;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            authentication = authenticationManager.authenticate(authenticationToken);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UsernameNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServiceException</span>(SystemException.USER_NOT_EXIST);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BadCredentialsException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServiceException</span>(SystemException.USERNAME_OR_PASSWORD_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 认证不通过，给予用户提示</span></span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(authentication)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServiceException</span>(SystemException.USERNAME_OR_PASSWORD_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 认证通过，使用 userId 生成 token 并将用户信息存入 redis</span></span><br><span class="line">        <span class="type">LoginUser</span> <span class="variable">loginUser</span> <span class="operator">=</span> ((LoginUser) authentication.getPrincipal());</span><br><span class="line">        <span class="type">User</span> <span class="variable">current</span> <span class="operator">=</span> loginUser.getUser();</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> JwtTokenUtil.createToken(Integer.toString(current.getId()), <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 将用户信息（包括权限信息）存入 Redis</span></span><br><span class="line">        redisUtil.set(<span class="string">&quot;login:&quot;</span> + current.getId(), loginUser);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回 token 和用户信息</span></span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;token&quot;</span>, token);</span><br><span class="line">        current.setPassword(<span class="literal">null</span>);</span><br><span class="line">        map.put(<span class="string">&quot;userInfo&quot;</span>, current);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ResultUtil.success(<span class="string">&quot;success&quot;</span>, map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;String&gt; <span class="title function_">logout</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 从 SecurityContextHolder 中获取用户 id</span></span><br><span class="line">        <span class="type">Authentication</span> <span class="variable">authentication</span> <span class="operator">=</span> SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">id</span> <span class="operator">=</span> (Integer) authentication.getPrincipal();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 删除 redis 中的用户信息（删除用户的已登录状态）</span></span><br><span class="line">        <span class="keyword">return</span> redisUtil.delete(<span class="string">&quot;login:&quot;</span> + id) &gt; <span class="number">0</span> ? ResultUtil.success(<span class="string">&quot;已成功退出登录&quot;</span>) : ResultUtil.error(<span class="string">&quot;退出登录失败，请重试&quot;</span>, -<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是否需要将 token 存入 redis 这件事还需要进一步研究。</p><h1 id="授权流程"><a href="#授权流程" class="headerlink" title="授权流程"></a>授权流程</h1><p>Spring Security中，使用默认的 FilterSecurityInterceptor 进行权限校验。在 FilterSecurityInterceptor 中会从 SecurityContextHolder 获取其中的 authentication，然后获取其中权限信息。以此来判断用户是否拥有访问当前资源的权限。</p><p>因此需要将权限信息也存进 authentication 中。</p><h1 id="授权实现"><a href="#授权实现" class="headerlink" title="授权实现"></a>授权实现</h1><ol><li>数据库中创建权限表</li></ol><p>包括 menu 表、角色表、用户-角色表、角色菜单表在内的五张表（实际上可能只需要一张，对用户和需要的权限进行标识，属性包括：用户id 和 权限名称，两者构成主键）</p><p>RBAC 模式下的权限表需要：</p><p><img src="https://s2.loli.net/2024/03/05/UmI5w9sSPRQheTn.png" alt="RBAC.png"></p><p>建表脚本：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">use db1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> `tb_menu`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> `tb_menu` (</span><br><span class="line">`id` <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">`menu_name` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> <span class="string">&#x27;null&#x27;</span>,</span><br><span class="line">`path` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">default</span> <span class="keyword">null</span> comment <span class="string">&#x27;路由地址&#x27;</span>,</span><br><span class="line">component <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">default</span> <span class="keyword">null</span> comment <span class="string">&#x27;组件路径&#x27;</span>,</span><br><span class="line">`visible` <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">default</span> <span class="string">&#x27;0&#x27;</span> comment <span class="string">&#x27;菜单状态(0显示 1隐藏）&#x27;</span>,</span><br><span class="line">`status` <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">default</span> <span class="string">&#x27;0&#x27;</span> comment <span class="string">&#x27;菜单状态（0正常 1停用）&#x27;</span>,</span><br><span class="line">`perms` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">default</span> <span class="keyword">null</span> comment <span class="string">&#x27;权限标识&#x27;</span>,</span><br><span class="line">`icon` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">default</span> <span class="string">&#x27;#&#x27;</span> comment <span class="string">&#x27;菜单图标&#x27;</span>,</span><br><span class="line">`create_by` <span class="type">int</span> <span class="keyword">default</span> <span class="keyword">null</span>,</span><br><span class="line">`create_time` <span class="type">date</span> <span class="keyword">default</span> <span class="keyword">null</span>,</span><br><span class="line">`update_by` <span class="type">int</span> <span class="keyword">default</span> <span class="keyword">null</span>,</span><br><span class="line">`update_time` <span class="type">date</span> <span class="keyword">default</span> <span class="keyword">null</span>,</span><br><span class="line">`del_flag` <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span> comment <span class="string">&#x27;是否删除（0未删除 1已删除）&#x27;</span>,</span><br><span class="line">`remark` <span class="type">varchar</span>(<span class="number">500</span>) <span class="keyword">default</span> <span class="keyword">null</span> comment <span class="string">&#x27;备注&#x27;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> `tb_role` (</span><br><span class="line">`id` <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">`name` <span class="type">varchar</span>(<span class="number">18</span>) <span class="keyword">default</span> <span class="keyword">null</span>,</span><br><span class="line">`role_key` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">default</span> <span class="keyword">null</span> comment <span class="string">&#x27;角色权限字符串&#x27;</span>,</span><br><span class="line">`status` <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">default</span> <span class="string">&#x27;0&#x27;</span> comment <span class="string">&#x27;角色状态（0正常 1停用）&#x27;</span>,</span><br><span class="line">`del_flag` <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">default</span> <span class="string">&#x27;0&#x27;</span> comment <span class="string">&#x27;角色状态（0正常 1删除）&#x27;</span>,</span><br><span class="line">`create_by` <span class="type">int</span> <span class="keyword">default</span> <span class="keyword">null</span>,</span><br><span class="line">`create_time` <span class="type">date</span> <span class="keyword">default</span> <span class="keyword">null</span>,</span><br><span class="line">`update_by` <span class="type">int</span> <span class="keyword">default</span> <span class="keyword">null</span>,</span><br><span class="line">`update_time` <span class="type">date</span> <span class="keyword">default</span> <span class="keyword">null</span>,</span><br><span class="line">`remark` <span class="type">varchar</span>(<span class="number">500</span>) <span class="keyword">default</span> <span class="keyword">null</span> comment <span class="string">&#x27;备注&#x27;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> `tb_role_menu` (</span><br><span class="line">`role_id` <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> <span class="number">0</span> comment <span class="string">&#x27;角色ID&#x27;</span>,</span><br><span class="line">`menu_id` <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> <span class="number">0</span> comment <span class="string">&#x27;菜单ID&#x27;</span>,</span><br><span class="line"><span class="keyword">primary</span> key(`role_id`,</span><br><span class="line">`menu_id`)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> `tb_user_role` (</span><br><span class="line">`user_id` <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> <span class="number">0</span> comment <span class="string">&#x27;用户ID&#x27;</span>,</span><br><span class="line">`role_id` <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> <span class="number">0</span> comment <span class="string">&#x27;角色ID&#x27;</span>,</span><br><span class="line"><span class="keyword">primary</span> key(`user_id`,</span><br><span class="line">`role_id`)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>根据用户 id 查询权限信息：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 根据 userId 查询 perms 对应的 role 和 menu 都必须是正常状态 </span></span><br><span class="line"><span class="keyword">select</span></span><br><span class="line"><span class="keyword">distinct</span> tm.perms </span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">tb_user_role tur </span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> tb_role tr <span class="keyword">on</span> tr.id <span class="operator">=</span> tur.role_id</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> tb_role_menu trm <span class="keyword">on</span> tur.role_id <span class="operator">=</span> trm.role_id </span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> tb_menu tm <span class="keyword">on</span> tm.id <span class="operator">=</span> trm.menu_id </span><br><span class="line"><span class="keyword">where</span> </span><br><span class="line">user_id <span class="operator">=</span> <span class="number">2</span> <span class="keyword">and</span> tr.status <span class="operator">=</span> <span class="string">&#x27;0&#x27;</span> <span class="keyword">and</span> tm.status <span class="operator">=</span><span class="string">&#x27;0&#x27;</span>;</span><br></pre></td></tr></table></figure><ol><li>查询用户权限，将权限封装到 LoginUser</li></ol><p>UserDetailsServiceImpl：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询用户权限</span></span><br><span class="line">List&lt;String&gt; list = menuDao.selectPermsByUserId(user.getId());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LoginUser</span>(user, list);</span><br></pre></td></tr></table></figure><ol start="2"><li>权限信息封装</li></ol><p>LoginUser：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginUser</span> <span class="keyword">implements</span> <span class="title class_">UserDetails</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; permissions;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LoginUser</span><span class="params">(User user, List&lt;String&gt; privileges)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.user = user;</span><br><span class="line">        System.out.println(<span class="string">&quot;assign:&quot;</span> + privileges);</span><br><span class="line">        <span class="built_in">this</span>.permissions = privileges;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 授权</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回权限信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; getAuthorities() &#123;</span><br><span class="line">        <span class="keyword">return</span> permissions.stream()</span><br><span class="line">                .map(SimpleGrantedAuthority::<span class="keyword">new</span>)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取用户密码</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 数据库查出来的密码（默认加密方式），将用于与前端传入的密码进行比对</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> user.getPassword();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取用户名</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 用户名字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> user.getUsername();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAccountNonExpired</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAccountNonLocked</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> user.getStatus() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCredentialsNonExpired</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEnabled</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> user.getStatus() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将权限封装进 LoginUser 类中，通过 getAuthorities 方法将权限信息返回出来。</p><ol start="3"><li>将用户权限存入 SercurityContextHolder 中</li></ol><p>JwtAuthenticationFilter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4. 将用户信息存进 securityContextHolder 中</span></span><br><span class="line"><span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authenticationToken</span> <span class="operator">=</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(loginUser.getUser().getId(), <span class="literal">null</span>, loginUser.getAuthorities());</span><br><span class="line">SecurityContextHolder.getContext().setAuthentication(authenticationToken);</span><br></pre></td></tr></table></figure><p>至此，可以从 securityContext 中获取到用户的权限。</p><ol start="4"><li>登录接口完善</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">login</span><span class="params">(User user)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. AuthenticationManager 身份认证</span></span><br><span class="line">    <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authenticationToken</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(user.getUsername(), user.getPassword());</span><br><span class="line"></span><br><span class="line">    Authentication authentication;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        authentication = authenticationManager.authenticate(authenticationToken);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UsernameNotFoundException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServiceException</span>(SystemException.USER_NOT_EXIST);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (BadCredentialsException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServiceException</span>(SystemException.USERNAME_OR_PASSWORD_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 认证不通过，给予用户提示</span></span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(authentication)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServiceException</span>(SystemException.USERNAME_OR_PASSWORD_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 认证通过，使用 userId 生成 token 并将用户信息存入 redis</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Redis 中是否有可用 token，有则删除（可能更新了权限），没有则最好</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">oldToken</span> <span class="operator">=</span> ((String) redisUtil.get(<span class="string">&quot;login:&quot;</span> + user.getId()));</span><br><span class="line">    <span class="keyword">if</span> (oldToken != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 保证只有一个 token 可用</span></span><br><span class="line">        redisUtil.delete(oldToken);</span><br><span class="line">        redisUtil.delete(<span class="string">&quot;login:&quot;</span> + user.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">LoginUser</span> <span class="variable">loginUser</span> <span class="operator">=</span> ((LoginUser) authentication.getPrincipal());</span><br><span class="line">    <span class="type">User</span> <span class="variable">current</span> <span class="operator">=</span> loginUser.getUser();</span><br><span class="line">    <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> JwtTokenUtil.createToken(Integer.toString(current.getId()), <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按用户 id 存储 token</span></span><br><span class="line">    redisUtil.set(<span class="string">&quot;login:&quot;</span> + current.getId(), token, <span class="number">3600</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按 token（存储用户信息 + 权限信息）</span></span><br><span class="line">    redisUtil.set(<span class="string">&quot;token:&quot;</span> + token, loginUser, <span class="number">3600</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 token 和用户信息</span></span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;token&quot;</span>, token);</span><br><span class="line">    current.setPassword(<span class="literal">null</span>);</span><br><span class="line">    map.put(<span class="string">&quot;userInfo&quot;</span>, user);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ResultUtil.success(<span class="string">&quot;success&quot;</span>, map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>登录的时候先去 Redis  中删除先前的登录信息，保证可用的 token 只有一个。</p><p>存入当前登录用户的 id、token、用户信息。</p><ol start="5"><li>给接口添加访问权限</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;hasAuthority(&#x27;system:test:list&#x27;)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result&lt;String&gt; <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ResultUtil.success(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当用户有 ‘system:test:list’ 权限时，才能够访问该接口。</p><ol start="6"><li>刷新 token</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 刷新 token，更新 redis</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回新 token</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result&lt;String&gt; <span class="title function_">refreshToken</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 从 SecurityContextHolder 中获取用户 id</span></span><br><span class="line">    <span class="type">Authentication</span> <span class="variable">authentication</span> <span class="operator">=</span> SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">id</span> <span class="operator">=</span> (Integer) authentication.getPrincipal();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 重新生成新 token</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> JwtTokenUtil.createToken(Integer.toString(id), <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 删除 Redis 中存储的用户信息（不太需要这一步，就是取不到用户信息才要刷新 token）</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">oldToken</span> <span class="operator">=</span> ((String) redisUtil.get(<span class="string">&quot;login:&quot;</span> + id));</span><br><span class="line">    <span class="type">LoginUser</span> <span class="variable">userInfo</span> <span class="operator">=</span> (LoginUser) redisUtil.get(<span class="string">&quot;token:&quot;</span> + oldToken);</span><br><span class="line">    redisUtil.delete(<span class="string">&quot;login:&quot;</span> + id);</span><br><span class="line">    redisUtil.delete(oldToken);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 存进 redis，有效时间为 1 小时</span></span><br><span class="line">    redisUtil.set(<span class="string">&quot;login:&quot;</span> + id, token, <span class="number">3600</span>);</span><br><span class="line">    redisUtil.set(<span class="string">&quot;token:&quot;</span> + token, userInfo, <span class="number">3600</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ResultUtil.success(<span class="string">&quot;刷新成功&quot;</span>, token);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
            <tag> Jwt </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git基本使用</title>
      <link href="/2023/07/05/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/07/05/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Git-基本使用"><a href="#Git-基本使用" class="headerlink" title="Git 基本使用"></a>Git 基本使用</h1><h2 id="配置用户名和邮箱"><a href="#配置用户名和邮箱" class="headerlink" title="配置用户名和邮箱"></a>配置用户名和邮箱</h2><p>查看用户名和邮箱</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.name</span><br><span class="line">git config user.email</span><br></pre></td></tr></table></figure><p>配置用户名和邮箱</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;username&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;email&quot;</span></span><br></pre></td></tr></table></figure><h2 id="配置-SSH-和-HTPS-克隆仓库"><a href="#配置-SSH-和-HTPS-克隆仓库" class="headerlink" title="配置 SSH 和 HTPS 克隆仓库"></a>配置 SSH 和 HTPS 克隆仓库</h2><h3 id="配置-SSH"><a href="#配置-SSH" class="headerlink" title="配置 SSH"></a>配置 SSH</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t [fileName] -C <span class="string">&quot;email&quot;</span> <span class="comment"># 生成公钥</span></span><br><span class="line"><span class="built_in">cd</span> ~/.ssh </span><br><span class="line"><span class="built_in">cat</span> id_fileName.pub</span><br></pre></td></tr></table></figure><p>将公钥输入到远程仓库正确的位置即可使用。</p><h3 id="配置-HTTPS"><a href="#配置-HTTPS" class="headerlink" title="配置 HTTPS"></a>配置 HTTPS</h3><p>没有配置直接直接使用 https 克隆仓库，会收到报错：<code>SSL certificate problem:unable to get local issuer certificate</code> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.sslverify <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>输入上述命令之后，再次尝试克隆仓库，输入密码即可。</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>参考</p><p> <a href="https://blog.csdn.net/weixin_43866583/article/details/125644017">Git基本指令的使用</a> </p><p>初始化仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>克隆仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span></span><br></pre></td></tr></table></figure><p>将文件暂存&#x2F;从暂存区删除&#x2F;移动或重命名文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add/rm/mv</span><br></pre></td></tr></table></figure><p>查看工作区中的修改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure><p>带描述的提交到版本控制：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;comment&quot;</span><br><span class="line">git commit -am &quot;comment&quot; # 相当于先执行 git add . 再提交</span><br></pre></td></tr></table></figure><p>将远程仓库中的文件拉下来（建立仓库的时候选择了 gitignore 还有 LICENSE 都要拉下来）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull 仓库链接（http/ssh）</span><br></pre></td></tr></table></figure><p>–allow-unrelated-hostories 合并本地和远程两个不同的仓库。</p><p>添加远程仓库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin [repoAddress]</span><br></pre></td></tr></table></figure><p>origin 用来在本地标识远程仓库，可能有多个远程仓库，推送或拉取时，需要指明推送或者拉取哪个仓库的最新版本</p><p>将远程仓库移除：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote remove 仓库名</span><br></pre></td></tr></table></figure><p>拉取最新的版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin master </span><br></pre></td></tr></table></figure><p>追踪仓库文件状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p>推送本地最新版本到远程仓库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git push # 推送到默认分支</span><br><span class="line">git push origin master # 推送到远程仓库 origin 的 mater 分支</span><br><span class="line">git push -u origin dev # 推送并设置上游分支</span><br></pre></td></tr></table></figure><p>–force 参数表强制推送</p><p>切换分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout [branchName] <span class="comment"># 切换到已有分支</span></span><br><span class="line">git checkout -b [branchName] <span class="comment"># 创建分支并切换</span></span><br></pre></td></tr></table></figure><p>查看远程仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure><p>解除本地仓库与远程仓库的关联：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote remove [repoAddress]</span><br></pre></td></tr></table></figure><p>添加远程仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add [repoAddress]</span><br></pre></td></tr></table></figure><p>修改远程仓库的 URL：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url origin [newUrl]</span><br></pre></td></tr></table></figure><p>拉取某一分支的特定提交到另一分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> <span class="comment"># 寻找所需提交记录</span></span><br><span class="line"></span><br><span class="line">git cherry-pick &lt;commit-hash1&gt; &lt;commit-hash2&gt; &lt;commit-hash3&gt; <span class="comment"># 多个不连续的哈希值</span></span><br><span class="line"></span><br><span class="line">git cherry-pick &lt;commit-hash1&gt;..&lt;commit-hash2&gt; <span class="comment"># 一系列连续的提交</span></span><br></pre></td></tr></table></figure><h2 id="MR"><a href="#MR" class="headerlink" title="MR"></a>MR</h2><p>团队成员通过创建分支进行写作，成员做出更改后将代码推送到自己的分支上，新建从自己的分支到主干仓库的合并请求。</p><h2 id="回合"><a href="#回合" class="headerlink" title="回合"></a>回合</h2><p>主干仓库接收多个成员的贡献，版本领先于其他分支。成员需要将主干仓库中的代码更新到自己的分支。</p><h2 id="冲突解决"><a href="#冲突解决" class="headerlink" title="冲突解决"></a>冲突解决</h2><p>团队成员对同一文件的同一位置进行了修改，分支提交 MR 后显示存在冲突。</p><p>协商结束后应当执行的操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切换到目标分支（例如 main 或 master）</span></span><br><span class="line">git checkout main</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拉取最新的代码</span></span><br><span class="line">git pull origin main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到自己的分支</span></span><br><span class="line">git checkout [branchName]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将目标分支合并到自己的分支</span></span><br><span class="line">git merge main</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解决冲突</span></span><br><span class="line"></span><br><span class="line">git add [resolvedFiles]</span><br><span class="line"></span><br><span class="line">git commit </span><br><span class="line"></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><h2 id="回退"><a href="#回退" class="headerlink" title="回退"></a>回退</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset -soft [commitId] <span class="comment"># 仅本地仓库回退，工作区和暂存区</span></span><br><span class="line">git reset -hard [commitId] <span class="comment"># 工作区、暂存区和本地仓库均回退</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 安装使用</title>
      <link href="/2023/03/25/Docker-%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/03/25/Docker-%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker-安装"><a href="#Docker-安装" class="headerlink" title="Docker 安装"></a>Docker 安装</h1><p>Docker 对 Linux 内核的版本有些要求，使用命令验证内核和架构信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname - a</span><br></pre></td></tr></table></figure><p>内核版本高于 3.10 即可。</p><p>更新软件源：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt upgrade</span><br><span class="line">sudo apt full-upgrade</span><br></pre></td></tr></table></figure><p>安装必要的证书并允许 apt 管理器使用以下命令通过 Https 使用存储库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install apt-transport-https ca-certificates curl software-properties-common gnupg lsb-release</span><br></pre></td></tr></table></figure><p>运行下列命令添加 docker 的官方 GPG 密钥：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</span><br></pre></td></tr></table></figure><p>添加 docker 官方库:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br></pre></td></tr></table></figure><p>使用命令更新 Ubuntu 软件源：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><p>最后运行下面命令，在 Ubuntu 22.04 中安装 docker</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install docker-ce docker-ce-cli containerd.io docker-compose-plugin</span><br></pre></td></tr></table></figure><p>Archlinux 只需要下面一条命令完成上述操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S docker</span><br></pre></td></tr></table></figure><p>安装完成之后，运行下面命令验证 docker 服务正在运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status docker</span><br></pre></td></tr></table></figure><p>如果没有运行，则使用下面命令将 docker 服务启动起来：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure><p>将 docker 服务设置成每次重启时自动启动：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable docker</span><br></pre></td></tr></table></figure><p>运行下面命令查看 Docker 的版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker version</span><br></pre></td></tr></table></figure><p>终端输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Client: Docker Engine - Community</span><br><span class="line"> Version:           23.0.1</span><br><span class="line"> API version:       1.42</span><br><span class="line"> Go version:        go1.19.5</span><br><span class="line"> Git commit:        a5ee5b1</span><br><span class="line"> Built:             Thu Feb  9 19:47:01 2023</span><br><span class="line"> OS/Arch:           linux/amd64</span><br><span class="line"> Context:           default</span><br><span class="line"></span><br><span class="line">Server: Docker Engine - Community</span><br><span class="line"> Engine:</span><br><span class="line">  Version:          23.0.1</span><br><span class="line">  API version:      1.42 (minimum version 1.12)</span><br><span class="line">  Go version:       go1.19.5</span><br><span class="line">  Git commit:       bc3805a</span><br><span class="line">  Built:            Thu Feb  9 19:47:01 2023</span><br><span class="line">  OS/Arch:          linux/amd64</span><br><span class="line">  Experimental:     false</span><br><span class="line"> containerd:</span><br><span class="line">  Version:          1.6.18</span><br><span class="line">  GitCommit:        2456e983eb9e37e47538f59ea18f2043c9a73640</span><br><span class="line"> runc:</span><br><span class="line">  Version:          1.1.4</span><br><span class="line">  GitCommit:        v1.1.4-0-g5fd4c4d</span><br><span class="line"> docker-init:</span><br><span class="line">  Version:          0.19.0</span><br><span class="line">  GitCommit:        de40ad0</span><br></pre></td></tr></table></figure><p>一切正常。</p><p>建立 docker 用户组：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo groupadd docker</span><br></pre></td></tr></table></figure><p>将当前用户加入 docker 组</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -aG docker $USER</span><br></pre></td></tr></table></figure><p>关闭当前终端，重新登陆后测试 docker 是否安装正确：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run hello-world</span><br></pre></td></tr></table></figure><p>终端输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Unable to find image &#x27;hello-world:latest&#x27; locally</span><br><span class="line">latest: Pulling from library/hello-world</span><br><span class="line">b8dfde127a29: Pull complete</span><br><span class="line">Digest: sha256:308866a43596e83578c7dfa15e27a73011bdd402185a84c5cd7f32a88b501a24</span><br><span class="line">Status: Downloaded newer image for hello-world:latest</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line"> 1. The Docker client contacted the Docker daemon.</span><br><span class="line"> 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.</span><br><span class="line">    (amd64)</span><br><span class="line"> 3. The Docker daemon created a new container from that image which runs the</span><br><span class="line">    executable that produces the output you are currently reading.</span><br><span class="line"> 4. The Docker daemon streamed that output to the Docker client, which sent it</span><br><span class="line">    to your terminal.</span><br><span class="line"></span><br><span class="line">To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line"><span class="meta prompt_"> $ </span><span class="language-bash">docker run -it ubuntu bash</span></span><br><span class="line"></span><br><span class="line">Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line"> https://hub.docker.com/</span><br><span class="line"></span><br><span class="line">For more examples and ideas, visit:</span><br><span class="line"> https://docs.docker.com/get-started/</span><br></pre></td></tr></table></figure><p>正常输出上面内容则说明安装成功。</p><h1 id="Docker-常用命令"><a href="#Docker-常用命令" class="headerlink" title="Docker 常用命令"></a>Docker 常用命令</h1><p>拉取镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull</span><br></pre></td></tr></table></figure><p>容器中已经挂载的镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><p>查看拉取过的所有镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p>停止一个运行中的容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop 容器ID/容器名</span><br></pre></td></tr></table></figure><p>删除一个或者多个进程：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f 容器ID/容器名</span><br></pre></td></tr></table></figure><p>删除已停止的镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker remove 容器ID/容器名</span><br></pre></td></tr></table></figure><p>获取容器日志：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs [-f] 容器ID/容器名</span><br></pre></td></tr></table></figure><p>加上 -f 可以不断拉取最新日志</p><p>从宿主机将文件复制到docker容器中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp /path/filename 容器ID:绝对路径</span><br></pre></td></tr></table></figure><p>将容器中文件拷贝到宿主机某位置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp 容器ID:绝对路径 /path/filename</span><br></pre></td></tr></table></figure><p>更新容器重启策略：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker update --restart=[param] &lt;容器ID/容器名&gt;</span><br></pre></td></tr></table></figure><p>restart 参数含义</p><ul><li><strong><code>no</code></strong> – 不主动重启容器</li><li><strong><code>on-failure[:max-retries]</code></strong> – 仅在非正常退出时重启，最多n次（可选</li><li><strong><code>always</code></strong> – 总是重启容器</li><li><strong><code>unless-stopped</code></strong> – 仅在手动退出时不重启容器</li></ul><h1 id="Docker-网络"><a href="#Docker-网络" class="headerlink" title="Docker 网络"></a>Docker 网络</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">docker network create --help     </span><br><span class="line"></span><br><span class="line">Usage:  docker network create [OPTIONS] NETWORK</span><br><span class="line"></span><br><span class="line">Create a network</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">      --attachable           Enable manual container attachment</span><br><span class="line">      --aux-address map      Auxiliary IPv4 or IPv6 addresses used by Network driver (default map[])</span><br><span class="line">      --config-from string   The network from which to copy the configuration</span><br><span class="line">      --config-only          Create a configuration only network</span><br><span class="line">  -d, --driver string        Driver to manage the Network (default &quot;bridge&quot;)</span><br><span class="line">      --gateway strings      IPv4 or IPv6 Gateway for the master subnet</span><br><span class="line">      --ingress              Create swarm routing-mesh network</span><br><span class="line">      --internal             Restrict external access to the network</span><br><span class="line">      --ip-range strings     Allocate container ip from a sub-range</span><br><span class="line">      --ipam-driver string   IP Address Management Driver (default &quot;default&quot;)</span><br><span class="line">      --ipam-opt map         Set IPAM driver specific options (default map[])</span><br><span class="line">      --ipv4                 Enable or disable IPv4 address assignment (default true)</span><br><span class="line">      --ipv6                 Enable or disable IPv6 address assignment</span><br><span class="line">      --label list           Set metadata on a network</span><br><span class="line">  -o, --opt map              Set driver specific options (default map[])</span><br><span class="line">      --scope string         Control the network&#x27;s scope</span><br><span class="line">      --subnet strings       Subnet in CIDR format that represents a network segment</span><br></pre></td></tr></table></figure><p>效果：同一Docker网络内的不同容器可以使用容器名称互相访问，容器不需要互相知道IP（网桥模式或者overlay模式下，Docker内置的DNS发挥作用）</p><blockquote><p>分布式架构下应当不需要此配置</p></blockquote><h1 id="Dockerfile-语法"><a href="#Dockerfile-语法" class="headerlink" title="Dockerfile 语法"></a>Dockerfile 语法</h1><p><a href="https://docs.docker.com/reference/dockerfile/">官方文档</a> </p><blockquote><p>不区分大小写，但是习惯上使用大写强调关键字</p></blockquote><p>指令：</p><ul><li>FROM：构建镜像时，指定基础镜像</li><li>RUN：</li><li>CMD：定义容器运行时的默认命令，可以在 docker run 的时候覆盖 <code>docker run helloworld:1.0 echo 1</code> <ul><li>语法：</li><li><code>CMD [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code> executable 不指定时默认为 ENTRYPOINT，<code>CMD [&quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot;]</code> 这种形式才会解析环境变量</li><li><code>CMD command param1 param2</code> （可以解析环境变量）</li><li>只有最后一个生效</li></ul></li><li>ENV：dockerfile 中定义环境变量，可以通过 <code>docker run -e 环境变量名=值</code> 改环境变量的值</li><li>WORKDIR：设置当前工作文件夹，不存在则创建</li><li>RUN：构建镜像时执行指令</li><li>ADD：构建镜像时，将宿主机文件添加到镜像中，如果是压缩包则自动解压，如果是网络文件，则执行下载，不解压</li><li>EXPOSE：指明需要暴露的端口号，使镜像使用者知晓</li><li>COPY：将文件添加到镜像中（仅拷贝）</li><li>ENTRYPOINT：容器运行时的默认命令，不可以被覆盖，JSON格式参数</li></ul><p>示例：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定基础镜像，此处使用 archliux 最新镜像</span></span><br><span class="line"><span class="keyword">FROM</span> archlinux:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件中配置环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> CONTENT=<span class="string">&quot;test&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置工作区</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> a</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> b</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建文件夹</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> -p <span class="built_in">test</span> &amp;&amp; <span class="built_in">cd</span> <span class="built_in">test</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行命令</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="variable">$CONTENT</span> &gt; content.txt</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">pwd</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行时执行</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> <span class="built_in">cat</span> content.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行时执行内容 </span></span><br><span class="line"><span class="comment"># CMD [&quot;echo&quot;, &quot;test&quot;]</span></span><br><span class="line"><span class="comment"># CMD echo $CONTENT</span></span><br></pre></td></tr></table></figure><p>构建镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t h1:1.3 -f test.yml .</span><br></pre></td></tr></table></figure><ul><li>-t：指定目标镜像的名字和tag</li><li>-f：指定根据哪个 dockerfile 构建镜像</li><li>. ：dockerfile 路径</li></ul><p>输出：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">DEPRECATED: The legacy builder is deprecated and will be removed in a future release.</span><br><span class="line">            Install the buildx component to build images with BuildKit:</span><br><span class="line">            https://docs.docker.com/go/buildx/</span><br><span class="line"></span><br><span class="line">Sending build context to Docker daemon  2.048kB</span><br><span class="line">Step 1/9 : FROM archlinux:latest</span><br><span class="line"> ---&gt; d60cf1d6ee7e</span><br><span class="line">Step 2/9 : ENV CONTENT=&quot;test&quot;</span><br><span class="line"> ---&gt; Running in f7381572e379</span><br><span class="line"> ---&gt; Removed intermediate container f7381572e379</span><br><span class="line"> ---&gt; bc2e745a12b4</span><br><span class="line">Step 3/9 : WORKDIR /app</span><br><span class="line"> ---&gt; Running in 43ab59bb52b4</span><br><span class="line"> ---&gt; Removed intermediate container 43ab59bb52b4</span><br><span class="line"> ---&gt; 4e69534047a8</span><br><span class="line">Step 4/9 : WORKDIR a</span><br><span class="line"> ---&gt; Running in 9888d272802f</span><br><span class="line"> ---&gt; Removed intermediate container 9888d272802f</span><br><span class="line"> ---&gt; 9851fa032c0d</span><br><span class="line">Step 5/9 : WORKDIR b</span><br><span class="line"> ---&gt; Running in a3259691c3e0</span><br><span class="line"> ---&gt; Removed intermediate container a3259691c3e0</span><br><span class="line"> ---&gt; 9f4818ecc9d8</span><br><span class="line">Step 6/9 : RUN mkdir -p test &amp;&amp; cd test</span><br><span class="line"> ---&gt; Running in 7f0801a403a5</span><br><span class="line"> ---&gt; Removed intermediate container 7f0801a403a5</span><br><span class="line"> ---&gt; c7b8e98b8469</span><br><span class="line">Step 7/9 : RUN echo $CONTENT &gt; content.txt</span><br><span class="line"> ---&gt; Running in 79789bf90405</span><br><span class="line"> ---&gt; Removed intermediate container 79789bf90405</span><br><span class="line"> ---&gt; 9425a3f90ad6</span><br><span class="line">Step 8/9 : RUN pwd</span><br><span class="line"> ---&gt; Running in 6240ac796f8d</span><br><span class="line">/app/a/b</span><br><span class="line"> ---&gt; Removed intermediate container 6240ac796f8d</span><br><span class="line"> ---&gt; 304f6ae805a1</span><br><span class="line">Step 9/9 : CMD cat content.txt</span><br><span class="line"> ---&gt; Running in 3210b18b21a3</span><br><span class="line"> ---&gt; Removed intermediate container 3210b18b21a3</span><br><span class="line"> ---&gt; 373d0c1070ef</span><br><span class="line">Successfully built 373d0c1070ef</span><br><span class="line">Successfully tagged h1:1.3</span><br></pre></td></tr></table></figure><p>运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name h1 -e CONTENT=<span class="string">&quot;111&quot;</span> h1:1.3</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test</span><br></pre></td></tr></table></figure><blockquote><p>为什么这里输出的是 test，而不是命令中指定的 111 呢？</p><ul><li>原因：RUN 在构建镜像时运行，CMD 在容器运行之初执行。即 content.txt 在覆盖环境变量之前就已写入</li></ul></blockquote><h2 id="使用-dockerfile-构建应用镜像"><a href="#使用-dockerfile-构建应用镜像" class="headerlink" title="使用 dockerfile 构建应用镜像"></a>使用 dockerfile 构建应用镜像</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx:<span class="number">1.21</span>.<span class="number">5</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> xxx-vue.tar.gz</span></span><br><span class="line"><span class="comment"># ADD http://xxxx/yy.tar.gz  # 这种情况下并不会解压</span></span><br><span class="line"><span class="comment"># RUN tar -zxvf xxx-vue.tar.gz # ADD 指令自动解压</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cp</span> -r xxx-vue/dist/* /usr/share/nginx/html</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">90</span> <span class="comment"># EXPOSE 90 9090</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;nginx&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;daemon off;&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>![使用ADD指令和添加压缩包文件](D:\Learning\Notes\Markdown\Typora\Java\Docker 安装使用.assets\image-20251215004853554.png)</p><h2 id="生产环境下部署前端项目"><a href="#生产环境下部署前端项目" class="headerlink" title="生产环境下部署前端项目"></a>生产环境下部署前端项目</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ---------- 构建阶段 ----------</span></span><br><span class="line"><span class="keyword">FROM</span> node:<span class="number">20</span>-alpine AS build</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> package*.json ./</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> npm ci</span></span><br><span class="line"><span class="comment"># 拷贝全部项目文件，包括 src/、vite.config.js、public/等，需要配合 .dockerignore 使用</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> npm run build</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------- 运行阶段 ----------</span></span><br><span class="line"><span class="keyword">FROM</span> nginx:<span class="number">1.25</span>-alpine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除默认配置</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">rm</span> /etc/nginx/conf.d/default.conf</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝自定义 nginx 配置</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> nginx.conf /etc/nginx/conf.d/default.conf</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝 Vue 构建产物</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=build /app/dist /usr/share/nginx/html</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;nginx&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;daemon off;&quot;</span>]</span></span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> localhost;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">root</span> /usr/share/nginx/html;</span><br><span class="line">    <span class="attribute">index</span> index.html;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 接口代理（可选）</span></span><br><span class="line">    <span class="section">location</span> /api/ &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://backend:8080/;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构建&amp;运行镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker build -t vue-nginx .</span><br><span class="line">docker run -d -p 80:80 vue-nginx</span><br></pre></td></tr></table></figure><h1 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h1><h2 id="Docker-compose-安装"><a href="#Docker-compose-安装" class="headerlink" title="Docker compose 安装"></a>Docker compose 安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S docker-compose</span><br></pre></td></tr></table></figure><blockquote><p>注意 docker compose 和 Docker 的兼容性</p></blockquote><h2 id="Docker-Compose-file-语法"><a href="#Docker-Compose-file-语法" class="headerlink" title="Docker Compose file 语法"></a>Docker Compose file 语法</h2><p><a href="https://docs.docker.com/reference/compose-file/">官方文档</a> </p><p>元素：</p><ul><li>command：覆盖容器启动后的默认命令</li><li>environment：指定环境变量，docker run 命令中的 -e 选项</li><li>image：指定镜像</li><li>networks：指定网络，docker run 命令中的 –network</li><li>ports：端口映射策略，-p 选项</li><li>volumes：数据卷挂载策略</li><li>restart：重启策略，–restart 选项</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:latest</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/usr/data:/var/lib/mysql</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/usr/conf:/etc/mysql.d</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">3306</span><span class="string">:3306</span> <span class="comment"># 不建议使用3306端口</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">    <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">xxx_service</span></span><br><span class="line">    <span class="attr">redis:</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">mysql:latest</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">pathToConfigFile:/etc/redis/redis.conf</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">pathToData:/data</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">6379</span><span class="string">:6379</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">    <span class="attr">ENABLE_OVERCOMMIT_MEMORY:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&#x27;redis-server&#x27;</span>, <span class="string">&#x27;--appendonly&#x27;</span>, <span class="string">&#x27;yes&#x27;</span>, <span class="string">&#x27;--requirepass&#x27;</span>, <span class="string">&#x27;***&#x27;</span>]</span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">xxx_service</span></span><br><span class="line">    <span class="attr">backend:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">backend:latest</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">8080</span><span class="string">:8080</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">xxx_service</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">frontend:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">front:latest</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">80</span><span class="string">:80</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">xxx_service</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line"><span class="attr">xxx_service:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span> <span class="comment"># 按需使用，如果想挂载到现有 volume，使用 external: true</span></span><br></pre></td></tr></table></figure><h1 id="Docker-挂载-MySQL"><a href="#Docker-挂载-MySQL" class="headerlink" title="Docker 挂载 MySQL"></a>Docker 挂载 MySQL</h1><p>拉取 MySQL </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql</span><br></pre></td></tr></table></figure><p>创建用于存储配置文件文件夹：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /usr/local/docker/mysql/conf.d &amp;&amp; sudo mkdir -p /usr/local/docker/mysql/data</span><br></pre></td></tr></table></figure><p>使用路径挂载 MySQL ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line">--name mysql \</span><br><span class="line">-d \</span><br><span class="line">-p 3306:3306 \</span><br><span class="line">--restart unless-stopped \</span><br><span class="line">-v /usr/local/docker/mysql/data:/var/lib/mysql \</span><br><span class="line">-v /usr/local/docker/mysql/conf.d:/etc/mysql.d \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=123456 \</span><br><span class="line">mysql# mysql:lastest 镜像名:版本</span><br></pre></td></tr></table></figure><p>-d 表示后台运行</p><p>–name 容器名</p><p>-p 端口映射（冒号前面是宿主机端口，冒号后面是容器内端口）</p><p>-e 设置环境变量（键值对）</p><h1 id="Docker-挂载-Minio"><a href="#Docker-挂载-Minio" class="headerlink" title="Docker 挂载 Minio"></a>Docker 挂载 Minio</h1><p>拉取镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull minio/minio</span><br></pre></td></tr></table></figure><p>创建文件目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /usr/local/docker/minio/config</span><br><span class="line">sudo mkdir -p /usr/local/docker/minio/data</span><br></pre></td></tr></table></figure><p>运行镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--name minio \</span><br><span class="line">--restart=always \</span><br><span class="line">-p 9000:9000 \</span><br><span class="line">-p 9090:9090 \</span><br><span class="line">-v /usr/local/docker/minio/data:/data \</span><br><span class="line">-v /usr/local/docker/minio/config:/root/.minio \</span><br><span class="line">-e &quot;MINIO_ROOT_USER=******&quot; \</span><br><span class="line">-e &quot;MINIO_ROOT_PASSWORD=******&quot; \</span><br><span class="line">minio/minio:RELEASE.2025-04-08T15-41-24Z server /data --console-address &quot;:9090&quot;</span><br></pre></td></tr></table></figure><p>运行成功的情况下，浏览器输入 ip:9090，进入登录页，默认账号密码为 minioadmin，在可视化界面中创建桶、用户组、在 Service Accounts 中设置并下载用户获取数据的 key 和 密钥。</p><p>application.yml 中写入以下信息（在可视化界面中下载的文件中的信息）：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">minio:</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">ip:9000</span> <span class="comment"># 获取文件的端口</span></span><br><span class="line">  <span class="attr">accessKey:</span> <span class="string">***</span> <span class="comment"># 身份令牌（自己设置的）</span></span><br><span class="line">  <span class="attr">secretKey:</span> <span class="string">***</span> <span class="comment"># 用户密钥</span></span><br><span class="line">  <span class="attr">bucketName:</span> <span class="string">public</span> <span class="comment"># 桶的访问权限</span></span><br></pre></td></tr></table></figure><p>然后根据网上的教程在 springboot 项目中使用 minio：</p><p>创建配置文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinioConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;minio.url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;minio.accessKey&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String accessKey;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;minio.secretKey&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String secretKey;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;minio.bucketName&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String bucketName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MinioClient <span class="title function_">minioClient</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> MinioClient.builder().endpoint(url).credentials(accessKey, secretKey).build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建工具类，实现基本的文件操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinioUtil</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> MinioConfig minioConfig;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> MinioClient minioClient;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查存储桶是否存在</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bucketName 存储桶名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 桶是否存在的标志</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">bucketExists</span><span class="params">(String bucketName)</span> &#123;</span><br><span class="line">        <span class="type">BucketExistsArgs</span> <span class="variable">args</span> <span class="operator">=</span> BucketExistsArgs.builder().bucket(bucketName).build();</span><br><span class="line">        <span class="keyword">return</span> minioClient.bucketExists(args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建存储桶</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bucketName 存储桶名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeBucket</span><span class="params">(String bucketName)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!bucketExists(bucketName)) &#123;</span><br><span class="line">            <span class="type">MakeBucketArgs</span> <span class="variable">args</span> <span class="operator">=</span> MakeBucketArgs.builder().bucket(bucketName).build();</span><br><span class="line">            minioClient.makeBucket(args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取全部bucket</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Bucket&gt; <span class="title function_">getAllBuckets</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;Bucket&gt; buckets = minioClient.listBuckets();</span><br><span class="line">            <span class="keyword">return</span> buckets;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查看文件对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 存储bucket内文件对象信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Item&gt; <span class="title function_">listObjects</span><span class="params">()</span> &#123;</span><br><span class="line">        Iterable&lt;Result&lt;Item&gt;&gt; results = minioClient.listObjects(</span><br><span class="line">                ListObjectsArgs.builder().bucket(minioConfig.getBucketName()).build());</span><br><span class="line">        List&lt;Item&gt; items = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Result&lt;Item&gt; result : results) &#123;</span><br><span class="line">                items.add(result.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> items;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询单个储桶中的所有对象。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bucketName 存储桶名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Object&gt; <span class="title function_">listObjects</span><span class="params">(String bucketName)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Iterable&lt;Result&lt;Item&gt;&gt; results = minioClient.listObjects(ListObjectsArgs.builder().bucket(bucketName).build());</span><br><span class="line">        Iterator&lt;Result&lt;Item&gt;&gt; iterator = results.iterator();</span><br><span class="line">        List&lt;Object&gt; items = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> <span class="string">&quot;&#123;&#x27;fileName&#x27;:&#x27;%s&#x27;,&#x27;fileSize&#x27;:&#x27;%s&#x27;&#125;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="type">Item</span> <span class="variable">item</span> <span class="operator">=</span> iterator.next().get();</span><br><span class="line">            items.add(JSON.parse(String.format(format, item.objectName(),</span><br><span class="line">                    formatFileSize(item.size()))));</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;查询单个储桶中的所有对象信息：&#123;&#125;&quot;</span>, items);</span><br><span class="line">        <span class="keyword">return</span> items;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 列出存储桶中的所有对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bucketName 存储桶名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="keyword">public</span> Iterable&lt;Result&lt;Item&gt;&gt; <span class="title function_">listObjects1</span><span class="params">(String bucketName)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (bucketExists(bucketName)) &#123;</span><br><span class="line">            <span class="type">ListObjectsArgs</span> <span class="variable">args</span> <span class="operator">=</span> ListObjectsArgs.builder().bucket(bucketName).build();</span><br><span class="line">            <span class="keyword">return</span> minioClient.listObjects(args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除存储bucket</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bucketName 存储bucket名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Boolean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">removeBucket</span><span class="params">(String bucketName)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            minioClient.removeBucket(RemoveBucketArgs.builder()</span><br><span class="line">                    .bucket(bucketName)</span><br><span class="line">                    .build());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除一个对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bucketName 存储桶名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> objectName 存储桶里的对象名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeObject</span><span class="params">(String bucketName, String objectName)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (bucketExists(bucketName)) &#123;</span><br><span class="line">            <span class="type">RemoveObjectArgs</span> <span class="variable">args</span> <span class="operator">=</span> RemoveObjectArgs.builder().bucket(bucketName).object(objectName).build();</span><br><span class="line">            minioClient.removeObject(args);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量删除文件对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bucketName 存储bucket名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> objects    对象名称集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Iterable&lt;Result&lt;DeleteError&gt;&gt; <span class="title function_">removeObjects</span><span class="params">(String bucketName, List&lt;String&gt; objects)</span> &#123;</span><br><span class="line">        List&lt;DeleteObject&gt; dos = objects.stream().map(e -&gt; <span class="keyword">new</span> <span class="title class_">DeleteObject</span>(e)).collect(Collectors.toList());</span><br><span class="line">        Iterable&lt;Result&lt;DeleteError&gt;&gt; results = minioClient.removeObjects(RemoveObjectsArgs.builder().bucket(bucketName).objects(dos).build());</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * description: 上传文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: java.lang.String</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">putObject</span><span class="params">(MultipartFile[] multipartFile)</span> &#123;</span><br><span class="line">        List&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(multipartFile.length);</span><br><span class="line">        <span class="keyword">for</span> (MultipartFile file : multipartFile) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> file.getOriginalFilename();</span><br><span class="line">            String[] split = fileName.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (split.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                fileName = split[<span class="number">0</span>] + <span class="string">&quot;_&quot;</span> + System.currentTimeMillis() + <span class="string">&quot;.&quot;</span> + split[<span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                fileName = fileName + System.currentTimeMillis();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                in = file.getInputStream();</span><br><span class="line">                minioClient.putObject(PutObjectArgs.builder()</span><br><span class="line">                        .bucket(minioConfig.getBucketName())</span><br><span class="line">                        .object(fileName)</span><br><span class="line">                        .stream(in, in.available(), -<span class="number">1</span>)</span><br><span class="line">                        .contentType(file.getContentType())</span><br><span class="line">                        .build()</span><br><span class="line">                );</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (in != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        in.close();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            names.add(fileName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> names;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件上传</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file 文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Boolean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">putObject</span><span class="params">(MultipartFile file)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">PutObjectArgs</span> <span class="variable">objectArgs</span> <span class="operator">=</span> PutObjectArgs.builder().bucket(minioConfig.getBucketName()).object(file.getOriginalFilename())</span><br><span class="line">                    .stream(file.getInputStream(), file.getSize(), -<span class="number">1</span>).contentType(file.getContentType()).build();</span><br><span class="line">            <span class="comment">//文件名称相同会覆盖</span></span><br><span class="line">            minioClient.putObject(objectArgs);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取文件外链</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getObjectUrl</span><span class="params">(String fileName)</span> &#123;</span><br><span class="line">        <span class="comment">// 查看文件地址</span></span><br><span class="line">        <span class="type">GetPresignedObjectUrlArgs</span> <span class="variable">build</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GetPresignedObjectUrlArgs</span>().builder().bucket(minioConfig.getBucketName()).object(fileName).method(Method.GET).build();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> minioClient.getPresignedObjectUrl(build);</span><br><span class="line">            <span class="keyword">return</span> url;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取文件外链</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getObjectUrl</span><span class="params">(String bucketName, String region, String fileName)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> minioClient.getPresignedObjectUrl(</span><br><span class="line">                GetPresignedObjectUrlArgs.builder()</span><br><span class="line">                        .method(Method.GET)</span><br><span class="line">                        .bucket(bucketName)</span><br><span class="line">                        .region(region)</span><br><span class="line">                        .object(fileName)</span><br><span class="line">                        .build());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * description: 下载文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> org.springframework.http.ResponseEntity&lt;byte [ ]&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;<span class="type">byte</span>[]&gt; download(String fileName) &#123;</span><br><span class="line">        ResponseEntity&lt;<span class="type">byte</span>[]&gt; responseEntity = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            in = minioClient.getObject(GetObjectArgs.builder().bucket(minioConfig.getBucketName()).object(fileName).build());</span><br><span class="line">            out = <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            IOUtils.copy(in, out);</span><br><span class="line">            <span class="comment">//封装返回值</span></span><br><span class="line">            <span class="type">byte</span>[] bytes = out.toByteArray();</span><br><span class="line">            <span class="type">HttpHeaders</span> <span class="variable">headers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpHeaders</span>();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                headers.add(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment;filename=&quot;</span> + URLEncoder.encode(fileName, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            headers.setContentLength(bytes.length);</span><br><span class="line">            headers.setContentType(MediaType.APPLICATION_OCTET_STREAM);</span><br><span class="line">            headers.setAccessControlExposeHeaders(Arrays.asList(<span class="string">&quot;*&quot;</span>));</span><br><span class="line">            responseEntity = <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;&gt;(bytes, headers, HttpStatus.OK);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (in != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        in.close();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (out != <span class="literal">null</span>) &#123;</span><br><span class="line">                    out.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> responseEntity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件下载</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fileName 文件名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> res      response</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">download</span><span class="params">(String fileName, HttpServletResponse res)</span> &#123;</span><br><span class="line">        <span class="type">GetObjectArgs</span> <span class="variable">objectArgs</span> <span class="operator">=</span> GetObjectArgs.builder().bucket(minioConfig.getBucketName())</span><br><span class="line">                .object(fileName).build();</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">GetObjectResponse</span> <span class="variable">response</span> <span class="operator">=</span> minioClient.getObject(objectArgs)) &#123;</span><br><span class="line">            <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">try</span> (<span class="type">FastByteArrayOutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FastByteArrayOutputStream</span>()) &#123;</span><br><span class="line">                <span class="keyword">while</span> ((len = response.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                    os.write(buf, <span class="number">0</span>, len);</span><br><span class="line">                &#125;</span><br><span class="line">                os.flush();</span><br><span class="line">                <span class="type">byte</span>[] bytes = os.toByteArray();</span><br><span class="line">                res.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">                <span class="comment">// 设置强制下载不打开</span></span><br><span class="line">                <span class="comment">// res.setContentType(&quot;application/force-download&quot;);</span></span><br><span class="line">                res.addHeader(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment;fileName=&quot;</span> + fileName);</span><br><span class="line">                <span class="keyword">try</span> (<span class="type">ServletOutputStream</span> <span class="variable">stream</span> <span class="operator">=</span> res.getOutputStream()) &#123;</span><br><span class="line">                    stream.write(bytes);</span><br><span class="line">                    stream.flush();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">formatFileSize</span><span class="params">(<span class="type">long</span> fileS)</span> &#123;</span><br><span class="line">        <span class="type">DecimalFormat</span> <span class="variable">df</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;#.00&quot;</span>);</span><br><span class="line">        String fileSizeString;</span><br><span class="line">        <span class="type">String</span> <span class="variable">wrongSize</span> <span class="operator">=</span> <span class="string">&quot;0B&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (fileS == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> wrongSize;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fileS &lt; <span class="number">1024</span>) &#123;</span><br><span class="line">            fileSizeString = df.format((<span class="type">double</span>) fileS) + <span class="string">&quot; B&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fileS &lt; <span class="number">1048576</span>) &#123;</span><br><span class="line">            fileSizeString = df.format((<span class="type">double</span>) fileS / <span class="number">1024</span>) + <span class="string">&quot; KB&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fileS &lt; <span class="number">1073741824</span>) &#123;</span><br><span class="line">            fileSizeString = df.format((<span class="type">double</span>) fileS / <span class="number">1048576</span>) + <span class="string">&quot; MB&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fileSizeString = df.format((<span class="type">double</span>) fileS / <span class="number">1073741824</span>) + <span class="string">&quot; GB&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fileSizeString;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是根据项目业务实现的控制器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CrossOrigin</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/file&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UploadController</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> MinioConfig minioProperties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> MinioUtil util;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/list&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">list</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.success(util.listObjects(minioProperties.getBucketName()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/upload&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">uploadFile</span><span class="params">(MultipartFile file)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> file.getOriginalFilename();</span><br><span class="line">            <span class="comment">// 可能会抛出异常</span></span><br><span class="line">            <span class="keyword">assert</span> fileName != <span class="literal">null</span>;</span><br><span class="line">            </span><br><span class="line">            util.putObject(file);</span><br><span class="line"></span><br><span class="line">            String[] split = util.getObjectUrl(fileName).split(<span class="string">&quot;\\?&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> Result.success(split[<span class="number">0</span>]);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;上传失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/delete/&#123;fileName&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">deleteFile</span><span class="params">(<span class="meta">@PathVariable(&quot;fileName&quot;)</span> String fileName)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">status</span> <span class="operator">=</span> util.removeObject(minioProperties.getBucketName(), fileName);</span><br><span class="line">        <span class="keyword">return</span> status ? Result.success(<span class="string">&quot;删除成功&quot;</span>) : Result.fail(<span class="string">&quot;删除失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本完成。</p><h1 id="Docker-挂载-Redis"><a href="#Docker-挂载-Redis" class="headerlink" title="Docker 挂载 Redis"></a>Docker 挂载 Redis</h1><p>拉取 Redis 镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull redis</span><br></pre></td></tr></table></figure><p>运行上面命令拉取 redis 最新版镜像。</p><p>redis.conf</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br><span class="line">1058</span><br><span class="line">1059</span><br><span class="line">1060</span><br><span class="line">1061</span><br><span class="line">1062</span><br><span class="line">1063</span><br><span class="line">1064</span><br><span class="line">1065</span><br><span class="line">1066</span><br><span class="line">1067</span><br><span class="line">1068</span><br><span class="line">1069</span><br><span class="line">1070</span><br><span class="line">1071</span><br><span class="line">1072</span><br><span class="line">1073</span><br><span class="line">1074</span><br><span class="line">1075</span><br><span class="line">1076</span><br><span class="line">1077</span><br><span class="line">1078</span><br><span class="line">1079</span><br><span class="line">1080</span><br><span class="line">1081</span><br><span class="line">1082</span><br><span class="line">1083</span><br><span class="line">1084</span><br><span class="line">1085</span><br><span class="line">1086</span><br><span class="line">1087</span><br><span class="line">1088</span><br><span class="line">1089</span><br><span class="line">1090</span><br><span class="line">1091</span><br><span class="line">1092</span><br><span class="line">1093</span><br><span class="line">1094</span><br><span class="line">1095</span><br><span class="line">1096</span><br><span class="line">1097</span><br><span class="line">1098</span><br><span class="line">1099</span><br><span class="line">1100</span><br><span class="line">1101</span><br><span class="line">1102</span><br><span class="line">1103</span><br><span class="line">1104</span><br><span class="line">1105</span><br><span class="line">1106</span><br><span class="line">1107</span><br><span class="line">1108</span><br><span class="line">1109</span><br><span class="line">1110</span><br><span class="line">1111</span><br><span class="line">1112</span><br><span class="line">1113</span><br><span class="line">1114</span><br><span class="line">1115</span><br><span class="line">1116</span><br><span class="line">1117</span><br><span class="line">1118</span><br><span class="line">1119</span><br><span class="line">1120</span><br><span class="line">1121</span><br><span class="line">1122</span><br><span class="line">1123</span><br><span class="line">1124</span><br><span class="line">1125</span><br><span class="line">1126</span><br><span class="line">1127</span><br><span class="line">1128</span><br><span class="line">1129</span><br><span class="line">1130</span><br><span class="line">1131</span><br><span class="line">1132</span><br><span class="line">1133</span><br><span class="line">1134</span><br><span class="line">1135</span><br><span class="line">1136</span><br><span class="line">1137</span><br><span class="line">1138</span><br><span class="line">1139</span><br><span class="line">1140</span><br><span class="line">1141</span><br><span class="line">1142</span><br><span class="line">1143</span><br><span class="line">1144</span><br><span class="line">1145</span><br><span class="line">1146</span><br><span class="line">1147</span><br><span class="line">1148</span><br><span class="line">1149</span><br><span class="line">1150</span><br><span class="line">1151</span><br><span class="line">1152</span><br><span class="line">1153</span><br><span class="line">1154</span><br><span class="line">1155</span><br><span class="line">1156</span><br><span class="line">1157</span><br><span class="line">1158</span><br><span class="line">1159</span><br><span class="line">1160</span><br><span class="line">1161</span><br><span class="line">1162</span><br><span class="line">1163</span><br><span class="line">1164</span><br><span class="line">1165</span><br><span class="line">1166</span><br><span class="line">1167</span><br><span class="line">1168</span><br><span class="line">1169</span><br><span class="line">1170</span><br><span class="line">1171</span><br><span class="line">1172</span><br><span class="line">1173</span><br><span class="line">1174</span><br><span class="line">1175</span><br><span class="line">1176</span><br><span class="line">1177</span><br><span class="line">1178</span><br><span class="line">1179</span><br><span class="line">1180</span><br><span class="line">1181</span><br><span class="line">1182</span><br><span class="line">1183</span><br><span class="line">1184</span><br><span class="line">1185</span><br><span class="line">1186</span><br><span class="line">1187</span><br><span class="line">1188</span><br><span class="line">1189</span><br><span class="line">1190</span><br><span class="line">1191</span><br><span class="line">1192</span><br><span class="line">1193</span><br><span class="line">1194</span><br><span class="line">1195</span><br><span class="line">1196</span><br><span class="line">1197</span><br><span class="line">1198</span><br><span class="line">1199</span><br><span class="line">1200</span><br><span class="line">1201</span><br><span class="line">1202</span><br><span class="line">1203</span><br><span class="line">1204</span><br><span class="line">1205</span><br><span class="line">1206</span><br><span class="line">1207</span><br><span class="line">1208</span><br><span class="line">1209</span><br><span class="line">1210</span><br><span class="line">1211</span><br><span class="line">1212</span><br><span class="line">1213</span><br><span class="line">1214</span><br><span class="line">1215</span><br><span class="line">1216</span><br><span class="line">1217</span><br><span class="line">1218</span><br><span class="line">1219</span><br><span class="line">1220</span><br><span class="line">1221</span><br><span class="line">1222</span><br><span class="line">1223</span><br><span class="line">1224</span><br><span class="line">1225</span><br><span class="line">1226</span><br><span class="line">1227</span><br><span class="line">1228</span><br><span class="line">1229</span><br><span class="line">1230</span><br><span class="line">1231</span><br><span class="line">1232</span><br><span class="line">1233</span><br><span class="line">1234</span><br><span class="line">1235</span><br><span class="line">1236</span><br><span class="line">1237</span><br><span class="line">1238</span><br><span class="line">1239</span><br><span class="line">1240</span><br><span class="line">1241</span><br><span class="line">1242</span><br><span class="line">1243</span><br><span class="line">1244</span><br><span class="line">1245</span><br><span class="line">1246</span><br><span class="line">1247</span><br><span class="line">1248</span><br><span class="line">1249</span><br><span class="line">1250</span><br><span class="line">1251</span><br><span class="line">1252</span><br><span class="line">1253</span><br><span class="line">1254</span><br><span class="line">1255</span><br><span class="line">1256</span><br><span class="line">1257</span><br><span class="line">1258</span><br><span class="line">1259</span><br><span class="line">1260</span><br><span class="line">1261</span><br><span class="line">1262</span><br><span class="line">1263</span><br><span class="line">1264</span><br><span class="line">1265</span><br><span class="line">1266</span><br><span class="line">1267</span><br><span class="line">1268</span><br><span class="line">1269</span><br><span class="line">1270</span><br><span class="line">1271</span><br><span class="line">1272</span><br><span class="line">1273</span><br><span class="line">1274</span><br><span class="line">1275</span><br><span class="line">1276</span><br><span class="line">1277</span><br><span class="line">1278</span><br><span class="line">1279</span><br><span class="line">1280</span><br><span class="line">1281</span><br><span class="line">1282</span><br><span class="line">1283</span><br><span class="line">1284</span><br><span class="line">1285</span><br><span class="line">1286</span><br><span class="line">1287</span><br><span class="line">1288</span><br><span class="line">1289</span><br><span class="line">1290</span><br><span class="line">1291</span><br><span class="line">1292</span><br><span class="line">1293</span><br><span class="line">1294</span><br><span class="line">1295</span><br><span class="line">1296</span><br><span class="line">1297</span><br><span class="line">1298</span><br><span class="line">1299</span><br><span class="line">1300</span><br><span class="line">1301</span><br><span class="line">1302</span><br><span class="line">1303</span><br><span class="line">1304</span><br><span class="line">1305</span><br><span class="line">1306</span><br><span class="line">1307</span><br><span class="line">1308</span><br><span class="line">1309</span><br><span class="line">1310</span><br><span class="line">1311</span><br><span class="line">1312</span><br><span class="line">1313</span><br><span class="line">1314</span><br><span class="line">1315</span><br><span class="line">1316</span><br><span class="line">1317</span><br><span class="line">1318</span><br><span class="line">1319</span><br><span class="line">1320</span><br><span class="line">1321</span><br><span class="line">1322</span><br><span class="line">1323</span><br><span class="line">1324</span><br><span class="line">1325</span><br><span class="line">1326</span><br><span class="line">1327</span><br><span class="line">1328</span><br><span class="line">1329</span><br><span class="line">1330</span><br><span class="line">1331</span><br><span class="line">1332</span><br><span class="line">1333</span><br><span class="line">1334</span><br><span class="line">1335</span><br><span class="line">1336</span><br><span class="line">1337</span><br><span class="line">1338</span><br><span class="line">1339</span><br><span class="line">1340</span><br><span class="line">1341</span><br><span class="line">1342</span><br><span class="line">1343</span><br><span class="line">1344</span><br><span class="line">1345</span><br><span class="line">1346</span><br><span class="line">1347</span><br><span class="line">1348</span><br><span class="line">1349</span><br><span class="line">1350</span><br><span class="line">1351</span><br><span class="line">1352</span><br><span class="line">1353</span><br><span class="line">1354</span><br><span class="line">1355</span><br><span class="line">1356</span><br><span class="line">1357</span><br><span class="line">1358</span><br><span class="line">1359</span><br><span class="line">1360</span><br><span class="line">1361</span><br><span class="line">1362</span><br><span class="line">1363</span><br><span class="line">1364</span><br><span class="line">1365</span><br><span class="line">1366</span><br><span class="line">1367</span><br><span class="line">1368</span><br><span class="line">1369</span><br><span class="line">1370</span><br><span class="line">1371</span><br><span class="line">1372</span><br><span class="line">1373</span><br><span class="line">1374</span><br><span class="line">1375</span><br><span class="line">1376</span><br><span class="line">1377</span><br><span class="line">1378</span><br><span class="line">1379</span><br><span class="line">1380</span><br><span class="line">1381</span><br><span class="line">1382</span><br><span class="line">1383</span><br><span class="line">1384</span><br><span class="line">1385</span><br><span class="line">1386</span><br><span class="line">1387</span><br><span class="line">1388</span><br><span class="line">1389</span><br><span class="line">1390</span><br><span class="line">1391</span><br><span class="line">1392</span><br><span class="line">1393</span><br><span class="line">1394</span><br><span class="line">1395</span><br><span class="line">1396</span><br><span class="line">1397</span><br><span class="line">1398</span><br><span class="line">1399</span><br><span class="line">1400</span><br><span class="line">1401</span><br><span class="line">1402</span><br><span class="line">1403</span><br><span class="line">1404</span><br><span class="line">1405</span><br><span class="line">1406</span><br><span class="line">1407</span><br><span class="line">1408</span><br><span class="line">1409</span><br><span class="line">1410</span><br><span class="line">1411</span><br><span class="line">1412</span><br><span class="line">1413</span><br><span class="line">1414</span><br><span class="line">1415</span><br><span class="line">1416</span><br><span class="line">1417</span><br><span class="line">1418</span><br><span class="line">1419</span><br><span class="line">1420</span><br><span class="line">1421</span><br><span class="line">1422</span><br><span class="line">1423</span><br><span class="line">1424</span><br><span class="line">1425</span><br><span class="line">1426</span><br><span class="line">1427</span><br><span class="line">1428</span><br><span class="line">1429</span><br><span class="line">1430</span><br><span class="line">1431</span><br><span class="line">1432</span><br><span class="line">1433</span><br><span class="line">1434</span><br><span class="line">1435</span><br><span class="line">1436</span><br><span class="line">1437</span><br><span class="line">1438</span><br><span class="line">1439</span><br><span class="line">1440</span><br><span class="line">1441</span><br><span class="line">1442</span><br><span class="line">1443</span><br><span class="line">1444</span><br><span class="line">1445</span><br><span class="line">1446</span><br><span class="line">1447</span><br><span class="line">1448</span><br><span class="line">1449</span><br><span class="line">1450</span><br><span class="line">1451</span><br><span class="line">1452</span><br><span class="line">1453</span><br><span class="line">1454</span><br><span class="line">1455</span><br><span class="line">1456</span><br><span class="line">1457</span><br><span class="line">1458</span><br><span class="line">1459</span><br><span class="line">1460</span><br><span class="line">1461</span><br><span class="line">1462</span><br><span class="line">1463</span><br><span class="line">1464</span><br><span class="line">1465</span><br><span class="line">1466</span><br><span class="line">1467</span><br><span class="line">1468</span><br><span class="line">1469</span><br><span class="line">1470</span><br><span class="line">1471</span><br><span class="line">1472</span><br><span class="line">1473</span><br><span class="line">1474</span><br><span class="line">1475</span><br><span class="line">1476</span><br><span class="line">1477</span><br><span class="line">1478</span><br><span class="line">1479</span><br><span class="line">1480</span><br><span class="line">1481</span><br><span class="line">1482</span><br><span class="line">1483</span><br><span class="line">1484</span><br><span class="line">1485</span><br><span class="line">1486</span><br><span class="line">1487</span><br><span class="line">1488</span><br><span class="line">1489</span><br><span class="line">1490</span><br><span class="line">1491</span><br><span class="line">1492</span><br><span class="line">1493</span><br><span class="line">1494</span><br><span class="line">1495</span><br><span class="line">1496</span><br><span class="line">1497</span><br><span class="line">1498</span><br><span class="line">1499</span><br><span class="line">1500</span><br><span class="line">1501</span><br><span class="line">1502</span><br><span class="line">1503</span><br><span class="line">1504</span><br><span class="line">1505</span><br><span class="line">1506</span><br><span class="line">1507</span><br><span class="line">1508</span><br><span class="line">1509</span><br><span class="line">1510</span><br><span class="line">1511</span><br><span class="line">1512</span><br><span class="line">1513</span><br><span class="line">1514</span><br><span class="line">1515</span><br><span class="line">1516</span><br><span class="line">1517</span><br><span class="line">1518</span><br><span class="line">1519</span><br><span class="line">1520</span><br><span class="line">1521</span><br><span class="line">1522</span><br><span class="line">1523</span><br><span class="line">1524</span><br><span class="line">1525</span><br><span class="line">1526</span><br><span class="line">1527</span><br><span class="line">1528</span><br><span class="line">1529</span><br><span class="line">1530</span><br><span class="line">1531</span><br><span class="line">1532</span><br><span class="line">1533</span><br><span class="line">1534</span><br><span class="line">1535</span><br><span class="line">1536</span><br><span class="line">1537</span><br><span class="line">1538</span><br><span class="line">1539</span><br><span class="line">1540</span><br><span class="line">1541</span><br><span class="line">1542</span><br><span class="line">1543</span><br><span class="line">1544</span><br><span class="line">1545</span><br><span class="line">1546</span><br><span class="line">1547</span><br><span class="line">1548</span><br><span class="line">1549</span><br><span class="line">1550</span><br><span class="line">1551</span><br><span class="line">1552</span><br><span class="line">1553</span><br><span class="line">1554</span><br><span class="line">1555</span><br><span class="line">1556</span><br><span class="line">1557</span><br><span class="line">1558</span><br><span class="line">1559</span><br><span class="line">1560</span><br><span class="line">1561</span><br><span class="line">1562</span><br><span class="line">1563</span><br><span class="line">1564</span><br><span class="line">1565</span><br><span class="line">1566</span><br><span class="line">1567</span><br><span class="line">1568</span><br><span class="line">1569</span><br><span class="line">1570</span><br><span class="line">1571</span><br><span class="line">1572</span><br><span class="line">1573</span><br><span class="line">1574</span><br><span class="line">1575</span><br><span class="line">1576</span><br><span class="line">1577</span><br><span class="line">1578</span><br><span class="line">1579</span><br><span class="line">1580</span><br><span class="line">1581</span><br><span class="line">1582</span><br><span class="line">1583</span><br><span class="line">1584</span><br><span class="line">1585</span><br><span class="line">1586</span><br><span class="line">1587</span><br><span class="line">1588</span><br><span class="line">1589</span><br><span class="line">1590</span><br><span class="line">1591</span><br><span class="line">1592</span><br><span class="line">1593</span><br><span class="line">1594</span><br><span class="line">1595</span><br><span class="line">1596</span><br><span class="line">1597</span><br><span class="line">1598</span><br><span class="line">1599</span><br><span class="line">1600</span><br><span class="line">1601</span><br><span class="line">1602</span><br><span class="line">1603</span><br><span class="line">1604</span><br><span class="line">1605</span><br><span class="line">1606</span><br><span class="line">1607</span><br><span class="line">1608</span><br><span class="line">1609</span><br><span class="line">1610</span><br><span class="line">1611</span><br><span class="line">1612</span><br><span class="line">1613</span><br><span class="line">1614</span><br><span class="line">1615</span><br><span class="line">1616</span><br><span class="line">1617</span><br><span class="line">1618</span><br><span class="line">1619</span><br><span class="line">1620</span><br><span class="line">1621</span><br><span class="line">1622</span><br><span class="line">1623</span><br><span class="line">1624</span><br><span class="line">1625</span><br><span class="line">1626</span><br><span class="line">1627</span><br><span class="line">1628</span><br><span class="line">1629</span><br><span class="line">1630</span><br><span class="line">1631</span><br><span class="line">1632</span><br><span class="line">1633</span><br><span class="line">1634</span><br><span class="line">1635</span><br><span class="line">1636</span><br><span class="line">1637</span><br><span class="line">1638</span><br><span class="line">1639</span><br><span class="line">1640</span><br><span class="line">1641</span><br><span class="line">1642</span><br><span class="line">1643</span><br><span class="line">1644</span><br><span class="line">1645</span><br><span class="line">1646</span><br><span class="line">1647</span><br><span class="line">1648</span><br><span class="line">1649</span><br><span class="line">1650</span><br><span class="line">1651</span><br><span class="line">1652</span><br><span class="line">1653</span><br><span class="line">1654</span><br><span class="line">1655</span><br><span class="line">1656</span><br><span class="line">1657</span><br><span class="line">1658</span><br><span class="line">1659</span><br><span class="line">1660</span><br><span class="line">1661</span><br><span class="line">1662</span><br><span class="line">1663</span><br><span class="line">1664</span><br><span class="line">1665</span><br><span class="line">1666</span><br><span class="line">1667</span><br><span class="line">1668</span><br><span class="line">1669</span><br><span class="line">1670</span><br><span class="line">1671</span><br><span class="line">1672</span><br><span class="line">1673</span><br><span class="line">1674</span><br><span class="line">1675</span><br><span class="line">1676</span><br><span class="line">1677</span><br><span class="line">1678</span><br><span class="line">1679</span><br><span class="line">1680</span><br><span class="line">1681</span><br><span class="line">1682</span><br><span class="line">1683</span><br><span class="line">1684</span><br><span class="line">1685</span><br><span class="line">1686</span><br><span class="line">1687</span><br><span class="line">1688</span><br><span class="line">1689</span><br><span class="line">1690</span><br><span class="line">1691</span><br><span class="line">1692</span><br><span class="line">1693</span><br><span class="line">1694</span><br><span class="line">1695</span><br><span class="line">1696</span><br><span class="line">1697</span><br><span class="line">1698</span><br><span class="line">1699</span><br><span class="line">1700</span><br><span class="line">1701</span><br><span class="line">1702</span><br><span class="line">1703</span><br><span class="line">1704</span><br><span class="line">1705</span><br><span class="line">1706</span><br><span class="line">1707</span><br><span class="line">1708</span><br><span class="line">1709</span><br><span class="line">1710</span><br><span class="line">1711</span><br><span class="line">1712</span><br><span class="line">1713</span><br><span class="line">1714</span><br><span class="line">1715</span><br><span class="line">1716</span><br><span class="line">1717</span><br><span class="line">1718</span><br><span class="line">1719</span><br><span class="line">1720</span><br><span class="line">1721</span><br><span class="line">1722</span><br><span class="line">1723</span><br><span class="line">1724</span><br><span class="line">1725</span><br><span class="line">1726</span><br><span class="line">1727</span><br><span class="line">1728</span><br><span class="line">1729</span><br><span class="line">1730</span><br><span class="line">1731</span><br><span class="line">1732</span><br><span class="line">1733</span><br><span class="line">1734</span><br><span class="line">1735</span><br><span class="line">1736</span><br><span class="line">1737</span><br><span class="line">1738</span><br><span class="line">1739</span><br><span class="line">1740</span><br><span class="line">1741</span><br><span class="line">1742</span><br><span class="line">1743</span><br><span class="line">1744</span><br><span class="line">1745</span><br><span class="line">1746</span><br><span class="line">1747</span><br><span class="line">1748</span><br><span class="line">1749</span><br><span class="line">1750</span><br><span class="line">1751</span><br><span class="line">1752</span><br><span class="line">1753</span><br><span class="line">1754</span><br><span class="line">1755</span><br><span class="line">1756</span><br><span class="line">1757</span><br><span class="line">1758</span><br><span class="line">1759</span><br><span class="line">1760</span><br><span class="line">1761</span><br><span class="line">1762</span><br><span class="line">1763</span><br><span class="line">1764</span><br><span class="line">1765</span><br><span class="line">1766</span><br><span class="line">1767</span><br><span class="line">1768</span><br><span class="line">1769</span><br><span class="line">1770</span><br><span class="line">1771</span><br><span class="line">1772</span><br><span class="line">1773</span><br><span class="line">1774</span><br><span class="line">1775</span><br><span class="line">1776</span><br><span class="line">1777</span><br><span class="line">1778</span><br><span class="line">1779</span><br><span class="line">1780</span><br><span class="line">1781</span><br><span class="line">1782</span><br><span class="line">1783</span><br><span class="line">1784</span><br><span class="line">1785</span><br><span class="line">1786</span><br><span class="line">1787</span><br><span class="line">1788</span><br><span class="line">1789</span><br><span class="line">1790</span><br><span class="line">1791</span><br><span class="line">1792</span><br><span class="line">1793</span><br><span class="line">1794</span><br><span class="line">1795</span><br><span class="line">1796</span><br><span class="line">1797</span><br><span class="line">1798</span><br><span class="line">1799</span><br><span class="line">1800</span><br><span class="line">1801</span><br><span class="line">1802</span><br><span class="line">1803</span><br><span class="line">1804</span><br><span class="line">1805</span><br><span class="line">1806</span><br><span class="line">1807</span><br><span class="line">1808</span><br><span class="line">1809</span><br><span class="line">1810</span><br><span class="line">1811</span><br><span class="line">1812</span><br><span class="line">1813</span><br><span class="line">1814</span><br><span class="line">1815</span><br><span class="line">1816</span><br><span class="line">1817</span><br><span class="line">1818</span><br><span class="line">1819</span><br><span class="line">1820</span><br><span class="line">1821</span><br><span class="line">1822</span><br><span class="line">1823</span><br><span class="line">1824</span><br><span class="line">1825</span><br><span class="line">1826</span><br><span class="line">1827</span><br><span class="line">1828</span><br><span class="line">1829</span><br><span class="line">1830</span><br><span class="line">1831</span><br><span class="line">1832</span><br><span class="line">1833</span><br><span class="line">1834</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">#</span> Redis configuration file example.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> Note that in order to read the configuration file, Redis must be</span><br><span class="line"><span class="params">#</span> started with the file path as first argument:</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> ./redis-server /path/to/redis.conf</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> Note on units: when memory size is needed, it is possible to specify</span><br><span class="line"><span class="params">#</span> it in the usual form of 1k 5GB 4M and so forth:</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> 1k =&gt; 1000 bytes</span><br><span class="line"><span class="params">#</span> 1kb =&gt; 1024 bytes</span><br><span class="line"><span class="params">#</span> 1m =&gt; 1000000 bytes</span><br><span class="line"><span class="params">#</span> 1mb =&gt; 1024*1024 bytes</span><br><span class="line"><span class="params">#</span> 1g =&gt; 1000000000 bytes</span><br><span class="line"><span class="params">#</span> 1gb =&gt; 1024*1024*1024 bytes</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> units are case insensitive so 1GB 1Gb 1gB are all the same.</span><br><span class="line"></span><br><span class="line"><span class="params">##################################</span> INCLUDES <span class="params">###################################</span></span><br><span class="line"></span><br><span class="line"><span class="params">#</span> Include one or more other config files here.  This is useful if you</span><br><span class="line"><span class="params">#</span> have a standard template that goes to all Redis servers but also need</span><br><span class="line"><span class="params">#</span> to customize a few per-server settings.  Include files can include</span><br><span class="line"><span class="params">#</span> other files, so use this wisely.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> Notice option &quot;include&quot; won&#x27;t be rewritten by command &quot;CONFIG REWRITE&quot;</span><br><span class="line"><span class="params">#</span> from admin or Redis Sentinel. Since Redis always uses the last processed</span><br><span class="line"><span class="params">#</span> line as value of a configuration directive, you&#x27;d better put includes</span><br><span class="line"><span class="params">#</span> at the beginning of this file to avoid overwriting config change at runtime.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> If instead you are interested in using includes to override configuration</span><br><span class="line"><span class="params">#</span> options, it is better to use include as the last line.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> include /path/to/local.conf</span><br><span class="line"><span class="params">#</span> include /path/to/other.conf</span><br><span class="line"></span><br><span class="line"><span class="params">##################################</span> MODULES <span class="params">#####################################</span></span><br><span class="line"></span><br><span class="line"><span class="params">#</span> Load modules at startup. If the server is not able to load modules</span><br><span class="line"><span class="params">#</span> it will abort. It is possible to use multiple loadmodule directives.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> loadmodule /path/to/my<span class="built_in">_</span>module.so</span><br><span class="line"><span class="params">#</span> loadmodule /path/to/other<span class="built_in">_</span>module.so</span><br><span class="line"></span><br><span class="line"><span class="params">##################################</span> NETWORK <span class="params">#####################################</span></span><br><span class="line"></span><br><span class="line"><span class="params">#</span> By default, if no &quot;bind&quot; configuration directive is specified, Redis listens</span><br><span class="line"><span class="params">#</span> for connections from all the network interfaces available on the server.</span><br><span class="line"><span class="params">#</span> It is possible to listen to just one or multiple selected interfaces using</span><br><span class="line"><span class="params">#</span> the &quot;bind&quot; configuration directive, followed by one or more IP addresses.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> Examples:</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> bind 192.168.1.100 10.0.0.1</span><br><span class="line"><span class="params">#</span> bind 127.0.0.1 ::1</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> ~~~ WARNING ~~~ If the computer running Redis is directly exposed to the</span><br><span class="line"><span class="params">#</span> internet, binding to all the interfaces is dangerous and will expose the</span><br><span class="line"><span class="params">#</span> instance to everybody on the internet. So by default we uncomment the</span><br><span class="line"><span class="params">#</span> following bind directive, that will force Redis to listen only into</span><br><span class="line"><span class="params">#</span> the IPv4 loopback interface address (this means Redis will be able to</span><br><span class="line"><span class="params">#</span> accept connections only from clients running into the same computer it</span><br><span class="line"><span class="params">#</span> is running).</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> IF YOU ARE SURE YOU WANT YOUR INSTANCE TO LISTEN TO ALL THE INTERFACES</span><br><span class="line"><span class="params">#</span> JUST COMMENT THE FOLLOWING LINE.</span><br><span class="line"><span class="params">#</span> ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line"><span class="params">#</span> 只允许本地访问</span><br><span class="line">bind 127.0.0.1</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> Protected mode is a layer of security protection, in order to avoid that</span><br><span class="line"><span class="params">#</span> Redis instances left open on the internet are accessed and exploited.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> When protected mode is on and if:</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> 1) The server is not binding explicitly to a set of addresses using the</span><br><span class="line"><span class="params">#</span>    &quot;bind&quot; directive.</span><br><span class="line"><span class="params">#</span> 2) No password is configured.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> The server only accepts connections from clients connecting from the</span><br><span class="line"><span class="params">#</span> IPv4 and IPv6 loopback addresses 127.0.0.1 and ::1, and from Unix domain</span><br><span class="line"><span class="params">#</span> sockets.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> By default protected mode is enabled. You should disable it only if</span><br><span class="line"><span class="params">#</span> you are sure you want clients from other hosts to connect to Redis</span><br><span class="line"><span class="params">#</span> even if no authentication is configured, nor a specific set of interfaces</span><br><span class="line"><span class="params">#</span> are explicitly listed using the &quot;bind&quot; directive.</span><br><span class="line">protected-mode yes</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> Accept connections on the specified port, default is 6379 (IANA <span class="params">#8</span>15344).</span><br><span class="line"><span class="params">#</span> If port 0 is specified Redis will not listen on a TCP socket.</span><br><span class="line">port 6379</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> TCP listen() backlog.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> In high requests-per-second environments you need an high backlog in order</span><br><span class="line"><span class="params">#</span> to avoid slow clients connections issues. Note that the Linux kernel</span><br><span class="line"><span class="params">#</span> will silently truncate it to the value of /proc/sys/net/core/somaxconn so</span><br><span class="line"><span class="params">#</span> make sure to raise both the value of somaxconn and tcp<span class="built_in">_</span>max<span class="built_in">_</span>syn<span class="built_in">_</span>backlog</span><br><span class="line"><span class="params">#</span> in order to get the desired effect.</span><br><span class="line">tcp-backlog 511</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> Unix socket.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> Specify the path for the Unix socket that will be used to listen for</span><br><span class="line"><span class="params">#</span> incoming connections. There is no default, so Redis will not listen</span><br><span class="line"><span class="params">#</span> on a unix socket when not specified.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> unixsocket /tmp/redis.sock</span><br><span class="line"><span class="params">#</span> unixsocketperm 700</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> Close the connection after a client is idle for N seconds (0 to disable)</span><br><span class="line">timeout 0</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> TCP keepalive.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> If non-zero, use SO<span class="built_in">_</span>KEEPALIVE to send TCP ACKs to clients in absence</span><br><span class="line"><span class="params">#</span> of communication. This is useful for two reasons:</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> 1) Detect dead peers.</span><br><span class="line"><span class="params">#</span> 2) Take the connection alive from the point of view of network</span><br><span class="line"><span class="params">#</span>    equipment in the middle.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> On Linux, the specified value (in seconds) is the period used to send ACKs.</span><br><span class="line"><span class="params">#</span> Note that to close the connection the double of the time is needed.</span><br><span class="line"><span class="params">#</span> On other kernels the period depends on the kernel configuration.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> A reasonable value for this option is 300 seconds, which is the new</span><br><span class="line"><span class="params">#</span> Redis default starting with Redis 3.2.1.</span><br><span class="line">tcp-keepalive 300</span><br><span class="line"></span><br><span class="line"><span class="params">#################################</span> TLS/SSL <span class="params">#####################################</span></span><br><span class="line"></span><br><span class="line"><span class="params">#</span> By default, TLS/SSL is disabled. To enable it, the &quot;tls-port&quot; configuration</span><br><span class="line"><span class="params">#</span> directive can be used to define TLS-listening ports. To enable TLS on the</span><br><span class="line"><span class="params">#</span> default port, use:</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> port 0</span><br><span class="line"><span class="params">#</span> tls-port 6379</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> Configure a X.509 certificate and private key to use for authenticating the</span><br><span class="line"><span class="params">#</span> server to connected clients, masters or cluster peers.  These files should be</span><br><span class="line"><span class="params">#</span> PEM formatted.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> tls-cert-file redis.crt </span><br><span class="line"><span class="params">#</span> tls-key-file redis.key</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> Configure a DH parameters file to enable Diffie-Hellman (DH) key exchange:</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> tls-dh-params-file redis.dh</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> Configure a CA certificate(s) bundle or directory to authenticate TLS/SSL</span><br><span class="line"><span class="params">#</span> clients and peers.  Redis requires an explicit configuration of at least one</span><br><span class="line"><span class="params">#</span> of these, and will not implicitly use the system wide configuration.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> tls-ca-cert-file ca.crt</span><br><span class="line"><span class="params">#</span> tls-ca-cert-dir /etc/ssl/certs</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> By default, clients (including replica servers) on a TLS port are required</span><br><span class="line"><span class="params">#</span> to authenticate using valid client side certificates.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> It is possible to disable authentication using this directive.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> tls-auth-clients no</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> By default, a Redis replica does not attempt to establish a TLS connection</span><br><span class="line"><span class="params">#</span> with its master.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> Use the following directive to enable TLS on replication links.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> tls-replication yes</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> By default, the Redis Cluster bus uses a plain TCP connection. To enable</span><br><span class="line"><span class="params">#</span> TLS for the bus protocol, use the following directive:</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> tls-cluster yes</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> Explicitly specify TLS versions to support. Allowed values are case insensitive</span><br><span class="line"><span class="params">#</span> and include &quot;TLSv1&quot;, &quot;TLSv1.1&quot;, &quot;TLSv1.2&quot;, &quot;TLSv1.3&quot; (OpenSSL &gt;= 1.1.1) or</span><br><span class="line"><span class="params">#</span> any combination. To enable only TLSv1.2 and TLSv1.3, use:</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> tls-protocols &quot;TLSv1.2 TLSv1.3&quot;</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> Configure allowed ciphers.  See the ciphers(1ssl) manpage for more information</span><br><span class="line"><span class="params">#</span> about the syntax of this string.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> Note: this configuration applies only to &lt;= TLSv1.2.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> tls-ciphers DEFAULT:!MEDIUM</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> Configure allowed TLSv1.3 ciphersuites.  See the ciphers(1ssl) manpage for more</span><br><span class="line"><span class="params">#</span> information about the syntax of this string, and specifically for TLSv1.3</span><br><span class="line"><span class="params">#</span> ciphersuites.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> tls-ciphersuites TLS<span class="built_in">_</span>CHACHA20<span class="built_in">_</span>POLY1305<span class="built_in">_</span>SHA256</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> When choosing a cipher, use the server&#x27;s preference instead of the client</span><br><span class="line"><span class="params">#</span> preference. By default, the server follows the client&#x27;s preference.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> tls-prefer-server-ciphers yes</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> By default, TLS session caching is enabled to allow faster and less expensive</span><br><span class="line"><span class="params">#</span> reconnections by clients that support it. Use the following directive to disable</span><br><span class="line"><span class="params">#</span> caching.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> tls-session-caching no</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> Change the default number of TLS sessions cached. A zero value sets the cache</span><br><span class="line"><span class="params">#</span> to unlimited size. The default size is 20480.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> tls-session-cache-size 5000</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> Change the default timeout of cached TLS sessions. The default timeout is 300</span><br><span class="line"><span class="params">#</span> seconds.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> tls-session-cache-timeout 60</span><br><span class="line"></span><br><span class="line"><span class="params">#################################</span> GENERAL <span class="params">#####################################</span></span><br><span class="line"></span><br><span class="line"><span class="params">#</span> By default Redis does not run as a daemon. Use &#x27;yes&#x27; if you need it.</span><br><span class="line"><span class="params">#</span> Note that Redis will write a pid file in /var/run/redis.pid when daemonized.</span><br><span class="line">daemonize no</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> If you run Redis from upstart or systemd, Redis can interact with your</span><br><span class="line"><span class="params">#</span> supervision tree. Options:</span><br><span class="line"><span class="params">#</span>   supervised no      - no supervision interaction</span><br><span class="line"><span class="params">#</span>   supervised upstart - signal upstart by putting Redis into SIGSTOP mode</span><br><span class="line"><span class="params">#</span>   supervised systemd - signal systemd by writing READY=1 to <span class="built_in">$</span>NOTIFY<span class="built_in">_</span>SOCKET</span><br><span class="line"><span class="params">#</span>   supervised auto    - detect upstart or systemd method based on</span><br><span class="line"><span class="params">#</span>                        UPSTART<span class="built_in">_</span>JOB or NOTIFY<span class="built_in">_</span>SOCKET environment variables</span><br><span class="line"><span class="params">#</span> Note: these supervision methods only signal &quot;process is ready.&quot;</span><br><span class="line"><span class="params">#</span>       They do not enable continuous liveness pings back to your supervisor.</span><br><span class="line">supervised no</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> If a pid file is specified, Redis writes it where specified at startup</span><br><span class="line"><span class="params">#</span> and removes it at exit.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> When the server runs non daemonized, no pid file is created if none is</span><br><span class="line"><span class="params">#</span> specified in the configuration. When the server is daemonized, the pid file</span><br><span class="line"><span class="params">#</span> is used even if not specified, defaulting to &quot;/var/run/redis.pid&quot;.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> Creating a pid file is best effort: if Redis is not able to create it</span><br><span class="line"><span class="params">#</span> nothing bad happens, the server will start and run normally.</span><br><span class="line">pidfile /var/run/redis<span class="built_in">_</span>6379.pid</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> Specify the server verbosity level.</span><br><span class="line"><span class="params">#</span> This can be one of:</span><br><span class="line"><span class="params">#</span> debug (a lot of information, useful for development/testing)</span><br><span class="line"><span class="params">#</span> verbose (many rarely useful info, but not a mess like the debug level)</span><br><span class="line"><span class="params">#</span> notice (moderately verbose, what you want in production probably)</span><br><span class="line"><span class="params">#</span> warning (only very important / critical messages are logged)</span><br><span class="line">loglevel notice</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> Specify the log file name. Also the empty string can be used to force</span><br><span class="line"><span class="params">#</span> Redis to log on the standard output. Note that if you use standard</span><br><span class="line"><span class="params">#</span> output for logging but daemonize, logs will be sent to /dev/null</span><br><span class="line">logfile &quot;&quot;</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> To enable logging to the system logger, just set &#x27;syslog-enabled&#x27; to yes,</span><br><span class="line"><span class="params">#</span> and optionally update the other syslog parameters to suit your needs.</span><br><span class="line"><span class="params">#</span> syslog-enabled no</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> Specify the syslog identity.</span><br><span class="line"><span class="params">#</span> syslog-ident redis</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> Specify the syslog facility. Must be USER or between LOCAL0-LOCAL7.</span><br><span class="line"><span class="params">#</span> syslog-facility local0</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> Set the number of databases. The default database is DB 0, you can select</span><br><span class="line"><span class="params">#</span> a different one on a per-connection basis using SELECT &lt;dbid&gt; where</span><br><span class="line"><span class="params">#</span> dbid is a number between 0 and &#x27;databases&#x27;-1</span><br><span class="line">databases 16</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> By default Redis shows an ASCII art logo only when started to log to the</span><br><span class="line"><span class="params">#</span> standard output and if the standard output is a TTY. Basically this means</span><br><span class="line"><span class="params">#</span> that normally a logo is displayed only in interactive sessions.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> However it is possible to force the pre-4.0 behavior and always show a</span><br><span class="line"><span class="params">#</span> ASCII art logo in startup logs by setting the following option to yes.</span><br><span class="line">always-show-logo yes</span><br><span class="line"></span><br><span class="line"><span class="params">################################</span> SNAPSHOTTING  <span class="params">################################</span></span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> Save the DB on disk:</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span>   save &lt;seconds&gt; &lt;changes&gt;</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span>   Will save the DB if both the given number of seconds and the given</span><br><span class="line"><span class="params">#</span>   number of write operations against the DB occurred.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span>   In the example below the behaviour will be to save:</span><br><span class="line"><span class="params">#</span>   after 900 sec (15 min) if at least 1 key changed</span><br><span class="line"><span class="params">#</span>   after 300 sec (5 min) if at least 10 keys changed</span><br><span class="line"><span class="params">#</span>   after 60 sec if at least 10000 keys changed</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span>   Note: you can disable saving completely by commenting out all &quot;save&quot; lines.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span>   It is also possible to remove all the previously configured save</span><br><span class="line"><span class="params">#</span>   points by adding a save directive with a single empty string argument</span><br><span class="line"><span class="params">#</span>   like in the following example:</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span>   save &quot;&quot;</span><br><span class="line"></span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> By default Redis will stop accepting writes if RDB snapshots are enabled</span><br><span class="line"><span class="params">#</span> (at least one save point) and the latest background save failed.</span><br><span class="line"><span class="params">#</span> This will make the user aware (in a hard way) that data is not persisting</span><br><span class="line"><span class="params">#</span> on disk properly, otherwise chances are that no one will notice and some</span><br><span class="line"><span class="params">#</span> disaster will happen.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> If the background saving process will start working again Redis will</span><br><span class="line"><span class="params">#</span> automatically allow writes again.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> However if you have setup your proper monitoring of the Redis server</span><br><span class="line"><span class="params">#</span> and persistence, you may want to disable this feature so that Redis will</span><br><span class="line"><span class="params">#</span> continue to work as usual even if there are problems with disk,</span><br><span class="line"><span class="params">#</span> permissions, and so forth.</span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> Compress string objects using LZF when dump .rdb databases?</span><br><span class="line"><span class="params">#</span> For default that&#x27;s set to &#x27;yes&#x27; as it&#x27;s almost always a win.</span><br><span class="line"><span class="params">#</span> If you want to save some CPU in the saving child set it to &#x27;no&#x27; but</span><br><span class="line"><span class="params">#</span> the dataset will likely be bigger if you have compressible values or keys.</span><br><span class="line">rdbcompression yes</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> Since version 5 of RDB a CRC64 checksum is placed at the end of the file.</span><br><span class="line"><span class="params">#</span> This makes the format more resistant to corruption but there is a performance</span><br><span class="line"><span class="params">#</span> hit to pay (around 10<span class="comment">%) when saving and loading RDB files, so you can disable it</span></span><br><span class="line"><span class="params">#</span> for maximum performances.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> RDB files created with checksum disabled have a checksum of zero that will</span><br><span class="line"><span class="params">#</span> tell the loading code to skip the check.</span><br><span class="line">rdbchecksum yes</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> The filename where to dump the DB</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> Remove RDB files used by replication in instances without persistence</span><br><span class="line"><span class="params">#</span> enabled. By default this option is disabled, however there are environments</span><br><span class="line"><span class="params">#</span> where for regulations or other security concerns, RDB files persisted on</span><br><span class="line"><span class="params">#</span> disk by masters in order to feed replicas, or stored on disk by replicas</span><br><span class="line"><span class="params">#</span> in order to load them for the initial synchronization, should be deleted</span><br><span class="line"><span class="params">#</span> ASAP. Note that this option ONLY WORKS in instances that have both AOF</span><br><span class="line"><span class="params">#</span> and RDB persistence disabled, otherwise is completely ignored.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> An alternative (and sometimes better) way to obtain the same effect is</span><br><span class="line"><span class="params">#</span> to use diskless replication on both master and replicas instances. However</span><br><span class="line"><span class="params">#</span> in the case of replicas, diskless is not always an option.</span><br><span class="line">rdb-del-sync-files no</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> The working directory.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> The DB will be written inside this directory, with the filename specified</span><br><span class="line"><span class="params">#</span> above using the &#x27;dbfilename&#x27; configuration directive.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> The Append Only File will also be created inside this directory.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> Note that you must specify a directory here, not a file name.</span><br><span class="line">dir ./</span><br><span class="line"></span><br><span class="line"><span class="params">#################################</span> REPLICATION <span class="params">#################################</span></span><br><span class="line"></span><br><span class="line"><span class="params">#</span> Master-Replica replication. Use replicaof to make a Redis instance a copy of</span><br><span class="line"><span class="params">#</span> another Redis server. A few things to understand ASAP about Redis replication.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span>   +------------------+      +---------------+</span><br><span class="line"><span class="params">#</span>   |      Master      | ---&gt; |    Replica    |</span><br><span class="line"><span class="params">#</span>   | (receive writes) |      |  (exact copy) |</span><br><span class="line"><span class="params">#</span>   +------------------+      +---------------+</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> 1) Redis replication is asynchronous, but you can configure a master to</span><br><span class="line"><span class="params">#</span>    stop accepting writes if it appears to be not connected with at least</span><br><span class="line"><span class="params">#</span>    a given number of replicas.</span><br><span class="line"><span class="params">#</span> 2) Redis replicas are able to perform a partial resynchronization with the</span><br><span class="line"><span class="params">#</span>    master if the replication link is lost for a relatively small amount of</span><br><span class="line"><span class="params">#</span>    time. You may want to configure the replication backlog size (see the next</span><br><span class="line"><span class="params">#</span>    sections of this file) with a sensible value depending on your needs.</span><br><span class="line"><span class="params">#</span> 3) Replication is automatic and does not need user intervention. After a</span><br><span class="line"><span class="params">#</span>    network partition replicas automatically try to reconnect to masters</span><br><span class="line"><span class="params">#</span>    and resynchronize with them.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> replicaof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> If the master is password protected (using the &quot;requirepass&quot; configuration</span><br><span class="line"><span class="params">#</span> directive below) it is possible to tell the replica to authenticate before</span><br><span class="line"><span class="params">#</span> starting the replication synchronization process, otherwise the master will</span><br><span class="line"><span class="params">#</span> refuse the replica request.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> masterauth &lt;master-password&gt;</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> However this is not enough if you are using Redis ACLs (for Redis version</span><br><span class="line"><span class="params">#</span> 6 or greater), and the default user is not capable of running the PSYNC</span><br><span class="line"><span class="params">#</span> command and/or other commands needed for replication. In this case it&#x27;s</span><br><span class="line"><span class="params">#</span> better to configure a special user to use with replication, and specify the</span><br><span class="line"><span class="params">#</span> masteruser configuration as such:</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> masteruser &lt;username&gt;</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> When masteruser is specified, the replica will authenticate against its</span><br><span class="line"><span class="params">#</span> master using the new AUTH form: AUTH &lt;username&gt; &lt;password&gt;.</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> When a replica loses its connection with the master, or when the replication</span><br><span class="line"><span class="params">#</span> is still in progress, the replica can act in two different ways:</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> 1) if replica-serve-stale-data is set to &#x27;yes&#x27; (the default) the replica will</span><br><span class="line"><span class="params">#</span>    still reply to client requests, possibly with out of date data, or the</span><br><span class="line"><span class="params">#</span>    data set may just be empty if this is the first synchronization.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> 2) if replica-serve-stale-data is set to &#x27;no&#x27; the replica will reply with</span><br><span class="line"><span class="params">#</span>    an error &quot;SYNC with master in progress&quot; to all the kind of commands</span><br><span class="line"><span class="params">#</span>    but to INFO, replicaOF, AUTH, PING, SHUTDOWN, REPLCONF, ROLE, CONFIG,</span><br><span class="line"><span class="params">#</span>    SUBSCRIBE, UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, PUBLISH, PUBSUB,</span><br><span class="line"><span class="params">#</span>    COMMAND, POST, HOST: and LATENCY.</span><br><span class="line"><span class="params">#</span></span><br><span class="line">replica-serve-stale-data yes</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> You can configure a replica instance to accept writes or not. Writing against</span><br><span class="line"><span class="params">#</span> a replica instance may be useful to store some ephemeral data (because data</span><br><span class="line"><span class="params">#</span> written on a replica will be easily deleted after resync with the master) but</span><br><span class="line"><span class="params">#</span> may also cause problems if clients are writing to it because of a</span><br><span class="line"><span class="params">#</span> misconfiguration.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> Since Redis 2.6 by default replicas are read-only.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> Note: read only replicas are not designed to be exposed to untrusted clients</span><br><span class="line"><span class="params">#</span> on the internet. It&#x27;s just a protection layer against misuse of the instance.</span><br><span class="line"><span class="params">#</span> Still a read only replica exports by default all the administrative commands</span><br><span class="line"><span class="params">#</span> such as CONFIG, DEBUG, and so forth. To a limited extent you can improve</span><br><span class="line"><span class="params">#</span> security of read only replicas using &#x27;rename-command&#x27; to shadow all the</span><br><span class="line"><span class="params">#</span> administrative / dangerous commands.</span><br><span class="line">replica-read-only yes</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> Replication SYNC strategy: disk or socket.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> New replicas and reconnecting replicas that are not able to continue the</span><br><span class="line"><span class="params">#</span> replication process just receiving differences, need to do what is called a</span><br><span class="line"><span class="params">#</span> &quot;full synchronization&quot;. An RDB file is transmitted from the master to the</span><br><span class="line"><span class="params">#</span> replicas.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> The transmission can happen in two different ways:</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> 1) Disk-backed: The Redis master creates a new process that writes the RDB</span><br><span class="line"><span class="params">#</span>                 file on disk. Later the file is transferred by the parent</span><br><span class="line"><span class="params">#</span>                 process to the replicas incrementally.</span><br><span class="line"><span class="params">#</span> 2) Diskless: The Redis master creates a new process that directly writes the</span><br><span class="line"><span class="params">#</span>              RDB file to replica sockets, without touching the disk at all.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> With disk-backed replication, while the RDB file is generated, more replicas</span><br><span class="line"><span class="params">#</span> can be queued and served with the RDB file as soon as the current child</span><br><span class="line"><span class="params">#</span> producing the RDB file finishes its work. With diskless replication instead</span><br><span class="line"><span class="params">#</span> once the transfer starts, new replicas arriving will be queued and a new</span><br><span class="line"><span class="params">#</span> transfer will start when the current one terminates.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> When diskless replication is used, the master waits a configurable amount of</span><br><span class="line"><span class="params">#</span> time (in seconds) before starting the transfer in the hope that multiple</span><br><span class="line"><span class="params">#</span> replicas will arrive and the transfer can be parallelized.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> With slow disks and fast (large bandwidth) networks, diskless replication</span><br><span class="line"><span class="params">#</span> works better.</span><br><span class="line">repl-diskless-sync no</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> When diskless replication is enabled, it is possible to configure the delay</span><br><span class="line"><span class="params">#</span> the server waits in order to spawn the child that transfers the RDB via socket</span><br><span class="line"><span class="params">#</span> to the replicas.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> This is important since once the transfer starts, it is not possible to serve</span><br><span class="line"><span class="params">#</span> new replicas arriving, that will be queued for the next RDB transfer, so the</span><br><span class="line"><span class="params">#</span> server waits a delay in order to let more replicas arrive.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> The delay is specified in seconds, and by default is 5 seconds. To disable</span><br><span class="line"><span class="params">#</span> it entirely just set it to 0 seconds and the transfer will start ASAP.</span><br><span class="line">repl-diskless-sync-delay 5</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> -----------------------------------------------------------------------------</span><br><span class="line"><span class="params">#</span> WARNING: RDB diskless load is experimental. Since in this setup the replica</span><br><span class="line"><span class="params">#</span> does not immediately store an RDB on disk, it may cause data loss during</span><br><span class="line"><span class="params">#</span> failovers. RDB diskless load + Redis modules not handling I/O reads may also</span><br><span class="line"><span class="params">#</span> cause Redis to abort in case of I/O errors during the initial synchronization</span><br><span class="line"><span class="params">#</span> stage with the master. Use only if your do what you are doing.</span><br><span class="line"><span class="params">#</span> -----------------------------------------------------------------------------</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> Replica can load the RDB it reads from the replication link directly from the</span><br><span class="line"><span class="params">#</span> socket, or store the RDB to a file and read that file after it was completely</span><br><span class="line"><span class="params">#</span> recived from the master.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> In many cases the disk is slower than the network, and storing and loading</span><br><span class="line"><span class="params">#</span> the RDB file may increase replication time (and even increase the master&#x27;s</span><br><span class="line"><span class="params">#</span> Copy on Write memory and salve buffers).</span><br><span class="line"><span class="params">#</span> However, parsing the RDB file directly from the socket may mean that we have</span><br><span class="line"><span class="params">#</span> to flush the contents of the current database before the full rdb was</span><br><span class="line"><span class="params">#</span> received. For this reason we have the following options:</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> &quot;disabled&quot;    - Don&#x27;t use diskless load (store the rdb file to the disk first)</span><br><span class="line"><span class="params">#</span> &quot;on-empty-db&quot; - Use diskless load only when it is completely safe.</span><br><span class="line"><span class="params">#</span> &quot;swapdb&quot;      - Keep a copy of the current db contents in RAM while parsing</span><br><span class="line"><span class="params">#</span>                 the data directly from the socket. note that this requires</span><br><span class="line"><span class="params">#</span>                 sufficient memory, if you don&#x27;t have it, you risk an OOM kill.</span><br><span class="line">repl-diskless-load disabled</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> Replicas send PINGs to server in a predefined interval. It&#x27;s possible to</span><br><span class="line"><span class="params">#</span> change this interval with the repl<span class="built_in">_</span>ping<span class="built_in">_</span>replica<span class="built_in">_</span>period option. The default</span><br><span class="line"><span class="params">#</span> value is 10 seconds.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> repl-ping-replica-period 10</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> The following option sets the replication timeout for:</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> 1) Bulk transfer I/O during SYNC, from the point of view of replica.</span><br><span class="line"><span class="params">#</span> 2) Master timeout from the point of view of replicas (data, pings).</span><br><span class="line"><span class="params">#</span> 3) Replica timeout from the point of view of masters (REPLCONF ACK pings).</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> It is important to make sure that this value is greater than the value</span><br><span class="line"><span class="params">#</span> specified for repl-ping-replica-period otherwise a timeout will be detected</span><br><span class="line"><span class="params">#</span> every time there is low traffic between the master and the replica.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> repl-timeout 60</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> Disable TCP<span class="built_in">_</span>NODELAY on the replica socket after SYNC?</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> If you select &quot;yes&quot; Redis will use a smaller number of TCP packets and</span><br><span class="line"><span class="params">#</span> less bandwidth to send data to replicas. But this can add a delay for</span><br><span class="line"><span class="params">#</span> the data to appear on the replica side, up to 40 milliseconds with</span><br><span class="line"><span class="params">#</span> Linux kernels using a default configuration.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> If you select &quot;no&quot; the delay for data to appear on the replica side will</span><br><span class="line"><span class="params">#</span> be reduced but more bandwidth will be used for replication.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> By default we optimize for low latency, but in very high traffic conditions</span><br><span class="line"><span class="params">#</span> or when the master and replicas are many hops away, turning this to &quot;yes&quot; may</span><br><span class="line"><span class="params">#</span> be a good idea.</span><br><span class="line">repl-disable-tcp-nodelay no</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> Set the replication backlog size. The backlog is a buffer that accumulates</span><br><span class="line"><span class="params">#</span> replica data when replicas are disconnected for some time, so that when a</span><br><span class="line"><span class="params">#</span> replica wants to reconnect again, often a full resync is not needed, but a</span><br><span class="line"><span class="params">#</span> partial resync is enough, just passing the portion of data the replica</span><br><span class="line"><span class="params">#</span> missed while disconnected.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> The bigger the replication backlog, the longer the time the replica can be</span><br><span class="line"><span class="params">#</span> disconnected and later be able to perform a partial resynchronization.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> The backlog is only allocated once there is at least a replica connected.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> repl-backlog-size 1mb</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> After a master has no longer connected replicas for some time, the backlog</span><br><span class="line"><span class="params">#</span> will be freed. The following option configures the amount of seconds that</span><br><span class="line"><span class="params">#</span> need to elapse, starting from the time the last replica disconnected, for</span><br><span class="line"><span class="params">#</span> the backlog buffer to be freed.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> Note that replicas never free the backlog for timeout, since they may be</span><br><span class="line"><span class="params">#</span> promoted to masters later, and should be able to correctly &quot;partially</span><br><span class="line"><span class="params">#</span> resynchronize&quot; with the replicas: hence they should always accumulate backlog.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> A value of 0 means to never release the backlog.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> repl-backlog-ttl 3600</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> The replica priority is an integer number published by Redis in the INFO</span><br><span class="line"><span class="params">#</span> output. It is used by Redis Sentinel in order to select a replica to promote</span><br><span class="line"><span class="params">#</span> into a master if the master is no longer working correctly.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> A replica with a low priority number is considered better for promotion, so</span><br><span class="line"><span class="params">#</span> for instance if there are three replicas with priority 10, 100, 25 Sentinel</span><br><span class="line"><span class="params">#</span> will pick the one with priority 10, that is the lowest.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> However a special priority of 0 marks the replica as not able to perform the</span><br><span class="line"><span class="params">#</span> role of master, so a replica with priority of 0 will never be selected by</span><br><span class="line"><span class="params">#</span> Redis Sentinel for promotion.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> By default the priority is 100.</span><br><span class="line">replica-priority 100</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> It is possible for a master to stop accepting writes if there are less than</span><br><span class="line"><span class="params">#</span> N replicas connected, having a lag less or equal than M seconds.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> The N replicas need to be in &quot;online&quot; state.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> The lag in seconds, that must be &lt;= the specified value, is calculated from</span><br><span class="line"><span class="params">#</span> the last ping received from the replica, that is usually sent every second.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> This option does not GUARANTEE that N replicas will accept the write, but</span><br><span class="line"><span class="params">#</span> will limit the window of exposure for lost writes in case not enough replicas</span><br><span class="line"><span class="params">#</span> are available, to the specified number of seconds.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> For example to require at least 3 replicas with a lag &lt;= 10 seconds use:</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> min-replicas-to-write 3</span><br><span class="line"><span class="params">#</span> min-replicas-max-lag 10</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> Setting one or the other to 0 disables the feature.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> By default min-replicas-to-write is set to 0 (feature disabled) and</span><br><span class="line"><span class="params">#</span> min-replicas-max-lag is set to 10.</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> A Redis master is able to list the address and port of the attached</span><br><span class="line"><span class="params">#</span> replicas in different ways. For example the &quot;INFO replication&quot; section</span><br><span class="line"><span class="params">#</span> offers this information, which is used, among other tools, by</span><br><span class="line"><span class="params">#</span> Redis Sentinel in order to discover replica instances.</span><br><span class="line"><span class="params">#</span> Another place where this info is available is in the output of the</span><br><span class="line"><span class="params">#</span> &quot;ROLE&quot; command of a master.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> The listed IP and address normally reported by a replica is obtained</span><br><span class="line"><span class="params">#</span> in the following way:</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span>   IP: The address is auto detected by checking the peer address</span><br><span class="line"><span class="params">#</span>   of the socket used by the replica to connect with the master.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span>   Port: The port is communicated by the replica during the replication</span><br><span class="line"><span class="params">#</span>   handshake, and is normally the port that the replica is using to</span><br><span class="line"><span class="params">#</span>   listen for connections.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> However when port forwarding or Network Address Translation (NAT) is</span><br><span class="line"><span class="params">#</span> used, the replica may be actually reachable via different IP and port</span><br><span class="line"><span class="params">#</span> pairs. The following two options can be used by a replica in order to</span><br><span class="line"><span class="params">#</span> report to its master a specific set of IP and port, so that both INFO</span><br><span class="line"><span class="params">#</span> and ROLE will report those values.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> There is no need to use both the options if you need to override just</span><br><span class="line"><span class="params">#</span> the port or the IP address.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> replica-announce-ip 5.5.5.5</span><br><span class="line"><span class="params">#</span> replica-announce-port 1234</span><br><span class="line"></span><br><span class="line"><span class="params">###############################</span> KEYS TRACKING <span class="params">#################################</span></span><br><span class="line"></span><br><span class="line"><span class="params">#</span> Redis implements server assisted support for client side caching of values.</span><br><span class="line"><span class="params">#</span> This is implemented using an invalidation table that remembers, using</span><br><span class="line"><span class="params">#</span> 16 millions of slots, what clients may have certain subsets of keys. In turn</span><br><span class="line"><span class="params">#</span> this is used in order to send invalidation messages to clients. Please</span><br><span class="line"><span class="params">#</span> to understand more about the feature check this page:</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span>   https://redis.io/topics/client-side-caching</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> When tracking is enabled for a client, all the read only queries are assumed</span><br><span class="line"><span class="params">#</span> to be cached: this will force Redis to store information in the invalidation</span><br><span class="line"><span class="params">#</span> table. When keys are modified, such information is flushed away, and</span><br><span class="line"><span class="params">#</span> invalidation messages are sent to the clients. However if the workload is</span><br><span class="line"><span class="params">#</span> heavily dominated by reads, Redis could use more and more memory in order</span><br><span class="line"><span class="params">#</span> to track the keys fetched by many clients.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> For this reason it is possible to configure a maximum fill value for the</span><br><span class="line"><span class="params">#</span> invalidation table. By default it is set to 1M of keys, and once this limit</span><br><span class="line"><span class="params">#</span> is reached, Redis will start to evict keys in the invalidation table</span><br><span class="line"><span class="params">#</span> even if they were not modified, just to reclaim memory: this will in turn</span><br><span class="line"><span class="params">#</span> force the clients to invalidate the cached values. Basically the table</span><br><span class="line"><span class="params">#</span> maximum size is a trade off between the memory you want to spend server</span><br><span class="line"><span class="params">#</span> side to track information about who cached what, and the ability of clients</span><br><span class="line"><span class="params">#</span> to retain cached objects in memory.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> If you set the value to 0, it means there are no limits, and Redis will</span><br><span class="line"><span class="params">#</span> retain as many keys as needed in the invalidation table.</span><br><span class="line"><span class="params">#</span> In the &quot;stats&quot; INFO section, you can find information about the number of</span><br><span class="line"><span class="params">#</span> keys in the invalidation table at every given moment.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> Note: when key tracking is used in broadcasting mode, no memory is used</span><br><span class="line"><span class="params">#</span> in the server side so this setting is useless.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> tracking-table-max-keys 1000000</span><br><span class="line"></span><br><span class="line"><span class="params">##################################</span> SECURITY <span class="params">###################################</span></span><br><span class="line"></span><br><span class="line"><span class="params">#</span> Warning: since Redis is pretty fast an outside user can try up to</span><br><span class="line"><span class="params">#</span> 1 million passwords per second against a modern box. This means that you</span><br><span class="line"><span class="params">#</span> should use very strong passwords, otherwise they will be very easy to break.</span><br><span class="line"><span class="params">#</span> Note that because the password is really a shared secret between the client</span><br><span class="line"><span class="params">#</span> and the server, and should not be memorized by any human, the password</span><br><span class="line"><span class="params">#</span> can be easily a long string from /dev/urandom or whatever, so by using a</span><br><span class="line"><span class="params">#</span> long and unguessable password no brute force attack will be possible.</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> Redis ACL users are defined in the following format:</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span>   user &lt;username&gt; ... acl rules ...</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> For example:</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span>   user worker +@list +@connection ~jobs:* on &gt;ffa9203c493aa99</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> The special username &quot;default&quot; is used for new connections. If this user</span><br><span class="line"><span class="params">#</span> has the &quot;nopass&quot; rule, then new connections will be immediately authenticated</span><br><span class="line"><span class="params">#</span> as the &quot;default&quot; user without the need of any password provided via the</span><br><span class="line"><span class="params">#</span> AUTH command. Otherwise if the &quot;default&quot; user is not flagged with &quot;nopass&quot;</span><br><span class="line"><span class="params">#</span> the connections will start in not authenticated state, and will require</span><br><span class="line"><span class="params">#</span> AUTH (or the HELLO command AUTH option) in order to be authenticated and</span><br><span class="line"><span class="params">#</span> start to work.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> The ACL rules that describe what an user can do are the following:</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span>  on           Enable the user: it is possible to authenticate as this user.</span><br><span class="line"><span class="params">#</span>  off          Disable the user: it&#x27;s no longer possible to authenticate</span><br><span class="line"><span class="params">#</span>               with this user, however the already authenticated connections</span><br><span class="line"><span class="params">#</span>               will still work.</span><br><span class="line"><span class="params">#</span>  +&lt;command&gt;   Allow the execution of that command</span><br><span class="line"><span class="params">#</span>  -&lt;command&gt;   Disallow the execution of that command</span><br><span class="line"><span class="params">#</span>  +@&lt;category&gt; Allow the execution of all the commands in such category</span><br><span class="line"><span class="params">#</span>               with valid categories are like @admin, @set, @sortedset, ...</span><br><span class="line"><span class="params">#</span>               and so forth, see the full list in the server.c file where</span><br><span class="line"><span class="params">#</span>               the Redis command table is described and defined.</span><br><span class="line"><span class="params">#</span>               The special category @all means all the commands, but currently</span><br><span class="line"><span class="params">#</span>               present in the server, and that will be loaded in the future</span><br><span class="line"><span class="params">#</span>               via modules.</span><br><span class="line"><span class="params">#</span>  +&lt;command&gt;|subcommand    Allow a specific subcommand of an otherwise</span><br><span class="line"><span class="params">#</span>                           disabled command. Note that this form is not</span><br><span class="line"><span class="params">#</span>                           allowed as negative like -DEBUG|SEGFAULT, but</span><br><span class="line"><span class="params">#</span>                           only additive starting with &quot;+&quot;.</span><br><span class="line"><span class="params">#</span>  allcommands  Alias for +@all. Note that it implies the ability to execute</span><br><span class="line"><span class="params">#</span>               all the future commands loaded via the modules system.</span><br><span class="line"><span class="params">#</span>  nocommands   Alias for -@all.</span><br><span class="line"><span class="params">#</span>  ~&lt;pattern&gt;   Add a pattern of keys that can be mentioned as part of</span><br><span class="line"><span class="params">#</span>               commands. For instance ~* allows all the keys. The pattern</span><br><span class="line"><span class="params">#</span>               is a glob-style pattern like the one of KEYS.</span><br><span class="line"><span class="params">#</span>               It is possible to specify multiple patterns.</span><br><span class="line"><span class="params">#</span>  allkeys      Alias for ~*</span><br><span class="line"><span class="params">#</span>  resetkeys    Flush the list of allowed keys patterns.</span><br><span class="line"><span class="params">#</span>  &gt;&lt;password&gt;  Add this passowrd to the list of valid password for the user.</span><br><span class="line"><span class="params">#</span>               For example &gt;mypass will add &quot;mypass&quot; to the list.</span><br><span class="line"><span class="params">#</span>               This directive clears the &quot;nopass&quot; flag (see later).</span><br><span class="line"><span class="params">#</span>  &lt;&lt;password&gt;  Remove this password from the list of valid passwords.</span><br><span class="line"><span class="params">#</span>  nopass       All the set passwords of the user are removed, and the user</span><br><span class="line"><span class="params">#</span>               is flagged as requiring no password: it means that every</span><br><span class="line"><span class="params">#</span>               password will work against this user. If this directive is</span><br><span class="line"><span class="params">#</span>               used for the default user, every new connection will be</span><br><span class="line"><span class="params">#</span>               immediately authenticated with the default user without</span><br><span class="line"><span class="params">#</span>               any explicit AUTH command required. Note that the &quot;resetpass&quot;</span><br><span class="line"><span class="params">#</span>               directive will clear this condition.</span><br><span class="line"><span class="params">#</span>  resetpass    Flush the list of allowed passwords. Moreover removes the</span><br><span class="line"><span class="params">#</span>               &quot;nopass&quot; status. After &quot;resetpass&quot; the user has no associated</span><br><span class="line"><span class="params">#</span>               passwords and there is no way to authenticate without adding</span><br><span class="line"><span class="params">#</span>               some password (or setting it as &quot;nopass&quot; later).</span><br><span class="line"><span class="params">#</span>  reset        Performs the following actions: resetpass, resetkeys, off,</span><br><span class="line"><span class="params">#</span>               -@all. The user returns to the same state it has immediately</span><br><span class="line"><span class="params">#</span>               after its creation.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> ACL rules can be specified in any order: for instance you can start with</span><br><span class="line"><span class="params">#</span> passwords, then flags, or key patterns. However note that the additive</span><br><span class="line"><span class="params">#</span> and subtractive rules will CHANGE MEANING depending on the ordering.</span><br><span class="line"><span class="params">#</span> For instance see the following example:</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span>   user alice on +@all -DEBUG ~* &gt;somepassword</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> This will allow &quot;alice&quot; to use all the commands with the exception of the</span><br><span class="line"><span class="params">#</span> DEBUG command, since +@all added all the commands to the set of the commands</span><br><span class="line"><span class="params">#</span> alice can use, and later DEBUG was removed. However if we invert the order</span><br><span class="line"><span class="params">#</span> of two ACL rules the result will be different:</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span>   user alice on -DEBUG +@all ~* &gt;somepassword</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> Now DEBUG was removed when alice had yet no commands in the set of allowed</span><br><span class="line"><span class="params">#</span> commands, later all the commands are added, so the user will be able to</span><br><span class="line"><span class="params">#</span> execute everything.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> Basically ACL rules are processed left-to-right.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> For more information about ACL configuration please refer to</span><br><span class="line"><span class="params">#</span> the Redis web site at https://redis.io/topics/acl</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> ACL LOG</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> The ACL Log tracks failed commands and authentication events associated</span><br><span class="line"><span class="params">#</span> with ACLs. The ACL Log is useful to troubleshoot failed commands blocked </span><br><span class="line"><span class="params">#</span> by ACLs. The ACL Log is stored in memory. You can reclaim memory with </span><br><span class="line"><span class="params">#</span> ACL LOG RESET. Define the maximum entry length of the ACL Log below.</span><br><span class="line">acllog-max-len 128</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> Using an external ACL file</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> Instead of configuring users here in this file, it is possible to use</span><br><span class="line"><span class="params">#</span> a stand-alone file just listing users. The two methods cannot be mixed:</span><br><span class="line"><span class="params">#</span> if you configure users here and at the same time you activate the exteranl</span><br><span class="line"><span class="params">#</span> ACL file, the server will refuse to start.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> The format of the external ACL user file is exactly the same as the</span><br><span class="line"><span class="params">#</span> format that is used inside redis.conf to describe users.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> aclfile /etc/redis/users.acl</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> IMPORTANT NOTE: starting with Redis 6 &quot;requirepass&quot; is just a compatiblity</span><br><span class="line"><span class="params">#</span> layer on top of the new ACL system. The option effect will be just setting</span><br><span class="line"><span class="params">#</span> the password for the default user. Clients will still authenticate using</span><br><span class="line"><span class="params">#</span> AUTH &lt;password&gt; as usually, or more explicitly with AUTH default &lt;password&gt;</span><br><span class="line"><span class="params">#</span> if they follow the new protocol: both will work.</span><br><span class="line"><span class="params">#</span> user defined password</span><br><span class="line">requirepass ***</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> Command renaming (DEPRECATED).</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> ------------------------------------------------------------------------</span><br><span class="line"><span class="params">#</span> WARNING: avoid using this option if possible. Instead use ACLs to remove</span><br><span class="line"><span class="params">#</span> commands from the default user, and put them only in some admin user you</span><br><span class="line"><span class="params">#</span> create for administrative purposes.</span><br><span class="line"><span class="params">#</span> ------------------------------------------------------------------------</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> It is possible to change the name of dangerous commands in a shared</span><br><span class="line"><span class="params">#</span> environment. For instance the CONFIG command may be renamed into something</span><br><span class="line"><span class="params">#</span> hard to guess so that it will still be available for internal-use tools</span><br><span class="line"><span class="params">#</span> but not available for general clients.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> Example:</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> It is also possible to completely kill a command by renaming it into</span><br><span class="line"><span class="params">#</span> an empty string:</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> rename-command CONFIG &quot;&quot;</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> Please note that changing the name of commands that are logged into the</span><br><span class="line"><span class="params">#</span> AOF file or transmitted to replicas may cause problems.</span><br><span class="line"></span><br><span class="line"><span class="params">###################################</span> CLIENTS <span class="params">####################################</span></span><br><span class="line"></span><br><span class="line"><span class="params">#</span> Set the max number of connected clients at the same time. By default</span><br><span class="line"><span class="params">#</span> this limit is set to 10000 clients, however if the Redis server is not</span><br><span class="line"><span class="params">#</span> able to configure the process file limit to allow for the specified limit</span><br><span class="line"><span class="params">#</span> the max number of allowed clients is set to the current file limit</span><br><span class="line"><span class="params">#</span> minus 32 (as Redis reserves a few file descriptors for internal uses).</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> Once the limit is reached Redis will close all the new connections sending</span><br><span class="line"><span class="params">#</span> an error &#x27;max number of clients reached&#x27;.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> IMPORTANT: When Redis Cluster is used, the max number of connections is also</span><br><span class="line"><span class="params">#</span> shared with the cluster bus: every node in the cluster will use two</span><br><span class="line"><span class="params">#</span> connections, one incoming and another outgoing. It is important to size the</span><br><span class="line"><span class="params">#</span> limit accordingly in case of very large clusters.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> maxclients 10000</span><br><span class="line"></span><br><span class="line"><span class="params">##############################</span> MEMORY MANAGEMENT <span class="params">################################</span></span><br><span class="line"></span><br><span class="line"><span class="params">#</span> Set a memory usage limit to the specified amount of bytes.</span><br><span class="line"><span class="params">#</span> When the memory limit is reached Redis will try to remove keys</span><br><span class="line"><span class="params">#</span> according to the eviction policy selected (see maxmemory-policy).</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> If Redis can&#x27;t remove keys according to the policy, or if the policy is</span><br><span class="line"><span class="params">#</span> set to &#x27;noeviction&#x27;, Redis will start to reply with errors to commands</span><br><span class="line"><span class="params">#</span> that would use more memory, like SET, LPUSH, and so on, and will continue</span><br><span class="line"><span class="params">#</span> to reply to read-only commands like GET.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> This option is usually useful when using Redis as an LRU or LFU cache, or to</span><br><span class="line"><span class="params">#</span> set a hard memory limit for an instance (using the &#x27;noeviction&#x27; policy).</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> WARNING: If you have replicas attached to an instance with maxmemory on,</span><br><span class="line"><span class="params">#</span> the size of the output buffers needed to feed the replicas are subtracted</span><br><span class="line"><span class="params">#</span> from the used memory count, so that network problems / resyncs will</span><br><span class="line"><span class="params">#</span> not trigger a loop where keys are evicted, and in turn the output</span><br><span class="line"><span class="params">#</span> buffer of replicas is full with DELs of keys evicted triggering the deletion</span><br><span class="line"><span class="params">#</span> of more keys, and so forth until the database is completely emptied.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> In short... if you have replicas attached it is suggested that you set a lower</span><br><span class="line"><span class="params">#</span> limit for maxmemory so that there is some free RAM on the system for replica</span><br><span class="line"><span class="params">#</span> output buffers (but this is not needed if the policy is &#x27;noeviction&#x27;).</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> maxmemory &lt;bytes&gt;</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> MAXMEMORY POLICY: how Redis will select what to remove when maxmemory</span><br><span class="line"><span class="params">#</span> is reached. You can select one from the following behaviors:</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> volatile-lru -&gt; Evict using approximated LRU, only keys with an expire set.</span><br><span class="line"><span class="params">#</span> allkeys-lru -&gt; Evict any key using approximated LRU.</span><br><span class="line"><span class="params">#</span> volatile-lfu -&gt; Evict using approximated LFU, only keys with an expire set.</span><br><span class="line"><span class="params">#</span> allkeys-lfu -&gt; Evict any key using approximated LFU.</span><br><span class="line"><span class="params">#</span> volatile-random -&gt; Remove a random key having an expire set.</span><br><span class="line"><span class="params">#</span> allkeys-random -&gt; Remove a random key, any key.</span><br><span class="line"><span class="params">#</span> volatile-ttl -&gt; Remove the key with the nearest expire time (minor TTL)</span><br><span class="line"><span class="params">#</span> noeviction -&gt; Don&#x27;t evict anything, just return an error on write operations.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> LRU means Least Recently Used</span><br><span class="line"><span class="params">#</span> LFU means Least Frequently Used</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> Both LRU, LFU and volatile-ttl are implemented using approximated</span><br><span class="line"><span class="params">#</span> randomized algorithms.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> Note: with any of the above policies, Redis will return an error on write</span><br><span class="line"><span class="params">#</span>       operations, when there are no suitable keys for eviction.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span>       At the date of writing these commands are: set setnx setex append</span><br><span class="line"><span class="params">#</span>       incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd</span><br><span class="line"><span class="params">#</span>       sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby</span><br><span class="line"><span class="params">#</span>       zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby</span><br><span class="line"><span class="params">#</span>       getset mset msetnx exec sort</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> The default is:</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> maxmemory-policy noeviction</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> LRU, LFU and minimal TTL algorithms are not precise algorithms but approximated</span><br><span class="line"><span class="params">#</span> algorithms (in order to save memory), so you can tune it for speed or</span><br><span class="line"><span class="params">#</span> accuracy. For default Redis will check five keys and pick the one that was</span><br><span class="line"><span class="params">#</span> used less recently, you can change the sample size using the following</span><br><span class="line"><span class="params">#</span> configuration directive.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> The default of 5 produces good enough results. 10 Approximates very closely</span><br><span class="line"><span class="params">#</span> true LRU but costs more CPU. 3 is faster but not very accurate.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> maxmemory-samples 5</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> Starting from Redis 5, by default a replica will ignore its maxmemory setting</span><br><span class="line"><span class="params">#</span> (unless it is promoted to master after a failover or manually). It means</span><br><span class="line"><span class="params">#</span> that the eviction of keys will be just handled by the master, sending the</span><br><span class="line"><span class="params">#</span> DEL commands to the replica as keys evict in the master side.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> This behavior ensures that masters and replicas stay consistent, and is usually</span><br><span class="line"><span class="params">#</span> what you want, however if your replica is writable, or you want the replica</span><br><span class="line"><span class="params">#</span> to have a different memory setting, and you are sure all the writes performed</span><br><span class="line"><span class="params">#</span> to the replica are idempotent, then you may change this default (but be sure</span><br><span class="line"><span class="params">#</span> to understand what you are doing).</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> Note that since the replica by default does not evict, it may end using more</span><br><span class="line"><span class="params">#</span> memory than the one set via maxmemory (there are certain buffers that may</span><br><span class="line"><span class="params">#</span> be larger on the replica, or data structures may sometimes take more memory</span><br><span class="line"><span class="params">#</span> and so forth). So make sure you monitor your replicas and make sure they</span><br><span class="line"><span class="params">#</span> have enough memory to never hit a real out-of-memory condition before the</span><br><span class="line"><span class="params">#</span> master hits the configured maxmemory setting.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> replica-ignore-maxmemory yes</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> Redis reclaims expired keys in two ways: upon access when those keys are</span><br><span class="line"><span class="params">#</span> found to be expired, and also in background, in what is called the</span><br><span class="line"><span class="params">#</span> &quot;active expire key&quot;. The key space is slowly and interactively scanned</span><br><span class="line"><span class="params">#</span> looking for expired keys to reclaim, so that it is possible to free memory</span><br><span class="line"><span class="params">#</span> of keys that are expired and will never be accessed again in a short time.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> The default effort of the expire cycle will try to avoid having more than</span><br><span class="line"><span class="params">#</span> ten percent of expired keys still in memory, and will try to avoid consuming</span><br><span class="line"><span class="params">#</span> more than 25<span class="comment">% of total memory and to add latency to the system. However</span></span><br><span class="line"><span class="params">#</span> it is possible to increase the expire &quot;effort&quot; that is normally set to</span><br><span class="line"><span class="params">#</span> &quot;1&quot;, to a greater value, up to the value &quot;10&quot;. At its maximum value the</span><br><span class="line"><span class="params">#</span> system will use more CPU, longer cycles (and technically may introduce</span><br><span class="line"><span class="params">#</span> more latency), and will tollerate less already expired keys still present</span><br><span class="line"><span class="params">#</span> in the system. It&#x27;s a tradeoff betweeen memory, CPU and latecy.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> active-expire-effort 1</span><br><span class="line"></span><br><span class="line"><span class="params">#############################</span> LAZY FREEING <span class="params">####################################</span></span><br><span class="line"></span><br><span class="line"><span class="params">#</span> Redis has two primitives to delete keys. One is called DEL and is a blocking</span><br><span class="line"><span class="params">#</span> deletion of the object. It means that the server stops processing new commands</span><br><span class="line"><span class="params">#</span> in order to reclaim all the memory associated with an object in a synchronous</span><br><span class="line"><span class="params">#</span> way. If the key deleted is associated with a small object, the time needed</span><br><span class="line"><span class="params">#</span> in order to execute the DEL command is very small and comparable to most other</span><br><span class="line"><span class="params">#</span> O(1) or O(log<span class="built_in">_</span>N) commands in Redis. However if the key is associated with an</span><br><span class="line"><span class="params">#</span> aggregated value containing millions of elements, the server can block for</span><br><span class="line"><span class="params">#</span> a long time (even seconds) in order to complete the operation.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> For the above reasons Redis also offers non blocking deletion primitives</span><br><span class="line"><span class="params">#</span> such as UNLINK (non blocking DEL) and the ASYNC option of FLUSHALL and</span><br><span class="line"><span class="params">#</span> FLUSHDB commands, in order to reclaim memory in background. Those commands</span><br><span class="line"><span class="params">#</span> are executed in constant time. Another thread will incrementally free the</span><br><span class="line"><span class="params">#</span> object in the background as fast as possible.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> DEL, UNLINK and ASYNC option of FLUSHALL and FLUSHDB are user-controlled.</span><br><span class="line"><span class="params">#</span> It&#x27;s up to the design of the application to understand when it is a good</span><br><span class="line"><span class="params">#</span> idea to use one or the other. However the Redis server sometimes has to</span><br><span class="line"><span class="params">#</span> delete keys or flush the whole database as a side effect of other operations.</span><br><span class="line"><span class="params">#</span> Specifically Redis deletes objects independently of a user call in the</span><br><span class="line"><span class="params">#</span> following scenarios:</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> 1) On eviction, because of the maxmemory and maxmemory policy configurations,</span><br><span class="line"><span class="params">#</span>    in order to make room for new data, without going over the specified</span><br><span class="line"><span class="params">#</span>    memory limit.</span><br><span class="line"><span class="params">#</span> 2) Because of expire: when a key with an associated time to live (see the</span><br><span class="line"><span class="params">#</span>    EXPIRE command) must be deleted from memory.</span><br><span class="line"><span class="params">#</span> 3) Because of a side effect of a command that stores data on a key that may</span><br><span class="line"><span class="params">#</span>    already exist. For example the RENAME command may delete the old key</span><br><span class="line"><span class="params">#</span>    content when it is replaced with another one. Similarly SUNIONSTORE</span><br><span class="line"><span class="params">#</span>    or SORT with STORE option may delete existing keys. The SET command</span><br><span class="line"><span class="params">#</span>    itself removes any old content of the specified key in order to replace</span><br><span class="line"><span class="params">#</span>    it with the specified string.</span><br><span class="line"><span class="params">#</span> 4) During replication, when a replica performs a full resynchronization with</span><br><span class="line"><span class="params">#</span>    its master, the content of the whole database is removed in order to</span><br><span class="line"><span class="params">#</span>    load the RDB file just transferred.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> In all the above cases the default is to delete objects in a blocking way,</span><br><span class="line"><span class="params">#</span> like if DEL was called. However you can configure each case specifically</span><br><span class="line"><span class="params">#</span> in order to instead release memory in a non-blocking way like if UNLINK</span><br><span class="line"><span class="params">#</span> was called, using the following configuration directives.</span><br><span class="line"></span><br><span class="line">lazyfree-lazy-eviction no</span><br><span class="line">lazyfree-lazy-expire no</span><br><span class="line">lazyfree-lazy-server-del no</span><br><span class="line">replica-lazy-flush no</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> It is also possible, for the case when to replace the user code DEL calls</span><br><span class="line"><span class="params">#</span> with UNLINK calls is not easy, to modify the default behavior of the DEL</span><br><span class="line"><span class="params">#</span> command to act exactly like UNLINK, using the following configuration</span><br><span class="line"><span class="params">#</span> directive:</span><br><span class="line"></span><br><span class="line">lazyfree-lazy-user-del no</span><br><span class="line"></span><br><span class="line"><span class="params">################################</span> THREADED I/O <span class="params">#################################</span></span><br><span class="line"></span><br><span class="line"><span class="params">#</span> Redis is mostly single threaded, however there are certain threaded</span><br><span class="line"><span class="params">#</span> operations such as UNLINK, slow I/O accesses and other things that are</span><br><span class="line"><span class="params">#</span> performed on side threads.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> Now it is also possible to handle Redis clients socket reads and writes</span><br><span class="line"><span class="params">#</span> in different I/O threads. Since especially writing is so slow, normally</span><br><span class="line"><span class="params">#</span> Redis users use pipelining in order to speedup the Redis performances per</span><br><span class="line"><span class="params">#</span> core, and spawn multiple instances in order to scale more. Using I/O</span><br><span class="line"><span class="params">#</span> threads it is possible to easily speedup two times Redis without resorting</span><br><span class="line"><span class="params">#</span> to pipelining nor sharding of the instance.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> By default threading is disabled, we suggest enabling it only in machines</span><br><span class="line"><span class="params">#</span> that have at least 4 or more cores, leaving at least one spare core.</span><br><span class="line"><span class="params">#</span> Using more than 8 threads is unlikely to help much. We also recommend using</span><br><span class="line"><span class="params">#</span> threaded I/O only if you actually have performance problems, with Redis</span><br><span class="line"><span class="params">#</span> instances being able to use a quite big percentage of CPU time, otherwise</span><br><span class="line"><span class="params">#</span> there is no point in using this feature.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> So for instance if you have a four cores boxes, try to use 2 or 3 I/O</span><br><span class="line"><span class="params">#</span> threads, if you have a 8 cores, try to use 6 threads. In order to</span><br><span class="line"><span class="params">#</span> enable I/O threads use the following configuration directive:</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> io-threads 4</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> Setting io-threads to 1 will just use the main thread as usually.</span><br><span class="line"><span class="params">#</span> When I/O threads are enabled, we only use threads for writes, that is</span><br><span class="line"><span class="params">#</span> to thread the write(2) syscall and transfer the client buffers to the</span><br><span class="line"><span class="params">#</span> socket. However it is also possible to enable threading of reads and</span><br><span class="line"><span class="params">#</span> protocol parsing using the following configuration directive, by setting</span><br><span class="line"><span class="params">#</span> it to yes:</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> io-threads-do-reads no</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> Usually threading reads doesn&#x27;t help much.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> NOTE 1: This configuration directive cannot be changed at runtime via</span><br><span class="line"><span class="params">#</span> CONFIG SET. Aso this feature currently does not work when SSL is</span><br><span class="line"><span class="params">#</span> enabled.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> NOTE 2: If you want to test the Redis speedup using redis-benchmark, make</span><br><span class="line"><span class="params">#</span> sure you also run the benchmark itself in threaded mode, using the</span><br><span class="line"><span class="params">#</span> --threads option to match the number of Redis theads, otherwise you&#x27;ll not</span><br><span class="line"><span class="params">#</span> be able to notice the improvements.</span><br><span class="line"></span><br><span class="line"><span class="params">##############################</span> APPEND ONLY MODE <span class="params">###############################</span></span><br><span class="line"></span><br><span class="line"><span class="params">#</span> By default Redis asynchronously dumps the dataset on disk. This mode is</span><br><span class="line"><span class="params">#</span> good enough in many applications, but an issue with the Redis process or</span><br><span class="line"><span class="params">#</span> a power outage may result into a few minutes of writes lost (depending on</span><br><span class="line"><span class="params">#</span> the configured save points).</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> The Append Only File is an alternative persistence mode that provides</span><br><span class="line"><span class="params">#</span> much better durability. For instance using the default data fsync policy</span><br><span class="line"><span class="params">#</span> (see later in the config file) Redis can lose just one second of writes in a</span><br><span class="line"><span class="params">#</span> dramatic event like a server power outage, or a single write if something</span><br><span class="line"><span class="params">#</span> wrong with the Redis process itself happens, but the operating system is</span><br><span class="line"><span class="params">#</span> still running correctly.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> AOF and RDB persistence can be enabled at the same time without problems.</span><br><span class="line"><span class="params">#</span> If the AOF is enabled on startup Redis will load the AOF, that is the file</span><br><span class="line"><span class="params">#</span> with the better durability guarantees.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> Please check http://redis.io/topics/persistence for more information.</span><br><span class="line"></span><br><span class="line">appendonly no</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> The name of the append only file (default: &quot;appendonly.aof&quot;)</span><br><span class="line"></span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> The fsync() call tells the Operating System to actually write data on disk</span><br><span class="line"><span class="params">#</span> instead of waiting for more data in the output buffer. Some OS will really flush</span><br><span class="line"><span class="params">#</span> data on disk, some other OS will just try to do it ASAP.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> Redis supports three different modes:</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> no: don&#x27;t fsync, just let the OS flush the data when it wants. Faster.</span><br><span class="line"><span class="params">#</span> always: fsync after every write to the append only log. Slow, Safest.</span><br><span class="line"><span class="params">#</span> everysec: fsync only one time every second. Compromise.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> The default is &quot;everysec&quot;, as that&#x27;s usually the right compromise between</span><br><span class="line"><span class="params">#</span> speed and data safety. It&#x27;s up to you to understand if you can relax this to</span><br><span class="line"><span class="params">#</span> &quot;no&quot; that will let the operating system flush the output buffer when</span><br><span class="line"><span class="params">#</span> it wants, for better performances (but if you can live with the idea of</span><br><span class="line"><span class="params">#</span> some data loss consider the default persistence mode that&#x27;s snapshotting),</span><br><span class="line"><span class="params">#</span> or on the contrary, use &quot;always&quot; that&#x27;s very slow but a bit safer than</span><br><span class="line"><span class="params">#</span> everysec.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> More details please check the following article:</span><br><span class="line"><span class="params">#</span> http://antirez.com/post/redis-persistence-demystified.html</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> If unsure, use &quot;everysec&quot;.</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> appendfsync always</span><br><span class="line">appendfsync everysec</span><br><span class="line"><span class="params">#</span> appendfsync no</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> When the AOF fsync policy is set to always or everysec, and a background</span><br><span class="line"><span class="params">#</span> saving process (a background save or AOF log background rewriting) is</span><br><span class="line"><span class="params">#</span> performing a lot of I/O against the disk, in some Linux configurations</span><br><span class="line"><span class="params">#</span> Redis may block too long on the fsync() call. Note that there is no fix for</span><br><span class="line"><span class="params">#</span> this currently, as even performing fsync in a different thread will block</span><br><span class="line"><span class="params">#</span> our synchronous write(2) call.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> In order to mitigate this problem it&#x27;s possible to use the following option</span><br><span class="line"><span class="params">#</span> that will prevent fsync() from being called in the main process while a</span><br><span class="line"><span class="params">#</span> BGSAVE or BGREWRITEAOF is in progress.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> This means that while another child is saving, the durability of Redis is</span><br><span class="line"><span class="params">#</span> the same as &quot;appendfsync none&quot;. In practical terms, this means that it is</span><br><span class="line"><span class="params">#</span> possible to lose up to 30 seconds of log in the worst scenario (with the</span><br><span class="line"><span class="params">#</span> default Linux settings).</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> If you have latency problems turn this to &quot;yes&quot;. Otherwise leave it as</span><br><span class="line"><span class="params">#</span> &quot;no&quot; that is the safest pick from the point of view of durability.</span><br><span class="line"></span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> Automatic rewrite of the append only file.</span><br><span class="line"><span class="params">#</span> Redis is able to automatically rewrite the log file implicitly calling</span><br><span class="line"><span class="params">#</span> BGREWRITEAOF when the AOF log size grows by the specified percentage.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> This is how it works: Redis remembers the size of the AOF file after the</span><br><span class="line"><span class="params">#</span> latest rewrite (if no rewrite has happened since the restart, the size of</span><br><span class="line"><span class="params">#</span> the AOF at startup is used).</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> This base size is compared to the current size. If the current size is</span><br><span class="line"><span class="params">#</span> bigger than the specified percentage, the rewrite is triggered. Also</span><br><span class="line"><span class="params">#</span> you need to specify a minimal size for the AOF file to be rewritten, this</span><br><span class="line"><span class="params">#</span> is useful to avoid rewriting the AOF file even if the percentage increase</span><br><span class="line"><span class="params">#</span> is reached but it is still pretty small.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> Specify a percentage of zero in order to disable the automatic AOF</span><br><span class="line"><span class="params">#</span> rewrite feature.</span><br><span class="line"></span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> An AOF file may be found to be truncated at the end during the Redis</span><br><span class="line"><span class="params">#</span> startup process, when the AOF data gets loaded back into memory.</span><br><span class="line"><span class="params">#</span> This may happen when the system where Redis is running</span><br><span class="line"><span class="params">#</span> crashes, especially when an ext4 filesystem is mounted without the</span><br><span class="line"><span class="params">#</span> data=ordered option (however this can&#x27;t happen when Redis itself</span><br><span class="line"><span class="params">#</span> crashes or aborts but the operating system still works correctly).</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> Redis can either exit with an error when this happens, or load as much</span><br><span class="line"><span class="params">#</span> data as possible (the default now) and start if the AOF file is found</span><br><span class="line"><span class="params">#</span> to be truncated at the end. The following option controls this behavior.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> If aof-load-truncated is set to yes, a truncated AOF file is loaded and</span><br><span class="line"><span class="params">#</span> the Redis server starts emitting a log to inform the user of the event.</span><br><span class="line"><span class="params">#</span> Otherwise if the option is set to no, the server aborts with an error</span><br><span class="line"><span class="params">#</span> and refuses to start. When the option is set to no, the user requires</span><br><span class="line"><span class="params">#</span> to fix the AOF file using the &quot;redis-check-aof&quot; utility before to restart</span><br><span class="line"><span class="params">#</span> the server.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> Note that if the AOF file will be found to be corrupted in the middle</span><br><span class="line"><span class="params">#</span> the server will still exit with an error. This option only applies when</span><br><span class="line"><span class="params">#</span> Redis will try to read more data from the AOF file but not enough bytes</span><br><span class="line"><span class="params">#</span> will be found.</span><br><span class="line">aof-load-truncated yes</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> When rewriting the AOF file, Redis is able to use an RDB preamble in the</span><br><span class="line"><span class="params">#</span> AOF file for faster rewrites and recoveries. When this option is turned</span><br><span class="line"><span class="params">#</span> on the rewritten AOF file is composed of two different stanzas:</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span>   [RDB file][AOF tail]</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> When loading Redis recognizes that the AOF file starts with the &quot;REDIS&quot;</span><br><span class="line"><span class="params">#</span> string and loads the prefixed RDB file, and continues loading the AOF</span><br><span class="line"><span class="params">#</span> tail.</span><br><span class="line">aof-use-rdb-preamble yes</span><br><span class="line"></span><br><span class="line"><span class="params">################################</span> LUA SCRIPTING  <span class="params">###############################</span></span><br><span class="line"></span><br><span class="line"><span class="params">#</span> Max execution time of a Lua script in milliseconds.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> If the maximum execution time is reached Redis will log that a script is</span><br><span class="line"><span class="params">#</span> still in execution after the maximum allowed time and will start to</span><br><span class="line"><span class="params">#</span> reply to queries with an error.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> When a long running script exceeds the maximum execution time only the</span><br><span class="line"><span class="params">#</span> SCRIPT KILL and SHUTDOWN NOSAVE commands are available. The first can be</span><br><span class="line"><span class="params">#</span> used to stop a script that did not yet called write commands. The second</span><br><span class="line"><span class="params">#</span> is the only way to shut down the server in the case a write command was</span><br><span class="line"><span class="params">#</span> already issued by the script but the user doesn&#x27;t want to wait for the natural</span><br><span class="line"><span class="params">#</span> termination of the script.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> Set it to 0 or a negative value for unlimited execution without warnings.</span><br><span class="line">lua-time-limit 5000</span><br><span class="line"></span><br><span class="line"><span class="params">################################</span> REDIS CLUSTER  <span class="params">###############################</span></span><br><span class="line"></span><br><span class="line"><span class="params">#</span> Normal Redis instances can&#x27;t be part of a Redis Cluster; only nodes that are</span><br><span class="line"><span class="params">#</span> started as cluster nodes can. In order to start a Redis instance as a</span><br><span class="line"><span class="params">#</span> cluster node enable the cluster support uncommenting the following:</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> cluster-enabled yes</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> Every cluster node has a cluster configuration file. This file is not</span><br><span class="line"><span class="params">#</span> intended to be edited by hand. It is created and updated by Redis nodes.</span><br><span class="line"><span class="params">#</span> Every Redis Cluster node requires a different cluster configuration file.</span><br><span class="line"><span class="params">#</span> Make sure that instances running in the same system do not have</span><br><span class="line"><span class="params">#</span> overlapping cluster configuration file names.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> cluster-config-file nodes-6379.conf</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> Cluster node timeout is the amount of milliseconds a node must be unreachable</span><br><span class="line"><span class="params">#</span> for it to be considered in failure state.</span><br><span class="line"><span class="params">#</span> Most other internal time limits are multiple of the node timeout.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> cluster-node-timeout 15000</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> A replica of a failing master will avoid to start a failover if its data</span><br><span class="line"><span class="params">#</span> looks too old.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> There is no simple way for a replica to actually have an exact measure of</span><br><span class="line"><span class="params">#</span> its &quot;data age&quot;, so the following two checks are performed:</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> 1) If there are multiple replicas able to failover, they exchange messages</span><br><span class="line"><span class="params">#</span>    in order to try to give an advantage to the replica with the best</span><br><span class="line"><span class="params">#</span>    replication offset (more data from the master processed).</span><br><span class="line"><span class="params">#</span>    Replicas will try to get their rank by offset, and apply to the start</span><br><span class="line"><span class="params">#</span>    of the failover a delay proportional to their rank.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> 2) Every single replica computes the time of the last interaction with</span><br><span class="line"><span class="params">#</span>    its master. This can be the last ping or command received (if the master</span><br><span class="line"><span class="params">#</span>    is still in the &quot;connected&quot; state), or the time that elapsed since the</span><br><span class="line"><span class="params">#</span>    disconnection with the master (if the replication link is currently down).</span><br><span class="line"><span class="params">#</span>    If the last interaction is too old, the replica will not try to failover</span><br><span class="line"><span class="params">#</span>    at all.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> The point &quot;2&quot; can be tuned by user. Specifically a replica will not perform</span><br><span class="line"><span class="params">#</span> the failover if, since the last interaction with the master, the time</span><br><span class="line"><span class="params">#</span> elapsed is greater than:</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span>   (node-timeout * replica-validity-factor) + repl-ping-replica-period</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> So for example if node-timeout is 30 seconds, and the replica-validity-factor</span><br><span class="line"><span class="params">#</span> is 10, and assuming a default repl-ping-replica-period of 10 seconds, the</span><br><span class="line"><span class="params">#</span> replica will not try to failover if it was not able to talk with the master</span><br><span class="line"><span class="params">#</span> for longer than 310 seconds.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> A large replica-validity-factor may allow replicas with too old data to failover</span><br><span class="line"><span class="params">#</span> a master, while a too small value may prevent the cluster from being able to</span><br><span class="line"><span class="params">#</span> elect a replica at all.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> For maximum availability, it is possible to set the replica-validity-factor</span><br><span class="line"><span class="params">#</span> to a value of 0, which means, that replicas will always try to failover the</span><br><span class="line"><span class="params">#</span> master regardless of the last time they interacted with the master.</span><br><span class="line"><span class="params">#</span> (However they&#x27;ll always try to apply a delay proportional to their</span><br><span class="line"><span class="params">#</span> offset rank).</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> Zero is the only value able to guarantee that when all the partitions heal</span><br><span class="line"><span class="params">#</span> the cluster will always be able to continue.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> cluster-replica-validity-factor 10</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> Cluster replicas are able to migrate to orphaned masters, that are masters</span><br><span class="line"><span class="params">#</span> that are left without working replicas. This improves the cluster ability</span><br><span class="line"><span class="params">#</span> to resist to failures as otherwise an orphaned master can&#x27;t be failed over</span><br><span class="line"><span class="params">#</span> in case of failure if it has no working replicas.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> Replicas migrate to orphaned masters only if there are still at least a</span><br><span class="line"><span class="params">#</span> given number of other working replicas for their old master. This number</span><br><span class="line"><span class="params">#</span> is the &quot;migration barrier&quot;. A migration barrier of 1 means that a replica</span><br><span class="line"><span class="params">#</span> will migrate only if there is at least 1 other working replica for its master</span><br><span class="line"><span class="params">#</span> and so forth. It usually reflects the number of replicas you want for every</span><br><span class="line"><span class="params">#</span> master in your cluster.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> Default is 1 (replicas migrate only if their masters remain with at least</span><br><span class="line"><span class="params">#</span> one replica). To disable migration just set it to a very large value.</span><br><span class="line"><span class="params">#</span> A value of 0 can be set but is useful only for debugging and dangerous</span><br><span class="line"><span class="params">#</span> in production.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> cluster-migration-barrier 1</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> By default Redis Cluster nodes stop accepting queries if they detect there</span><br><span class="line"><span class="params">#</span> is at least an hash slot uncovered (no available node is serving it).</span><br><span class="line"><span class="params">#</span> This way if the cluster is partially down (for example a range of hash slots</span><br><span class="line"><span class="params">#</span> are no longer covered) all the cluster becomes, eventually, unavailable.</span><br><span class="line"><span class="params">#</span> It automatically returns available as soon as all the slots are covered again.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> However sometimes you want the subset of the cluster which is working,</span><br><span class="line"><span class="params">#</span> to continue to accept queries for the part of the key space that is still</span><br><span class="line"><span class="params">#</span> covered. In order to do so, just set the cluster-require-full-coverage</span><br><span class="line"><span class="params">#</span> option to no.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> cluster-require-full-coverage yes</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> This option, when set to yes, prevents replicas from trying to failover its</span><br><span class="line"><span class="params">#</span> master during master failures. However the master can still perform a</span><br><span class="line"><span class="params">#</span> manual failover, if forced to do so.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> This is useful in different scenarios, especially in the case of multiple</span><br><span class="line"><span class="params">#</span> data center operations, where we want one side to never be promoted if not</span><br><span class="line"><span class="params">#</span> in the case of a total DC failure.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> cluster-replica-no-failover no</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> This option, when set to yes, allows nodes to serve read traffic while the</span><br><span class="line"><span class="params">#</span> the cluster is in a down state, as long as it believes it owns the slots. </span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> This is useful for two cases.  The first case is for when an application </span><br><span class="line"><span class="params">#</span> doesn&#x27;t require consistency of data during node failures or network partitions.</span><br><span class="line"><span class="params">#</span> One example of this is a cache, where as long as the node has the data it</span><br><span class="line"><span class="params">#</span> should be able to serve it. </span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> The second use case is for configurations that don&#x27;t meet the recommended  </span><br><span class="line"><span class="params">#</span> three shards but want to enable cluster mode and scale later. A </span><br><span class="line"><span class="params">#</span> master outage in a 1 or 2 shard configuration causes a read/write outage to the</span><br><span class="line"><span class="params">#</span> entire cluster without this option set, with it set there is only a write outage.</span><br><span class="line"><span class="params">#</span> Without a quorum of masters, slot ownership will not change automatically. </span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> cluster-allow-reads-when-down no</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> In order to setup your cluster make sure to read the documentation</span><br><span class="line"><span class="params">#</span> available at http://redis.io web site.</span><br><span class="line"></span><br><span class="line"><span class="params">##########################</span> CLUSTER DOCKER/NAT support  <span class="params">########################</span></span><br><span class="line"></span><br><span class="line"><span class="params">#</span> In certain deployments, Redis Cluster nodes address discovery fails, because</span><br><span class="line"><span class="params">#</span> addresses are NAT-ted or because ports are forwarded (the typical case is</span><br><span class="line"><span class="params">#</span> Docker and other containers).</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> In order to make Redis Cluster working in such environments, a static</span><br><span class="line"><span class="params">#</span> configuration where each node knows its public address is needed. The</span><br><span class="line"><span class="params">#</span> following two options are used for this scope, and are:</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> * cluster-announce-ip</span><br><span class="line"><span class="params">#</span> * cluster-announce-port</span><br><span class="line"><span class="params">#</span> * cluster-announce-bus-port</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> Each instruct the node about its address, client port, and cluster message</span><br><span class="line"><span class="params">#</span> bus port. The information is then published in the header of the bus packets</span><br><span class="line"><span class="params">#</span> so that other nodes will be able to correctly map the address of the node</span><br><span class="line"><span class="params">#</span> publishing the information.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> If the above options are not used, the normal Redis Cluster auto-detection</span><br><span class="line"><span class="params">#</span> will be used instead.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> Note that when remapped, the bus port may not be at the fixed offset of</span><br><span class="line"><span class="params">#</span> clients port + 10000, so you can specify any port and bus-port depending</span><br><span class="line"><span class="params">#</span> on how they get remapped. If the bus-port is not set, a fixed offset of</span><br><span class="line"><span class="params">#</span> 10000 will be used as usually.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> Example:</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> cluster-announce-ip 10.1.1.5</span><br><span class="line"><span class="params">#</span> cluster-announce-port 6379</span><br><span class="line"><span class="params">#</span> cluster-announce-bus-port 6380</span><br><span class="line"></span><br><span class="line"><span class="params">##################################</span> SLOW LOG <span class="params">###################################</span></span><br><span class="line"></span><br><span class="line"><span class="params">#</span> The Redis Slow Log is a system to log queries that exceeded a specified</span><br><span class="line"><span class="params">#</span> execution time. The execution time does not include the I/O operations</span><br><span class="line"><span class="params">#</span> like talking with the client, sending the reply and so forth,</span><br><span class="line"><span class="params">#</span> but just the time needed to actually execute the command (this is the only</span><br><span class="line"><span class="params">#</span> stage of command execution where the thread is blocked and can not serve</span><br><span class="line"><span class="params">#</span> other requests in the meantime).</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> You can configure the slow log with two parameters: one tells Redis</span><br><span class="line"><span class="params">#</span> what is the execution time, in microseconds, to exceed in order for the</span><br><span class="line"><span class="params">#</span> command to get logged, and the other parameter is the length of the</span><br><span class="line"><span class="params">#</span> slow log. When a new command is logged the oldest one is removed from the</span><br><span class="line"><span class="params">#</span> queue of logged commands.</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> The following time is expressed in microseconds, so 1000000 is equivalent</span><br><span class="line"><span class="params">#</span> to one second. Note that a negative number disables the slow log, while</span><br><span class="line"><span class="params">#</span> a value of zero forces the logging of every command.</span><br><span class="line">slowlog-log-slower-than 10000</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> There is no limit to this length. Just be aware that it will consume memory.</span><br><span class="line"><span class="params">#</span> You can reclaim memory used by the slow log with SLOWLOG RESET.</span><br><span class="line">slowlog-max-len 128</span><br><span class="line"></span><br><span class="line"><span class="params">################################</span> LATENCY MONITOR <span class="params">##############################</span></span><br><span class="line"></span><br><span class="line"><span class="params">#</span> The Redis latency monitoring subsystem samples different operations</span><br><span class="line"><span class="params">#</span> at runtime in order to collect data related to possible sources of</span><br><span class="line"><span class="params">#</span> latency of a Redis instance.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> Via the LATENCY command this information is available to the user that can</span><br><span class="line"><span class="params">#</span> print graphs and obtain reports.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> The system only logs operations that were performed in a time equal or</span><br><span class="line"><span class="params">#</span> greater than the amount of milliseconds specified via the</span><br><span class="line"><span class="params">#</span> latency-monitor-threshold configuration directive. When its value is set</span><br><span class="line"><span class="params">#</span> to zero, the latency monitor is turned off.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> By default latency monitoring is disabled since it is mostly not needed</span><br><span class="line"><span class="params">#</span> if you don&#x27;t have latency issues, and collecting data has a performance</span><br><span class="line"><span class="params">#</span> impact, that while very small, can be measured under big load. Latency</span><br><span class="line"><span class="params">#</span> monitoring can easily be enabled at runtime using the command</span><br><span class="line"><span class="params">#</span> &quot;CONFIG SET latency-monitor-threshold &lt;milliseconds&gt;&quot; if needed.</span><br><span class="line">latency-monitor-threshold 0</span><br><span class="line"></span><br><span class="line"><span class="params">#############################</span> EVENT NOTIFICATION <span class="params">##############################</span></span><br><span class="line"></span><br><span class="line"><span class="params">#</span> Redis can notify Pub/Sub clients about events happening in the key space.</span><br><span class="line"><span class="params">#</span> This feature is documented at http://redis.io/topics/notifications</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> For instance if keyspace events notification is enabled, and a client</span><br><span class="line"><span class="params">#</span> performs a DEL operation on key &quot;foo&quot; stored in the Database 0, two</span><br><span class="line"><span class="params">#</span> messages will be published via Pub/Sub:</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> PUBLISH <span class="built_in">_</span><span class="built_in">_</span>keyspace@0<span class="built_in">_</span><span class="built_in">_</span>:foo del</span><br><span class="line"><span class="params">#</span> PUBLISH <span class="built_in">_</span><span class="built_in">_</span>keyevent@0<span class="built_in">_</span><span class="built_in">_</span>:del foo</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> It is possible to select the events that Redis will notify among a set</span><br><span class="line"><span class="params">#</span> of classes. Every class is identified by a single character:</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span>  K     Keyspace events, published with <span class="built_in">_</span><span class="built_in">_</span>keyspace@&lt;db&gt;<span class="built_in">_</span><span class="built_in">_</span> prefix.</span><br><span class="line"><span class="params">#</span>  E     Keyevent events, published with <span class="built_in">_</span><span class="built_in">_</span>keyevent@&lt;db&gt;<span class="built_in">_</span><span class="built_in">_</span> prefix.</span><br><span class="line"><span class="params">#</span>  g     Generic commands (non-type specific) like DEL, EXPIRE, RENAME, ...</span><br><span class="line"><span class="params">#</span>  <span class="built_in">$</span>     String commands</span><br><span class="line"><span class="params">#</span>  l     List commands</span><br><span class="line"><span class="params">#</span>  s     Set commands</span><br><span class="line"><span class="params">#</span>  h     Hash commands</span><br><span class="line"><span class="params">#</span>  z     Sorted set commands</span><br><span class="line"><span class="params">#</span>  x     Expired events (events generated every time a key expires)</span><br><span class="line"><span class="params">#</span>  e     Evicted events (events generated when a key is evicted for maxmemory)</span><br><span class="line"><span class="params">#</span>  t     Stream commands</span><br><span class="line"><span class="params">#</span>  m     Key-miss events (Note: It is not included in the &#x27;A&#x27; class)</span><br><span class="line"><span class="params">#</span>  A     Alias for g<span class="built_in">$</span>lshzxet, so that the &quot;AKE&quot; string means all the events</span><br><span class="line"><span class="params">#</span>        (Except key-miss events which are excluded from &#x27;A&#x27; due to their</span><br><span class="line"><span class="params">#</span>         unique nature).</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span>  The &quot;notify-keyspace-events&quot; takes as argument a string that is composed</span><br><span class="line"><span class="params">#</span>  of zero or multiple characters. The empty string means that notifications</span><br><span class="line"><span class="params">#</span>  are disabled.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span>  Example: to enable list and generic events, from the point of view of the</span><br><span class="line"><span class="params">#</span>           event name, use:</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span>  notify-keyspace-events Elg</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span>  Example 2: to get the stream of the expired keys subscribing to channel</span><br><span class="line"><span class="params">#</span>             name <span class="built_in">_</span><span class="built_in">_</span>keyevent@0<span class="built_in">_</span><span class="built_in">_</span>:expired use:</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span>  notify-keyspace-events Ex</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span>  By default all notifications are disabled because most users don&#x27;t need</span><br><span class="line"><span class="params">#</span>  this feature and the feature has some overhead. Note that if you don&#x27;t</span><br><span class="line"><span class="params">#</span>  specify at least one of K or E, no events will be delivered.</span><br><span class="line">notify-keyspace-events &quot;&quot;</span><br><span class="line"></span><br><span class="line"><span class="params">###############################</span> GOPHER SERVER <span class="params">#################################</span></span><br><span class="line"></span><br><span class="line"><span class="params">#</span> Redis contains an implementation of the Gopher protocol, as specified in</span><br><span class="line"><span class="params">#</span> the RFC 1436 (https://www.ietf.org/rfc/rfc1436.txt).</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> The Gopher protocol was very popular in the late &#x27;90s. It is an alternative</span><br><span class="line"><span class="params">#</span> to the web, and the implementation both server and client side is so simple</span><br><span class="line"><span class="params">#</span> that the Redis server has just 100 lines of code in order to implement this</span><br><span class="line"><span class="params">#</span> support.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> What do you do with Gopher nowadays? Well Gopher never *really* died, and</span><br><span class="line"><span class="params">#</span> lately there is a movement in order for the Gopher more hierarchical content</span><br><span class="line"><span class="params">#</span> composed of just plain text documents to be resurrected. Some want a simpler</span><br><span class="line"><span class="params">#</span> internet, others believe that the mainstream internet became too much</span><br><span class="line"><span class="params">#</span> controlled, and it&#x27;s cool to create an alternative space for people that</span><br><span class="line"><span class="params">#</span> want a bit of fresh air.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> Anyway for the 10nth birthday of the Redis, we gave it the Gopher protocol</span><br><span class="line"><span class="params">#</span> as a gift.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> --- HOW IT WORKS? ---</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> The Redis Gopher support uses the inline protocol of Redis, and specifically</span><br><span class="line"><span class="params">#</span> two kind of inline requests that were anyway illegal: an empty request</span><br><span class="line"><span class="params">#</span> or any request that starts with &quot;/&quot; (there are no Redis commands starting</span><br><span class="line"><span class="params">#</span> with such a slash). Normal RESP2/RESP3 requests are completely out of the</span><br><span class="line"><span class="params">#</span> path of the Gopher protocol implementation and are served as usually as well.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> If you open a connection to Redis when Gopher is enabled and send it</span><br><span class="line"><span class="params">#</span> a string like &quot;/foo&quot;, if there is a key named &quot;/foo&quot; it is served via the</span><br><span class="line"><span class="params">#</span> Gopher protocol.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> In order to create a real Gopher &quot;hole&quot; (the name of a Gopher site in Gopher</span><br><span class="line"><span class="params">#</span> talking), you likely need a script like the following:</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span>   https://github.com/antirez/gopher2redis</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> --- SECURITY WARNING ---</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> If you plan to put Redis on the internet in a publicly accessible address</span><br><span class="line"><span class="params">#</span> to server Gopher pages MAKE SURE TO SET A PASSWORD to the instance.</span><br><span class="line"><span class="params">#</span> Once a password is set:</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span>   1. The Gopher server (when enabled, not by default) will still serve</span><br><span class="line"><span class="params">#</span>      content via Gopher.</span><br><span class="line"><span class="params">#</span>   2. However other commands cannot be called before the client will</span><br><span class="line"><span class="params">#</span>      authenticate.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> So use the &#x27;requirepass&#x27; option to protect your instance.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> To enable Gopher support uncomment the following line and set</span><br><span class="line"><span class="params">#</span> the option from no (the default) to yes.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> gopher-enabled no</span><br><span class="line"></span><br><span class="line"><span class="params">###############################</span> ADVANCED CONFIG <span class="params">###############################</span></span><br><span class="line"></span><br><span class="line"><span class="params">#</span> Hashes are encoded using a memory efficient data structure when they have a</span><br><span class="line"><span class="params">#</span> small number of entries, and the biggest entry does not exceed a given</span><br><span class="line"><span class="params">#</span> threshold. These thresholds can be configured using the following directives.</span><br><span class="line">hash-max-ziplist-entries 512</span><br><span class="line">hash-max-ziplist-value 64</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> Lists are also encoded in a special way to save a lot of space.</span><br><span class="line"><span class="params">#</span> The number of entries allowed per internal list node can be specified</span><br><span class="line"><span class="params">#</span> as a fixed maximum size or a maximum number of elements.</span><br><span class="line"><span class="params">#</span> For a fixed maximum size, use -5 through -1, meaning:</span><br><span class="line"><span class="params">#</span> -5: max size: 64 Kb  &lt;-- not recommended for normal workloads</span><br><span class="line"><span class="params">#</span> -4: max size: 32 Kb  &lt;-- not recommended</span><br><span class="line"><span class="params">#</span> -3: max size: 16 Kb  &lt;-- probably not recommended</span><br><span class="line"><span class="params">#</span> -2: max size: 8 Kb   &lt;-- good</span><br><span class="line"><span class="params">#</span> -1: max size: 4 Kb   &lt;-- good</span><br><span class="line"><span class="params">#</span> Positive numbers mean store up to <span class="built_in">_</span>exactly<span class="built_in">_</span> that number of elements</span><br><span class="line"><span class="params">#</span> per list node.</span><br><span class="line"><span class="params">#</span> The highest performing option is usually -2 (8 Kb size) or -1 (4 Kb size),</span><br><span class="line"><span class="params">#</span> but if your use case is unique, adjust the settings as necessary.</span><br><span class="line">list-max-ziplist-size -2</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> Lists may also be compressed.</span><br><span class="line"><span class="params">#</span> Compress depth is the number of quicklist ziplist nodes from *each* side of</span><br><span class="line"><span class="params">#</span> the list to *exclude* from compression.  The head and tail of the list</span><br><span class="line"><span class="params">#</span> are always uncompressed for fast push/pop operations.  Settings are:</span><br><span class="line"><span class="params">#</span> 0: disable all list compression</span><br><span class="line"><span class="params">#</span> 1: depth 1 means &quot;don&#x27;t start compressing until after 1 node into the list,</span><br><span class="line"><span class="params">#</span>    going from either the head or tail&quot;</span><br><span class="line"><span class="params">#</span>    So: [head]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[tail]</span><br><span class="line"><span class="params">#</span>    [head], [tail] will always be uncompressed; inner nodes will compress.</span><br><span class="line"><span class="params">#</span> 2: [head]-&gt;[next]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[prev]-&gt;[tail]</span><br><span class="line"><span class="params">#</span>    2 here means: don&#x27;t compress head or head-&gt;next or tail-&gt;prev or tail,</span><br><span class="line"><span class="params">#</span>    but compress all nodes between them.</span><br><span class="line"><span class="params">#</span> 3: [head]-&gt;[next]-&gt;[next]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[prev]-&gt;[prev]-&gt;[tail]</span><br><span class="line"><span class="params">#</span> etc.</span><br><span class="line">list-compress-depth 0</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> Sets have a special encoding in just one case: when a set is composed</span><br><span class="line"><span class="params">#</span> of just strings that happen to be integers in radix 10 in the range</span><br><span class="line"><span class="params">#</span> of 64 bit signed integers.</span><br><span class="line"><span class="params">#</span> The following configuration setting sets the limit in the size of the</span><br><span class="line"><span class="params">#</span> set in order to use this special memory saving encoding.</span><br><span class="line">set-max-intset-entries 512</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> Similarly to hashes and lists, sorted sets are also specially encoded in</span><br><span class="line"><span class="params">#</span> order to save a lot of space. This encoding is only used when the length and</span><br><span class="line"><span class="params">#</span> elements of a sorted set are below the following limits:</span><br><span class="line">zset-max-ziplist-entries 128</span><br><span class="line">zset-max-ziplist-value 64</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> HyperLogLog sparse representation bytes limit. The limit includes the</span><br><span class="line"><span class="params">#</span> 16 bytes header. When an HyperLogLog using the sparse representation crosses</span><br><span class="line"><span class="params">#</span> this limit, it is converted into the dense representation.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> A value greater than 16000 is totally useless, since at that point the</span><br><span class="line"><span class="params">#</span> dense representation is more memory efficient.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> The suggested value is ~ 3000 in order to have the benefits of</span><br><span class="line"><span class="params">#</span> the space efficient encoding without slowing down too much PFADD,</span><br><span class="line"><span class="params">#</span> which is O(N) with the sparse encoding. The value can be raised to</span><br><span class="line"><span class="params">#</span> ~ 10000 when CPU is not a concern, but space is, and the data set is</span><br><span class="line"><span class="params">#</span> composed of many HyperLogLogs with cardinality in the 0 - 15000 range.</span><br><span class="line">hll-sparse-max-bytes 3000</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> Streams macro node max size / items. The stream data structure is a radix</span><br><span class="line"><span class="params">#</span> tree of big nodes that encode multiple items inside. Using this configuration</span><br><span class="line"><span class="params">#</span> it is possible to configure how big a single node can be in bytes, and the</span><br><span class="line"><span class="params">#</span> maximum number of items it may contain before switching to a new node when</span><br><span class="line"><span class="params">#</span> appending new stream entries. If any of the following settings are set to</span><br><span class="line"><span class="params">#</span> zero, the limit is ignored, so for instance it is possible to set just a</span><br><span class="line"><span class="params">#</span> max entires limit by setting max-bytes to 0 and max-entries to the desired</span><br><span class="line"><span class="params">#</span> value.</span><br><span class="line">stream-node-max-bytes 4096</span><br><span class="line">stream-node-max-entries 100</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> Active rehashing uses 1 millisecond every 100 milliseconds of CPU time in</span><br><span class="line"><span class="params">#</span> order to help rehashing the main Redis hash table (the one mapping top-level</span><br><span class="line"><span class="params">#</span> keys to values). The hash table implementation Redis uses (see dict.c)</span><br><span class="line"><span class="params">#</span> performs a lazy rehashing: the more operation you run into a hash table</span><br><span class="line"><span class="params">#</span> that is rehashing, the more rehashing &quot;steps&quot; are performed, so if the</span><br><span class="line"><span class="params">#</span> server is idle the rehashing is never complete and some more memory is used</span><br><span class="line"><span class="params">#</span> by the hash table.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> The default is to use this millisecond 10 times every second in order to</span><br><span class="line"><span class="params">#</span> actively rehash the main dictionaries, freeing memory when possible.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> If unsure:</span><br><span class="line"><span class="params">#</span> use &quot;activerehashing no&quot; if you have hard latency requirements and it is</span><br><span class="line"><span class="params">#</span> not a good thing in your environment that Redis can reply from time to time</span><br><span class="line"><span class="params">#</span> to queries with 2 milliseconds delay.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> use &quot;activerehashing yes&quot; if you don&#x27;t have such hard requirements but</span><br><span class="line"><span class="params">#</span> want to free memory asap when possible.</span><br><span class="line">activerehashing yes</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> The client output buffer limits can be used to force disconnection of clients</span><br><span class="line"><span class="params">#</span> that are not reading data from the server fast enough for some reason (a</span><br><span class="line"><span class="params">#</span> common reason is that a Pub/Sub client can&#x27;t consume messages as fast as the</span><br><span class="line"><span class="params">#</span> publisher can produce them).</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> The limit can be set differently for the three different classes of clients:</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> normal -&gt; normal clients including MONITOR clients</span><br><span class="line"><span class="params">#</span> replica  -&gt; replica clients</span><br><span class="line"><span class="params">#</span> pubsub -&gt; clients subscribed to at least one pubsub channel or pattern</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> The syntax of every client-output-buffer-limit directive is the following:</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> client-output-buffer-limit &lt;class&gt; &lt;hard limit&gt; &lt;soft limit&gt; &lt;soft seconds&gt;</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> A client is immediately disconnected once the hard limit is reached, or if</span><br><span class="line"><span class="params">#</span> the soft limit is reached and remains reached for the specified number of</span><br><span class="line"><span class="params">#</span> seconds (continuously).</span><br><span class="line"><span class="params">#</span> So for instance if the hard limit is 32 megabytes and the soft limit is</span><br><span class="line"><span class="params">#</span> 16 megabytes / 10 seconds, the client will get disconnected immediately</span><br><span class="line"><span class="params">#</span> if the size of the output buffers reach 32 megabytes, but will also get</span><br><span class="line"><span class="params">#</span> disconnected if the client reaches 16 megabytes and continuously overcomes</span><br><span class="line"><span class="params">#</span> the limit for 10 seconds.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> By default normal clients are not limited because they don&#x27;t receive data</span><br><span class="line"><span class="params">#</span> without asking (in a push way), but just after a request, so only</span><br><span class="line"><span class="params">#</span> asynchronous clients may create a scenario where data is requested faster</span><br><span class="line"><span class="params">#</span> than it can read.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> Instead there is a default limit for pubsub and replica clients, since</span><br><span class="line"><span class="params">#</span> subscribers and replicas receive data in a push fashion.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> Both the hard or the soft limit can be disabled by setting them to zero.</span><br><span class="line">client-output-buffer-limit normal 0 0 0</span><br><span class="line">client-output-buffer-limit replica 256mb 64mb 60</span><br><span class="line">client-output-buffer-limit pubsub 32mb 8mb 60</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> Client query buffers accumulate new commands. They are limited to a fixed</span><br><span class="line"><span class="params">#</span> amount by default in order to avoid that a protocol desynchronization (for</span><br><span class="line"><span class="params">#</span> instance due to a bug in the client) will lead to unbound memory usage in</span><br><span class="line"><span class="params">#</span> the query buffer. However you can configure it here if you have very special</span><br><span class="line"><span class="params">#</span> needs, such us huge multi/exec requests or alike.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> client-query-buffer-limit 1gb</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> In the Redis protocol, bulk requests, that are, elements representing single</span><br><span class="line"><span class="params">#</span> strings, are normally limited ot 512 mb. However you can change this limit</span><br><span class="line"><span class="params">#</span> here.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> proto-max-bulk-len 512mb</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> Redis calls an internal function to perform many background tasks, like</span><br><span class="line"><span class="params">#</span> closing connections of clients in timeout, purging expired keys that are</span><br><span class="line"><span class="params">#</span> never requested, and so forth.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> Not all tasks are performed with the same frequency, but Redis checks for</span><br><span class="line"><span class="params">#</span> tasks to perform according to the specified &quot;hz&quot; value.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> By default &quot;hz&quot; is set to 10. Raising the value will use more CPU when</span><br><span class="line"><span class="params">#</span> Redis is idle, but at the same time will make Redis more responsive when</span><br><span class="line"><span class="params">#</span> there are many keys expiring at the same time, and timeouts may be</span><br><span class="line"><span class="params">#</span> handled with more precision.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> The range is between 1 and 500, however a value over 100 is usually not</span><br><span class="line"><span class="params">#</span> a good idea. Most users should use the default of 10 and raise this up to</span><br><span class="line"><span class="params">#</span> 100 only in environments where very low latency is required.</span><br><span class="line">hz 10</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> Normally it is useful to have an HZ value which is proportional to the</span><br><span class="line"><span class="params">#</span> number of clients connected. This is useful in order, for instance, to</span><br><span class="line"><span class="params">#</span> avoid too many clients are processed for each background task invocation</span><br><span class="line"><span class="params">#</span> in order to avoid latency spikes.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> Since the default HZ value by default is conservatively set to 10, Redis</span><br><span class="line"><span class="params">#</span> offers, and enables by default, the ability to use an adaptive HZ value</span><br><span class="line"><span class="params">#</span> which will temporary raise when there are many connected clients.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> When dynamic HZ is enabled, the actual configured HZ will be used</span><br><span class="line"><span class="params">#</span> as a baseline, but multiples of the configured HZ value will be actually</span><br><span class="line"><span class="params">#</span> used as needed once more clients are connected. In this way an idle</span><br><span class="line"><span class="params">#</span> instance will use very little CPU time while a busy instance will be</span><br><span class="line"><span class="params">#</span> more responsive.</span><br><span class="line">dynamic-hz yes</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> When a child rewrites the AOF file, if the following option is enabled</span><br><span class="line"><span class="params">#</span> the file will be fsync-ed every 32 MB of data generated. This is useful</span><br><span class="line"><span class="params">#</span> in order to commit the file to the disk more incrementally and avoid</span><br><span class="line"><span class="params">#</span> big latency spikes.</span><br><span class="line">aof-rewrite-incremental-fsync yes</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> When redis saves RDB file, if the following option is enabled</span><br><span class="line"><span class="params">#</span> the file will be fsync-ed every 32 MB of data generated. This is useful</span><br><span class="line"><span class="params">#</span> in order to commit the file to the disk more incrementally and avoid</span><br><span class="line"><span class="params">#</span> big latency spikes.</span><br><span class="line">rdb-save-incremental-fsync yes</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> Redis LFU eviction (see maxmemory setting) can be tuned. However it is a good</span><br><span class="line"><span class="params">#</span> idea to start with the default settings and only change them after investigating</span><br><span class="line"><span class="params">#</span> how to improve the performances and how the keys LFU change over time, which</span><br><span class="line"><span class="params">#</span> is possible to inspect via the OBJECT FREQ command.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> There are two tunable parameters in the Redis LFU implementation: the</span><br><span class="line"><span class="params">#</span> counter logarithm factor and the counter decay time. It is important to</span><br><span class="line"><span class="params">#</span> understand what the two parameters mean before changing them.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> The LFU counter is just 8 bits per key, it&#x27;s maximum value is 255, so Redis</span><br><span class="line"><span class="params">#</span> uses a probabilistic increment with logarithmic behavior. Given the value</span><br><span class="line"><span class="params">#</span> of the old counter, when a key is accessed, the counter is incremented in</span><br><span class="line"><span class="params">#</span> this way:</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> 1. A random number R between 0 and 1 is extracted.</span><br><span class="line"><span class="params">#</span> 2. A probability P is calculated as 1/(old<span class="built_in">_</span>value*lfu<span class="built_in">_</span>log<span class="built_in">_</span>factor+1).</span><br><span class="line"><span class="params">#</span> 3. The counter is incremented only if R &lt; P.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> The default lfu-log-factor is 10. This is a table of how the frequency</span><br><span class="line"><span class="params">#</span> counter changes with a different number of accesses with different</span><br><span class="line"><span class="params">#</span> logarithmic factors:</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> +--------+------------+------------+------------+------------+------------+</span><br><span class="line"><span class="params">#</span> | factor | 100 hits   | 1000 hits  | 100K hits  | 1M hits    | 10M hits   |</span><br><span class="line"><span class="params">#</span> +--------+------------+------------+------------+------------+------------+</span><br><span class="line"><span class="params">#</span> | 0      | 104        | 255        | 255        | 255        | 255        |</span><br><span class="line"><span class="params">#</span> +--------+------------+------------+------------+------------+------------+</span><br><span class="line"><span class="params">#</span> | 1      | 18         | 49         | 255        | 255        | 255        |</span><br><span class="line"><span class="params">#</span> +--------+------------+------------+------------+------------+------------+</span><br><span class="line"><span class="params">#</span> | 10     | 10         | 18         | 142        | 255        | 255        |</span><br><span class="line"><span class="params">#</span> +--------+------------+------------+------------+------------+------------+</span><br><span class="line"><span class="params">#</span> | 100    | 8          | 11         | 49         | 143        | 255        |</span><br><span class="line"><span class="params">#</span> +--------+------------+------------+------------+------------+------------+</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> NOTE: The above table was obtained by running the following commands:</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span>   redis-benchmark -n 1000000 incr foo</span><br><span class="line"><span class="params">#</span>   redis-cli object freq foo</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> NOTE 2: The counter initial value is 5 in order to give new objects a chance</span><br><span class="line"><span class="params">#</span> to accumulate hits.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> The counter decay time is the time, in minutes, that must elapse in order</span><br><span class="line"><span class="params">#</span> for the key counter to be divided by two (or decremented if it has a value</span><br><span class="line"><span class="params">#</span> less &lt;= 10).</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> The default value for the lfu-decay-time is 1. A Special value of 0 means to</span><br><span class="line"><span class="params">#</span> decay the counter every time it happens to be scanned.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> lfu-log-factor 10</span><br><span class="line"><span class="params">#</span> lfu-decay-time 1</span><br><span class="line"></span><br><span class="line"><span class="params">###########################</span> ACTIVE DEFRAGMENTATION <span class="params">#######################</span></span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> What is active defragmentation?</span><br><span class="line"><span class="params">#</span> -------------------------------</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> Active (online) defragmentation allows a Redis server to compact the</span><br><span class="line"><span class="params">#</span> spaces left between small allocations and deallocations of data in memory,</span><br><span class="line"><span class="params">#</span> thus allowing to reclaim back memory.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> Fragmentation is a natural process that happens with every allocator (but</span><br><span class="line"><span class="params">#</span> less so with Jemalloc, fortunately) and certain workloads. Normally a server</span><br><span class="line"><span class="params">#</span> restart is needed in order to lower the fragmentation, or at least to flush</span><br><span class="line"><span class="params">#</span> away all the data and create it again. However thanks to this feature</span><br><span class="line"><span class="params">#</span> implemented by Oran Agra for Redis 4.0 this process can happen at runtime</span><br><span class="line"><span class="params">#</span> in an &quot;hot&quot; way, while the server is running.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> Basically when the fragmentation is over a certain level (see the</span><br><span class="line"><span class="params">#</span> configuration options below) Redis will start to create new copies of the</span><br><span class="line"><span class="params">#</span> values in contiguous memory regions by exploiting certain specific Jemalloc</span><br><span class="line"><span class="params">#</span> features (in order to understand if an allocation is causing fragmentation</span><br><span class="line"><span class="params">#</span> and to allocate it in a better place), and at the same time, will release the</span><br><span class="line"><span class="params">#</span> old copies of the data. This process, repeated incrementally for all the keys</span><br><span class="line"><span class="params">#</span> will cause the fragmentation to drop back to normal values.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> Important things to understand:</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> 1. This feature is disabled by default, and only works if you compiled Redis</span><br><span class="line"><span class="params">#</span>    to use the copy of Jemalloc we ship with the source code of Redis.</span><br><span class="line"><span class="params">#</span>    This is the default with Linux builds.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> 2. You never need to enable this feature if you don&#x27;t have fragmentation</span><br><span class="line"><span class="params">#</span>    issues.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> 3. Once you experience fragmentation, you can enable this feature when</span><br><span class="line"><span class="params">#</span>    needed with the command &quot;CONFIG SET activedefrag yes&quot;.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> The configuration parameters are able to fine tune the behavior of the</span><br><span class="line"><span class="params">#</span> defragmentation process. If you are not sure about what they mean it is</span><br><span class="line"><span class="params">#</span> a good idea to leave the defaults untouched.</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> Enabled active defragmentation</span><br><span class="line"><span class="params">#</span> activedefrag no</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> Minimum amount of fragmentation waste to start active defrag</span><br><span class="line"><span class="params">#</span> active-defrag-ignore-bytes 100mb</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> Minimum percentage of fragmentation to start active defrag</span><br><span class="line"><span class="params">#</span> active-defrag-threshold-lower 10</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> Maximum percentage of fragmentation at which we use maximum effort</span><br><span class="line"><span class="params">#</span> active-defrag-threshold-upper 100</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> Minimal effort for defrag in CPU percentage, to be used when the lower</span><br><span class="line"><span class="params">#</span> threshold is reached</span><br><span class="line"><span class="params">#</span> active-defrag-cycle-min 1</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> Maximal effort for defrag in CPU percentage, to be used when the upper</span><br><span class="line"><span class="params">#</span> threshold is reached</span><br><span class="line"><span class="params">#</span> active-defrag-cycle-max 25</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> Maximum number of set/hash/zset/list fields that will be processed from</span><br><span class="line"><span class="params">#</span> the main dictionary scan</span><br><span class="line"><span class="params">#</span> active-defrag-max-scan-fields 1000</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> Jemalloc background thread for purging will be enabled by default</span><br><span class="line">jemalloc-bg-thread yes</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> It is possible to pin different threads and processes of Redis to specific</span><br><span class="line"><span class="params">#</span> CPUs in your system, in order to maximize the performances of the server.</span><br><span class="line"><span class="params">#</span> This is useful both in order to pin different Redis threads in different</span><br><span class="line"><span class="params">#</span> CPUs, but also in order to make sure that multiple Redis instances running</span><br><span class="line"><span class="params">#</span> in the same host will be pinned to different CPUs.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> Normally you can do this using the &quot;taskset&quot; command, however it is also</span><br><span class="line"><span class="params">#</span> possible to this via Redis configuration directly, both in Linux and FreeBSD.</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> You can pin the server/IO threads, bio threads, aof rewrite child process, and</span><br><span class="line"><span class="params">#</span> the bgsave child process. The syntax to specify the cpu list is the same as</span><br><span class="line"><span class="params">#</span> the taskset command:</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> Set redis server/io threads to cpu affinity 0,2,4,6:</span><br><span class="line"><span class="params">#</span> server<span class="built_in">_</span>cpulist 0-7:2</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> Set bio threads to cpu affinity 1,3:</span><br><span class="line"><span class="params">#</span> bio<span class="built_in">_</span>cpulist 1,3</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> Set aof rewrite child process to cpu affinity 8,9,10,11:</span><br><span class="line"><span class="params">#</span> aof<span class="built_in">_</span>rewrite<span class="built_in">_</span>cpulist 8-11</span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params">#</span> Set bgsave child process to cpu affinity 1,10,11</span><br><span class="line"><span class="params">#</span> bgsave<span class="built_in">_</span>cpulist 1,10-11</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创建挂载数据的文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /usr/local/docker/redis/config</span><br><span class="line">sudo mkdir -p /usr/local/docker/redis/data</span><br></pre></td></tr></table></figure><p>将 redis.conf 文件复制到 redis&#x2F;config 文件夹下，然后修改其中的配置信息：</p><ul><li>注释掉 bind 127.0.0.1 这个语句</li><li>修改 requirepass 之后跟随的密码</li></ul><p>命令行运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line">--restart=always \</span><br><span class="line">--log-opt max-size=100m \</span><br><span class="line">--log-opt max-file=2 \</span><br><span class="line">-p 6379:6379 \</span><br><span class="line">--name redis \</span><br><span class="line">-v /usr/local/docker/redis/redis.conf:/etc/redis/redis.conf \</span><br><span class="line">-v /usr/local/docker/redis/data:/data \</span><br><span class="line">-e ENABLE_OVERCOMMIT_MEMORY=true \</span><br><span class="line">-d redis redis-server \</span><br><span class="line">/etc/redis/redis.conf \</span><br><span class="line">--appendonly yes \</span><br><span class="line">--requirepass ***</span><br></pre></td></tr></table></figure><p>或者是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --restart=always --log-opt max-size=100m --log-opt max-file=2 -p 6379:6379 --name redis -v /usr/local/docker/redis/redis.conf:/etc/redis/redis.conf -v /usr/local/docker/redis/data:/data -d redis redis-server /etc/redis/redis.conf --appendonly yes --requirepass ***</span><br></pre></td></tr></table></figure><p>使用 docker exec  -it redis redis-cli 命令进入到容器内部。</p><h1 id="Docker-挂载-Ollama"><a href="#Docker-挂载-Ollama" class="headerlink" title="Docker 挂载 Ollama"></a>Docker 挂载 Ollama</h1><p>拉取镜像</p><p><code>docker pull ollama</code> </p><p>以纯 CPU 模式运行 ollama</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -v /usr/local/docker/ollama/models:/root/.ollama -p 11434:11434 --name ollama ollama/ollama</span><br></pre></td></tr></table></figure><p>以GPU方式运行 ollama</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --gpus=all -v /usr/local/docker/ollama/models:/root/.ollama -p 11434:11434 --name ollama ollama/ollama</span><br></pre></td></tr></table></figure><p>进入 ollama 容器</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it ollama bash</span><br></pre></td></tr></table></figure><h1 id="Docker-挂载-zookeeper"><a href="#Docker-挂载-zookeeper" class="headerlink" title="Docker 挂载 zookeeper"></a>Docker 挂载 zookeeper</h1><p><code>docker pull zookeeper</code> </p><p>创建挂载目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir /usr/local/docker/zookeeper/data</span><br><span class="line">mkdir /usr/local/docker/zookeeper/conf</span><br><span class="line">mkdir /usr/local/docker/zookeeper/datalog</span><br></pre></td></tr></table></figure><p>conf 目录下创建 zoo.cfg</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">dataDir=/data</span><br><span class="line">dataLogDir=/datalog</span><br><span class="line">tickTime=2000</span><br><span class="line">initLimit=10</span><br><span class="line">syncLimit=5</span><br><span class="line">autopurge.snapRetainCount=3</span><br><span class="line">autopurge.purgeInterval=0</span><br><span class="line">maxClientCnxns=60</span><br><span class="line"># 单机模式</span><br><span class="line">standaloneEnabled=true</span><br><span class="line"># 管理端口</span><br><span class="line">admin.serverPort=8088</span><br><span class="line"># 是否启用 Jetty  管理接口</span><br><span class="line">admin.enableServer=true</span><br><span class="line"># 用于客户端连接的端口</span><br><span class="line">clientPort=2181</span><br><span class="line"># 最大数据长度</span><br><span class="line">jute.maxbuffer=4194304</span><br></pre></td></tr></table></figure><p>运行镜像，挂载数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line">-d --name zookeeper --privileged=true \</span><br><span class="line">-p 2181:2181 \</span><br><span class="line">-p 8088:8088 \</span><br><span class="line">--restart=unless-stopped \</span><br><span class="line">-v /usr/local/docker/zookeeper/data/:/data \</span><br><span class="line">-v /usr/local/docker/zookeeper/conf:/conf \</span><br><span class="line">-v /usr/local/docker/zookeeper/datalog:/datalog \</span><br><span class="line">zookeeper</span><br></pre></td></tr></table></figure><p>查看 zookeeper 运行状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it zookeeper bash</span><br><span class="line"></span><br><span class="line">cd /bin </span><br><span class="line"></span><br><span class="line">./zkServer.sh status</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出如下，则为正常</p><blockquote><p>ZooKeeper JMX enabled by default<br>Using config: &#x2F;conf&#x2F;zoo.cfg<br>Client port found: 2181. Client address: localhost. Client SSL: false.<br>Mode: standalone</p></blockquote><h1 id="Docker-挂载-PostgreSQL"><a href="#Docker-挂载-PostgreSQL" class="headerlink" title="Docker 挂载 PostgreSQL"></a>Docker 挂载 PostgreSQL</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull postgres:13:22</span><br></pre></td></tr></table></figure><p><code>mkdir -p /usr/local/docker/postgre/data/</code> </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line">--name postgres \</span><br><span class="line">-d \</span><br><span class="line">--restart=unless-stopped \</span><br><span class="line">-p 5432:5432 \</span><br><span class="line">-e POSTGRES_USER=user \</span><br><span class="line">-e POSTGRES_PASSWORD=password \</span><br><span class="line">-e POSTGRES_DB=myDb \</span><br><span class="line">-e POSTGRES_INITDB_ARGS=&quot;--auth-host=scram-sha-256&quot; \</span><br><span class="line">-v /localPath/data:/var/lib/postgresql/data \</span><br><span class="line">-v /localPath/config/postgresql.conf:/etc/postgresql/postgresql.conf \</span><br><span class="line">-v /localPath/config/pg_hba.conf:/etc/postgresql/pg_hba.conf \</span><br><span class="line">postgre:13.22</span><br><span class="line"> -c &#x27;config_file=/etc/postgresql/postgresql.conf&#x27;</span><br></pre></td></tr></table></figure><p>笔者希望提高数据库系统的安全性，且想要通过挂载配置文件的方式实现（避免启动容器之后进去用命令配置）。折腾了一段时间之后发现，postgresql 默认用户的密码默认使用 md5 算法编码后存储到数据表中，由于笔者更偏向于使用 scrasm-sha-256，于是修改了两个配置文件，通过本地挂载的方式生效。</p><blockquote><p>值得注意的是，初始化之后，新建用户或者更新用户密码的时候才会用 postgresql.conf 中 password_encryption 字段指定的加密&#x2F;编码方式处理密码。</p></blockquote><p>如何获得默认的配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line">--name postgres \</span><br><span class="line">-d \</span><br><span class="line">--restart=unless-stopped \</span><br><span class="line">-p 5432:5432 \</span><br><span class="line">-e POSTGRES_USER=user \</span><br><span class="line">-e POSTGRES_PASSWORD=password \</span><br><span class="line">-e POSTGRES_DB=myDb \</span><br><span class="line">-v /localPath/data:/var/lib/postgresql/data \</span><br><span class="line">postgre:13.22</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将默认配置文件拷贝出来（当然，直接去挂载目录捞也行，删除容器的时候顺带重新创建挂载目录即可</span></span><br><span class="line">sudo docker cp postgres:/var/lib/postgresql/data/postgresql.conf ./postgresql.conf</span><br><span class="line">sudo docker cp postgres:/var/lib/postgresql/data/pg_hba.conf ./pg_hba.conf</span><br></pre></td></tr></table></figure><p>修改配置文件：</p><p><strong>pg_hba.conf</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># TYPE  DATABASE        USER            ADDRESS                 METHOD</span><br><span class="line"># &quot;local&quot; is for Unix domain socket connections only</span><br><span class="line">local   all             all                                     scram-sha-256</span><br><span class="line"># IPv4 local connections:</span><br><span class="line">host    all             all             0.0.0.0/0               scram-sha-256</span><br><span class="line"># IPv6 local connections:</span><br><span class="line">host    all             all             ::1/128                 scram-sha-256</span><br></pre></td></tr></table></figure><p><strong>postgresql.conf</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">password_encryption = scram-sha-256</span><br></pre></td></tr></table></figure><p>修改上述配置后重新挂载</p><p>登录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">免密登录</span></span><br><span class="line">docker exec -it postgres psql -user -d myDb -w</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用密码登录（但是你会发现，不输入甚至随便输些什么都能登进去，因为默认配置允许localhost 的connection不使用密码登录）</span></span><br><span class="line">docker exec -it postgres psql -user -d myDb -W</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">另一种方式</span></span><br><span class="line">docker exec -it postgres bash</span><br><span class="line">psql -h localhost -p 5432 -U user -d myDb -w</span><br></pre></td></tr></table></figure><p>如何查看当前使用的配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">某一个配置项的值</span></span><br><span class="line">docker exec -it postgres psql -U user -d postgreDb -c &quot;SHOW password_encryption;&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看配置来源</span></span><br><span class="line">docker exec -it postgres psql -U user -d postgreDb -c &quot;SHOW all;&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看配置文件位置</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">postgresql.conf</span></span><br><span class="line">docker exec -it postgres psql -U user -d postgreDb -c &quot;SHOW config_file;&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">pg_hba.conf</span></span><br><span class="line">docker exec -it postgres psql -U user -d postgreDb -c &quot;SHOW hba_file;&quot;</span><br></pre></td></tr></table></figure><p>用户表：</p><figure class="highlight postgresql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> rolname,rolpassword <span class="keyword">from</span> pg_authid;</span><br></pre></td></tr></table></figure><p>查看认证规则</p><figure class="highlight postgresql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> pg_hba_file_rules;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL更改记</title>
      <link href="/2023/02/19/MySQL%E6%9B%B4%E6%94%B9%E8%AE%B0/"/>
      <url>/2023/02/19/MySQL%E6%9B%B4%E6%94%B9%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL修改记录"><a href="#MySQL修改记录" class="headerlink" title="MySQL修改记录"></a>MySQL修改记录</h1><p>大三上学期末根据 CSDN 上的某篇博客在虚拟机里安装了 MySQL，本意是将其用于大数据大作业，将数据处理结果存储到 MySQL 中，后来直接使用了主机里的数据库。</p><p>因为 Java EE 大作业还没真正开工，只是初步搭建了个环境出来，也因为没有微服务的基础，没有服务中心可供下发配置文件，所以必须要有一个能够公用的服务器以及数据库。</p><p>软件工程的老师统一申请优惠券的时候因为没有及时去同意开发者协议，所以没有获得优惠券，遂想到用虚拟机作为服务器，将端口开放出来用。</p><p>所做的改动主要是将 3306 端口开放，查看 3306 端口状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -an | grep 3306</span><br></pre></td></tr></table></figure><p>看到 3306 端口前面的 localhost，这个时候 MySQL 只能在虚拟机中进行使用，用户只能在虚拟机上登录，所以先去将用户权限更改掉。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h localhost -u root -p </span><br></pre></td></tr></table></figure><p>输入密码之后</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">User</span>, Host <span class="keyword">from</span> mysql.User;</span><br></pre></td></tr></table></figure><p>结果集中，root 用户对应的 Host 为 localhost（可以通过更改 Host 实现数据库仅供某一 IP 使用）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> mysql.user <span class="keyword">set</span> Host<span class="operator">=</span><span class="string">&#x27;%&#x27;</span> <span class="keyword">where</span> <span class="keyword">User</span><span class="operator">=</span><span class="string">&#x27;root;</span></span><br></pre></td></tr></table></figure><p>使 root 用户能够远程登录，下一步将 root 用户的权限提上来，刷新权限。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> privileges <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line"></span><br><span class="line">flush privileges;</span><br><span class="line"></span><br><span class="line">\q</span><br></pre></td></tr></table></figure><p>要使 MySQL 能够跨主机访问，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd etc/mysql/mysql.conf.d/</span><br><span class="line"></span><br><span class="line">ls</span><br><span class="line"></span><br><span class="line">sudo vim mysqld.config</span><br></pre></td></tr></table></figure><p>打开文件之后将 bind-address &#x3D; 127.0.0.1 注释掉，再添加一条 port &#x3D; 3306。</p><p>重启 MySQL 服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysql restart</span><br></pre></td></tr></table></figure><p>再看一眼 端口状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -an | grep 3306</span><br></pre></td></tr></table></figure><p>如果先前看到的 localhost 消失了则说明配置完成。可以在主机使用 IDEA 自带的数据库连接工具或者 Navicat 测试连接，如果运行 SQL　报 1055 的错误可以不用管。</p><p>Ubuntu防火墙简易教程 <a href="https://blog.csdn.net/weixin_42171170/article/details/106957543">https://blog.csdn.net/weixin_42171170/article/details/106957543</a><br>Ubuntu开放 3306 端口 <a href="https://blog.csdn.net/yu128164/article/details/109511548">https://blog.csdn.net/yu128164/article/details/109511548</a></p>]]></content>
      
      
      <categories>
          
          <category> 问题解决 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 笔记</title>
      <link href="/2022/12/05/Spring/"/>
      <url>/2022/12/05/Spring/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><ul><li>简化开发：<ul><li>IOC</li><li>AOP – 事务处理</li></ul></li><li>框架整合<ul><li>mybatis</li><li>mybatis-plus</li><li>……</li></ul></li></ul><blockquote><p> 重点：<font color=#d44c47>Spring中操作与思想的联系是学习的重点</font></font>  </p></blockquote><p>官网：spring.io</p><p>EJB思想（Enterprise Java Beans）：企业 Java Beans，是基于分布式事务处理的企业级应用程序的组件。</p><p><img src="https://s2.loli.net/2023/03/25/qWJNHQfjEOb4vYx.jpg" alt="Spring系统架构"></p><ol><li>Core Container：盛放对象（一切操作都基于对象）</li><li>Data Access&#x2F;Integration：DAO</li><li>AOP Aspects：面向切面编程</li><li>Transactions 事务处理</li></ol><ul><li><p>Part I 核心容器</p><ul><li>核心概念 IOC&#x2F;DI</li><li>容器基本操作</li></ul></li><li><p>Part II 整合</p><ul><li>整合数据层的 mybatis 和 mybatis-plus</li></ul></li><li><p>Part III AOP</p><ul><li>基础AOP</li><li>AOP实用操作</li></ul></li><li><p>Part IV Transactions</p><ul><li>事务概念，事务实用操作</li></ul></li></ul><h2 id="IOC-DI"><a href="#IOC-DI" class="headerlink" title="IOC &amp; DI"></a>IOC &amp; DI</h2><ul><li>IOC（Inversion Of Control）：控制反转，用从Spring容器中获取对象方式取代程序员自己创建对象</li><li>DI（Dependency Injection）：依赖注入，依赖注入是一种消除类之间依赖关系的设计模式。例如，A类要依赖B类，A类不再直接创建B类，而是把这种依赖关系配置在外部 XML 文件（或java config文件）中，然后由Spring容器根据配置信息创建、管理bean类。</li></ul><p>Servlet 层的代码中需要使用 new 关键字手动创建 service 实现类对象，耦合程度比较高。业务逻辑改变时，还需要修改创建对象的代码，进而重新编译、测试、部署，其中消耗的资源较多。</p><p>Spring 提供的解耦方案：</p><blockquote><p>  使用 XML 配置文件将实现类的全限定名标识出来，但是所需的对象需要从 Spring 客户端中获取， Spring 框架做的事情就是读取 XML 配置文件，根据 id 表示获得 Bean 全限定名。在需要更改时，只需要更改 XML 中相应的 Bean 的 class 来更改实现类，而不需要重新编译。</p></blockquote><p> <font size=5 color=red>id 按照规则取，并且在一个 XML 文件中必须唯一</font></p><p>Spring 客户端依赖反射机制完成对象的创建：<code>app.getBean(&quot;id&quot;);</code></p><p>实现步骤：</p><ol><li>导入 Spring 的包</li><li>写 Spring 配置文件（在已经完成对 Dao 层的操作之后，将 Bean 的全限定名写入 XML 文件）</li><li>使用 getBean 方法，传入 id，接收Spring 客户端返回的对象）</li></ol><h3 id="Spring-入门"><a href="#Spring-入门" class="headerlink" title="Spring 入门"></a>Spring 入门</h3><p>熟悉 Spring 框架的使用步骤。</p><p>Maven 导入 Spring坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.12.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>XML 配置文件一般起名为 applicationContext.xml</p><p><code>&lt;bean id=&quot;userDao&quot; class=&quot;com.example.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;</code></p><p>main\java\com\example\dao\UserDaoDemo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Application</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">    <span class="comment">// app 即为 Spring 客户端</span></span><br><span class="line">    <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> (UserDao)app.getBean(<span class="string">&quot;userDao&quot;</span>);</span><br><span class="line">    userDao.save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Bean-标签基本配置"><a href="#Bean-标签基本配置" class="headerlink" title="Bean 标签基本配置"></a>Bean 标签基本配置</h3><p>唯一标识 id 在同一配置文件中不可重复，Spring 创建对象时，默认情况下调用的是无参构造，如果没有无参构造则无法创建成功（编译器在程序员不提供构造函数的情况下提供无参构造函数）。</p><p>Bean 基本属性</p><ul><li>id：Bean 在 Spring 容器中的唯一标识</li><li>class：Bean的全限定名</li><li>scope：对象的作用范围、取值</li></ul><table><thead><tr><th>取值</th><th>说明</th></tr></thead><tbody><tr><td>singleton</td><td>默认值，单例（只能存在一个，获得的总是同一个对象）</td></tr><tr><td>prototype</td><td>多例（每次获得一个新对象）</td></tr><tr><td>request</td><td>Web项目中，Spring创建一个 Bean 对象，将对象存入到request 域中</td></tr><tr><td>session</td><td>Web项目中，Spring 创建一个 Bean 对象存入到 session 域中</td></tr><tr><td>global session</td><td>Web项目中，应用在 Portlet 环境下，如果没有 Portlet 环境那么 global session 相当于 session</td></tr></tbody></table><h3 id="Bean-对象的创建"><a href="#Bean-对象的创建" class="headerlink" title="Bean 对象的创建"></a>Bean 对象的创建</h3><ol><li>如果 scope 的值为 singleton，则在配置文件被加载时，Bean就被创建</li><li>如果 scope 的值为 prototype，则只有在调用 getBean 方法时才会创建 Bean 对象</li></ol><p><img src="https://s2.loli.net/2023/03/25/HnoFCGpmhNiKxk1.jpg" alt="Bean的scope属性"></p><h3 id="Bean-生命周期配置"><a href="#Bean-生命周期配置" class="headerlink" title="Bean 生命周期配置"></a>Bean 生命周期配置</h3><ul><li><p>init-method：值为类中初始化方法的名称</p></li><li><p>destroy-method：值为类中销毁方法的名称（没有回收空间作用的析构函数）</p></li></ul><p>例：在 Impl 中写入 constructor、init、destructor函数，在 XML 文件中完成配置，但由于测试函数执行很快，Bean 没有来得及调用 destroy 方法就已经被销毁，因此，需要手动关闭 app。又因为 app 是 ApplicationContext 类型，类中没有提供关闭操作，需要强行转换为ClassPathXmlApplicationContext 类型才能调用 close 方法</p><p><code>&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; init-method=&quot;init&quot; destroy-method=&quot;close&quot;&gt;</code> </p><h3 id="Bean-实例化的三种方式"><a href="#Bean-实例化的三种方式" class="headerlink" title="Bean 实例化的三种方式"></a>Bean 实例化的三种方式</h3><ol><li>无参构造</li><li>工厂静态</li><li>工厂实例</li></ol><p>SpringTest.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">springTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> (UserDao) app.getBean(<span class="string">&quot;userDao&quot;</span>);</span><br><span class="line">    <span class="comment">// 输出来个啥就得了</span></span><br><span class="line">    userDao.save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="静态工厂方式"><a href="#静态工厂方式" class="headerlink" title="静态工厂方式"></a>静态工厂方式</h4><p>com.example.factory.StaticFactory.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> UserDao <span class="title function_">getUserDao</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>XML 配置：</p><p>将 class 的值改为 com.example.factory.StaticFactory，factory-method 的值写作 getUserDao</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;factory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.factory.StaticFactory&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="工厂实例方式"><a href="#工厂实例方式" class="headerlink" title="工厂实例方式"></a>工厂实例方式</h4><p>com.example.factory.StaticFactory.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> UserDao <span class="title function_">getUserDao</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>XML 配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;factory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.factory.DynamicFactory&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--   依托于工厂创建实例   --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;factory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getUserDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>SpringTest 中的代码不需要改动。</p><h3 id="DI-的使用"><a href="#DI-的使用" class="headerlink" title="DI 的使用"></a>DI 的使用</h3><p>Servlet 中创建 Service 实现类对象，Service中创建 Mapper&#x2F;Dao 类对象，一个执行 Java 逻辑，一个提供数据库操作接口。</p><h4 id="在使用-DI-之前："><a href="#在使用-DI-之前：" class="headerlink" title="在使用 DI 之前："></a>在使用 DI 之前：</h4><p>XML 文件中的配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.dao.UserDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.service.UserService&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Controller：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line"><span class="type">UserService</span> <span class="variable">service</span> <span class="operator">=</span> app.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">service.save();</span><br></pre></td></tr></table></figure><p>ServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line"><span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> app.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">userDao.save();</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/03/25/zdCX2asOuYcrv4l.jpg" alt="DI之前"></p><h4 id="在使用-DI-之后："><a href="#在使用-DI-之后：" class="headerlink" title="在使用 DI 之后："></a>在使用 DI 之后：</h4><p>userService 实现类中创建私有成员 userDao，通过 set 方法，给其赋值，在 XML 中做出相应的更改，达到 DI 的目的。</p><p>DI 的操作具体表述为：将 userDao 设置为 UserService 类的成员对象，但是在 Java 代码中不会使用 new 方式创建对象，也不会直接将建某个对象并将其赋给 UserService 的成员。这种对象之间的依赖关系将会在 XML 配置文件中体现出来。</p><p>XML 配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.dao.UserDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.service.UserService&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="使用-Set-方法注入"><a href="#使用-Set-方法注入" class="headerlink" title="使用 Set 方法注入"></a>使用 Set 方法注入</h4><p>UserService 实现类中创建 私有成员对象 UserDao userDao，通过 Set 方法给 userDao 赋值，在　XML　配置文件中做出相应的更改达到 DI 的目的。</p><p>XML 配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.service.impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>解释：</p><ul><li>name：被复制对象（一般是“setXxx”中的 xxx，大写转小写并且保持小驼峰）</li><li>ref：容器中已有的Bean 对象的引用</li></ul><p><font size=5 color=red>一定要从Spring Container中取出对象，手动创建出来的因为没有 Set 属性无法使用。</font></p><h5 id="引入-p-名称空间，简化书写方式："><a href="#引入-p-名称空间，简化书写方式：" class="headerlink" title="引入 p 名称空间，简化书写方式："></a>引入 p 名称空间，简化书写方式：</h5><p>引入：xmlns:p&#x3D;”<a href="http://www.springframework.org/schema/p">http://www.springframework.org/schema/p</a>“</p><p>其次，修改注入方式为：</p><p><code>&lt;bean id=&quot;userService&quot; class=&quot;com.example.service.UserServiceImpl&quot; p:userDao-ref=&quot;userDao&quot;&gt;</code> </p><p>例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--   class 属性中只能填入 java 类，不能是接口   --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userMapper&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.mapper.impl.UserMapperImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.service.impl.UserServiceImpl&quot;</span> <span class="attr">p:mapper-ref</span>=<span class="string">&quot;userMapper&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    &lt;property name=&quot;mapper&quot; ref=&quot;userMapper&quot;/&gt;    --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>UserServiceImpl.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> SqlSessionFactory factory;</span><br><span class="line">    <span class="keyword">private</span> UserMapper mapper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        factory = (SqlSessionFactory) app.getBean(<span class="string">&quot;sqlSessionFactory&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMapper</span><span class="params">(UserMapper mapper)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mapper = mapper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">selectAllUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> factory.openSession();</span><br><span class="line"><span class="comment">//        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        List&lt;User&gt; userList = userMapper.selectAllUser();</span></span><br><span class="line"><span class="comment">//        System.out.println(userList);</span></span><br><span class="line"><span class="comment">//        sqlSession.close();</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mapper.selectAllUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserMapperImpl.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserMapperImpl</span> <span class="keyword">implements</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">selectAllUser</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;User&gt; userList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        userList.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>, <span class="string">&quot;zhangSan&quot;</span>, <span class="string">&quot;123&quot;</span>));</span><br><span class="line">        userList.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>, <span class="string">&quot;liSi&quot;</span>, <span class="string">&quot;111&quot;</span>));</span><br><span class="line">        userList.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>, <span class="string">&quot;wangWu&quot;</span>, <span class="string">&quot;456&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> userList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">DISetTest</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) app.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">        System.out.println(userService.selectAllUser());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="使用构造方法注入"><a href="#使用构造方法注入" class="headerlink" title="使用构造方法注入"></a>使用构造方法注入</h4><p>只需要在 set 方法的基础上改动 XML 文件中的注入方式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.service.impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;mapper&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userMapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="DI-的数据类型"><a href="#DI-的数据类型" class="headerlink" title="DI 的数据类型"></a>DI 的数据类型</h4><p>注入的数据类型：</p><ol><li>一般数据类型</li><li>引用数据类型</li><li>集合数据类型</li></ol><ul><li>引用数据类型用 ref 属性</li><li>一般数据类型用 value 属性</li><li>集合数据类型用相应的 <code>&lt;map&gt;&lt;/map&gt;</code> 、<code>&lt;list&gt;&lt;/list&gt;</code> 等标签</li></ul><p>举例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 一般数据类型  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.mapper.UserDao&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;zhangSan&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;16&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 集合属性 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- UserMapper 文件中添加：</span></span><br><span class="line"><span class="comment">private List&lt;String&gt; strList;</span></span><br><span class="line"><span class="comment">private List&lt;UserMaper&gt; userMaperList;</span></span><br><span class="line"><span class="comment">private Map&lt;String, User&gt; userMap;</span></span><br><span class="line"><span class="comment">private Properties props;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.mapper.UserDao&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userList&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 可任意选择注入引用类型 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>bbb<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>ccc<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;u1&quot;</span> <span class="attr">value-ref</span>=<span class="string">&quot;user1&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;u2&quot;</span> <span class="attr">value-ref</span>=<span class="string">&quot;user2&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;p1&quot;</span>&gt;</span>ppp1<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;p2&quot;</span>&gt;</span>ppp2<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;p3&quot;</span>&gt;</span>ppp3<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.pojo.USer&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Tom&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;addr&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Beijing&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.pojo.USer&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Lucy&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;addr&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Beijing&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="其他配置文件的引入"><a href="#其他配置文件的引入" class="headerlink" title="其他配置文件的引入"></a>其他配置文件的引入</h3><p>在实际应用中，Spring 的配置复杂并且体积很大，因此，产生了可以将部分配置文件拆解到其他文件配置中，在 Spring 主配置文件通过 import 标签进行加载</p><p><code>&lt;import resource=&quot;application-user.xml&quot;/&gt;</code> </p><h3 id="Spring-相关的-API"><a href="#Spring-相关的-API" class="headerlink" title="Spring 相关的 API"></a>Spring 相关的 API</h3><ol><li>ClassPathXmlApplicationContext 类的根路径下加载配置文件</li><li>FileSystemXmlApplicationContext 从磁盘路径上加载配置文件，文件可能在磁盘的任何位置</li><li>AnnotationConfigApplicationContext 使用注解配置容器对象时，需要使用其来读取注解，创建 spring 容器</li></ol><p>getBean 方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入 Bean 对象的 id</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    assertBeanFactoryActive();</span><br><span class="line">    <span class="keyword">return</span> getBeanFactory().getBean(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入指定类的字节码文件，手动指定所需的实现类（耦合）</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getBean</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    assertBeanFactoryActive();</span><br><span class="line">    <span class="keyword">return</span> getBeanFactory().getBean(requiredType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Spring-配置-Druid"><a href="#Spring-配置-Druid" class="headerlink" title="Spring 配置 Druid"></a>Spring 配置 Druid</h3><p>使用数据库连接池带来的好处：</p><ul><li>使用数据库（连接池）能提高程序性能</li><li>事先实例化数据源，初始化部分连接资源</li><li>使用连接资源是从数据源中获取</li><li>使用完毕后将连接资源归还给数据源</li></ul><p>常见的数据库连接池有 DBCP、C3P0、Druid等</p><p>原始的 Druid 连接池配置方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 硬编码问题比较严重</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DruidConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        dataSource.setDruidClassName(<span class="string">&quot;com.mysql.cj.jdbc&quot;</span>);</span><br><span class="line">        dataSource.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/db1?serverTimezone=UTC&amp;userSSL=false&quot;</span>);</span><br><span class="line">        dataSource.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        dataSource.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="type">DruidPooledConnection</span> <span class="variable">conn</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line">        System.out.println(conn);</span><br><span class="line">        conn.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽取 druid.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jdbc.driver</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">jdbc.url</span>=<span class="string">jdbc:mysql://localhost:3306/db1?serverTimezone=UTC&amp;useSSL=false</span></span><br><span class="line"><span class="attr">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">jdbc.password</span>=<span class="string">123456</span></span><br><span class="line"><span class="attr">initialSize</span>=<span class="string">5</span></span><br><span class="line"><span class="attr">maxActive</span>=<span class="string">10</span></span><br><span class="line"><span class="attr">maxWait</span>=<span class="string">3000</span></span><br></pre></td></tr></table></figure><p>使用 Spring 配置 Druid</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;testOnBorrow&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;testOnReturn&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 添加下面代码解决: testWhileIdle is true, validationQuery not set --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;testWhileIdle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dataSourceTest</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> (DruidDataSource) app.getBean(<span class="string">&quot;dataSource&quot;</span>);</span><br><span class="line">        <span class="type">DruidPooledConnection</span> <span class="variable">connection</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line">        System.out.println(connection);</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要时从 Spring 容器中获取连接池，进而获取 connection 即可。</p><p>Beans 中的伏笔：</p><p><font color=red size=5>EL表达式：${jdbc.driver}，使用目的：将数据库配置抽取到 druid.properties 中，在 xml 文件中将配置文件读取出来</font> </p><p>配置：</p><ol><li>applicationContext.xml 文件的头部添加 context 名称空间：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>读取文件</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入 properties 文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>在<code>&lt;bean&gt;&lt;/bean&gt;</code> 之间使用 EL 表达式</li></ol><h2 id="Spring-注解"><a href="#Spring-注解" class="headerlink" title="Spring 注解"></a>Spring 注解</h2><h3 id="原始注解-新注解"><a href="#原始注解-新注解" class="headerlink" title="原始注解 &amp; 新注解"></a>原始注解 &amp; 新注解</h3><p>Spring 轻代码而重配置，繁重的配置影响开发效率，因此注解成为一种趋势，注解代替 XML 配置文件以简化配置，提高效率。</p><p><img src="https://s2.loli.net/2023/03/25/TwjLcvyx12QUYNn.jpg" alt="原始注解"></p><p><img src="https://s2.loli.net/2023/03/25/7fhKbostI9uaA6Y.jpg" alt="新注解"></p><ol><li><p>配置 Druid，因为没有集成 mybatis，只能使用拼字符串的方式写 SQL</p></li><li><p><code>&lt;bean id=&quot;userMapper&quot; class=&quot;com.example.mapper.impl.UserMapperImpl&quot;&gt;&lt;/bean&gt;</code></p></li><li></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.service.impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userMapper&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userMapper&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">&lt;/bean</span><br></pre></td></tr></table></figure><p>UserServiceImpl.java</p><p>注解的使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;userService&quot;)</span></span><br><span class="line"><span class="meta">@Scope(&quot;singleton&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"><span class="comment">//    @Autowired</span></span><br><span class="line"><span class="comment">//    @Qualifier(&quot;sqlSessionFactory&quot;)</span></span><br><span class="line">    <span class="meta">@Resource(name = &quot;sqlSessionFactory&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> SqlSessionFactory factory;</span><br><span class="line"><span class="comment">//    @Autowired  // （自动）注入注解，如果单独使用则默认按照数据类型自动匹配（自动装配）</span></span><br><span class="line"><span class="comment">//    @Qualifier(&quot;userMapper&quot;)    // 若要使用，则XML 配置必须写 Set 方法，主要与 @Autowired 一起使用</span></span><br><span class="line">    <span class="meta">@Resource(name = &quot;userMapper&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper mapper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceImpl</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceImpl</span><span class="params">(UserMapper mapper)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mapper = mapper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMapper</span><span class="params">(UserMapper mapper)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mapper = mapper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">selectAllUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> factory.openSession();</span><br><span class="line">        <span class="type">UserMapper</span> <span class="variable">userMapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">        List&lt;User&gt; userList = userMapper.selectAllUser();</span><br><span class="line">        System.out.println(userList);</span><br><span class="line">        sqlSession.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 mybatis 而不是 jdbc + druid 可以直接返回</span></span><br><span class="line">        <span class="keyword">return</span> userList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFactory</span><span class="params">(SqlSessionFactory factory)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.factory = factory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在只有一个类型与所需类型匹配时，可以单独使用 @Autowired，但是最好使用 @Qualifier 注解按照名称指定 Bean 对象来进行注入。</p><blockquote><p>自动装配基于反射设计创建对象并暴力反射对应属性为私有属性初始化数据，因此无需提供 setter 方法，自动装配建议使用无参构造方法创建对象（默认），如果不提供对应构造方法，请提供唯一的构造方法。</p></blockquote><p>UserMapperImpl.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository(&quot;userMapper&quot;)</span></span><br><span class="line"><span class="meta">@Scope(&quot;singleton&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserMapperImpl</span> <span class="keyword">implements</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">selectAllUser</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;User&gt; userList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 无论有没有赋值语句都返回 SQL 的执行结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        userList.add(new User(1, &quot;zhangSan&quot;, &quot;123&quot;));</span></span><br><span class="line"><span class="comment">//        userList.add(new User(2, &quot;liSi&quot;, &quot;111&quot;));</span></span><br><span class="line"><span class="comment">//        userList.add(new User(3, &quot;wangWu&quot;, &quot;456&quot;));</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> userList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserControlller.java（做测试）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">USerController</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringUtil.class);</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService)app.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">        System.out.println(userService.selectAllUser());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Spring-管理第三方-Bean"><a href="#Spring-管理第三方-Bean" class="headerlink" title="Spring 管理第三方 Bean"></a>Spring 管理第三方 Bean</h3><ol><li>定义一个方法获得要管理的对象</li><li>添加 @Bean 注解，表示当前方法的返回值是一个 Bean</li></ol><h3 id="Spring-整合-Junit"><a href="#Spring-整合-Junit" class="headerlink" title="Spring 整合 Junit"></a>Spring 整合 Junit</h3><p>步骤：</p><ul><li>导入 spring 集成 junit 的得标</li><li>使用 @RunWith 注解替换原来的运行期</li><li>使用 @ContextConfiguration 指定配置文件或配置类</li><li>使用 @Autowired 注入需要测试的对象</li><li>创建测试方法进行测试</li></ul><p>导入坐标：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.12 RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>SpringJunitTest</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="comment">//@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = &#123; SpringUtil.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringJunitTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="comment">// 需要更改 SpringUtil 中的配置</span></span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        System.out.println(userService.selectAllUser());</span><br><span class="line">        System.out.println(dataSource.getConnection());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring 整合 Druid 数据库连接池</p><p>DruidDataSourceConfig</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DruidDataSourceConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;dataSource&quot;)</span></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    如果需要注入 Bean 则只需要参数即可，Spring 自动装配设置会在 Spring Container 中匹配对象甚至不需要 @Autowired 注解</span></span><br><span class="line"><span class="comment">    public DataSource getDataSource(Dao dao) &#123;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">getDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        ds.setDriverClassName(driver);</span><br><span class="line">        ds.setUrl(url);</span><br><span class="line">        ds.setUsername(username);</span><br><span class="line">        ds.setPassword(password);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font size=5 color=skyblue>引用类型注入只需要为 Bean 定义方法设置形参即可，容器会根据类型自动装配对象。</font> </p><p>SpringUtil</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.example&quot;)</span></span><br><span class="line"><span class="comment">// &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;</span></span><br><span class="line"><span class="comment">// 导入 properties 文件信息</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span></span><br><span class="line"><span class="comment">// 导入其他配置，多个文件则使用数组</span></span><br><span class="line"><span class="meta">@Import(&#123; DruidDataSourceConfig.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Spring-整合-MyBatis"><a href="#Spring-整合-MyBatis" class="headerlink" title="Spring 整合 MyBatis"></a>Spring 整合 MyBatis</h3><p> 使用 Spring 整合的 Druid 数据库连接池配合 MyBatis：</p><p>MyBatisConfig</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回创建 SqlSessionFactory 的 Bean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dataSource 数据源，使用 Druid</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(&quot;sqlSessionFactory&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactoryBean <span class="title function_">sqlSessionFactoryBean</span><span class="params">(DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="type">SqlSessionFactoryBean</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">        bean.setTypeAliasesPackage(<span class="string">&quot;com.example.pojo&quot;</span>);</span><br><span class="line">        bean.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置 MyBatis 映射文件路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 映射扫描配置器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MapperScannerConfigurer <span class="title function_">mapperScannerConfigurer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MapperScannerConfigurer</span> <span class="variable">msc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MapperScannerConfigurer</span>();</span><br><span class="line">        msc.setBasePackage(<span class="string">&quot;com.example.mapper&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> msc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 SpringConfig 中引入 该配置:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.example&quot;)</span></span><br><span class="line"><span class="comment">// &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;</span></span><br><span class="line"><span class="comment">// 导入 properties 文件信息</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span></span><br><span class="line"><span class="meta">@Import(&#123; DruidDataSourceConfig.class, MyBatisConfig.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释掉整个 UserMapperImpl 文件，另外，SqlSessionFactoryUtil 文件也用不到了。</p><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p><strong>AOP</strong>（Aspect Oriented Programming）：面向切面编程，是通过预编译方式和运行期动态代理实现程序功能的统一维护的技术。</p><p>（一种编程范式，主旨是如何组织程序结构）</p><p><strong>作用</strong>：在不改动原有代码的基础上为其做功能增强（无入侵式编程）</p><p><strong>OCP 原则</strong>：对扩展开放，对修改关闭。这里说的是程序包的使用问题，一般针对平时使用的 jar 包，可以继承并拓展新功能但是不支持修改源码。</p><ul><li><strong>连接点（JoinPoint）</strong>：程序执行过程中的<strong>任意</strong>位置，粒度为执行方法、抛出异常、设置变量等。</li><li><strong>切入点（Pointcut）</strong>：匹配连接点的表达式，针对谁做功能增强，谁就是切入点。<ul><li>在 Spring AOP 中，一个切入点可以只描述一个具体方法，也可以匹配多个方法<ul><li>一个具体方法：，某个包下某个接口中的无形参无返回值的方法</li><li>匹配多个方法：<strong>所有的无形参无返回值的方法、所有以 get 开头的方法、所有以 Dao 结尾的接口中的方法，所有带有一个参数的方法</strong></li></ul></li></ul></li><li><strong>通知（Advice）</strong>：在切入点处执行，也就是<strong>共性功能</strong><ul><li>在 Spring 中，<strong>功能最终以方法的形式呈现</strong></li></ul></li><li>**通知类：**定义通知的类</li><li><strong>切面（Aspect）</strong>：描述通知与切入点的对应关系，通知规定了在什么时机做什么事，切入点规定了在什么地方做事。web层级设计中，web层 -&gt; 网关层 -&gt; 服务层 -&gt; 数据层，每一层之间也是一个切面。<strong>编程中，对象与对象之间，方法与方法之间，模块与模块之间都是一个个切面。</strong> </li><li>切入点的范围比连接点的范围小，切入点一定在连接点中</li></ul><h3 id="AOP-的使用"><a href="#AOP-的使用" class="headerlink" title="AOP 的使用"></a>AOP 的使用</h3><ol><li>在 pom.xml 中导入坐标</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>制作连接点（原始操作，Dao 接口域实现类）</p></li><li><p>制作共性功能（通知类与通知）</p></li><li><p>定义切入点</p></li><li><p>绑定切入点与通知（切面）</p></li><li><p>定义通知类受 Spring 容器管理，同时定义当前通知类为切面类</p></li></ol><p>BookDao 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BookMapperImpl 接口实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository(&quot;bookMapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookMapperImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">        System.out.println(<span class="string">&quot;BookMapper save&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;BookMapper update&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MyAdvice 通知类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//要使用 Spring来管理这个类，并且将其定义为切面</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="comment">//给 update加上之前没有的东西</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(void com.example.mapper.BookDao.update())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//共性功能</span></span><br><span class="line">    <span class="meta">@Before(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>切入点定义依托一个不具有实际意义的方法进行，既无参数也无返回值，方法体没有实际逻辑。</p><p>SpringConfig</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.example&quot;)</span></span><br><span class="line"><span class="comment">// &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;</span></span><br><span class="line"><span class="comment">//导入 properties文件信息</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span></span><br><span class="line"><span class="meta">@Import(&#123; DruidDataSourceConfig.class, MyBatisConfig.class &#125;)</span></span><br><span class="line"><span class="comment">//启用切面自动代理</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Test 测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AOPExampleTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bean</span> <span class="operator">=</span> (BookDao) app.getBean(<span class="string">&quot;bookMapper&quot;</span>);</span><br><span class="line">        <span class="comment">//配置之后，也能够输出时间了</span></span><br><span class="line">        bean.update();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AOP-工作原理"><a href="#AOP-工作原理" class="headerlink" title="AOP 工作原理"></a>AOP 工作原理</h3><ol><li>Spring 容器启动；</li><li>读取所有切面配置中的切入点（切入点可以有多个，但是只加载会被使用的切入点）；</li><li>初始化 bean，判定 bean 对应的类中的方法是否匹配到任意切入点。<ol><li>匹配失败，创建原对象</li><li>匹配成功，创建**原对象（目标对象）**的**代理**对象</li></ol></li><li>获取 bean 执行方法<ol><li>获取 bean，调用方法并执行，完成操作</li><li>获取的是 bean 是代理对象时，根据代理对象的运行模式运行原始方法与增强的内容，完成操作</li></ol></li></ol><p>修改操作前（MyAdvice）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要使用 Spring 来管理这个类，并且将其定义为切面</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="comment">// 给 update 加上之前没有的东西，如果能够匹配的上方法，则创建 BookDao 对象的代理对象，反之创建 BookDao 对象</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(void com.example.mapper.BookDao.update())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 共性功能</span></span><br><span class="line">    <span class="meta">@Before(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类（AOPExceptionTest）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AOPExampleTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="comment">// 使用多态，接受实现类或者本类对象</span></span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bean</span> <span class="operator">=</span> (BookDao) app.getBean(<span class="string">&quot;bookMapper&quot;</span>);</span><br><span class="line">        <span class="comment">// 配置之后，也能够输出时间了</span></span><br><span class="line">        bean.update();</span><br><span class="line">        System.out.println(bean);</span><br><span class="line">        System.out.println(bean.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote><p>1663228093151</p><p>BookMapper update com.example.mapper.impl.BookMapperImpl@508dec2b class </p><p>com.sun.proxy.$Proxy24</p></blockquote><p>只对 MyAdvice 类进行修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要使用 Spring 来管理这个类，并且将其定义为切面</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="comment">// 给 update 加上之前没有的东西，如果能够匹配的上方法，则创建 BookDao 对象的代理对象，反之创建 BookDao 对象</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(void com.example.mapper.BookDao.update1())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 共性功能</span></span><br><span class="line">    <span class="meta">@Before(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote><p>BookMapper update com.example.mapper.impl.BookMapperImpl@7a6d7e92 class com.example.mapper.impl.BookMapperImpl</p></blockquote><p><strong>原始对象</strong>：目标功能去掉共性功能对应的类产生的对象，这种对象是无法直接完成最终工作的（非增强的类，就是自己写的那个实现类）</p><p><strong>代理对象</strong>：目标对象无法直接完成工作，需要对其进行功能回填，，通过原始对象的代理对象实现</p><h3 id="切入点表达式"><a href="#切入点表达式" class="headerlink" title="切入点表达式"></a>切入点表达式</h3><p>切入点：要增强的方法</p><p>切入点表达式：切入点的描述方式</p><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> con.example.dao;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(System.currentTimeMillis());</span><br><span class="line">    System.out.println(<span class="string">&quot;BookMapper update&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>描述方式：</p><ol><li><p>执行 com.example.dao 包下的 BookDao 接口中无参数的 update 方法</p><p> <code>eexcution(void com.example.dao.BookDao.update())</code></p></li><li><p>执行 com.example.dao.impl.BookDaoImpl 包下的  BookDaoImpl 类中的无参数 update 方法</p><p> <code>eexcution(void com.example.dao.impl.BookDaoImpl.update())</code></p></li></ol><p>切入点表达式标准格式：动作关键字（访问修饰符 返回值 包名.类&#x2F;接口名.方法名（参数）异常名）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution (<span class="keyword">public</span> User com.example.service.UserService.findById(<span class="type">int</span>))</span><br></pre></td></tr></table></figure><ul><li>动作关键字：描述切入点的行为动作，例如L execution 表示执行到指定切入点</li><li>访问关键字：public，private等，可以省略</li></ul><p>可以使用通配符描述切入点，快速描述：</p><ul><li>*：单个独立的任意符号，可以独立出现，也可以作为前缀或者后缀的匹配符出现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution (<span class="keyword">public</span> com.example.*.UserService.find*(*))</span><br></pre></td></tr></table></figure><p>匹配 com.example 包下任意包中得 UserService 类或者接口中所有以 find 开头的带一个参数的方法</p><ul><li>.. ：多个连续的任意符号，可以独立出现，长用于简化包名与参数的书写</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution (<span class="keyword">public</span> User com..UserService.findById(..))</span><br></pre></td></tr></table></figure><p>匹配 com 包下任意包中的 UserService 类或者接口中的所有名称为 findById 的方法</p><ul><li>+：专用于匹配子类类型（任意返回值、任意包、任意以 Service 结尾的子类中的方法）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution (* **..**Service+.*(..))</span><br></pre></td></tr></table></figure><p>匹配service 层的所有方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要使用 Spring 来管理这个类，并且将其定义为切面</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="comment">// 给 update 加上之前没有的东西，如果能够匹配的上方法，则创建 BookDao 对象的代理对象，反之创建 BookDao 对象</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(void com.example.mapper.BookDao.update1())&quot;)</span></span><br><span class="line">    <span class="comment">// @Pointcut(&quot;execution(* com.example.mapper.impl.BookMapperImpl.update(*))&quot;)</span></span><br><span class="line">    <span class="comment">// @Pointcut(&quot;execution(void com.*.*.*.update())&quot;) 匹配到接口中的 update 方法</span></span><br><span class="line">    <span class="comment">// @Pointcut(&quot;execution(void *..update())&quot;) 匹配整个工程中的 update 方法</span></span><br><span class="line">    <span class="comment">//@Pointcut(&quot;execution(* *..u*(..))&quot;) // 匹配所有 u开头的方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 共性功能</span></span><br><span class="line">    <span class="meta">@Before(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="书写方法"><a href="#书写方法" class="headerlink" title="书写方法"></a>书写方法</h4><ul><li>所有代码按照标注按规范开发，否则技巧全部失效</li><li>描述切入点<strong>通常描述接口</strong>，而不描述类</li><li>访问控制修饰符针对接口开发均采用 public 描述**（可省略访问控制修饰符）**</li><li>返回值类型对于增删改查类使用精准类型加速匹配，对于查询类使用 * 统配快速匹配</li><li><strong>包名</strong>书写<strong>尽量不使用 <code>..</code> 匹配</strong>，效率过低，常用 * 做单个包描述匹配，或净精准匹配</li><li><strong>接口名&#x2F;类名</strong>书写名称与模块相关的<strong>采取*匹配</strong>，例如 UserService 书写成 *Service，绑定业务层接口名</li><li><strong>方法名</strong>书写以<strong>动词</strong>进行<strong>精准匹配</strong>，名词采用<em>匹配，例如：getById 写作 getBy</em>、selectAll 写作 selectAll</li><li>参数规则较为复杂，根据业务灵活调整</li><li>通常<strong>不使用异常</strong>作为匹配规则</li></ul><h3 id="AOP-通知类型"><a href="#AOP-通知类型" class="headerlink" title="AOP 通知类型"></a>AOP 通知类型</h3><p>AOP 通知描述了抽取的共性功能，根据共性功能抽取的位置不同，最终运行代码时要将其加入到合理的位置</p><p><strong>类型分类：</strong></p><ul><li>前置类型</li><li>后置类型</li><li>环绕类型（重点）</li><li>返回后通知</li><li>抛出异常后通知</li></ul><p><strong>环绕通知注意事项</strong> </p><ol><li>环绕通知必须依赖形参 ProceedingJoinPoint 才能实现对原始方法的调用，进而实现对原始方法调用前后同时添加通知</li><li>通知中如果未使用 ProceedingJoinPoint 对原始方法进行调用将跳过原始方法的执行</li><li>对原始方法的调用可以不接收返回值，通知方法设置成 void 即可，如果接收返回值，则必须将返回值设置为 Object 类型</li><li>原始方法的返回值如果是 void 类型，通知方法的返回类型可以设置为 void 也可以设置为 Object</li><li>由于无法预知原始方法运行后是否会抛出异常，因此环绕通知方法必须抛出 Throwable 对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 切入点2</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;execution(int com.example.mapper.BookDao.select())&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pt2</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 环绕功能</span></span><br><span class="line"><span class="meta">@Around(&quot;pt2()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Around before&quot;</span>);</span><br><span class="line">    <span class="comment">// 对原始操作的调，将返回值扔出去</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">res</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line">    System.out.println(<span class="string">&quot;Around after&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>service 层业务执行效率</strong> </p><p>需求分析：任意业务层接口执行均可显示其执行效率（执行时长）</p><ol><li>业务层借口执行前后分别记录时间，求差值得执行效率</li><li>根据上面的分析，得出选择执行前后均可增强的类型— 环绕通知</li><li>测试的接口执行效率只是一个理论值，并不是一次完整的执行过程</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册为组件</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="comment">// 切面</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProjectAdvice</span> &#123;</span><br><span class="line">    <span class="comment">// 匹配业务层所有的方法</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.example.service.*Service.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">servicePt</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 接口方法与通知没有关联，相当于拦截器</span></span><br><span class="line">    <span class="meta">@Around(&quot;ProjectAdvice.servicePt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runSpeed</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 获取被执行方法的信息</span></span><br><span class="line">        <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> pjp.getSignature();</span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> signature.getDeclaringTypeName();</span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> signature.getName();</span><br><span class="line">        <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line">            <span class="comment">// 在这里输出，不返回查询结果（因为返回哪一次查询的结果都不合适）</span></span><br><span class="line">            <span class="comment">// System.out.println(obj);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(className + <span class="string">&quot;.&quot;</span> + methodName + <span class="string">&quot; 执行时间：&quot;</span> + (end - begin) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AOP-通知获取数据"><a href="#AOP-通知获取数据" class="headerlink" title="AOP 通知获取数据"></a>AOP 通知获取数据</h3><p><strong>能够获取相应数据的通知类型</strong> </p><ul><li>获取切入点方法的参数（通知函数的参数）<ul><li>JoinPoint：适用于前置、后置、返回后、抛出异常后通知</li><li>ProceedingJoinPoint：适用于环绕通知</li></ul></li><li>获取切入点<ul><li>返回后通知</li><li>环绕通知</li></ul></li><li>获取切入点方法运行异常信息<ul><li>抛出异常后通知</li><li>环绕通知</li></ul></li></ul><p>ProceedingJoinPoint 继承自 JoinPoint 类，自然能够使用 getArgs() 方法，并且在 Around  通知中能够获取参数并修改参数的值（但是参数的类型和数量一定要与原来相同）</p><p>BookDaoImpl.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">findName</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;id&quot;</span> + id);</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;OS&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MyAdvice.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要使用 Spring 来管理这个类，并且将其定义为切面</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="comment">// 给 update 加上之前没有的东西，如果能够匹配的上方法，则创建 BookDao 对象的代理对象，反之创建 BookDao 对象</span></span><br><span class="line"><span class="comment">//    @Pointcut(&quot;execution(void com.example.mapper.BookDao.update())&quot;)</span></span><br><span class="line">    <span class="comment">// @Pointcut(&quot;execution(void com.example.mapper.BookDao.update1())&quot;)</span></span><br><span class="line">     <span class="meta">@Pointcut(&quot;execution(void com.example.mapper.impl.BookMapperImpl.update(..))&quot;)</span></span><br><span class="line">    <span class="comment">// @Pointcut(&quot;execution(void com.*.*.*.update())&quot;) 匹配到接口中的 update 方法</span></span><br><span class="line">    <span class="comment">// @Pointcut(&quot;execution(void *..update())&quot;) 匹配整个工程中的 update 方法</span></span><br><span class="line">    <span class="comment">//@Pointcut(&quot;execution(* *..u*(..))&quot;) // 匹配所有 u开头的方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切入点2</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(int com.example.mapper.BookDao.select())&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pt2</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 共性功能，前置功能</span></span><br><span class="line">    <span class="meta">@Before(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before &quot;</span> + System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后置功能</span></span><br><span class="line">    <span class="meta">@After(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">(JoinPoint jp)</span> &#123;</span><br><span class="line"><span class="comment">//        Object[] args = jp.getArgs();</span></span><br><span class="line"><span class="comment">//        System.out.println(Arrays.toString(args));</span></span><br><span class="line">        System.out.println(<span class="string">&quot;After &quot;</span> + System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 环绕功能</span></span><br><span class="line">    <span class="meta">@Around(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Around before&quot;</span>);</span><br><span class="line">        Object[] args = pjp.getArgs();</span><br><span class="line"><span class="comment">//        System.out.println(Arrays.toString(args));</span></span><br><span class="line">        args[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line">        <span class="comment">// 对原始操作的调，将返回值扔出去，可以选择性地传递和修改 args</span></span><br><span class="line">        System.out.println(Arrays.toString(args));</span><br><span class="line">        <span class="type">Object</span> <span class="variable">res</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;Around after&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AfterReturning(value = &quot;pt()&quot;, returning = &quot;obj&quot;)</span></span><br><span class="line">    <span class="comment">// 定义一个用于接收返回值的形参（原始方法如果有返回值将返回值装载到obj中，returning的值必须与参数名相同），如果有切入点对象，则它必须位于其他参数的前面</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">(JoinPoint jp, Object obj)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AfterReturning&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抛出异常后通知</span></span><br><span class="line">    <span class="meta">@AfterThrowing(value = &quot;pt2()&quot;, throwing = &quot;t&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;AfterThrowing advice...&quot;</span> + t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一节主要是什么样的通知类型能够获取切入点方法的参数，什么类型的参数等。</p><p>所谓的百度网盘密码处理只不过是在 Around 通知中加入验证码处理（使用一次 trim 方法），但是在处理参数的时候一定要使用 for 循环 ，判断数组中数据的类型是不是字符串类型，如果不是则不处理，否则对其使用 trim 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (args[i].getClass().equals(String.class)) &#123;</span><br><span class="line">args[i] = args[i].toString().trim();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后使用修改后的数据作为参数传入函数</span></span><br><span class="line">Object res= pjp.proceed(args);</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure><h2 id="Transaction"><a href="#Transaction" class="headerlink" title="Transaction"></a>Transaction</h2><p>事务作用：在数据库层保障一系列的数据库操作同成功同失败</p><p>Spring 事务的作用：在数据库层<strong>或业务层</strong>保障一系列的数据库操作同成功同失败</p><p>实现方式：PlatformTransactionManager 接口中提供了 commit 和 rollback 方法，提交事务和回滚事务保证同一事务中的操作同成功或同失败。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PlatformTransactionManager</span> &#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">rollback</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceTransactionManager</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring Transaction 使用方式：</p><ol><li><p>在业务层接口上添加 Spring 事务管理注解 @Transactional</p><p> 注解式事务通常添加在业务层接口上而不添加到业务层实现类（Impl）中，降低耦合；</p><p> 注解式事务可以添加到业务方法上表示当前方法开启事务，也可以添加到接口上表示当前接口所有方法开启事务。</p></li><li><p>设置事务管理器</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> PlatformTransactionManager <span class="title function_">transactionManager</span><span class="params">(DataSource dataSource)</span> &#123;</span><br><span class="line">    <span class="type">DataSourceTransactionManager</span> <span class="variable">manager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>();</span><br><span class="line">    manager.setDataSource(dataSource);</span><br><span class="line">    <span class="keyword">return</span> manager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 事务管理器要根据实现技术进行选择，MyBatis 框架使用的是 JDBC 事务。</p></li><li><p>开启注解式事务管理驱动</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.example&quot;)</span></span><br><span class="line"><span class="comment">// &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;</span></span><br><span class="line"><span class="comment">// 导入 properties 文件信息</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span></span><br><span class="line"><span class="meta">@Import(&#123; DruidDataSourceConfig.class, MyBatisConfig.class &#125;)</span></span><br><span class="line"><span class="comment">// 启用切面自动代理</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="comment">// 启用注解式事务驱动</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>AccountDao</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountDao</span> &#123;</span><br><span class="line">    <span class="meta">@Update(&quot;update account set amount = amount + #&#123;money&#125; where name = #&#123;name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span>String name, <span class="meta">@Param(&quot;money&quot;)</span>Double money)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Update(&quot;update account set amount = amount - #&#123;money&#125; where name = #&#123;name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">decrease</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span>String name, <span class="meta">@Param(&quot;money&quot;)</span>Double money)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AccountService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String ut, String in, Double amount)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountDao accountMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String out, String in, Double amount)</span> &#123;</span><br><span class="line">        accountMapper.increase(out, amount);</span><br><span class="line">        accountMapper.decrease(in, amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DruidDataSourceConfig</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DruidDataSourceConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;dataSource&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">getDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        ds.setDriverClassName(driver);</span><br><span class="line">        ds.setUrl(url);</span><br><span class="line">        ds.setUsername(username);</span><br><span class="line">        ds.setPassword(password);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PlatformTransactionManager <span class="title function_">transactionManager</span><span class="params">(DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="type">DataSourceTransactionManager</span> <span class="variable">manager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>();</span><br><span class="line">        manager.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> manager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="comment">// 与 RunWith 注解联合起来做测试使用</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = &#123; SpringConfig.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountService service;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        service.transfer(<span class="string">&quot;Tom&quot;</span>, <span class="string">&quot;Jerry&quot;</span>, <span class="number">100D</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Spring-Transaction-Role"><a href="#Spring-Transaction-Role" class="headerlink" title="Spring Transaction Role"></a>Spring Transaction Role</h3><p><strong>事务管理员</strong> </p><p>发起事务方，在 Spring 中通常只带业务层开启事务的方法（Service 层中的 transfer 方法）</p><p>目前的事务管理是基于 DataSourceTransactionManager 和 SqlSessionFactoryBean 使用的是同一个数据源来实现的。</p><p><strong>事务协调员</strong> </p><p>加入事务方，在 Spring 中通常指代数据层方法，也可以是业务层方法（increase 和 decrease 方法）</p><h3 id="Transaction-property"><a href="#Transaction-property" class="headerlink" title="Transaction property"></a>Transaction property</h3><p><img src="https://s2.loli.net/2023/03/25/4SRTUzkKtiGIgqQ.png" alt="事务属性"></p><p>上面这些属性都可以在 @Transactional 注解中的参数上设置：</p><p>格式为 <code>@Transactional(readOnly = true, timeout = -1)</code></p><ul><li><p>readOnly：true只读事务，false读写事务，增删改要设为false，查询设为 true。</p></li><li><p>timeout：设置超时时间单位秒，在多长时间之内事务没有提交成功就自动回滚，-1表示不设置超时时间。</p></li><li><p>rollbackFor：当出现指定异常进行事务回滚（遇到某类异常就回滚事务）</p></li><li><p>noRollbackFor:当出现指定异常不进行事务回滚</p><ul><li>思考：出现异常事务会自动回滚，这个是我们之前就已经知道的</li><li>noRollbackFor是设定对于指定的异常不回滚，这个好理解</li><li>rollbackFor是指定回滚异常，对于异常事务不应该都回滚么，为什么还要指定? 这块需要更正一个知识点，并不是所有的异常都会回滚事务，比如下面的代码就不会回滚</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String out,String in ,Double money)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImp</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String out, String in, Double money)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        accountDao.outMoney(out, money);</span><br><span class="line">        <span class="comment">// int i = 1/0; //这个异常事务会回滚</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(); <span class="comment">// 这个异常事务就不会回滚 23 &#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">        accountDao.inMoney(in,money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原因：Spring 事务只会对 Error 类型的异常和 RunTimeException 进行回滚，但是 IOException 不在此列，所以事务没有回滚。</p><p>使用 rollbackfor 属性来解决上面的问题 <code>@Transactional(rollbackfor = IOException.class)</code></p><p>带有 ClassName 的属性作用与没有 ClassName 的属性作用相同，只是使用方式不同，需要将字节码文件换成异常类的全限定名。</p><p>isolation属性：隔离，属性值为枚举类型（<strong>不常用</strong>）</p><ul><li>DEFAULT :默认隔离级别, 会采用数据库的隔离级别</li><li>READ_UNCOMMITTED : 读未提交</li><li>READ_COMMITTED : 读已提交</li><li>REPEATABLE_READ : 重复读取</li><li>SERIALIZABLE: 串行化</li></ul><h3 id="转账业务追加日志"><a href="#转账业务追加日志" class="headerlink" title="转账业务追加日志"></a>转账业务追加日志</h3><ol><li>基于转账操作案例添加日志模块，实现数据库中记录日志</li><li>业务层转账操作（transfer），调用减钱、加钱与记录日志功能</li><li><font color=#d44c47><strong>无论转账操作是否成功，均进行转账操作的日志留痕</strong></font></li></ol><p>首先是写 Dao 层的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LogDao</span> &#123;</span><br><span class="line">    <span class="meta">@Insert(&quot;insert into tbLog(info, insertTime) values(#&#123;info&#125;, now())&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String info)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后 Service 层接口文件和实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LogService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String out, String in, Double money)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">LogService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LogDao logDao;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新创建一个事务，将其与转账操作隔离开</span></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String out, String in, Double money)</span> &#123;</span><br><span class="line">        logDao.log(<span class="string">&quot;从&quot;</span> + out + <span class="string">&quot;转出&quot;</span> + money + <span class="string">&quot;到&quot;</span> + in);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后修改 AccountServiceImpl 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountDao accountMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LogService logService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String out, String in, Double amount)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            accountMapper.decrease(out, amount);</span><br><span class="line">            accountMapper.increase(in, amount);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 这里调用日志功能，AccountService 既是 Service 层，也是 Controller 层</span></span><br><span class="line"><span class="comment">// 使用 try-finally 块，达到无论事务是否成功都能写日志的功能</span></span><br><span class="line">            logService.log(out, in, amount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h4><p><img src="https://s2.loli.net/2023/03/25/6OaRwVHxG9TCuoK.png" alt="事务传播属性"></p><p>对于我们开发实际中使用的话，因为默认值需要事务是常态的。根据开发过程选择其他的就可以了，例如案例中需要新事务就需要手工配置。其实入账和出账操作上也有事务，采用的就是默认值。</p><h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><ul><li>理解 SpringMVC 相关概念</li><li>SpringMVC 入门</li><li>使用 Postman 发送请求和数据</li><li>掌握 SpringMVC 对 Servlet 封装后的操作</li><li>掌握 RESTful 风格及其的使用</li></ul><p>SpringMVC 是 Spring 框架的一部分，主要用于 web 应用的开发，是对 Servlet 的封装（表现层框架技术）。</p><p>主要内容：</p><ul><li>SpringMVC 简介</li><li><font color=#d44c47><strong>请求与响应</strong></font> </li><li><font color=#d44c47><strong>REST风格</strong></font> </li><li><font color=#d44c47><strong>SSM 拦截器</strong></font> </li><li>拦截器（Filter）</li></ul><p>SpringMVC 是 Web 层的框架，主要作用是<strong>接收前端发送的请求和数据</strong>，然后<strong>经过处理将处理的结果响应给前端</strong>，<strong>如何处理请求和响应</strong>是 SpringMVC 中非常重要的部分。</p><p>RESTful 是一种软件架构的风格，用于降低开发的复杂度，提高系统的可伸缩性，后期的应用也非常广泛。</p><p>SSM 整合的目的是将 Spring、SpringMVC、MyBatis 整合到一起，是对学习的框架的总结。</p><p>主旨：</p><ul><li>获取请求参数和响应 JSON 数据操作</li><li>熟练应用基于 REST 风格的请求路径设置和参数传递</li><li>整合 SSM 做开发工作</li></ul><h2 id="Request-Response"><a href="#Request-Response" class="headerlink" title="Request &amp; Response"></a>Request &amp; Response</h2><ol><li>导入坐标</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.12.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>创建 SpringMVC Controller 类（等同于 Servlet 功能）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义方法即可处理请求，返回 JSON 格式的字符串</span></span><br><span class="line">    <span class="comment">// 设置当前方法的访问路径</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/save&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;User save&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123; \&quot;info\&quot;: \&quot;save\&quot; &#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>初始化 SpringMVC 环境（同 Spring 环境），谁那个 SpringMVC 加载对应的 Bean</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.example&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>初始化 Servlet 容器，记载 SpringMVC 环境，并设置 SpringMVC 技术处理的请求</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Servlet 容器启动的配置类，在其中加载 Spring 的配置</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletContainerInitConfig</span> <span class="keyword">extends</span> <span class="title class_">AbstractDispatcherServletInitializer</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于加载 Spring 容器配置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> WebApplicationContext <span class="title function_">createServletApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigWebApplicationContext</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigWebApplicationContext</span>();</span><br><span class="line">        <span class="comment">// 容器注册</span></span><br><span class="line">        app.register(SpringMvcConfig.class);</span><br><span class="line">        <span class="keyword">return</span>  app;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置哪些请求归属 SpringMVC，这里设置将所有请求归属到 SpringMVC 响应</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载 Spring 容器配置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> WebApplicationContext <span class="title function_">createRootApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解详解：</p><ul><li>@Controller：类注解，位于 SpringMVC 控制器类定义上，设定核心控制器 Bean</li><li>@RequestMapping：方法类注解，位于控制器方法定义上，设置当前控制器方法请求访问路径</li><li>@ResponseBody：方法注解，位于控制器方法定义上，设置当前控制器方法响应内容为当前返回值，无需解析</li></ul><blockquote><p>SpringMVC 入门程序总结：</p><p>​一次性工作：创建工程、设置服务器、加载工程；导入坐标；创建 Web 容器启动类、加载 SpringMVC配置并设置 SpringMVC 请求拦截路径；SpringMVC 核心控制类（设置配置类、包扫描、加载Controller控制器Bean）</p><p>​重复性工作：定义处理请求的控制器类；定义处理请求的控制器方法并配置映射路径与响应数据</p></blockquote><h2 id="Spring-work-process"><a href="#Spring-work-process" class="headerlink" title="Spring work process"></a>Spring work process</h2><p><strong>启动服务器初始化过程</strong> </p><ol><li>服务器启动，执行 ServletContainersInitConfig 类，初始化 web 容器</li><li>执行 createServletApplicationContext 方法，创建了 WebApplicationContext 对象</li><li>加载 SpringMvcConfig，</li><li>执行 @ComponentScan 加载对应的 bean</li><li>加载 UserController，每个 @RequestMapping 的名称对应一个具体的方法</li><li>执行 getServletMapping 方法，定义所有的请求都通过 SpringMVC</li></ol><p><strong>单次请求过程</strong> </p><ol><li>浏览器访问 localhost&#x2F;save，发送请求</li><li>web 容器发现所有的请求都经过 SpringMVC，将请求交给其处理</li><li>解析请求路径 &#x2F;save</li><li>由 &#x2F;save 匹配执行对应的方法 save()</li><li>执行 save()</li><li>检测到有 @ResponseBody 直接将 save() 方法的返回值作为响应体返回给请求方</li></ol><h2 id="Bean-加载控制"><a href="#Bean-加载控制" class="headerlink" title="Bean 加载控制"></a>Bean 加载控制</h2><p>问题：SpringMvcConfig配置类加载了什么内容而Spring又加载了什么？</p><ul><li>SpringMVC 加载表现层相关的 bean</li><li>Spring 加载业务层（service）和功能类（dao）的 bean<ul><li>功能类的 bean 比如：DataSource等</li></ul></li></ul><p>但是在配置 SpringConfig 类使用的是 <code>@ComponentScan(&quot;com.example&quot;)</code> ，SpringMvcConfig 类中使用的是 <code>@ComponentSacn(&quot;com.example.controller&quot;)</code> 。</p><p>因为功能不同，因而需要避免Spring 错误加载到 SpringMVC 的 bean —— 加载 Spring 控制的 bean 的时候排除掉 SpringMVC 控制的 bean。</p><ul><li>SpringMVC 相关 bean 加载控制<ul><li>SpringMVC 加载的 bean 对应的包均在 com.example.controller 包中</li></ul></li><li>Spring 相关 bean 加载控制<ul><li>方式一：Spring 加载的 bean 设定扫描范围为 com.example，并排除掉 controller 包以内的 bean</li><li>方式二：Spring 加载的 bean 设定扫描范围为精准范围，例如：service包、dao包<ul><li>excludeFilters 属性：设置扫描加载 bean 时，排除的过滤规则</li><li>type 属性：设置排除规则，当前使用按照定义 bean 时使用的注解类型进行排除<ul><li>ANNOTATION：按照注解排除</li><li>ASSIGNABLE_TYPE：按照指定的类型过滤</li><li>ASPECTJ：按照 Aspectj 表达式排除，基本上不会用</li><li>REGEX：按照正则表达式排除</li><li>CUSTOM：按照自定义规则排除</li></ul></li></ul></li><li>不区分 Spring 和 SpringMVC 的环境，加载到同一个环境中</li></ul></li></ul><p>SpringConfig</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    设定扫描范围为精准范围（方法二）</span></span><br><span class="line"><span class="comment">    @ComponentScan(&#123;&quot;com.example.service&quot;, &quot;com.example.dao&quot;&#125;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 排除法（方法一）</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span></span><br><span class="line"><span class="meta">@ComponentScan(value = &quot;com.example&quot;,</span></span><br><span class="line"><span class="meta">        excludeFilters = @ComponentScan.Filter(</span></span><br><span class="line"><span class="meta">                type = FilterType.ANNOTATION,</span></span><br><span class="line"><span class="meta">                classes = Controller.class</span></span><br><span class="line"><span class="meta">        )</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="meta">@Import(&#123; DruidConfig.class, MyBatisConfig.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SpringMvcConfig</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@Configuration</span></span><br><span class="line"><span class="comment">// 如果同时放开 Configuration 的注释，Spring 加载 Bean 的时候会扫描 SpringMvcConfig 类，同时 MVC 加载的 Bean 也会被 Spring 加载到</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.example.controller&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ServletContainerInitConfig</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Servlet 容器启动的配置类，在其中加载 Spring 的配置</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletContainerInitConfig</span> <span class="keyword">extends</span> <span class="title class_">AbstractDispatcherServletInitializer</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于加载 Spring 容器配置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> WebApplicationContext <span class="title function_">createServletApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigWebApplicationContext</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigWebApplicationContext</span>();</span><br><span class="line">        <span class="comment">// 容器注册</span></span><br><span class="line">        app.register(SpringMvcConfig.class);</span><br><span class="line">        <span class="keyword">return</span>  app;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置哪些请求归属 SpringMVC，这里设置将所有请求归属到 SpringMVC 响应</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载 Spring 容器配置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> WebApplicationContext <span class="title function_">createRootApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigWebApplicationContext</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigWebApplicationContext</span>();</span><br><span class="line">        app.register(SpringConfig.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> app;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Test</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = &#123; SpringConfig.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ApplicationContext app= <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        System.out.println(app.getBean(UserController.class));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法三：不区分 Spring 和 SpringMVC 的配置()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletContainerInitConfig</span> <span class="keyword">extends</span> <span class="title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123; SpringConfig.class &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123; SpringMvcConfig.class &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123; <span class="string">&quot;/&quot;</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@ComponentScan 注解</p><p>类注解，位于类定义上方，作用是设置 Spring 配置类扫描路径，用于加载使用注解格式定义的 bean，相关属性有：excludeFilters（排除扫描路径中加载的 bean，需要指定类别（type）和具体项（classes），includeDilters：加载指定的 bean，需要指定类别（type）和具体项（classes））</p><h2 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h2><p>Postman 的使用就此略过，软件测试课上学过一些，有问题问度娘。</p><h3 id="映射路径"><a href="#映射路径" class="headerlink" title="映射路径"></a>映射路径</h3><p><img src="https://s2.loli.net/2023/03/25/3WoHEh1x98tU4mF.jpg" alt="路径冲突"></p><p>不同的模块中可能有同名函数，如果使用 @RequestMapping 注解设置请求路径的话，可能会造成路径冲突（如上图），解决方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义方法即可处理请求，返回 JSON 格式的字符串</span></span><br><span class="line">    <span class="comment">// 设置当前方法的访问路径</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/save&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">(<span class="meta">@RequestParam(&quot;name&quot;)</span>String username)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;User save&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123; \&quot;module\&quot;: \&quot;User save\&quot; &#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/book&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/save&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Book save&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123; \&quot;module\&quot;: \&quot;Book save\&quot; &#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意事项：</p><p>当类上和方法上 @RequestMapping 注解时，前端发送请求时，请求路径需要与两个注解的 value 的<strong>和</strong>相等才可；</p><p>@RequestMapping 注解 value 前面加不加 &#x2F; 都可以</p></blockquote><h3 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h3><p>因为再 Java Web 中就已经不再区分 GET 和 POST 的请求处理方式了，所以在 MVC 中也不再分别处理这两种请求方式。</p><h4 id="处理请求乱码"><a href="#处理请求乱码" class="headerlink" title="处理请求乱码"></a>处理请求乱码</h4><ol><li>在 pom.xml 的 <properties>标签下添加</li></ol><p><code>&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</code> </p><ol start="2"><li>配置过滤器</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注解式的 ServletContainerInitConfig</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletContainerInitConfig</span> <span class="keyword">extends</span> <span class="title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123; SpringConfig.class &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123; SpringMvcConfig.class &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置请求归属</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123; <span class="string">&quot;/&quot;</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置过滤器，解决请求乱码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Filter[] getServletFilters() &#123;</span><br><span class="line">        <span class="type">CharacterEncodingFilter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CharacterEncodingFilter</span>();</span><br><span class="line">        filter.setEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Filter</span>[] &#123; filter &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h4><h5 id="传递普通参数"><a href="#传递普通参数" class="headerlink" title="传递普通参数"></a>传递普通参数</h5><p>主要解决地址参数名与形参名不一致的问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义方法即可处理请求，返回 JSON 格式的字符串</span></span><br><span class="line">    <span class="comment">// 设置当前方法的访问路径</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/save&quot;, produces = &quot;text/html;charset=utf-8&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">(<span class="meta">@RequestParam(&quot;name&quot;)</span>String username)</span> &#123;</span><br><span class="line">        System.out.println(username + <span class="string">&quot; save&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123; \&quot;module\&quot;: &quot;</span>  + username + <span class="string">&quot; \&quot; save\&quot; &#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求路径：<code>http://localhost/user/pojoParam?name=张三</code></p><h5 id="传递实体类型参数"><a href="#传递实体类型参数" class="headerlink" title="传递实体类型参数"></a>传递实体类型参数</h5><p>需要注意的是，参数名称与实体类成员变量名必须一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/pojoParam&quot;, produces = &quot;text/html;charset=utf-8&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">pojoParam</span><span class="params">(User user)</span> &#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;: &#x27;pojo param&#x27;&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求路径：<code>http://localhost/user/pojoParam?id=1&amp;username=张三&amp;password=111</code></p><h5 id="嵌套实体类参数"><a href="#嵌套实体类参数" class="headerlink" title="嵌套实体类参数"></a>嵌套实体类参数</h5><p>适用于类中有其它类对象作为成员变量的情况，参数名称依旧需要与实体类中成员变量名一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/nestingPojoParam&quot;, produces = &quot;text/html;charset=utf-8&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">complexPojoParam</span><span class="params">(UserInfo userInfo)</span> &#123;</span><br><span class="line">    System.out.println(userInfo);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;: &#x27;nesting pojo param&#x27;&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求路径：<code>http://localhost/user/complexPojoParam?username=张三&amp;password=111&amp;address.province=安徽&amp;address.city=合肥</code></p><h5 id="数组类型参数"><a href="#数组类型参数" class="headerlink" title="数组类型参数"></a>数组类型参数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;arrayParam&quot;, produces = &quot;text/html;charset=utf-8&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">arrayParam</span><span class="params">(String[] likes)</span> &#123;</span><br><span class="line">    System.out.println(JSON.toJSONString(likes));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;: &#x27;array param&#x27;&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求路径：<code>http://localhost/user/arrayParam?likes=apple&amp;likes=banana&amp;likes=pear</code></p><h5 id="集合类型参数"><a href="#集合类型参数" class="headerlink" title="集合类型参数"></a>集合类型参数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;listParam&quot;, produces = &quot;text/html;charset=utf-8&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">arrayParam</span><span class="params">(List&lt;String&gt; stringList)</span> &#123;</span><br><span class="line">    System.out.println(JSON.toJSONString(stringList));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;: &#x27;list param&#x27;&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求路径：<code>http://localhost/user/listParam?stringList=banana&amp;stringList=apple</code></p><p><font size=5 color=red>接收JSON必须使用@RequestBody注解</font> </p><h5 id="JSON数组参数"><a href="#JSON数组参数" class="headerlink" title="JSON数组参数"></a>JSON数组参数</h5><p>添加依赖：SpringMVC默认使用的是jackson来处理json的转换，所以需要在pom.xml添加jackson依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>需要在SpringMvcConfig中添加 <code>@EnableWebMvc</code>注解开启将JSON转换成对象的功能（添加之后，）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;listParamForJson&quot;, produces = &quot;application/json;charset=UTF-8&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">listParamForJson</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;String&gt; likes)</span> &#123;</span><br><span class="line">    System.out.println(likes);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;: &#x27;list common for JSON param&#x27;&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要使用接口测试工具发送JSON数据。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;name&quot;</span><span class="punctuation">,</span> <span class="string">&quot;string&quot;</span><span class="punctuation">,</span> <span class="string">&quot;password&quot;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><h5 id="JSON实体类型"><a href="#JSON实体类型" class="headerlink" title="JSON实体类型"></a>JSON实体类型</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/pojoParamForJson&quot;, produces = &quot;application/json;charset=UTF-8&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">listParamForJson</span><span class="params">(<span class="meta">@RequestBody</span> UserInfo user)</span> &#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;: &#x27;pojo for JSON param&#x27;&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用接口测试工具发送JSON数据：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;username&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bala&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;password&quot;</span><span class="punctuation">:</span> <span class="string">&quot;balabala&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;province&quot;</span><span class="punctuation">:</span> <span class="string">&quot;anhui&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;city&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hefei&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h5 id="JSON实体集合类型数据"><a href="#JSON实体集合类型数据" class="headerlink" title="JSON实体集合类型数据"></a>JSON实体集合类型数据</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/pojoListParamForJson&quot;, produces = &quot;application/json;charset=UTF-8&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">pojoListParamForJson</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;User&gt; userList)</span> &#123;</span><br><span class="line">    System.out.println(userList);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;: &#x27;pojo List for JSON param&#x27;&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用接口测试工具发送数据：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span><span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;password&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span><span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;password&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><h5 id="日期类型数据传递"><a href="#日期类型数据传递" class="headerlink" title="日期类型数据传递"></a>日期类型数据传递</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/dateParam&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">dateParam</span><span class="params">(Date date,</span></span><br><span class="line"><span class="params">                        <span class="meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span> Date date1,</span></span><br><span class="line"><span class="params">                        <span class="meta">@DateTimeFormat(pattern = &quot;yyyy/MM/dd HH:mm:SS&quot;)</span> Date date2)</span> &#123;</span><br><span class="line">    System.out.println(date);</span><br><span class="line">    System.out.println(date1);</span><br><span class="line">    System.out.println(date2);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;: &#x27;date param&#x27;&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求路径：<code>http://localhost/user/dateParam?date=2088/08/08&amp;date1=2008-08-08&amp;date2=2088/08/08 08:08:12</code> 可以任意数量的参数，但是格式必须正确。</p><h5 id="DateTimeFormat"><a href="#DateTimeFormat" class="headerlink" title="@DateTimeFormat"></a>@DateTimeFormat</h5><p>形参注解，放在SpringMvc控制器方法形参的前面，用于设定日期时间类型数据格式，设置其其pattern属性可以指定日期时间数据格式，值为一个字符串。</p><p>SpingMvc能够实现这一系列转换操作的背后是 @EnableWebMvc 注解以及在 pom.xml 中导入的 jackson 在起作用。</p><h2 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h2><h3 id="响应式页面跳转"><a href="#响应式页面跳转" class="headerlink" title="响应式页面跳转"></a>响应式页面跳转</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 响应，但是控制器类声明上不能加 RequestMapping 注解</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/jumpPage&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">jumpPage</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;page.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求路径：<code>localhost/jumpPage</code> </p><h3 id="响应字符串数据"><a href="#响应字符串数据" class="headerlink" title="响应字符串数据"></a>响应字符串数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/toText&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toText</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;text&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求路径：<code>localhost/toText</code> 跟JSON数据一样以字符串形式传输，与 Controller 上的请求路径无关。</p><h3 id="响应-JSON-格式数据"><a href="#响应-JSON-格式数据" class="headerlink" title="响应 JSON 格式数据"></a>响应 JSON 格式数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;toJsonPojo&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span><span class="comment">// 能够进行转换的关键</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">toJsonPojo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;pwd&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Response-注解"><a href="#Response-注解" class="headerlink" title="@Response 注解"></a>@Response 注解</h4><p>方法注解，位于 SpringMVC 控制器方法定义的上方，作用是设置当前位置控制器返回值作为响应体。如果返回值是 String 类型则不做任何处理，如果是 Pojo 类型则转换为 JSON 格式数据之后将其作为响应体。</p><p>转换器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HttpMessageConverter</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">canRead</span><span class="params">(Class&lt;?&gt; clazz, <span class="meta">@Nullable</span> MediaType mediaType)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">canWrite</span><span class="params">(Class&lt;?&gt; clazz, <span class="meta">@Nullable</span> MediaType mediaType)</span>;</span><br><span class="line">    List&lt;MediaType&gt; <span class="title function_">getSupportMediaTypes</span><span class="params">()</span>;</span><br><span class="line">    T <span class="title function_">read</span><span class="params">(Class&lt;? extends T&gt; clazz, HttpMessageNotReadable inputMessage)</span> </span><br><span class="line">        <span class="keyword">throws</span> IOException, HttpMessageNotReadableException;</span><br><span class="line">    T <span class="title function_">write</span><span class="params">(T t, <span class="meta">@Nullable</span> MediaType contextType, HttpOutputMessage outputMessage)</span> </span><br><span class="line">        <span class="keyword">throws</span> IOException, HttpMessageNotWritableException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转换机理：</p><p>查看 HttpMessageConverter 的继承结构，找到 GenericHttpMessageConverter 接口，其抽象实现类 AbstractGenericHttpMessageConverter，以及其子类 AbstractJackson2HttpMessageConverter，最终发现了 MappingJackson2HttpMessageConverter 类，它是转换的实现者。</p><h2 id="REST-风格"><a href="#REST-风格" class="headerlink" title="REST 风格"></a>REST 风格</h2><p>REST：Representational State Transfer 表现形式的状态转换（访问网络资源的格式）。</p><ul><li>传统的资源描述形式：<a href="http://localhost/user/getById?id=1%EF%BC%8C%E8%AF%B8%E5%A6%82%E6%AD%A4%E7%B1%BB">http://localhost/user/getById?id=1，诸如此类</a></li><li>REST 风格：<a href="http://localhost/user/1">http://localhost/user/1</a></li></ul><p>优点：</p><ul><li>隐藏资源的访问行为，无法通过URL得知资源是何种操作</li><li>书写简化</li></ul><p>REST 风格访问资源时使用 &#x3D;&#x3D;行为动作&#x3D;&#x3D; 区分对资源进行了何种操作</p><ul><li>GET 查询</li><li>POST 新增&#x2F;保存</li><li>PUT 修改&#x2F;更新</li><li>DELETE 删除</li></ul><blockquote><p>REST 不是规范，上面的行为都是约定的方式，可以不遵守。<br>描述模块的名称通常使用复数，表示一类资源。</p></blockquote><p>根据 REST 风格对资源进行访问称为 RESTful。</p><h3 id="REST-初探"><a href="#REST-初探" class="headerlink" title="REST 初探"></a>REST 初探</h3><p>重新创建一个控制器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RestController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/users&quot;, method = RequestMethod.POST)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;save&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;: &#x27;user save&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如何接收参数已经在这里说清了</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 需要删除的实体的 id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 删除成功消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/users/&#123;id&#125;&quot;, method = RequestMethod.DELETE)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">delete</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;delete &quot;</span> + id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;: &#x27;user delete&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/users&quot;, method = RequestMethod.PUT)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">update</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;insert&quot;</span> + user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;: &#x27;user update&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/users/&#123;id&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getById</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;get user&quot;</span> + id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;: &#x27;user getById&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/users&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;: &#x27;user getAll&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据请求方式的不同，做不同的操作。接收参数需要使用 @PathVariable 注解，请求路径也需要作相应改变。</p><h4 id="RequestBody、-RequestParam-和-PathVariable"><a href="#RequestBody、-RequestParam-和-PathVariable" class="headerlink" title="@RequestBody、@RequestParam 和 @PathVariable"></a>@RequestBody、@RequestParam 和 @PathVariable</h4><p><strong>区别：</strong> </p><ul><li>@RequestParam 用于接收 url 地址传参或表单传参</li><li>@RequestBody 用于接收 JSON 格式数据</li><li>@PathVariable 用于接受路径参数，使用 {参数名} 描述路径参数</li></ul><p><strong>应用：</strong> </p><ul><li>后期开发中，发送请求数量超过一个时，以 JSON 格式为主，@RequestBody 应用较广</li><li>如发送非 JSON 格式数据，选用 @RequestParam 接收请求参数</li><li>采用 RESTful 进行开发，当参数数量较少时，可以使用 @PathVariable 接收请求路径变量，通常用于传输 id</li></ul><p>###简化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 其中所有函数上都使用了 <span class="doctag">@ResponseBody</span> 的情况下就可以把注解提取出来</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//@Controller</span></span><br><span class="line"><span class="comment">//@ResponseBody</span></span><br><span class="line"><span class="meta">@org</span>.springframework.web.bind.annotation.RestController</span><br><span class="line"><span class="meta">@RequestMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RestController</span> &#123;</span><br><span class="line"><span class="comment">//    @RequestMapping(method = RequestMethod.POST)</span></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;save&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;: &#x27;user save&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如何接收参数已经在这里说清了</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 需要删除的实体的 id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 删除成功消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">//    @RequestMapping(value = &quot;/&#123;id&#125;&quot;, method = RequestMethod.DELETE)</span></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">delete</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;delete &quot;</span> + id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;: &#x27;user delete&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    @RequestMapping(method = RequestMethod.PUT)</span></span><br><span class="line">    <span class="meta">@PutMapping</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">update</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;insert&quot;</span> + user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;: &#x27;user update&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    @RequestMapping(value = &quot;/&#123;id&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getById</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;get user &quot;</span> + id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;: &#x27;user getById&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    @RequestMapping(method = RequestMethod.GET)</span></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;: &#x27;user getAll&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Annotation-details"><a href="#Annotation-details" class="headerlink" title="Annotation details"></a>Annotation details</h4><p>@RestController</p><p>类注解，位于 SpringMVC 的 RESTful 风格控制器类定义上，作用是设置当前控制器类为 REST 风格，等同于 @Controller + @ResponseBody 两个注解组合功能。</p><h4 id="GetMapping-PostMapping-PutMapping-DeleteMapping"><a href="#GetMapping-PostMapping-PutMapping-DeleteMapping" class="headerlink" title="@GetMapping @PostMapping @PutMapping @DeleteMapping"></a>@GetMapping @PostMapping @PutMapping @DeleteMapping</h4><p>方法注解，位于控制器方法定义上方，设置当前控制器方法请求访问路径与请求动作，每种对应一个请求动作，例如@GetMapping对应GET请求，value为访问路径</p><h1 id="SSM-整合"><a href="#SSM-整合" class="headerlink" title="SSM 整合"></a>SSM 整合</h1><h2 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h2><p>SpringConfig</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&#123;&quot;ssm.dao&quot;, &quot;ssm.service&quot;&#125;)</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span></span><br><span class="line"><span class="meta">@Import(&#123;DruidConfig.class, MyBatisConfig.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DruidConfig</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DruidConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;dataSource&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">getDataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        dataSource.setDriverClassName(driver);</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        dataSource.setUsername(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PlatformTransactionManager <span class="title function_">transactionManager</span><span class="params">(DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="type">DataSourceTransactionManager</span> <span class="variable">manager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>();</span><br><span class="line">        manager.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> manager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MyBatisConfig</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactoryBean <span class="title function_">sqlSessionFactory</span><span class="params">(DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="type">SqlSessionFactoryBean</span> <span class="variable">sqlSessionFactoryBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">        sqlSessionFactoryBean.setDataSource(dataSource);</span><br><span class="line">        sqlSessionFactoryBean.setTypeAliasesPackage(<span class="string">&quot;ssm.pojo&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MapperScannerConfigurer <span class="title function_">mapperScannerConfigurer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MapperScannerConfigurer</span> <span class="variable">configurer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MapperScannerConfigurer</span>();</span><br><span class="line">        configurer.setBasePackage(<span class="string">&quot;ssm.dao&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> configurer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SpringMvcConfig</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;ssm.controller&quot;)</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ServletContainerInitConfig</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletContainerInitConfig</span> <span class="keyword">extends</span> <span class="title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;SpringConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;SpringMvcConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Filter[] getServletFilters() &#123;</span><br><span class="line">        <span class="type">CharacterEncodingFilter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CharacterEncodingFilter</span>();</span><br><span class="line">        filter.setEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Filter</span>[]&#123;filter&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SpringMvcSupport</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcSupport</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurationSupport</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这一步，因为还没有建立静态资源的基本文件目录，所以暂时不做放行操作。</p><p>或者可以将 SpringConfig 和 SpringMvcConfig 合并：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;ssm&quot;)</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span></span><br><span class="line"><span class="meta">@Import(&#123;DruidConfig.class, MyBatisConfig.class&#125;)</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>Book（主要属性）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Integer id;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> String type;</span><br><span class="line"><span class="keyword">private</span> String description;</span><br></pre></td></tr></table></figure><p>Dao：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="meta">@Insert(&quot;insert into tb_book(type, name, description) values(#&#123;type&#125;, #&#123;name&#125;, #&#123;description&#125;)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addBook</span><span class="params">(Book book)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Delete(&quot;delete from tb_book where id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deleteById</span><span class="params">(Integer id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Update(&quot;update tb_book set name = #&#123;name&#125;, type = #&#123;type&#125;, description = #&#123;description&#125; where id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Book book)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;select * from tb_book where id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Book <span class="title function_">getById</span><span class="params">(Integer id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;select * from tb_book&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Book&gt; <span class="title function_">getAllBooks</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Service：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新增图书</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> book</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">save</span><span class="params">(Book book)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按照 id 删除图书</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">delete</span><span class="params">(Integer id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新图书信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> book</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">update</span><span class="params">(Book book)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按照 id 查询图书信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Book <span class="title function_">getById</span><span class="params">(Integer id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询所有图书信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Book&gt; <span class="title function_">getAllBooks</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BookServiceImpl：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookDao mapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">save</span><span class="params">(Book book)</span> &#123;</span><br><span class="line">        mapper.addBook(book);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">delete</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        mapper.deleteById(id);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">update</span><span class="params">(Book book)</span> &#123;</span><br><span class="line">        mapper.update(book);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Book <span class="title function_">getById</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mapper.getById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Book&gt; <span class="title function_">getAllBooks</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mapper.getAllBooks();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BookController：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/books&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookService service;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">save</span><span class="params">(<span class="meta">@RequestBody</span> Book book)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> service.save(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">delete</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> service.delete(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping()</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">update</span><span class="params">(<span class="meta">@RequestBody</span> Book book)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> service.update(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Book <span class="title function_">getById</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> service.getById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Book&gt; <span class="title function_">getAllBooks</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> service.getAllBooks();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="封装返回数据"><a href="#封装返回数据" class="headerlink" title="封装返回数据"></a>封装返回数据</h2><p>一般情况下，后端返回的数据包括：msg、code、data 三个字段，BookController 中返回的要么是布尔值，要么直接就是用户数据，返回数据格式不统一，前端操作数据略有麻烦。现在对 Controller 层返回的信息进行封装。</p><p>统一结果类 Result：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Result</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Result</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Result</span><span class="params">(Integer code, Object data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Result</span><span class="params">(Integer code, String msg)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Result</span><span class="params">(Integer code, String msg, Object data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 我觉得 Geters 和 Setters 可以不写，反正在 Java 文件中用不到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Code类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Integer</span> <span class="variable">SAVE_OK</span> <span class="operator">=</span> <span class="number">20011</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Integer</span> <span class="variable">DELETE_OK</span> <span class="operator">=</span> <span class="number">20021</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Integer</span> <span class="variable">UPDATE_OK</span> <span class="operator">=</span> <span class="number">20031</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Integer</span> <span class="variable">GET_OK</span> <span class="operator">=</span> <span class="number">20041</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Integer</span> <span class="variable">SAVE_ERR</span> <span class="operator">=</span> <span class="number">20010</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Integer</span> <span class="variable">DELETE_ERR</span> <span class="operator">=</span> <span class="number">20020</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Integer</span> <span class="variable">UPDATE_ERR</span> <span class="operator">=</span> <span class="number">20030</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Integer</span> <span class="variable">GET_ERR</span> <span class="operator">=</span> <span class="number">20040</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更改后的 BookController：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/books&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookService service;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">save</span><span class="params">(<span class="meta">@RequestBody</span> Book book)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> service.save(book);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(flag ? Code.SAVE_OK: Code.SAVE_ERR, flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">delete</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> service.delete(id);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(flag? Code.DELETE_OK: Code.DELETE_ERR, flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping()</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">update</span><span class="params">(<span class="meta">@RequestBody</span> Book book)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> service.update(book);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(flag? Code.UPDATE_OK: Code.UPDATE_ERR, flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">getById</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span> &#123;</span><br><span class="line">        <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> service.getById(id);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">code</span> <span class="operator">=</span> book != <span class="literal">null</span> ? Code.GET_OK: Code.GET_ERR;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> book != <span class="literal">null</span> ? <span class="string">&quot;Success&quot;</span>: <span class="string">&quot;数据查询失败，请重试。&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(code, msg, book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">getAllBooks</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Book&gt; books = service.getAllBooks();</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">code</span> <span class="operator">=</span> books != <span class="literal">null</span> ? Code.GET_OK: Code.GET_ERR;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> books != <span class="literal">null</span> ? <span class="string">&quot;Success&quot;</span>: <span class="string">&quot;数据查询失败，请重试。&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(code, msg, books);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="统一异常处理"><a href="#统一异常处理" class="headerlink" title="统一异常处理"></a>统一异常处理</h2><p>提到统一，应该想一想什么机制能够实现所有功能模块中可能出现的异常，这里使用的是 AOP。</p><h3 id="异常种类"><a href="#异常种类" class="headerlink" title="异常种类"></a>异常种类</h3><ul><li>框架内部抛出的异常：使用不合规导致</li><li>数据层抛出的异常：外部服务器故障导致（访问超时，或者 SQL 写的不对）</li><li>业务层抛出的异常：业务逻辑书写错误（遍历时越界）</li><li>表现层抛出的异常：数据收集、校验等规则不合理导致（不匹配的数据类型）</li><li>工具类抛出的异常：工具类书写不够严谨，不够健壮导致（必要释放的连接长期未释放）</li></ul><h3 id="异常处理逻辑"><a href="#异常处理逻辑" class="headerlink" title="异常处理逻辑"></a>异常处理逻辑</h3><p>所有的异常都应该抛到表现层进行处理</p><h3 id="异常处理器"><a href="#异常处理器" class="headerlink" title="异常处理器"></a>异常处理器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProjectExceptionAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">handleException</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;异常&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="number">500</span>, <span class="string">&quot;根据抓住的异常返回的信息&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 REST 风格的异常处理，定义异常处理函数，@ExceptionHandler(Exception.class) 用于指定异常类型，再通过形参传入处理函数。</p><h3 id="项目异常处理方案"><a href="#项目异常处理方案" class="headerlink" title="项目异常处理方案"></a>项目异常处理方案</h3><p>先对异常进行分类，针对不同的异常提供不同的解决方案。</p><ul><li>业务异常<ul><li>发送消息给用户，提醒操作规范<ul><li>常见的是类型不匹配的问题</li></ul></li></ul></li><li>系统异常<ul><li>发送固定消息给用户，安抚情绪<ul><li>系统繁忙，请稍后再试</li><li>系统正在维护升级，请稍后再试</li></ul></li><li>发送报告消息给运维，提醒维护</li><li>短信、邮件、或者通讯软件皆可</li></ul></li><li>其他异常<ul><li>发送固定消息给用户，安抚情绪</li><li>发送消息给开发人员，提醒维护，将异常纳入预期范围<ul><li>一般是写程序的时候考虑不周，未作非空校验等</li></ul></li><li>记录日志</li></ul></li></ul><h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><p>请求的处理流程：浏览器发送一个请求会先到 Tomcat 的 web 服务器，Tomcat 服务器接收到请求之后，会判断请求的是静态资源还是动态资源。如果是静态资源，会直接到 Tomcat 的项目部署目录下去直接访问；如果是动态资源，就组要交给项目后台进行处理。再找到具体方法之前，我们可以去配置过滤器（可以配置多个，按照顺序进行执行），然后进入中央处理器（SpringMVC中的内容），SpringMVC会根据配置的规则进行拦截。如果满足规则。则进行处理，找到其对应的Controller 类中方法进行执行，完成后返回结果；如果不满足规则，则不进行处理。这个时候，如果我们需要在每个 Controller 方法执行的前后添加业务。</p><ul><li>拦截器（Interceptor）是一种动态拦截方法调用的机制，在 SpringMVC 中动态拦截控制方法的执行</li><li>作用：<ul><li>在指定的方法调用前后执行预先设定的代码</li><li>组织原始方法的执行</li><li>总结：拦截器就是用来做增强的</li></ul></li></ul><p>过滤器和拦截器的区别：Filter 提供的工具，Intercepter 是 SpringMVC中的内容。但是可以用来做一些相同的功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义拦截器类，实现 HandlerInterceptor 接口</span></span><br><span class="line"><span class="comment"> * 但是这个类必须受到 Spring 容器的控制，要被 SpringMVC 扫描到（已经放到了 config 包下面）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProjectInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;preHandling&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// true 表示放行， false表示拦截</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;postHandling&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterCompletion&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&#123;&quot;ssm.controller&quot;, &quot;ssm.aop&quot;, &quot;ssm.config&quot;&#125;)</span></span><br><span class="line"><span class="meta">@Import(&#123;ServletContainerInitConfig.class&#125;)</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ProjectInterceptor interceptor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(interceptor).addPathPatterns(<span class="string">&quot;/books&quot;</span>, <span class="string">&quot;/books/*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 WebMvcConfigurer 方式对静态资源放行，省去了 SpringMvcSupport，不良反应未知。</p><h1 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h1><p>在 IDEA 中使用 Spring Initializer 创建 Spring 项目，创建项目的过程中，重点关注 GroupId、ArtifactId和 Version。打包的方式选择 jar，package 的名字需要自己改。</p><p>Server URL 默认为 start.spring.io，在网络状态不好的情况下可以选择 start.aliyun.com，进入工程之后更改 pom.xml 中 SpringBoot 的版本即可。</p><p>依赖：springBoot 的版本选择 2.7.5，添加 Spring Web依赖。</p><p>项目创建完之后，随便写个 Controller 就能在浏览器中访问，开发过程比 Spring MVC 简单的不是一点半点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringbootApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(SpringbootApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写 Controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/books&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getBook</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello SpringBoot&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;module: getBook&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 SpringbootApplication，看到控制台中输出 Spring 即启动成功，需要注意的是，SpringBootApplication必须在最外层的包中。</p><p><strong>手动创建 SpringBoot 的包</strong> </p><p>首先是 Maven 项目基础，加上git init，未必要使用 git 这个版本控制工具，但是需要它为版本控制提供一些基础。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><p>依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-Maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>依赖分析</strong> </p><p>spring-boot-starter-parent：启动时继承的父工程，继承于spring-boot-dependencies工程，其中导入了一些依赖并且定义了它们的版本。</p><p>spring-boot-starter-web：其中引入了springframework、spring-webmvc、tomcat服务器等依赖，由于Maven 项目之间依赖传递的原因，当前项目能够使用相关依赖。</p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><h3 id="配置文件分类"><a href="#配置文件分类" class="headerlink" title="配置文件分类"></a>配置文件分类</h3><ol><li>application.properties</li><li>application.yml    替换默认配置</li></ol><p>（默认配置文件名为 application）</p><p>以服务器端口号为例解释两种配置文件的书写格式：</p><p>properties：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">80</span></span><br></pre></td></tr></table></figure><p>yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">port:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>配置文件的优先级：properties &gt; yml &gt; yaml</p><h3 id="YAML-书写格式"><a href="#YAML-书写格式" class="headerlink" title="YAML 书写格式"></a>YAML 书写格式</h3><p>通过文本缩进的方式表明配置的层级关系，与 python 一样用 # 注释一行。</p><p>与 JSON 相似，属性与值之间使用英文冒号和空格分隔，但是不用写花括号。</p><p><font size=3 color=blue>特点：简介、以数据为核心</font> </p><p>不允许使用 Tab 进行缩进（不同的操作系统一个 tab 的长度不一样），但是空格数目不重要，只要求相同层级的属性左对齐。</p><h3 id="YAML-数据格式"><a href="#YAML-数据格式" class="headerlink" title="YAML 数据格式"></a>YAML 数据格式</h3><p>对象（Map）：键值对的集合</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">person:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">zhangsan</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 行内写法</span></span><br><span class="line"><span class="attr">person:</span> &#123;<span class="attr">name:</span> <span class="string">zhangsan</span>&#125;</span><br></pre></td></tr></table></figure><p>数组：一组按次序排列的值</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">address:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Beijing</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Shanghai</span></span><br><span class="line"><span class="attr">address:</span> [<span class="string">Beijing</span>, <span class="string">Shanghai</span>]</span><br></pre></td></tr></table></figure><p>纯量：单个不可再分的值</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">msg1:</span> <span class="string">&#x27;hello \n world!&#x27;</span> <span class="comment"># 单引号忽略转义字符</span></span><br><span class="line"><span class="attr">msg2:</span> <span class="string">&quot;hello \n world!&quot;</span> <span class="comment"># 双引号识别转义字符，输出换行</span></span><br></pre></td></tr></table></figure><p>参数引用：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Lisi</span></span><br><span class="line"><span class="attr">person:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">$&#123;name&#125;</span> <span class="comment"># 与 EL 表达式类似，表示对上面的 name 进行引用</span></span><br></pre></td></tr></table></figure><h3 id="读取-yml-文件内容"><a href="#读取-yml-文件内容" class="headerlink" title="读取 yml 文件内容"></a>读取 yml 文件内容</h3><p>方式：</p><ol><li>@Value 注解注入</li><li>Environment 对象封装（@Autowired 自动装配）</li><li>有针对性的封装数据（@ConfigurationProperties 注解）</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">abc</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对象</span></span><br><span class="line"><span class="attr">person:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">$&#123;name&#125;</span><span class="comment"># abc</span></span><br><span class="line"><span class="attr">age:</span> <span class="number">70</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对象行内写法</span></span><br><span class="line"><span class="attr">person:</span> &#123;<span class="attr">name:</span> <span class="string">$</span>&#123;<span class="string">name</span>&#125;, <span class="attr">age:</span> <span class="number">70</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="attr">person2:</span> </span><br><span class="line"><span class="attr">name:</span> <span class="string">zhangsan</span></span><br><span class="line"><span class="attr">age:</span> <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数组</span></span><br><span class="line"><span class="attr">address:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Beijing</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Shanghai</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数组行内写法</span></span><br><span class="line"><span class="attr">address:</span> [<span class="string">Beijing</span>, <span class="string">Shanghai</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 纯量</span></span><br><span class="line"><span class="attr">msg1:</span> <span class="string">&#x27;hello \n world!&#x27;</span> <span class="comment"># 单引号忽略转义字符</span></span><br><span class="line"><span class="attr">msg2:</span> <span class="string">&quot;hello \n world!&quot;</span> <span class="comment"># 双引号识别转义字符，输出换行</span></span><br></pre></td></tr></table></figure><p>引用 yml 中定义的数据进行注入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;person.name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name2;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;person.age&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将其中所有数据装配到 springframework 包中提供的对象里</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Environment env;</span><br><span class="line">    </span><br><span class="line"><span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        System.out.println(name2);</span><br><span class="line">        System.out.println(age);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello2&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 不能写错</span></span><br><span class="line">        System.out.println(env.getProperty(<span class="string">&quot;person.name&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="@ConfigurationProperties"></a>@ConfigurationProperties</h3><p>指定需要读取的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;person&quot;)</span></span><br><span class="line"><span class="comment">// 1、封装数据模型，封装 yml 文件中的对象</span></span><br><span class="line"><span class="comment">// 2、@Component 将类定义为受 Spring 管理的 Bean</span></span><br><span class="line"><span class="comment">// 3、@ConfigurationProperties 指定加载的数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// getters, setters and toString</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="框架整合"><a href="#框架整合" class="headerlink" title="框架整合"></a>框架整合</h2><h3 id="整合-Junit"><a href="#整合-Junit" class="headerlink" title="整合 Junit"></a>整合 Junit</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 其实并不需要整合，要做的工作在创建 springboot 工程时全都做好了，重点在于 @SpringBootTest 注解的使用和做单元测试的流程</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpringbootApplicationTests</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试流程：</span></span><br><span class="line"><span class="comment">     * 1、注入需要测试的对象</span></span><br><span class="line"><span class="comment">     * 2、执行方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookController controller;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(controller.getBook());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>准备工作：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 导入测试对应的 starter --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit-platform-launcher<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-platform-launcher<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>导入测试对应的 starter</li><li>测试类使用 @SpringBootTest 注解</li><li>使用自动装配的形式注入需要测试的对象</li></ol><blockquote><p>测试类只能在被测试类所在的包下或者它所在包的子包下，解决方法：@SpringBootTest(classes &#x3D;  引导类名称) 或者添加 @ContextConfiguration(classes &#x3D; 引导类.class）。</p><p>在给 Spring 做测试的时候，用了两个注解：@RunWith(SpringJUnit4ClassRunner.class) 和 @ContextConfiguration(SpringConfig.class)，标志被测类在 Spring 容器中。如果没有按照要求放置测试类，就找不到 Spring 容器。</p><p>如果在测试类所在的包及子包下能够找得到添加了 @SpringBootConfiguration 注解的类，或者是 Spring 的配置类就能够正常运行。</p></blockquote><h3 id="整合-MyBatis"><a href="#整合-MyBatis" class="headerlink" title="整合 MyBatis"></a>整合 MyBatis</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/db1?serverTimezone=UTC&amp;useSSL=false&amp;useserverprepstmts=true</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;select * from tb_book where id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Book <span class="title function_">selectBookById</span><span class="params">(Integer id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> BookDao mapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBookDao</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(mapper.selectBookById(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SpringMvc 时还需要获取 SqlSessionFactoryBean，到了 SpringBoot 就什么也不用做了，SpringBoot 已经做了一系列的操作（连接数据库、配置 MyBatis 等）让程序员能够直接执行查询。</p><h3 id="整合-MyBatis-Plus"><a href="#整合-MyBatis-Plus" class="headerlink" title="整合 MyBatis-Plus"></a>整合 MyBatis-Plus</h3><ol><li>添加 Mybatis-Plus 对应的 starter</li><li>数据层接口继承 BaseMapper </li><li>按需引入坐标</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承 BaseMapper 类，指定包装类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUserDao</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(userDao.selectById(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用-MyBatis-Plus-简化开发"><a href="#使用-MyBatis-Plus-简化开发" class="headerlink" title="使用 MyBatis-Plus 简化开发"></a>使用 MyBatis-Plus 简化开发</h4><p>dao 层的接口继承 <code>BaseMapper&lt;Domain&gt;</code> 传入封装类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;Book&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>service 层稍微复杂一点，接口需要继承 <code>IService&lt;Domain&gt;</code> ，接口的实现类需要 implements 接口，还要继承 <code>ServiceImpl&lt;Dao, Domain&gt;</code> 类：</p><p>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;Book&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;BookDao, Book&gt; <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基础的 CRUD 就已经有了，如果需要添加功能，只需要在类中添加函数，函数名需要避开所有 MyBatis-Plus 内置的函数，比如 remove、reate等。</p><h3 id="整合-Druid"><a href="#整合-Druid" class="headerlink" title="整合 Druid"></a>整合 Druid</h3><ol><li>导入坐标</li><li>yml配置</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.15<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果导入的是 druid 而不是 druid-spring-boot-starter，则可以使用下面配置，但是数据库连接归 jdbc 管理。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/db1?serverTimezone=UTC&amp;useSSL=false&amp;useserverprepstmts=true</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br></pre></td></tr></table></figure><p>导入 druid-spring-boot-starter 包之后，使用下面配置将数据库连接交给 Druid 来管理。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">druid:</span></span><br><span class="line">      <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/db1?serverTimezone=UTC&amp;useSSL=false&amp;useserverprepstmts=true</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line"><span class="comment"># 将数据库连接交给 Druid 管理</span></span><br></pre></td></tr></table></figure><p>总结整合第三方技术的通用方式：</p><ol><li>导入第三方技术对应的 starter 包</li><li>根据提供的配置格式，配置非默认值对应的配置项</li></ol><h3 id="整合指南"><a href="#整合指南" class="headerlink" title="整合指南"></a>整合指南</h3><ul><li>Lombok 的使用</li><li>MyBatis-plus 的使用</li><li>分页查询的实现</li></ul><h4 id="使用-Lombok"><a href="#使用-Lombok" class="headerlink" title="使用 Lombok"></a>使用 Lombok</h4><p>导入坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>常用注解为 @Data、@Getter、@Setter、@NoArgsConstructor、@AllArgsConstructor、@ToString</p><table><thead><tr><th>注解</th><th>作用</th></tr></thead><tbody><tr><td>@Data</td><td>提供 getters 和 setters</td></tr><tr><td>@Getter</td><td>只提供 getters</td></tr><tr><td>@Setter</td><td>只提供 setters</td></tr><tr><td>@NoArgsConstructor</td><td>只提供无参构造函数</td></tr><tr><td>@AllArgsConstructor</td><td>只提供包含所有参数的构造函数</td></tr></tbody></table><h4 id="MP-使用指南"><a href="#MP-使用指南" class="headerlink" title="MP 使用指南"></a>MP 使用指南</h4><blockquote><p>需要注意 MyBatis-Plus 默认使用雪花算法填充数据表 id 字段，如果数据库表配置了 id 自增，就需要进行相应的配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">auto</span> <span class="comment"># 数据库表 id 填充策略</span></span><br></pre></td></tr></table></figure></blockquote><p>在默认状态下，我们不知道 MP 在查询中做了什，使用了怎样的 SQL 语句，不利于调试程序，因此，在这里做一些配置，让我们能够在控制台中看到 MP 做了什么：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># MyBatis-plus 配置，配置表的前缀，但是未必所有的表的命名方式都一致</span></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">auto</span> <span class="comment"># 数据库表 id 填充策略</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br></pre></td></tr></table></figure><p>用标准输出方式，将 MP 的日志打印到控制台中。</p><h4 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h4><p>首先在 Controller 或者 Test 中使用 selectPage 方法，使用 IPage 封装分页数据，再将 IPage 对象作为 selectPage 方法的参数执行查询。</p><blockquote><p>但是仅仅如此还不够，必须配置 MyBatis-Plus 分页查询的拦截器，完成配置之后才能实现分页查询。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetUsersByPage</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">IPage</span> <span class="variable">page</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Page</span>(<span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">    userDao.selectPage(page, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置 MyBatisPlus 分页拦截器，配置之后才能开启分页查询</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MPConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 定义拦截器</span></span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        <span class="comment">// 添加具体的拦截器</span></span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>());</span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>补救当前页只有一条数据，删除该条数据之后不跳转页码的问题（不能完全解决）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/&#123;currentPage&#125;/&#123;pageSize&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">getPage</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">int</span> currentPage, <span class="meta">@PathVariable</span> <span class="type">int</span> pageSize)</span> &#123;</span><br><span class="line">    IPage&lt;Book&gt; page = bookService.getPage(currentPage, pageSize);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果当前页码值大于总页码值，那么重新执行查询操作，使用最大页码值作为当前页码值</span></span><br><span class="line">    <span class="keyword">if</span> (currentPage &gt; page.getPages()) &#123;</span><br><span class="line">        page = bookService.getPage((<span class="type">int</span>)page.getPages(), pageSize);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="number">200</span>, <span class="string">&quot;success&quot;</span>, page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h4><p>使用 MyBatis-Plus 提供的查询包装器，QueryWrapper 和 LambdaQueryWrapper。</p><p>查询条件：查询 user 表中 username 字段包含 admin 的所有 user</p><p><code>select * from user where username like &#39;%admin%&#39;;</code> </p><p>常规查询：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">querySelect</span><span class="params">()</span> &#123;</span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;User&gt;();</span><br><span class="line">    <span class="comment">// 但是 name 是自己写的，未必能和数据库表对应上</span></span><br><span class="line">    queryWrapper.like(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line">    userDao.selectList(queryWrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Lambda 表达式查询：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">querySelectLambda</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 如果查询参数是从外面传进来的</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;admin&quot;</span>;</span><br><span class="line">    LambdaQueryWrapper&lt;User&gt; lambdaQueryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    lambdaQueryWrapper.like(username != <span class="literal">null</span>, User::getUsername, username);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据条件查询出所有满足条件的行</span></span><br><span class="line">    userDao.selectList(lambdaQueryWrapper);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 selectList 的基础上增加分页功能</span></span><br><span class="line">    userDao.selectPage(<span class="keyword">new</span> <span class="title class_">Page</span>(<span class="number">1</span>,<span class="number">5</span>), lambdaQueryWrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SSMP-整合"><a href="#SSMP-整合" class="headerlink" title="SSMP 整合"></a>SSMP 整合</h3><h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><p>首先需要在 pom.xml 中导入需要的工具的坐标： mysql-connector-java、druid-spring-boot-starter、mybatis-plus-boot-starter、mybatis-spring-boot-starter、lombok等。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.15<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其次，在 application.yml 中配置运行端口、durid 数据源管理数据库连接、mybatis-plus 范围内配置数据库表前缀名、禁用默认用于设置 id 的雪花算法、让 mybatis-plus 输出日志信息等。</p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">druid:</span></span><br><span class="line">      <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/db1?serverTimezone=UTC&amp;useSSL=false&amp;useserverprepstmts=true</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">      <span class="attr">validation-query:</span> <span class="string">select</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">auto</span></span><br><span class="line">      <span class="attr">table-prefix:</span> <span class="string">tb_</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br></pre></td></tr></table></figure><h4 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h4><p>使用 lombok 提供 Getters、Setters、toString 方法、以及构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Result</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数据层"><a href="#数据层" class="headerlink" title="数据层"></a>数据层</h4><p>使用 mybatis-plus 提供的快速开发模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;Book&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="业务层"><a href="#业务层" class="headerlink" title="业务层"></a>业务层</h4><p>业务层接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;Book&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> IPage&lt;Book&gt; <span class="title function_">getPage</span><span class="params">(Integer currentPage, Integer pageSize)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>业务层实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;BookDao, Book&gt; <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分页查询</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> currentPage 当前页码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pageSize 最大容量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> IPage 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IPage&lt;Book&gt; <span class="title function_">getPage</span><span class="params">(Integer currentPage, Integer pageSize)</span> &#123;</span><br><span class="line">        IPage&lt;Book&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>(currentPage, pageSize);</span><br><span class="line">        bookDao.selectPage(page, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">return</span> page;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="表现层"><a href="#表现层" class="headerlink" title="表现层"></a>表现层</h4><p>标准表现层开发：REST风格的请求和响应、数据封装</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/books&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookService bookService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按照 id 查询图书</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 条件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 查询结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">selectById</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.builder(bookService.getById(id));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询所有图书记录</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 查询结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">selectAllBooks</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.builder(bookService.list());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按 id 删除对应图书记录</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 主键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 查询结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">deleteById</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.builder(bookService.removeById(id));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按照 id 更新或修改图书</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> book 更新后的记录</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 操作是否成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PutMapping</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">editById</span><span class="params">(<span class="meta">@RequestBody</span> Book book)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.builder(bookService.updateById(book));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新增一条图书记录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> book 图书记录的详细信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 操作是否成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">createBook</span><span class="params">(<span class="meta">@RequestBody</span> Book book)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.builder(bookService.save(book));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分页查询，传入页号和页面能容纳的数据条数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> currentPage 当前页号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pageSize    当前页最大容量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 查询结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;currentPage&#125;/&#123;pageSize&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">getByPage</span><span class="params">(<span class="meta">@PathVariable</span> Integer currentPage, <span class="meta">@PathVariable</span> Integer pageSize)</span> &#123;</span><br><span class="line">        IPage&lt;Book&gt; page = bookService.getPage(currentPage, pageSize);</span><br><span class="line">        <span class="keyword">return</span> Result.builder(page.getRecords());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本来想要使用 AOP，但是疯狂报错，感觉原因是：AOP 对 Controller 进行增强，但是还需要通过 Controller 返回，两边返回值类型对应不上就有问题，如果是这样的话，AOP 就非常鸡肋。</p><h3 id="Thymeleaf"><a href="#Thymeleaf" class="headerlink" title="Thymeleaf"></a>Thymeleaf</h3><p>适用于 Web 和 现代服务器端的 Java 模板引擎。</p><p>目标：</p><ul><li>为开发工作流程带来优雅自然的模板 + HTML 可以在浏览器中正确显示，也可以作为静态原型工作，从而可以在开发团队中加强协作；</li><li>拥有适用于 Spring Framework 的模块，兼容大量工具并且能够使程序员插入自己需要的功能，尽管他还不够强大，但他或是一个理想的选择。</li></ul><p><strong>动静分离</strong> ：选用 HTML 作为模板页，是其他模板引擎做不到的，其使用 HTML 通过一些特定的标签代表其含义，并且没有破坏 HTML 结构，即使没有网络、不通过后端渲染也能在浏览器成功打开（与 JSP 作比较），方便对界面的测试和修改。</p><p><strong>开箱即用</strong> ：提供标准和 Spring 标准两种方言，可以直接套用模板实现 JSTL、OGNL表达式效果，避免每天套模板、改 JSTL、改标签的困扰。同时开发人员也可以扩展和自定义 dialect。</p><h4 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="thymeleaf-配置"><a href="#thymeleaf-配置" class="headerlink" title="thymeleaf 配置"></a>thymeleaf 配置</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">thymeleaf:</span></span><br><span class="line"><span class="attr">cache:</span> <span class="literal">false</span> <span class="comment"># 开启会提高网页并发能力但是不利于开发（程序员做的修改不会立即生效）</span></span><br></pre></td></tr></table></figure><blockquote><p> Thymeleaf 使用的还是 MVC 的开发方式（并且前后端不分离），也就是说如果想要使用 Thymeleaf 就一定要使用 View &amp; Model，要使用 Model 就不能用 @RestController 注解，</p></blockquote><p>使用目的仅限于 Java EE 实验，至于语法之类的需要用到的时候去查（因为它不是前后端分离，并且引入前端框架或者写请求就反而不如分离）。</p><h2 id="项目运维"><a href="#项目运维" class="headerlink" title="项目运维"></a>项目运维</h2><p>主要解决项目运行中各种可能出现的问题。不可避免地，又要说到如何将 SpringBoot 的项目打包上传到服务器，并将项目启动起来。</p><h3 id="打包运行"><a href="#打包运行" class="headerlink" title="打包运行"></a>打包运行</h3><ul><li>打包：mvn package</li></ul><p>可以选择性跳过 test 阶段，测试过程中可能会对数据库造成影响（数据上的增删改），避免出现不必要的麻烦，可以在 Maven 工具栏中，展开 Lifecycle 将 test 阶段跳过。</p><ul><li>运行</li></ul><p>因操作系统不同，分成不同的两种情况：</p><ul><li>Windows 下，打开 cmd 输入 java -jar xxx.jar 即可启动项目</li><li>Linux 下，将包上传到 &#x2F;usr&#x2F;local&#x2F;app 目录下，输入跟上面相同的命令将项目启动起来</li></ul><blockquote><p>需要注意的是，SpringBoot 项目打成的 jar 包想要启动必须依赖于 Maven 插件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>插件的功能是：设定启动类、引导类、将项目依赖打包</p></blockquote><p>当项目启动时遇到端口占用的时候，因操作系统不同，处理方式也不同。</p><ul><li>Windows</li></ul><p>查看端口：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">netstat <span class="literal">-ano</span> | findstr <span class="string">&quot;端口号&quot;</span></span><br><span class="line"></span><br><span class="line">tasklist | findstr <span class="string">&quot;80&quot;</span></span><br></pre></td></tr></table></figure><p>杀进程：<code>taskkill -f -pid &quot;进程id&quot;</code> </p><ul><li>Linux</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">查看端口：</span><br><span class="line">netstat -tunlp | grep 端口号</span><br><span class="line"></span><br><span class="line">杀掉进程：</span><br><span class="line">kill -9 进程号</span><br></pre></td></tr></table></figure><p>服务器上后台启动进程：<code>nohup java -jar xxx.jar &gt; server.log 2&gt;&amp;1 &amp;</code> </p><p>将日志记录到 server.log 文件中</p><p>查找 java -jar启动的进程：<code>ps -ef | grep &quot;java -jar&quot;</code> </p><h3 id="配置高级"><a href="#配置高级" class="headerlink" title="配置高级"></a>配置高级</h3><p>启动项目时，可以通过命令行来更改项目的配置。</p><p>格式：<code>java -jar xxx.jar --server.port=8080</code> </p><p>不同的参数之间用空格做分隔。</p><p>配置的优先级：命令行参数 &gt; 配置文件</p><h4 id="开发环境中的临时属性"><a href="#开发环境中的临时属性" class="headerlink" title="开发环境中的临时属性"></a>开发环境中的临时属性</h4><p>IDEA 右上角运行配置 Edit Configurations，在 Program arguments 中填入需要更改的参数。格式与 .properties 文件书写格式相同。</p><p>启动 Boot 程序时断开读取外部临时配置的入口，即删除读取外部配置的形参（main函数中的 args）</p><p>默认情况下，Boot 程序引导类主函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    SpringApplication.run(SsmpApplication.class, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>断开外部临时配置入口之后（原因是临时配置风险比较高）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 断开外部临时配置读取入口。</span></span><br><span class="line">    SpringApplication.run(SsmpApplication.class);</span><br><span class="line"><span class="comment">// SpringApplication.run(SsmpApplication.class, args);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>启动 SpringBoot 程序时，可以选择是否使用命令行属性为程序传递启动属性（临时配置）</strong> </p><p>配置文件的分类：</p><ul><li>项目类路径下的配置文件：服务于开发和测试人员</li><li>项目类路径下 config 目录下配置文件：服务于项目管理人员</li><li>工程路径配置文件：服务于运维人员</li><li>工程路径 config 目录下配置文件：服务于运维管理人员</li></ul><p><font size=5 color=red>多层级配置文件间属性采用叠加并覆盖的形式作用于程序</font> </p><h4 id="自定义配置文件"><a href="#自定义配置文件" class="headerlink" title="自定义配置文件"></a>自定义配置文件</h4><ol><li>在项目运行配置中指定配置文件名：Program Arguments 栏中输入 <code>--spring.config.name=ebank</code> </li><li>在项目运行配置中指定配置文件路径：Program Arguments 栏中输入</li></ol><p><code>--spring.config.location=配置文件全路径</code> （支持classpath）</p><ol start="3"><li>基于微服务开发时由配置中心下发配置</li></ol><h4 id="多环境开发"><a href="#多环境开发" class="headerlink" title="多环境开发"></a>多环境开发</h4><p>使用三个减号即可分割不同的配置，最上面一般写所有环境中公共的部分，比如 mybatis-plus 日志输出格式和表的前缀名等。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">druid:</span></span><br><span class="line">      <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/db1?serverTimezone=UTC&amp;useSSL=false&amp;useserverprepstmts=true</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">      <span class="attr">validation-query:</span> <span class="string">select</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">auto</span></span><br><span class="line">      <span class="attr">table-prefix:</span> <span class="string">tb_</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="attr">activate:</span></span><br><span class="line">      <span class="attr">on-profile:</span> <span class="string">product</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="attr">activate:</span></span><br><span class="line">      <span class="attr">on-profile:</span> <span class="string">dev</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="attr">activate:</span></span><br><span class="line">      <span class="attr">on-profile:</span> <span class="string">test</span></span><br></pre></td></tr></table></figure><p>或可用于解决项目组内成员的环境不统一的问题（但是会暴露项目组中所有成员的数据库密码）。</p><h5 id="多环境多文件配置"><a href="#多环境多文件配置" class="headerlink" title="多环境多文件配置"></a>多环境多文件配置</h5><p>将 application.yml 中的内容拆成四份：生产、开发、测试以及最终使用的版本。</p><p>在 yml 中使用 include 属性在激活环境的情况下，同时对多个环境进行加载使其生效，多个环境之间使用逗号分隔。</p><p>SpringBoot 2.4 之后，使用环境组代替 include 属性：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">  <span class="attr">active:</span> <span class="string">dev</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">devDB,</span> <span class="string">devMVC</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">  <span class="attr">active:</span> </span><br><span class="line">    <span class="attr">group:</span></span><br><span class="line">      <span class="attr">&quot;dev&quot;:</span> <span class="string">devDB,</span> <span class="string">devMVC</span></span><br><span class="line">      <span class="attr">&quot;pro&quot;:</span> <span class="string">proDB,</span> <span class="string">proMVC</span></span><br><span class="line">      <span class="attr">&quot;test&quot;:</span> <span class="string">testDB,</span> <span class="string">testMVC</span></span><br></pre></td></tr></table></figure><p>配置优先级：主配置文件更高，从配置文件最后一个加载的生效。</p><h5 id="多环境开发控制"><a href="#多环境开发控制" class="headerlink" title="多环境开发控制"></a>多环境开发控制</h5><p>Maven 本身有一套自己的依赖配置，springboot 可以有自己的配置但是必须依赖于 Maven 运行所以如果两边有冲突则以 Maven 的配置为主。</p><p>Maven 配置环境：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>env_dev<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile.active</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">profile.active</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>env_pro<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">profile.active</span>&gt;</span>pro<span class="tag">&lt;/<span class="name">profile.active</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure><p>yml 中读取 Maven 启用的设置：spring.profiles.active: @profile.active@</p><blockquote><p>或许需要用到手动执行 mvn compile 以解决 IDEA 缓存环境（更改 activeByDefault 属性值之后不生效的问题）。</p></blockquote><h4 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h4><h5 id="日志基础"><a href="#日志基础" class="headerlink" title="日志基础"></a>日志基础</h5><ul><li>辅助调试</li><li>记录运行过程<ul><li>峰值流量、平均响应时长等</li><li>报错信息（StackTrace）</li><li>记录运维过程（扩容、宕机等）</li></ul></li></ul><p>这里使用通用日志“组件”为 slf4j，导入依赖之后，可以创建一个 Logger 对象，用它来输出一些信息。</p><p>日志等级：Debug、Info、Warn、Error。</p><p>要想输出 Debug 层面的信息则需要在 yml 中写：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出调试信息，常用于检查系统运行情况</span></span><br><span class="line"><span class="attr">debug:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置日志级别，root 表示根节点，即整体日志级别</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="comment"># 设置分组，规定分组使用什么样的日志级别</span></span><br><span class="line">  <span class="attr">group:</span></span><br><span class="line">    <span class="attr">ebank:</span> <span class="string">cn.mao.controller,</span> <span class="string">cn.mao.dao,</span> <span class="string">cn.mao.service</span></span><br><span class="line">    <span class="attr">alibaba:</span> <span class="string">com.alibaba</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">root:</span> <span class="string">debug</span></span><br><span class="line">    <span class="comment"># 设置某个包的日志级别</span></span><br><span class="line">    <span class="comment"># cn.mao.controller: info</span></span><br><span class="line">    <span class="attr">ebank:</span> <span class="string">info</span></span><br></pre></td></tr></table></figure><p>这里说明 @Slf4j 实际上是 Lombok 提供的，添加注解之后为类快速添加日志对象。</p><h5 id="日志输出格式控制"><a href="#日志输出格式控制" class="headerlink" title="日志输出格式控制"></a>日志输出格式控制</h5><p>日志格式可以改但是不怎么建议改，所以有需要百度。</p><h5 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h5><p>日志文件配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">file:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">server.log</span></span><br><span class="line">  <span class="attr">logback:</span></span><br><span class="line">    <span class="attr">rollingpolicy:</span></span><br><span class="line">      <span class="attr">max-file-size:</span> <span class="string">4MB</span></span><br><span class="line">      <span class="attr">file-name-pattern:</span> <span class="string">server.%d&#123;yyyy-MM-dd&#125;.%i.log</span></span><br></pre></td></tr></table></figure><h2 id="开发实用"><a href="#开发实用" class="headerlink" title="开发实用"></a>开发实用</h2><h3 id="热部署"><a href="#热部署" class="headerlink" title="热部署"></a>热部署</h3><h4 id="自动热部署"><a href="#自动热部署" class="headerlink" title="自动热部署"></a>自动热部署</h4><p>要想启动自动热部署首先需要导入 spring-boot-devtools 依赖，optional 属性设置为 true。这样之后还需要在更改程序之后手动重新 build project，这样还不能算是自动热部署。</p><p>自动热部署需要在 Settings -&gt; Build, Exxcution, Deployment-&gt; compiler -&gt; Build project automatically；</p><p>Advanced Settings -&gt; Allow auto-make to start even if developed application is currently running。</p><p>如此之后，IDEA 会在程序更改并失去焦点之后的 5 秒后重新构建项目。</p><h4 id="热部署范围配置"><a href="#热部署范围配置" class="headerlink" title="热部署范围配置"></a>热部署范围配置</h4><p>默认不会触发热部署的目录：</p><p>&#x2F;META-INF&#x2F;maven、&#x2F;META-INF&#x2F;resources、&#x2F;resources、&#x2F;static、&#x2F;public、&#x2F;templates</p><p>如何将某个目录或者文件排除到热部署范围之外：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">devtools:</span></span><br><span class="line">  <span class="attr">restart:</span> </span><br><span class="line">    <span class="comment"># 设置不参与热部署的文件夹或文件</span></span><br><span class="line">    <span class="attr">exclude:</span> <span class="string">static/**,</span> <span class="string">public/**,</span> <span class="string">config/aplication.yml</span></span><br></pre></td></tr></table></figure><h4 id="关闭热部署"><a href="#关闭热部署" class="headerlink" title="关闭热部署"></a>关闭热部署</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">devtools:</span></span><br><span class="line">    <span class="attr">restart:</span> </span><br><span class="line">      <span class="comment"># 关闭热部署，但是无法保障当前配置文件优先被使用</span></span><br><span class="line">      <span class="attr">enable:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>用设置系统参数的方式将热部署关掉：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SsmpApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 下面语句即可代替上面 yml 代码并且优先级足够覆盖所有配置文件</span></span><br><span class="line">        System.setProperty(<span class="string">&quot;spring.devtools.restart.enabled&quot;</span>, <span class="string">&quot;false&quot;</span>);</span><br><span class="line">        SpringApplication.run(SsmpApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Bean-属性绑定"><a href="#Bean-属性绑定" class="headerlink" title="Bean 属性绑定"></a>Bean 属性绑定</h3><p>先介绍两个注解 @EnableConfigurationProperties 和 @ConfigurationProperties 前者接收一个或多个 .class 文件，使这些文件能够使用配置文件中的值完成 Bean注入，并将相应的 Bean 放到 Spring Bean Factory 中；</p><p>@ConfigurationProperties 注解只能使类能够使用配置文件但是不会将 Bean 放进 Factory 中，需要手动使用 @Bean 或者 @Component 注解将 Bean 放进去。支持松散绑定（烤肉串模式），能够绑定到驼峰模式、下划线模式、中划线模式以及常量模式（变量名中字母全部大写）。现在的 @Value 注解也支持了松散绑定（宽松绑定）。</p><p>为了避免在绑定时出现问题，一般来说 @ConfigurationProperties(prefix &#x3D; “xxx”)，prefix 最好全部小写（前缀命名规范：仅能使用小写字母、下划线、数字作为合法的字符）。</p><h3 id="常用计量单位"><a href="#常用计量单位" class="headerlink" title="常用计量单位"></a>常用计量单位</h3><p>空间大小单位一般使用大写：B、KB、MB、GB、TB。</p><p>时间设置方式：JDK 8 提供了一套表示时间的类型：Duration 单位一般是 ms 与 long 表示事件的时候相同。可以用 @DurationUnit(ChronoUnit.HOURS) 设置时间单位。</p><p>空间单位设置方式（数据大小）：</p><p>JDK 8 提供的表示数据大小的类型：DataSize</p><p>@DataSizeUnit(DataUnit.MEGABYTES)，设置单位为 MB。</p><h3 id="数据校验"><a href="#数据校验" class="headerlink" title="数据校验"></a>数据校验</h3><p>数据校验 JSR303 标准，导入validation-api，groupId 为 Javax.validation，目前版本为 2.0.1 final pom.xml 中可以不写版本号。</p><p>除了上面说的 JSR303 规范以外，还需要提供校验框架作为校验器实现类。导入 hibernate-validator，groupId 为 org.hibernate.vaildator，版本号同样不写。</p><p>数据库密码如果全为数字以 0 开头并且下一位是 1-7 中的数，密码将被识别为八进制的数，连接数据库的时候就会报错，密码的值设置为字符串即可解决。</p><p>常用的注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Max</span></span><br><span class="line"><span class="meta">@Min</span></span><br><span class="line"><span class="meta">@Email</span></span><br><span class="line"><span class="meta">@NotNull</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br></pre></td></tr></table></figure><h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
            <tag> Java Web </tag>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
            <tag> SSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Web</title>
      <link href="/2022/11/11/Java-Web/"/>
      <url>/2022/11/11/Java-Web/</url>
      
        <content type="html"><![CDATA[<h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>简单来说，顺序执行一条以上语句才能完成的一个过程即可称为事件。</p><p>转账：</p><p>id 为 1 的银行用户给 id 为 2 的用户转账 500 块</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> account <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">-</span> <span class="number">500</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">update</span> account <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">-</span> <span class="number">500</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>MySQL 中的事件定义：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> EXENT E1 </span><br><span class="line"></span><br><span class="line"><span class="keyword">ON</span> SCHEDULE <span class="keyword">EVERY</span> <span class="number">9</span> <span class="keyword">DAY</span> STARTS NOW()</span><br><span class="line"><span class="keyword">ON</span> COMPLETION PRESERVE ENABLE</span><br><span class="line">DO</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">CALL</span> TOTAL();</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><p>在MySQL中，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="comment">----查询操作</span></span><br><span class="line"><span class="comment">----没有错误即可commit，有错误需要ROLLBACK</span></span><br></pre></td></tr></table></figure><h2 id="使用JDBC操作MySQL"><a href="#使用JDBC操作MySQL" class="headerlink" title="使用JDBC操作MySQL"></a>使用JDBC操作MySQL</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.JDBC是使用Java操作关系型数据库的一套API</span></span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.获取连接对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/db1?useSSL=false&amp;serverTimezone=UTC&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;1234&quot;</span>;</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> Drivermanager.getConnection(url, username, password);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.定义 SQL 对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update account set money = 2000 where id = 1&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.获取 SQL 执行对象</span></span><br><span class="line"><span class="type">Statement</span> <span class="variable">state</span> <span class="operator">=</span> conn.CreateStatement();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.执行 SQL</span></span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> state.executeQuery();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.处理结果</span></span><br><span class="line"><span class="comment">// System.out.println(count);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 7.释放资源</span></span><br><span class="line">state.close();</span><br><span class="line">conn.close();</span><br></pre></td></tr></table></figure><h3 id="操作流程："><a href="#操作流程：" class="headerlink" title="操作流程："></a>操作流程：</h3><ol><li>注册驱动：<code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</code> </li><li>获取连接对象：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc.mysql://localhost:3306/db1?useSSl=false&amp;serverTimezone=Asia/shanghai&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">pwd</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, username, pwd);</span><br></pre></td></tr></table></figure><ol start="3"><li>定义 SQL 对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from student&quot;</span>;</span><br><span class="line"><span class="type">Statement</span> <span class="variable">state</span> <span class="operator">=</span> conn.createStatememt();</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> state.executeQuery(sql);<span class="comment">// 执行 SQL</span></span><br></pre></td></tr></table></figure><ol start="4"><li>关闭连接</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">state.close();</span><br><span class="line">conn.close();</span><br></pre></td></tr></table></figure><p>执行语句，返回受影响的行数。</p><h2 id="JDBC-API详解"><a href="#JDBC-API详解" class="headerlink" title="JDBC API详解"></a>JDBC API详解</h2><h3 id="DriverManager"><a href="#DriverManager" class="headerlink" title="DriverManager"></a>DriverManager</h3><ul><li>注册驱动</li><li>获取连接</li></ul><p>URL 的组成：</p><p><code>jdbc.mysql://localhost:3306/db1?键值1&amp;键值2;</code></p><p>添加 useSSL&#x3D;false 之后就不会再有SSL警告</p><h3 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h3><ol><li>获取执行 SQL 的对象</li></ol><ul><li>普通执行 SQL 对象</li></ul><p>Statement createStatement(sql);</p><ul><li>预编译 SQL 的执行 SQL 对象：防止 SQL 注入</li></ul><p>PreparedStatement preparedStatement(sql);</p><ul><li>执行存储过程的对象</li></ul><p>CallableStatemrnt prepareCall(sql);</p><ol start="2"><li>事务管理</li></ol><ul><li>MySQL 事务管理</li></ul><blockquote><p>开启事务：BEGIN; &#x2F; START TRANSACETION;</p><p>提交事务：COMMIT</p><p>回滚事务：ROLLBACK</p><p>MySQL 默认自动提交事务</p></blockquote><ul><li>JDBC 事务管理：Connection接口中定义了三个对应的方法</li></ul><blockquote><p>开启事务：setAutoCommit(boolean autoCommit); true为自动提交事务，false为手动提交十五，即为开启事务</p><p>提交事务：commit();</p><p>回滚事务：rollback();</p></blockquote><p>希望用十五处理 SQL 时，需要在 SQL执行前开启事务来时 SQL 同时生效或无效。</p><p>JDBC 开启事务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 开启事务</span></span><br><span class="line">    conn.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 执行 SQL</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count1</span> <span class="operator">=</span> state.executeQuery(sql1);</span><br><span class="line">    <span class="comment">// 处理返回结果</span></span><br><span class="line">    System.out.println(count1);</span><br><span class="line">    <span class="comment">// 执行 SQL</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count2</span> <span class="operator">=</span> state.executeQuery(sql2);</span><br><span class="line">    System.out.println(count2);</span><br><span class="line">    <span class="comment">// 提交事务，如果前面没有发生异常，则可以正常提交</span></span><br><span class="line">    conn.commit();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 回滚</span></span><br><span class="line">    conn.rollback();</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主函数 throws Exception，try 块中填入可能出现的异常，捕捉 Exception 类型的异常</p><h3 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h3><p>作用：执行 SQL</p><ul><li>执行 SQL</li></ul><p>int executeUpdate(sql); &#x2F;&#x2F; 执行DML、DDL语句</p><p>返回值：DML语句影响的行数、DDL语句执行后，执行成功也会返回 0</p><ul><li>执行 DML 时，如果受影响的行数大于0，则 DML 语句执行成功</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;执行成功&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.prinln(<span class="string">&quot;执行失败&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行 DDL 时，则不能通过返回值判断语句的执行情况。</p><h4 id="ResultSet（结果集）"><a href="#ResultSet（结果集）" class="headerlink" title="ResultSet（结果集）"></a>ResultSet（结果集）</h4><ul><li>封装了DQL查询语句的结果</li></ul><p>ResultSet state.executeQuery(sql);&#x2F;&#x2F; 执行 DQL 语句，返回ResultSet 对象</p><ul><li>获取查询结果获取查询结果</li></ul><p>boolean next();</p><blockquote><ol><li>将游标从当前位置向前移一行</li><li>判断当前行是否为有效行</li></ol><p>返回值：</p><ul><li>true：有效行，当前行有数据</li><li>false：无效行，当前行没有数据</li></ul></blockquote><p>xxx getXxx(参数) 获取数据</p><blockquote><p>xxx：数据类型</p><p>参数：</p><ul><li>int：列编号（从1开始）</li><li>String：字段名</li></ul></blockquote><p>游标：默认指向数据表的表头，取数据的时候要先向下读取一行，判断其是否是数据不为空。</p><p>取数据操作的代码结构：</p><ol><li>游标下移一行，并判断该行数据是否为空</li><li>获取下一行的数据：get数据类型（parameter）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 SQL</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from account&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行 SQL，获取执行 SQL 的对象</span></span><br><span class="line"><span class="type">Statement</span> <span class="variable">state</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行 SQL</span></span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">res</span> <span class="operator">=</span> state.executeQuery(sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取数据</span></span><br><span class="line"><span class="keyword">while</span> (res.next()) &#123;</span><br><span class="line">    <span class="type">int</span> num - res.getInt(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放资源</span></span><br><span class="line">res.close();</span><br><span class="line">state.close();</span><br><span class="line">conn.close();</span><br></pre></td></tr></table></figure><p>parameter：可以是字段名，可以是列号</p><p>System.out.println(list);&#x2F;&#x2F; 隐式调用 list 成员方法 toString()</p><h4 id="PreparedStatement"><a href="#PreparedStatement" class="headerlink" title="PreparedStatement"></a>PreparedStatement</h4><p>作用：防止 SQL 注入</p><ul><li>获取 PreparedStatement 对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SQL 语句中的参数值，使用 ？ 占位符代替条件参数</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from user where username = ? and password = ?&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 Connection 对象获取，并传入对应的 SQL 语句</span></span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.preparedStatement(sql);</span><br></pre></td></tr></table></figure><ul><li>设置参数值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PreparedStatement对象：setXxx(参数<span class="number">1</span>， 参数<span class="number">2</span>);<span class="comment">// 给 ？ 赋值</span></span><br><span class="line">Xxx：数据类型</span><br><span class="line">参数：</span><br><span class="line">    参部<span class="number">1</span>：？的位置编号，从<span class="number">1</span>开始</span><br><span class="line">    参数<span class="number">2</span>：？的值</span><br></pre></td></tr></table></figure><ul><li>执行 SQL</li></ul><p><code>executeUpdate(); 或 executeQuery(); 不需要再传递 SQL 语句</code> </p><ul><li>使用占位符代替条件参数</li><li>传入参数并执行 SQL</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from account where username = ? and password = ? &quot;</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> conn.preparedStatement(sql);</span><br><span class="line">ps.setString(<span class="number">1</span>, name);</span><br><span class="line">ps.setStruing(<span class="number">2</span>, pwd);</span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">res</span> <span class="operator">=</span> ps.executeQuery();<span class="comment">// 无参</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收数据的语句相同</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放资源</span></span><br><span class="line">res.close();</span><br><span class="line">ps.close();</span><br><span class="line">conn.close();</span><br></pre></td></tr></table></figure><p>使用 PreparedStatement 之后，name 和 pwd 中的 ‘ 或被替换成转义字符 ‘\‘’</p><p>原理：</p><ol><li>预编译 SQL 语句</li><li>将敏感字符转义，防止 SQL 注入</li></ol><p>要想使用求预编译功能，需要在创建数据库连接的时候添加 &amp;useServerPrepStmts&#x3D;true。</p><h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><ol><li>连接池是一个容器，负责分配、管理数据库连接</li><li>允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个新的连接</li><li>释放空闲时间超过最大空闲时间的数据库连接以避免因未释放数据库连接而引起的数据库连接遗漏</li></ol><p>优点：</p><ul><li>资源服用</li><li>提升系统响应速度</li><li>避免数据库连接遗漏</li></ul><p>实现：</p><ul><li>标准接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">官方提供的数据库连接池标准接口，由第三方实现此接口</span><br><span class="line">功能：获取链接</span><br><span class="line">Connection <span class="title function_">getConnection</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><ul><li>常见的数据库连接池</li></ul><p>DBCP、C3P0、Druid等</p><ul><li>德鲁伊连接池</li></ul><p>阿里开源的数据库连接池项目，功能强大，性能优秀，是Java语言最好的数据库连接池之一。</p><p>德鲁伊数据库连接池的使用</p><ol><li>导入druid.jar包</li><li>定义配置文件并加载</li><li>获取连接池 obj</li><li>获取连接</li></ol><p><code>System.out.println(System.getProperties(&quot;user.dir&quot;);// 输出工作区文件路径</code> </p><p>druid.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">driverClassName</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql:///db1?useSSL=false&amp;serverTimezone=UTC</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">123456</span></span><br><span class="line"><span class="comment"># 初始化连接数量</span></span><br><span class="line"><span class="attr">initialSize</span>=<span class="string">5</span></span><br><span class="line"><span class="comment"># 最大连接数</span></span><br><span class="line"><span class="attr">maxActive</span>=<span class="string">10</span></span><br><span class="line"><span class="comment"># 最大等待时间</span></span><br><span class="line"><span class="attr">maxWait</span>=<span class="string">3000</span></span><br></pre></td></tr></table></figure><p>DruidDemo.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载配置文件</span></span><br><span class="line"><span class="type">Properties</span> <span class="variable">prop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">prop.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src/druid.properties&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取数据库连接池对象</span></span><br><span class="line"><span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> DruidDataSourceFactory.createDataSorce(prop);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取数据库连接 Connection</span></span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> dataSource.getConnction();</span><br></pre></td></tr></table></figure><p><font size=5 color=red>auto_increment</font> 自增</p><p>使用Alt + 鼠标左键在IDEA快速创建数据表的实体类。</p><p>推荐使用 Integer类型 而不是 int类型（默认为0），对业务可能有影响</p><p>在实体类中，基本数据类型建议使用其对应的包装类型。</p><p>这一小段的内容与前面的区别只在是否封装对象并保存到容器中。</p><p> JDBC操作：连接、查询、接收、释放</p><blockquote><p> 关于异常处理的一点心得：如果不捕捉的异常需要将其抛出。</p></blockquote><p>数据表中需要注意的是，主码不能由用户输入。</p><h1 id="Maven-基础"><a href="#Maven-基础" class="headerlink" title="Maven 基础"></a>Maven 基础</h1><ol><li>标准化：项目结构、构建流程（编译、测试、打包、发布）</li><li>依赖管理机制</li></ol><p>当项目中使用坐标引入jar包之后，Maven首先在 本地仓库中查找相应的包，有责引用之，疯狗则将从中央仓库下载到本地仓库并引入（如果没有配置阿里仓库）。</p><h2 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h2><p>因为IDEA自带Maven，所以只需要配置阿里私服</p><p>在 config&#x2F;settings.xml 文件中的 <mirrors>标签下，为其添加如下标签：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>url<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 需要从网上找这个链接 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><ul><li>常用命令</li><li>生命周期</li></ul><ol><li>常用命令</li></ol><p>编译、打包、清理、测试、安装。</p><ol start="2"><li>生命周期</li></ol><p>Maven岁项目构建的生命周期的划分</p><ul><li>clean：清理工作</li><li>default：核心工作（编译、测试、打包、安装等）</li><li>site：产生报告，发布站点等</li></ul><p>在IDEA中使用Maven</p><p>Files -&gt; settings 搜索maven，更改maven相关路径和配置文件</p><h3 id="坐标"><a href="#坐标" class="headerlink" title="坐标"></a>坐标</h3><ul><li>资源的唯一标识</li><li>使用坐标来定义项目或项目中需要的依赖</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>组成：</p><ul><li>groupId：项目所属的组织名称</li><li>artifactId：当前项目名称（通常为模块名称）</li><li>version：模块版本号</li></ul><p>创建 Maven 项目</p><p>Maven -&gt; next -&gt; name project -&gt; finish -&gt; apply -&gt; ok.</p><p>导入 Maven 项目</p><p>加强根目录放到当前工作区文件夹下，点击右侧边栏 Maven，添加 Maven 项目。</p><p>view -&gt; appearance -&gt; Tool window bars 即可将边栏调出。</p><p>导入 Maven web项目：点击add maven项目之后，双击项目的 pom.xml 文件。</p><p>插件推荐</p><p>Maven Helper</p><p>Settings -&gt; Plugins -&gt; search for Maven -&gt; install first listed plugin.</p><p>依赖管理：</p><p>在 properties 标签后面添加 dependencies 标签，如果需要导入jar包则需要在其下添加dependency标签。</p><p>浏览器中输入：包名 + maven 即可搜素到需要的依赖的版本信息。</p><p>添加、删除以来都需要刷新，快速添加模板：alt + insert 选中 dependencies 搜索 + enter</p><h2 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h2><p>通过设置坐标的依赖范围（scope），可以设置对应 jar 包的作用范围：编译环境、测试环境、运行环境。</p><table><thead><tr><th align="center">依赖范围</th><th align="center">编译classpath</th><th align="center">测试classpath</th><th align="center">运行classpath</th><th align="center">例子</th></tr></thead><tbody><tr><td align="center">compile</td><td align="center">Y</td><td align="center">Y</td><td align="center">Y</td><td align="center">logback</td></tr><tr><td align="center">test</td><td align="center">-</td><td align="center">Y</td><td align="center">-</td><td align="center">JUnit</td></tr><tr><td align="center">provided</td><td align="center">Y</td><td align="center">Y</td><td align="center">-</td><td align="center">serlet-api</td></tr><tr><td align="center">runtime</td><td align="center">-</td><td align="center">Y</td><td align="center">Y</td><td align="center">JDBC</td></tr><tr><td align="center">system</td><td align="center">Y</td><td align="center">Y</td><td align="center">-</td><td align="center">存储在本地的 jar包</td></tr><tr><td align="center">import</td><td align="center">引入 DependencyManagement</td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><p><scope> 的默认值为 compile。</p><h1 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h1><p>优秀的持久层框架，用于简化 JDBC 开发</p><p>持久层</p><p>负责将数据保存到数据库的那一层代码。</p><p>Java EE 的三层架构：</p><ul><li>表现层</li><li>业务层</li><li>持久层</li></ul><p>框架：</p><p>半成品软件，一套可复用的、通用的、软件基础代码模型。在框架的基础上构建软件，代码编写更加高效、规范、通用、可扩展。</p><p>JDBC的缺点</p><ol><li>硬编码</li></ol><p>使用JDBC的时候用了很多字符串，比如URL、username、pwd、sql等。</p><ol start="2"><li>操作频繁</li></ol><p>更改URL、sql语句，手动设置Statement的参数，手动封装查询结果。</p><p>Mybatis 提供的解决方案</p><ol><li>将url等写入配置文件</li></ol><h2 id="mybatis-config-xml"><a href="#mybatis-config-xml" class="headerlink" title="mybatis-config.xml"></a>mybatis-config.xml</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span> </span></span><br><span class="line"><span class="meta"><span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Copnfig 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta"><span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 连接池信息 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:/mysql://db1?useSSL=false&amp;serverTimezone=UTC&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1234&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 加载 SQL 的映射文件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;UserMapper.xml&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>将 SQL 语句提取到配置文件</li></ol><p>另外，使用：</p><p><code>List&lt;T&gt; t = sqlSelection.selectList(Statement, parameter);</code> </p><p>实现简化手动设置参数并封装结果集。</p><p>Mybatis 免除了几乎所有的JDBC代码以及设置参数和获取结果集的工作。</p><h2 id="Mybatis-XML-文件提示"><a href="#Mybatis-XML-文件提示" class="headerlink" title="Mybatis XML 文件提示"></a>Mybatis XML 文件提示</h2><p>在 Settings 中找到 <strong>Language &amp; Frameworks</strong> 下 Schemas and DTDs，在右上角空白处添加：</p><ol><li><a href="http://mybatis.org/dtd/mybatis-3-config.dtd">http://mybatis.org/dtd/mybatis-3-config.dtd</a> - C:&#x2F;Coding_tools&#x2F;Code&#x2F;Java&#x2F;Idea&#x2F;Mybatis&#x2F;mybatis-3-config.dtd</li><li><a href="http://mybatis.org/dtd/mybatis-3-mapper.dtd">http://mybatis.org/dtd/mybatis-3-mapper.dtd</a> - C:&#x2F;Coding_tools&#x2F;Code&#x2F;Java&#x2F;Idea&#x2F;Mybatis&#x2F;mybatis-3-mapper.dtd</li></ol><h2 id="Mybatis-快速入门"><a href="#Mybatis-快速入门" class="headerlink" title="Mybatis 快速入门"></a>Mybatis 快速入门</h2><p>创建Maven项目</p><p>​dependency的写法可以百度或者到Mybatis官网查询。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>导入JDBC、JUnit、logBack</p><p>mybatis-config.xml</p><p>就是上面写的配置文件</p><p>&#x3D;&#x3D;SQL 映射文件命名方式：XxxMapper.xml（遵循大驼峰命名方式，Xxx表示User或者其他实体）&#x3D;&#x3D; </p><p>&#x3D;&#x3D;按照增删改查四类划分名称空间，将与艰苦按照类别归纳到mapper的名称空间中。&#x3D;&#x3D; </p><p>id：一条SQL语句的唯一标识</p><p>resultType：SQL语句返回类型</p><p>&#x3D;&#x3D;mybatis配置文件中需要早mappers标签下写入SQL映射文件的路径。&#x3D;&#x3D; </p><h2 id="Mybatis-使用"><a href="#Mybatis-使用" class="headerlink" title="Mybatis 使用"></a>Mybatis 使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 1、 加载mybatis的核心配置文件，获取SqlSessionFactory</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">    <span class="type">InputStram</span> <span class="variable">in</span> <span class="operator">=</span> Resource.getResourceAsStream(resource);</span><br><span class="line">    <span class="type">SqlSessionFactory</span> <span class="variable">ssf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(in);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2、获取SqlSession对象，用其执行SQL</span></span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">ss</span> <span class="operator">=</span> ssf.openSession();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3、执行SQL</span></span><br><span class="line">    List&lt;user&gt; users = ss.selectList(<span class="string">&quot;test.selectAll&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理结果</span></span><br><span class="line">    System.out.println(users);</span><br><span class="line">    </span><br><span class="line">    ss.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>赋值logBack配置文件，使用彩色日志。</p><h2 id="消除-SQL-映射文件的警告提示"><a href="#消除-SQL-映射文件的警告提示" class="headerlink" title="消除 SQL 映射文件的警告提示"></a>消除 SQL 映射文件的警告提示</h2><p>起因：IDEA没有与数据库建立连接，不识别表信息。</p><p>解决：在IDEA中配置数据库连接</p><p>&#x3D;&#x3D;解决这个问题是为了让 IDEA 中有关于数据库信息的提示。&#x3D;&#x3D;   </p><p>右侧边栏DataBase，添加MySQL Data Source。</p><p>填入Host、port、username、password、DataBase name、url即可，选择驱动jar包，然后 test connection，连接之后可以使用IDEA内置的可视化工具操作数据库（与Navicat相似）。</p><h2 id="Mapper-代理开发"><a href="#Mapper-代理开发" class="headerlink" title="Mapper 代理开发"></a>Mapper 代理开发</h2><p>目的：解决原生方式中的硬编码问题，简化后期执行SQL的过程。</p><h3 id="Mapper-代理开发使用规则"><a href="#Mapper-代理开发使用规则" class="headerlink" title="Mapper 代理开发使用规则"></a>Mapper 代理开发使用规则</h3><ol><li>mapper 接口和 XxxMapper.xml 文件在同一目录下（使用 maven compile 之后查看文件目录即可知晓）</li></ol><p>需要在 resources 文件夹下创建 com&#x2F;itheima&#x2F;mapper Directory。</p><p>&#x3D;&#x3D;接口文件中需要根据SQL的返回值定义函数返回值。&#x3D;&#x3D; </p><ol start="2"><li>设置SQL映射文件的名称空间户型为Mapper接口全限定名</li></ol><p><code>namespace = &quot;com.itHeima.mapper.UserMapper&quot;</code> </p><ol start="3"><li>在Mapper接口中定义方法，方法名即为SQL映射文件中SQL语句的id，并保持参数类型和返回值类型一致</li></ol><blockquote><p> mybatis-config.xml文件中mappers下的SQL映射路径需要更改。</p></blockquote><h3 id="Mapper-代理开发方式使用"><a href="#Mapper-代理开发方式使用" class="headerlink" title="Mapper 代理开发方式使用"></a>Mapper 代理开发方式使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3.1 获取mapper接口代理对象</span></span><br><span class="line"><span class="type">UserMapper</span> <span class="variable">um</span> <span class="operator">=</span> sqlSessiocn.getMapper(UserMapper.class);</span><br><span class="line">List&lt;user&gt; users = um.selectAll();</span><br></pre></td></tr></table></figure><p>如果Mapper接口名称和 SQL 映射文件名相同，并在同一文件目录下，则可以使用包扫扫描的方式简化 SQL 映射文件的加载。</p><p>&#x3D;&#x3D;mybatis-config.xml&#x3D;&#x3D; </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.itheima.mapper&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="核心配置文件顶层结构："><a href="#核心配置文件顶层结构：" class="headerlink" title="核心配置文件顶层结构："></a>核心配置文件顶层结构：</h2><ul><li>configuration<ul><li>properties</li><li>settings</li><li>typeAliases</li><li>tyoeHandlers</li><li>objectFactory</li><li>plugins</li><li>environments<ul><li>environmrnt<ul><li>transactionManager</li><li>dataSource</li></ul></li></ul></li><li>databaseProvider</li><li>mappers</li></ul></li></ul><h2 id="类型别名（TypeAliases）"><a href="#类型别名（TypeAliases）" class="headerlink" title="类型别名（TypeAliases）"></a>类型别名（TypeAliases）</h2><p>使用typeAliases可以简化开发，在写查询ResultType时可以直接写类名</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.itheima.pojo&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="配置文件完成增删改查"><a href="#配置文件完成增删改查" class="headerlink" title="配置文件完成增删改查"></a>配置文件完成增删改查</h2><ul><li>要完成的功能列表清单：<ul><li><ol><li>查询<ol><li>查询所有数据</li><li>查看详情</li><li>条件查询</li></ol></li><li>添加</li><li>修改<ol><li>修改全部字段</li><li>修改动态字段</li></ol></li><li>删除<ol><li>删除一个</li><li>批量删除</li></ol></li></ol></li></ul></li></ul><p>准备环境</p><p>Brand 类</p><table><thead><tr><th>类型</th><th>属性名</th></tr></thead><tbody><tr><td>Integer</td><td>id</td></tr><tr><td>String</td><td>brandName</td></tr><tr><td>String</td><td>companyName</td></tr><tr><td>Integer</td><td>ordered</td></tr><tr><td>String</td><td>description</td></tr><tr><td>Integer</td><td>status</td></tr></tbody></table><p>安装 MybatisX插件</p><p>​将 mapper 与 Statement 关联起来。</p><p>查询</p><ul><li>完成查询功能</li><li>参数</li><li>返回值类型</li></ul><h2 id="字段名与实体属性对应问题"><a href="#字段名与实体属性对应问题" class="headerlink" title="字段名与实体属性对应问题"></a>字段名与实体属性对应问题</h2><p>&#x3D;&#x3D;数据库字段名称和实体类的属性名称不同无法将数据库中的数据对应到实体。&#x3D;&#x3D; </p><p>解决方法：</p><ol><li>SQL 中提供的重命名（将重命名字段）</li><li>SQL 片段</li><li>ResultMap</li></ol><p>重命名的 SQL 片段：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;brand_column&quot;</span>&gt;</span></span><br><span class="line">id, brand_name as brandName, comnpany_name as companyName, ordered, description, status</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br></pre></td></tr></table></figure><p>SQL片段的使用：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">reultType</span>=<span class="string">&quot;brand&quot;</span>&gt;</span></span><br><span class="line">select <span class="tag">&lt;<span class="name">include</span> <span class="attr">resId</span>=<span class="string">&quot;brand_column&quot;</span> /&gt;</span> from tb_brand;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>缺点：不够灵活。</p><p>ResultMap方式：</p><p>使用ResultMap标签将字段与属性建立关系，例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;brandResultMap&quot;</span><span class="attr">type</span>=<span class="string">&quot;brand&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;brand_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;brandName&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;company_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;companyName&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- id: 映射的唯一标识，type：关联的实体类 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用映射：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;bandResultMap&quot;</span>&gt;</span></span><br><span class="line">select * from tb_brand;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>resultMap下的子标签：</p><ul><li><id>：主码映射</li><li><result>：非主码映射</li></ul><p>resultMap使用：</p><ol><li>定义resultMap</li><li>使用resultMap属性替换resultType属性</li></ol><h2 id="条件查询："><a href="#条件查询：" class="headerlink" title="条件查询："></a>条件查询：</h2><p>​参数占位符：</p><ol><li><p><code>#</code>{}：将参数替换成问好，与preparedStatement相似，能够阻止SQL注入</p></li><li><p><code>$</code>{}：将参数填充到SQL语句中，无法阻止SQL注入，原理是拼字符串，用于表明或字段名不固定的查询</p></li></ol><p>条件查询的参数类型指定：</p><p><code>&lt;select&gt; 的parameter属性可以指定参数类型</code> </p><p>特殊字符处理：</p><ol><li>转义</li></ol><p>小于号可以用 <code>&amp;lt;</code>代替，在xml标签内容中使用，还有<code>&amp;nbsp</code>、<code>&amp;gt</code>。</p><ol start="2"><li>CDATA区</li></ol><![CDATA[ ... ]]><p> 在省略号区域填入所需要的符号，会被当作纯文本来处理</p><h2 id="多条件查询"><a href="#多条件查询" class="headerlink" title="多条件查询"></a>多条件查询</h2><ol><li>条件表达式</li><li>条件连接</li></ol><h2 id="SQL-语句设置多个参数的方式："><a href="#SQL-语句设置多个参数的方式：" class="headerlink" title="SQL 语句设置多个参数的方式："></a>SQL 语句设置多个参数的方式：</h2><ol><li>散装参数</li></ol><p>需要使用@Param(“SQL中的参数占位符名称”)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// brandMapper接口文件中定义：</span></span><br><span class="line">List&lt;Brand&gt; <span class="title function_">selectByCondition</span><span class="params">(<span class="meta">@Param(&quot;status&quot; int status, [Param(&quot;companyName&quot;) String companyName, @Param(&quot;brandName&quot;) String brandName)</span>;]</span></span><br></pre></td></tr></table></figure><ol start="2"><li>实体类封装参数</li></ol><p>只需要保证SQL中的参数名和实体类属性对应上，即可设置成功</p><blockquote><p>此时类内属性名与条件参数必须保持一致，而且需要对应的gettters</p></blockquote><ol start="3"><li>map集合</li></ol><p>只需要保证SQL中的参数名和map集合中的间的名称相对应，即可设置成功</p><p><code>List&lt;Brand&gt; selectByCondition(Map map);</code> </p><p>使用模糊查询需要对应传入的参数进行相应的处理：con &#x3D; % + con +%;</p><p>map的映射关系是字段名与变量，就是说map映射于变量的类型无关，单纯哈希。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">map.put(<span class="string">&quot;status&quot;</span>, status);</span><br><span class="line">map.put(<span class="string">&quot;companyName&quot;</span>, companyName);</span><br></pre></td></tr></table></figure><h2 id="动态-SQL"><a href="#动态-SQL" class="headerlink" title="动态 SQL"></a>动态 SQL</h2><p>根据实际情况进行变化的 SQL：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByCondition&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;brandResultMap&quot;</span>&gt;</span></span><br><span class="line">select * from tb_brand where </span><br><span class="line"><span class="comment">&lt;!-- 如果第一个条件没有生效，那么第二个条件中的and将会引发一系列的问题 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;status != null&quot;</span>&gt;</span></span><br><span class="line">status = #&#123;status&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;companyName != null and compantName != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">and companyName like #&#123;companyname&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>解决方案：</p><ol><li>添加恒等式，然后每个查询条件前都添加 and</li></ol><p>即：where 1 &#x3D;1 and …… and …… and ……；</p><ol start="2"><li>使用<where></where>替换where关键字并包裹查询条件</li></ol><p>即：<where> <if></if> <if></if> </where></p><p>下拉列表选择查询条件的动态SQL，任选一个条件有效：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;...&quot;</span>&gt;</span><br><span class="line">select * <span class="keyword">from</span> tb_brand where </span><br><span class="line">&lt;choose&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;status != null&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">status = #&#123;status&#125;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">when</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;companyName != null and companyName != &#x27;&#x27;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">company_name like #&#123;companyname&#125;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">when</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;brandName != null and brandName != &#x27;&#x27;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">brand_name = #&#123;brandname&#125;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">when</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">otherwise</span>&gt;</span> 1 = 1 <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span></span><br><span class="line">&lt;/choose&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><blockquote><p><choose></choose>类似switch</p><p><when></when>类似case</p><p><otherwise></otherwise>类似default</p><p>推荐使用<where></where>标签代替where关键字。</p></blockquote><p>在使用插入、更新、删除事，需要将获取的sqlSession语句的参数设为true，目的是开启事务的自动提交，或者在方法结束前手动提交。</p><p>即：</p><p><code>sqlSession.commit();     // 提交事务</code> </p><p><code>openSession(true);         // 可以设置为自动提交事务</code> </p><h3 id="返回新增记录的主键"><a href="#返回新增记录的主键" class="headerlink" title="返回新增记录的主键"></a>返回新增记录的主键</h3><p>返回新增记录的主码，可用于删除商品、加购物车、生成订单功能。</p><p>并不适用于联合主码的情况。</p><p>方案：</p><p>给insert语句添加useGeneratedKeys&#x3D;”true” 和 keyProperty&#x3D;”id”属性，id为主码。</p><h3 id="修改数据表的动态SQL"><a href="#修改数据表的动态SQL" class="headerlink" title="修改数据表的动态SQL"></a>修改数据表的动态SQL</h3><p>依然是使用<if></if>和<where></where>改造SQL语句。</p><p>在这些例子中，传参操作都是通过向方法中传递一个类对象来实现的。</p><h3 id="批量删除"><a href="#批量删除" class="headerlink" title="批量删除"></a>批量删除</h3><p>SQL 语句 delete from tb_brand where id in (?, ?, ?);</p><p>上面的问号代表的是元素，括号括起表示集合。</p><p>Mappers 中的方法定义：</p><p><code>public void deleteByIds(int[] ids);</code> </p><p>xml 中相应的配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span> = <span class="string">&quot;deleteByIds&quot;</span>&gt;</span></span><br><span class="line">delete from tb_btand where id</span><br><span class="line">    in (</span><br><span class="line"><span class="comment">&lt;!-- 在没有使用 @Param 注解之前，collection 的值是 array --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;array&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">foreach</span>&gt;</span>);</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure><p><foreach> 与C++的for_each相似。</p><p>mybatis会将数组参数封装成一个Map集合，默认状态下array为数组，可以使用@Param注解改变map集合默认key的名称。</p><p>单纯改变数组的名称作用并不大，并且Mapper中需要更改方法的定义为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">deleteByIds</span><span class="params">(<span class="meta">@Param(&quot;ids&quot;)</span> <span class="type">int</span>[] ids)</span>;</span><br></pre></td></tr></table></figure><p>更适合的编写方式（使用其提供的方式书写括号）：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">delete</span> id=<span class="string">&quot;deleteByIds&quot;</span>&gt;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> tb_brand where id</span><br><span class="line"><span class="keyword">in</span></span><br><span class="line">&lt;foreach collection=<span class="string">&quot;ids&quot;</span> item=<span class="string">&quot;id&quot;</span> separator=<span class="string">&quot;,&quot;</span> open=<span class="string">&quot;(&quot;</span> close=<span class="string">&quot;)&quot;</span>&gt;</span><br><span class="line">#&#123;id&#125;</span><br><span class="line">&lt;/foreach&gt;</span><br><span class="line">&lt;/<span class="keyword">delete</span>&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>$\textcolor{Red}{在标签下可以不写英文分号。} $</strong></li></ul><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>Mybatis 会接口方法中可以接收各类参数，其底层对这些参数进行不同方式的封装处理。</p><ul><li>单个参数：</li></ul><p>实体类、Map、Colection、List、Array、其他</p><ul><li>多个参数：</li></ul><p>需要@Param 注解，并且占位参数需要一一对应。</p><ol><li>多参处理</li></ol><p>Mybatis 会将参数封装成 Map 集合，将注解作为映射的 key。</p><ul><li>如果传递 Collection 对象，则 Map 集合中最少要有两个不同的 key 对应其 HashSet，如果是 List 类对象，则还要多一个。<ul><li><code>map.put(&quot;arg0&quot;, Collection集合);</code></li><li><code>map.put(&quot;collection&quot;, Collection集合);</code></li><li><code>map.put(&quot;list&quot;, List集合);         // List 多出的参数</code></li></ul></li></ul><ol start="2"><li>POJO 类型（数据库实体类）</li></ol><p>直接使用，键名与参数占位符名一致。</p><ol start="3"><li>Map 类型</li></ol><p>直接使用，但是键名需要跟参数占位符名一致。</p><ol start="4"><li>Array 类型</li></ol><p>封装成 Map 集合，如上面所述。</p><p>&#x3D;&#x3D;使用注解替换 Map 集合中默认的 arg 键名，即默认的参数键名虽然可以使用，但是不建议。&#x3D;&#x3D; </p><h3 id="注解开发"><a href="#注解开发" class="headerlink" title="注解开发"></a>注解开发</h3><p>注解开发与配置文件完成开发的区别：</p><ul><li>注解完成简单功能</li><li>配置文件完成复杂功能</li></ul><p>使用注解来映射简单语句会使代码显得更加简洁，但对于稍微复杂一点的语句，Java注解不仅力不从心，还有让本就复杂的 SQL 更加混乱不堪，因此，最好使用 xml 来映射复杂的 SQL 语句。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select</span> (<span class="string">&quot;select * from tb_brand where id = #&#123;id&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">selectById</span><span class="params">(<span class="type">int</span> id)</span>;</span><br></pre></td></tr></table></figure><h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><p>在JavaScript中，使用 let 关键字创建的变量不允许被重复定义，使用 const 修饰的变量为常量，这种声明方式与C&#x2F;C++中的const 关键字相似。</p><p>运算符</p><p>全等于 “&#x3D;&#x3D;&#x3D;” 值相等且类型也相同</p><p>Array对象</p><ul><li>var val1 &#x3D; new Array(元素列表);</li><li>var val2 &#x3D; [元素列表];</li></ul><p>例：</p><ul><li>var val1 &#x3D; new Array(1, 2, 3);</li><li>var val2 &#x3D; [1, 2, 3];</li></ul><p>JS数组的长度、类型都是可变的。</p><p>类内属性：</p><table><thead><tr><th>constructor</th><th>返回对Array构造函数的引用</th></tr></thead><tbody><tr><td>length</td><td>数组长度</td></tr><tr><td>prototype</td><td>向Array对象中添加属性的方法</td></tr><tr><td>concat</td><td>连接两个或更多的数组，并返回结果</td></tr><tr><td>join</td><td>把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分离</td></tr><tr><td>pop</td><td>删除并返回数组的最后一个元素</td></tr><tr><td>push</td><td>像数组的末尾添加一个或更多元素，并返回新的长度</td></tr><tr><td>reverse</td><td>颠倒数组中的元素顺序</td></tr><tr><td>shift</td><td>删除并返回数组的第一个元素</td></tr><tr><td>slice</td><td>从某个已有的数组返回选定的元素</td></tr><tr><td>sort</td><td>对数组的元素进行排序</td></tr><tr><td>splice</td><td>删除元素，并向数组添加新的元素</td></tr><tr><td>toSource</td><td>返回该对象的源代码</td></tr><tr><td>toString</td><td>将数组转换为字符串，并返回结果</td></tr><tr><td>toLocaleString</td><td>将数组转换为本地数组，并返回结果</td></tr><tr><td>unshift</td><td>像数组的开头添加一个或更多元素，并返回新的长度</td></tr><tr><td>valueOf</td><td>返回数组对象的原始值</td></tr></tbody></table><p>支持加强 for</p><ul><li>splice(0, 1&#96;) 从 0 号位置开始删除一个元素</li></ul><p>String 对象</p><p>字符串单引和双引是没有区别的。</p><h2 id="自定义对象"><a href="#自定义对象" class="headerlink" title="自定义对象"></a>自定义对象</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 对象名 = &#123;</span><br><span class="line"></span><br><span class="line"><span class="attr">attribute1</span>: values,</span><br><span class="line"></span><br><span class="line"><span class="attr">attribute2</span>: value2,</span><br><span class="line"></span><br><span class="line"><span class="attr">func</span>: <span class="keyword">function</span>(<span class="params">parameters</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="BOM-对象"><a href="#BOM-对象" class="headerlink" title="BOM 对象"></a>BOM 对象</h2><p>window、navigator、screen、history、location</p><h3 id="window"><a href="#window" class="headerlink" title="window"></a>window</h3><p>直接使用window，window.调用可以省略</p><p>例：window.alert();  ⇒ alert();</p><ul><li>属性：获取其他四种对象</li></ul><p>方法：</p><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>alert</td><td>警告</td></tr><tr><td>confirm</td><td>消息对话框</td></tr><tr><td>setInterval</td><td>按照指定周期（单位为毫秒）来调用函数或者计算表达式</td></tr><tr><td>setTimeout</td><td>在指定时间后调用函数或者计算表达式</td></tr></tbody></table><h3 id="confirm"><a href="#confirm" class="headerlink" title="confirm()"></a>confirm()</h3><p><code>var flag = confirm(””);    按下确定则将flag置为true</code> </p><h3 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval()"></a>setInterval()</h3><p>循环执行某个动作</p><p><code>setInterval(function() &#123; alert(”haha”); &#125;, 3000);</code> </p><p>3秒以后弹出警告框，显示 haha</p><h3 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout()"></a>setTimeout()</h3><p>倒计时，只执行一次动作</p><h2 id="隔一段时间闪烁一次的灯"><a href="#隔一段时间闪烁一次的灯" class="headerlink" title="隔一段时间闪烁一次的灯"></a>隔一段时间闪烁一次的灯</h2><ol><li><pre><code class="language-javascript"> var img = document.getElementById(”Image”); img.src = &quot;路径&quot;;  var count = 0; setInterval(function() &#123;     if (count % 2) &#123;         on();     &#125; else &#123;         off();     &#125; &#125;, 1000); <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. ```javascript</span><br><span class="line">setInterval(function() &#123;</span><br><span class="line">    setTimeout(on, 1000);</span><br><span class="line">    setTimeout(off, 1000);</span><br><span class="line">&#125;, 2000);</span><br></pre></td></tr></table></figure> 每一秒执行一次更改src的路径。</code></pre></li></ol><h2 id="history-对象"><a href="#history-对象" class="headerlink" title="history 对象"></a>history 对象</h2><p>window. 调用history 对象（window.history);  window.可以省略</p><h3 id="history-内置方法"><a href="#history-内置方法" class="headerlink" title="history 内置方法"></a>history 内置方法</h3><ul><li>back() 加载history列表中前一个url</li><li>forward() 加载history 列表中后一个url</li></ul><h2 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h2><p>window.location获取location对象，其中window. 可以省略。</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>href 设置或返回完整的url</p><p>location.href &#x3D; “target”</p><p>3秒后跳转到首页：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;3秒后跳转到首页&quot;</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123; location.<span class="property">href</span> = <span class="string">&quot;target&quot;</span>; &#125;, <span class="number">3000</span>);</span><br></pre></td></tr></table></figure><h2 id="prompt-对话框"><a href="#prompt-对话框" class="headerlink" title="prompt 对话框"></a>prompt 对话框</h2><p><code>window.prompt（&quot;your name&quot;, &quot;Xiao Ming&quot;);</code> </p><p>浏览器窗口顶部弹出输入提示框，第一个参数是输入提示，第二个参数是输入框默认值。</p><h2 id="DOM（文档对象模型）"><a href="#DOM（文档对象模型）" class="headerlink" title="DOM（文档对象模型）"></a>DOM（文档对象模型）</h2><p>获取DOM对象的方法：</p><ol><li>通过 id 获取文档元素</li></ol><p><code>document.getElementById(&quot;a&quot;);</code> </p><ol start="2"><li>通过类名获取文档元素</li></ol><p><code>document.getElementByClassName(&quot;myName&quot;);</code> </p><p>返回值是文档元素数组。</p><ol start="3"><li>通过标签名获取文档元素</li></ol><p><code>document.getElementByTagName(&quot;span&quot;);</code> </p><ol start="4"><li><p>H5 中获取文档元素的方法</p><ol><li><code>document.querySelector()</code> <ul><li>“.class”</li><li>“#id”</li><li>“p”</li></ul></li></ol><ul><li>返回匹配指定 css 选择器的第一个元素</li></ul><ol start="2"><li><code>document.querySelectorAll(&quot;.pClass&quot;);</code></li></ol><ul><li>返回值为 DOM 对象数组</li></ul></li><li><p>节点树上的操作</p></li></ol><p>HTML    -&gt;      head      -&gt;    a    -&gt;    text3</p><p>|     |</p><p>headp</p><p>| |</p><p>title                text2</p><h3 id="文档元素属性"><a href="#文档元素属性" class="headerlink" title="文档元素属性"></a>文档元素属性</h3><ul><li>第一个子节点：firstElementChild</li><li>前一个兄弟节点：previousElementSibling</li><li>后一个兄弟节点：nextElementSibling</li><li>子节点列表：children</li><li>最后一个子节点：lastElementChild</li></ul><h2 id="HTML-DOM-对象的使用"><a href="#HTML-DOM-对象的使用" class="headerlink" title="HTML DOM 对象的使用"></a>HTML DOM 对象的使用</h2><h3 id="属性值的获取"><a href="#属性值的获取" class="headerlink" title="属性值的获取"></a>属性值的获取</h3><p><code>DOM.getAttribute(&quot;class&quot;)</code> </p><p>attribute: id、class、href、src、style等，style下还有color等属性</p><p><code>Dom.getclassName</code> 获取类名</p><h3 id="设置属性值"><a href="#设置属性值" class="headerlink" title="设置属性值"></a>设置属性值</h3><p><code>document.getElementById(&quot;form1&quot;).setAttribute(&quot;style.color&quot;, black);</code> 没试过</p><h3 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h3><p>绑定事件的方式：</p><ol><li>HTML标签中的时间属性进行绑定</li></ol><p>给标签的 onclick 属性设置值，在 <code>&lt;script&gt;</code> 标签下定义 function</p><ol start="2"><li>DOM 元素属性进行绑定</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;btn&quot;</span>).<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="表单验证"><a href="#表单验证" class="headerlink" title="表单验证"></a>表单验证</h3><ol><li>输入框失去焦点时，验证输入内容是否符合要求</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> username = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">useranme.<span class="property">onblur</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> textName = username.<span class="property">value</span>.<span class="title function_">trim</span>();</span><br><span class="line"><span class="keyword">var</span> userNameReg = <span class="regexp">/^\w&#123;6, 12&#125;$/</span>;<span class="comment">// 正则表达式</span></span><br></pre></td></tr></table></figure><p>如果不符合要求，就将提示信息的display属性设置为 ‘’，以使其显示。</p><ol start="2"><li>点击提交时，判断所有输入框的内容是不是都符合要求，如果不符合则阻止表单提交</li></ol><p>给提交按钮绑定 onsubmit 事件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">form = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;form&quot;</span>);</span><br><span class="line">form.<span class="property">onsubmit</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 判断所有输入内容，任何一个不符合要求都返回 false</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">checkUserName</span>() &amp;&amp; <span class="title function_">checkPassword</span>() &amp;&amp; <span class="title function_">checkTel</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><ul><li>^：开始</li><li>$：结束</li><li>[]：某个范围内的单个字符，比如[0-9]单个字符</li><li>.：表示任意单个字符，除了换行和行结束符</li><li>\w：代表单词字符：字母、数字、下划线</li><li>\d：数字字符：限定为 0 - 9</li></ul><p>量词：</p><ul><li>+：至少一个</li><li>*：零个或多个</li><li>?：零个或一个</li><li>{x}：x 个</li><li>{m, }：至少 m 个</li><li>{m, n}：至少 m 个，至多 n 个</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/^\w&#123;6, 12&#125;&amp;/</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> flag = reg.<span class="title function_">test</span>(str);</span><br></pre></td></tr></table></figure><h1 id="Web-核心"><a href="#Web-核心" class="headerlink" title="Web 核心"></a>Web 核心</h1><p>B&#x2F;S框架：Browser&#x2F;Server，浏览器&#x2F;服务器架构模式。</p><p>特点：</p><ul><li>客户端只需要浏览器</li><li>应用程序的逻辑和数据都存储在服务器</li><li>浏览器请求服务器，获取web资源，服务器将资源发送给浏览器</li></ul><p>优点：易于维护升级，服务器升级后，客户端无需任何部署就可以使用新的版本。</p><ul><li>静态资源：HTML、CSS、JavaScript、图片等，负责页面展示</li><li>动态资源：Servelet、JSP等，负责逻辑处理</li><li>数据库：负责存储数据</li><li>HTTP协议：定义通信规则</li><li>Web服务器：负责解析 HTTP 协议，解析请求数据，并发送响应数据</li></ul><p>&#x3D;&#x3D;Java EE 的13项规范：JDBC，JNDI，EJB，RMI，JSP，Servlets，XML，JMS，Java IDL，JTS，JTA，JavaMail，JAF。&#x3D;&#x3D; </p><h1 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h1><p>HyperText Transfer Protocol，超文本传输协议，规定了浏览器和服务器之间数据传输的规则。</p><p>特点：</p><ul><li>基于 TCP 协议，面向连接，安全</li><li>基于请求-响应模型：一次请求对应一次响应</li><li>HTTP 协议时无状态的协议：对事物处理没有记忆能力，每次请求都是独立的</li></ul><p>缺点：</p><ul><li>请求之间不能共享数据，Java中使用会话技术（Cookie、Session）解决</li></ul><p>优点：快</p><h2 id="请求数据格式"><a href="#请求数据格式" class="headerlink" title="请求数据格式"></a>请求数据格式</h2><ol><li>请求行：请求数据的第一行，其中 GET 表示请求方式，&#x2F; 表示请求资源路径，HTTP&#x2F;1.1表示协议版本</li><li>请求头：第2行开始，格式为键值对形式</li><li>请求体：POST请求的最后一部分，存放请求参数</li></ol><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET /HTTP/1.1</span><br><span class="line">Host:www.itcast.cn</span><br><span class="line">Connection:keep-alive</span><br><span class="line">Cache-Control:max-age=0 Upgrade-Insecure-Request:1</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 Chrome/91.0.4472.106</span><br><span class="line">···</span><br></pre></td></tr></table></figure><h2 id="常见请求头"><a href="#常见请求头" class="headerlink" title="常见请求头"></a>常见请求头</h2><ul><li><p>HOST：请求的主机名</p></li><li><p>User-Agent：浏览器版本</p></li><li><p>Accept：表示浏览器能接受的资源类型，如 text&#x2F;<code>*</code>，image&#x2F;<code>*</code>，或者<code>*/*</code>表示所有</p></li><li><p>Accept-Language：浏览器的偏好语言，服务器可以据此返回不同语言的网页</p></li><li><p>Accept-Encoding：浏览器可以支持的压缩类型，例如：gzip、deflate等</p></li></ul><h2 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h2><p>请求头与请求体之间有一空行</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST /HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.itcast.cn</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line">Cache-Control:max-age=0 Upgrade-Insecure-Request:1</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 Chrome/91.0.4472.106</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">username=superbaby&amp;password=123456</span><br></pre></td></tr></table></figure><h4 id="GET请求与POST请求的区别"><a href="#GET请求与POST请求的区别" class="headerlink" title="GET请求与POST请求的区别"></a>GET请求与POST请求的区别</h4><ol><li>GET 请求的参数在请求行中，没有请求体；POST 请求的参数在请求体中</li></ol><p>GET 的参数接在网页链接后面，POST则不是</p><ol start="2"><li>GET 请求的参数大小有限制，POST没有</li></ol><p>&#x3D;&#x3D;上次的表单页面，通过修改 <form> 标签的 method 属性可以看到差异。&#x3D;&#x3D; </p><h2 id="响应数据格式"><a href="#响应数据格式" class="headerlink" title="响应数据格式"></a>响应数据格式</h2><ol><li>响应行：响应数据的第一行，其中 HTTP&#x2F;1.1 为协议版本，200 表示响应码，OK表示状态码描述</li><li>响应头：第二行开始，格式为键值对形式</li><li>响应体：最后一部分，存放响应数据</li></ol><h3 id="常见的-HTTP-响应头"><a href="#常见的-HTTP-响应头" class="headerlink" title="常见的 HTTP 响应头"></a>常见的 HTTP 响应头</h3><table><thead><tr><th align="center">名称</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">Content-Type</td><td align="center">响应内容的类型，例如：text&#x2F;html、image&#x2F;jpeg</td></tr><tr><td align="center">Content-Length</td><td align="center">响应内容的长度（字节数）</td></tr><tr><td align="center">Content-Encoding</td><td align="center">响应的压缩算法，如：gzip</td></tr><tr><td align="center">Cache-Control</td><td align="center">指示客户端应如何缓存，例如max-age&#x3D;300，表示最多可以缓存 300 秒</td></tr></tbody></table><p>响应头与响应体之间应有一空行。</p><h3 id="状态码分类"><a href="#状态码分类" class="headerlink" title="状态码分类"></a>状态码分类</h3><table><thead><tr><th>状态码</th><th>含义</th></tr></thead><tbody><tr><td>1xx</td><td>响应中 – 临时状态码，表示请求已接收，告诉客户端应继续请求或者请求已经完成可以忽略</td></tr><tr><td>2xx</td><td>成功 – 请求已被成功接收，处理完成</td></tr><tr><td>3xx</td><td>重定向 – 重定向到其它地方，让客户端再发起一个请求以完成整个过程</td></tr><tr><td>4xx</td><td>客户端错误 – 处理发生错误，责任在客户端，如：客户端请求一个不存在的资源、客户端未授权、禁止访问等</td></tr><tr><td>5xx</td><td>服务器错误 – 处理发生错误，责任在服务端，如：服务器抛出异常、路由出错、HTTP 版本不支持等</td></tr><tr><td>状态码大全</td><td><a href="https://cloud.tencent.com/developer/chapter/13553">https://cloud.tencent.com/developer/chapter/13553</a></td></tr></tbody></table><h3 id="常见的响应状态码"><a href="#常见的响应状态码" class="headerlink" title="常见的响应状态码"></a>常见的响应状态码</h3><table><thead><tr><th>状态码</th><th>英文描述</th><th>解释</th></tr></thead><tbody><tr><td>200</td><td><strong><code>OK</code></strong></td><td>客户端请求成功，即<strong>处理成功</strong>，这是我们最想看到的状态码</td></tr><tr><td>302</td><td><strong><code>Found</code></strong></td><td>指示所请求的资源已移动到由<code>Location</code>响应头给定的 URL，浏览器会自动重新访问到这个页面</td></tr><tr><td>304</td><td><strong><code>Not Modified</code></strong></td><td>告诉客户端，你请求的资源至上次取得后，服务端并未更改，你直接用你本地缓存吧。隐式重定向</td></tr><tr><td>400</td><td><strong><code>Bad Request</code></strong></td><td>客户端请求有<strong>语法错误</strong>，不能被服务器所理解</td></tr><tr><td>403</td><td><strong><code>Forbidden</code></strong></td><td>服务器收到请求，但是<strong>拒绝提供服务</strong>，比如：没有权限访问相关资源</td></tr><tr><td>404</td><td><strong><code>Not Found</code></strong></td><td><strong>请求资源不存在</strong>，一般是URL输入有误，或者网站资源被删除了</td></tr><tr><td>428</td><td><strong><code>Precondition Required</code></strong></td><td><strong>服务器要求有条件的请求</strong>，告诉客户端要想访问该资源，必须携带特定的请求头</td></tr><tr><td>429</td><td><strong><code>Too Many Requests</code></strong></td><td><strong>太多请求</strong>，可以限制客户端请求某个资源的数量，配合 Retry-After(多长时间后可以请求)响应头一起使用</td></tr><tr><td>431</td><td><strong><code> Request Header Fields Too Large</code></strong></td><td><strong>请求头太大</strong>，服务器不愿意处理请求，因为它的头部字段太大。请求可以在减少请求头域的大小后重新提交。</td></tr><tr><td>405</td><td><strong><code>Method Not Allowed</code></strong></td><td>请求方式有误，比如应该用GET请求方式的资源，用了POST</td></tr><tr><td>500</td><td><strong><code>Internal Server Error</code></strong></td><td><strong>服务器发生不可预期的错误</strong>。服务器出异常了，赶紧看日志去吧</td></tr></tbody></table><h1 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h1><p>主要了解其与 Servelet 的交互方式。</p><p>web 服务器：</p><ul><li>封装HTTP协议操作，简化开发</li><li>可以将web项目部署到服务器中，对外提供网上浏览服务</li></ul><p>Tomcat 是一个轻量级的 web 服务器，支持 Servelet&#x2F;JSP 少量 Java EE 规范，也成为 web 容器或 Servelet容器。</p><h2 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="下载、安装、卸载、启动、关闭"><a href="#下载、安装、卸载、启动、关闭" class="headerlink" title="下载、安装、卸载、启动、关闭"></a>下载、安装、卸载、启动、关闭</h3><p>下载对应安装包之后解压即安装完成（注意路径中不要包含中文），这里需要说明双击 bin 目录下的 startup.bat 文件可以将 tomcat 启动起来，如果有中文乱码，则需要找到 conf&#x2F;logging.properties 文件：</p><p><code>java.util.logging.ConsoleHandler.encoding = UTF-8</code> </p><p>修改上述代码为：</p><p><code>java.util.logging.ConsoleHandler.encoding = GBK</code> </p><p>再次双击 bin&#x2F;startup.bat 控制台不会再出现中文乱码。</p><p>需要将 tomcat 根目录添加到系统变量中：</p><p>CATALINA_HOME：C:\Coding_tools\apache-tomcat-9.0.65</p><p>TOMCAT_HOME：C:\Coding_tools\apache-tomcat-9.0.65</p><h4 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h4><ul><li><p>强制关闭：直接关掉 startup.bat 弹出的控制台窗口（无法正常执行资源释放方法）</p></li><li><p>正常关闭：</p><ul><li>bin&#x2F;shutdowm.bat </li><li>Ctrl + C</li></ul></li></ul><h3 id="配置以及项目部署"><a href="#配置以及项目部署" class="headerlink" title="配置以及项目部署"></a>配置以及项目部署</h3><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><ol><li>修改默认端口号</li></ol><p>在 conf&#x2F;serve.xml 文件中，找到以下代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8080&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;HTTP/1.1&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>HTTP 协议默认端口号为 $\textcolor{red}{80}$，将 tomcat 默认端口改为80之后，在浏览器地址栏输入 localhost 就能直接访问到 tomcat 。</p></blockquote><ol start="2"><li>启动 tomcat 时可能出现的问题</li></ol><ul><li>端口号冲突：找到对应程序，将其关闭 （Address alread in use）</li><li>启动窗口一闪而过：检查 JAVA_HOME 环境变量是否正确</li></ul><h4 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h4><ul><li>将项目放到 webapps 路径下，就完成了部署</li></ul><p>一般，JavaWeb项目会被打包成 war 包，将 war 包放到 webapps 目录下，tomcat 就会自动解压缩 war 文件。</p><h3 id="IDEA-中创建-Maven-Web-项目"><a href="#IDEA-中创建-Maven-Web-项目" class="headerlink" title="IDEA 中创建 Maven Web 项目"></a>IDEA 中创建 Maven Web 项目</h3><h4 id="Maven-Web-项目结构：开发中的项目"><a href="#Maven-Web-项目结构：开发中的项目" class="headerlink" title="Maven Web 项目结构：开发中的项目"></a>Maven Web 项目结构：开发中的项目</h4><ul><li>hello 项目名称<ul><li>src 主目录<ul><li>main <ul><li>java    Java 代码</li><li>resources    资源文件</li><li>webapp    Web项目独有的目录<ul><li>html    HTML 文件目录（可选）</li><li>WEB-INF    Web 项目核心目录（必须叫这个名字）<ul><li>web.xml    Web 项目配置文件</li></ul></li></ul></li></ul></li><li>test     测试目录</li></ul></li><li>pom.xml</li></ul></li></ul><p>部署的 JavaWeb 项目结构：开发完成，可以部署的项目（只需要打包即可）</p><ul><li>hello    项目访问路径（虚拟目录）<ul><li>html    HTML文件目录</li><li>WEB_INF    Web 项目核心目录（必须叫这个名字）<ul><li>classes    （Java 字节码文件）</li><li>lib    项目需要的 jar 包</li><li>web.xml    Web项目配置文件</li></ul></li></ul></li></ul><ol><li>项目表以后的 Java 字节码文件和 resources 的资源文件，放到 WEB_INF 下的 classes 目录下</li><li>pom.xml 中依赖坐标对应的 jar 包，放入 WEB_INF&#x2F;lib 目录下</li></ol><h4 id="项目创建"><a href="#项目创建" class="headerlink" title="项目创建"></a>项目创建</h4><ul><li>使用骨架<ul><li>项目模板</li></ul></li></ul><ol><li>选择 web 项目骨架，创建项目 maven-archetype-webapp，或者干脆不使用</li><li>删除 pom.xml 中多余的坐标，不使用骨架就不会有很多报错</li><li>补齐缺失的目录结构</li></ol><ul><li>不使用骨架</li></ul><ol><li>创建 maven 项目，在 pom.xml 中删除多余的坐标，设置打包方式为 war </li><li>补齐目录，在 facets 中加入当前项目，Deployment Descriptions 中加入 web.xml 的路径，修改 web Resources Directory 信息</li></ol><h3 id="IDEA-中使用-tomcat"><a href="#IDEA-中使用-tomcat" class="headerlink" title="IDEA 中使用 tomcat"></a>IDEA 中使用 tomcat</h3><p>将本地 Tomcat 集成到 IDEA 中，然后进行项目部署即可。</p><p>在 IDEA 中下载 smart tomcat 插件，点击 Add Configuration，选中 smart tomcat，配置 Tomcat server、Server port以及更改名字即可。</p><p>将 logging.properties 中 java.util.ConaoleHandler.encoding 改回 UTF-8 可以解决控制台乱码问题。</p><p>&#x3D;&#x3D;web主页名称默认为 index.html，其他名称需要按照：<a href="http://localhost:5443/a.html">http://localhost:5443/a.html</a> 这种方式访问&#x3D;&#x3D; </p><p>请求不存在的资源网页出现 404。</p><h4 id="IDEA-中使用-Tomcat-Tomcat-Maven-插件"><a href="#IDEA-中使用-Tomcat-Tomcat-Maven-插件" class="headerlink" title="IDEA 中使用 Tomcat - Tomcat Maven 插件"></a>IDEA 中使用 Tomcat - Tomcat Maven 插件</h4><ol><li>pom.xml 中添加 Tomcat 插件</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--   tomcat 插件   --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">port</span>&gt;</span>80<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 启动之后：http://localhost:80/tomcat-demo1 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">path</span>&gt;</span>/tomcat-demo1<span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>使用 Maven Helper 插件快速启动项目，选中项目，右键 -&gt; Run Maven -&gt; tomcat7:run</li></ol><p>如果需要调试则选择 Debug Maven -&gt; tomcat7:run</p><h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><p>Java EE 的规范之一，本质是一个接口，将来需要定义 Servlet 类实现 Servlet 接口，并由 web 服务器运行 Servlet</p><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><ol><li>创建 web 项目，导入 Servlet 依赖坐标</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>创建：定义一个类，实现 Servlet 接口，并重写接口中所有方法，并在 service 方法中输入一句话</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo1</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>配置：在类上使用 @WebServlet 注解，配置该 Servlet 的访问路径</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/demo1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo1</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>访问：启动 Tomcat，浏览器输入 URL 访问该 Servlet</li></ol><p>$\textcolor{green}{<a href="http://localhost:8080/web-demo%7D$%60/demo1%60">http://localhost:8080/web-demo}$`/demo1`</a> </p><p>例：port 为 80</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.web;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(&quot;/demo1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo1</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig servletConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ServletConfig <span class="title function_">getServletConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// service 方法是重头戏</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Servlet hello world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getServletInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问 <a href="http://localhost/demo1">http://localhost/demo1</a> 控制台输出 Servlet hello world!。</p><h2 id="Servlet-执行流程"><a href="#Servlet-执行流程" class="headerlink" title="Servlet 执行流程"></a>Servlet 执行流程</h2><p>例：<a href="http://localhost:8080/web-demo/demo1">http://localhost:8080/web-demo/demo1</a></p><p><a href="http://localhost:8080/">http://localhost:8080</a> 能够访问到 tomcat 服务器，web-demo为项目，demo1将访问 Servlet 。</p><p>在访问到 demo1 之后，由 tomcat 服务器创建 Servlet 对象创建 ServletDemo1 这个 Servlet 对象，再由tomcat 调用其中 service 方法，随后 service 方法将响应客户端请求，发送数据到客户端。</p><p>服务器如何知道 Servlet 中一定有 service 方法？</p><p>因为自定义的 Servlet 类要实现 Servlet 接口，就必须重写 service 方法。</p><h2 id="Servlet-生命周期"><a href="#Servlet-生命周期" class="headerlink" title="Servlet 生命周期"></a>Servlet 生命周期</h2><p>Servlet 运行在 Servlet 容器中（web服务器），其生命周期由容器来管理，分为四个阶段：</p><ol><li>加载和实例化：默认情况下，当 Servlet第一次被访问时，由容器（tomcat）来创建 Servlet 对象；</li><li>初始化：在 Servlet 实例化之后，容器将调用 Servlet 的 init 方法初始化这个对象，完成一些如加载配置文件、资源文件、创建链接等初始化的工作，该方法只调用一次；</li><li>请求处理：每次请求 Servlet 时，Servlet 容器（tomcat）都会调用 Servlet 的 service 方法对请求进行处理；</li><li>服务终止：当需要释放内存或者容器关闭时，容器（tomcat）就会调用Servlet 实例的 destroy 方法完成资源的释放。在 destroy 方法调用之后，容器会释放这个 Servlet 实例，该实例随后会被 Java 的垃圾收集器回收。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* loadOnStartUp 设为负整数表示在第一次访问时创建 Servlet 对象，0 或 正整数 表示服务器在启动时创建 Servlet 对象，数字越小优先级越高 */</span></span><br><span class="line"><span class="meta">@WebServlet(urlPatterns=&quot;demo&quot;, loadOnStartUp = 1)</span></span><br></pre></td></tr></table></figure><p>创建实际提前，目的是将比较耗时的 Servlet 对象的创建提前，便于访问。</p><p>使用 Maven tomcat 插件提供的便捷操作是看不到对象销毁的，所以在 Terminal 中输入 ：</p><p><code>mvn tomcat7:run</code> 多次访问 demo2 之后 Ctrl + C 终止进程。</p><p>&#x3D;&#x3D;与C++的构造析构相似&#x3D;&#x3D; </p><h2 id="Servlet-方法"><a href="#Servlet-方法" class="headerlink" title="Servlet 方法"></a>Servlet 方法</h2><ol><li>初始化方法，在 Servlet 被创建时执行，只执行一次</li></ol><p><code>vois init(ServletConfig config);</code> </p><ol start="2"><li>提供服务的方法，每次Servlet 被访问都会调用该方法</li></ol><p><code>void service(SerletRequest req, SerletResponse res);</code> </p><ol start="3"><li>销毁方法，当 Servlet 被销毁时，调用该方法。在内存释放或者服务器关闭时销毁 Servlet</li></ol><p><code>void dedtroy();</code> </p><ol start="4"><li>获取 ServletConfig 对象</li></ol><p><code>ServletConfig getServletConfig();</code> </p><p>init 方法接受了一个 ServletConfig 参数，只需要在 getServletConfig 方法中将其返回即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ServletConfig config;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig config)</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="built_in">this</span>.config = config;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> getServletConfig <span class="title function_">getgetServletConfig</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>获取 Servlet 信息</li></ol><p><code>String getServletInfo();</code> </p><p>Returns information about the Servlet, such as author, version and copyright.</p><p>一般不用，返回空字符串。</p><h2 id="Servlet-体系结构"><a href="#Servlet-体系结构" class="headerlink" title="Servlet 体系结构"></a>Servlet 体系结构</h2><ul><li>Servlet   –  Servlet 体系根接口</li><li>GenericServlet  – 继承自 Servlet，是 Servlet 抽象实现类</li><li>HttpServlet  –  继承自 GenericServlet，对 HTTP 协议封装的 Servlet 实现类</li></ul><p>B&#x2F;S 架构下的 web 项目都是针对于 HTTP 协议的，所以自定义的 Servlet 类要继承 HTTPServlet 类，重写 doGet 和 doPost 方法。</p><p>直接访问网页链接相当于使用 GET 方法请求资源，如需使用 POST 还要创建一个表单，method 设为 post：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- http://localhost:80/ 没有项目路径，不需要访问项目，直接访问 demo3 页面即可 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;demo3&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/demo3&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo3</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"><span class="comment">//        super.doGet(req, resp);</span></span><br><span class="line">        System.out.println(<span class="string">&quot;doGet&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"><span class="comment">//        super.doPost(req, resp);</span></span><br><span class="line">        System.out.println(<span class="string">&quot;doPost&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>为什么要根据请求方式的不同，调用不同的方法？</li></ul><p>因为需要请求方式不同，请求体的位置不同，service 需要根据请求体的内容进行相应的调整，所以有doGet 和 doPost 方法。</p><h3 id="HttpServlet-使用步骤"><a href="#HttpServlet-使用步骤" class="headerlink" title="HttpServlet 使用步骤"></a>HttpServlet 使用步骤</h3><ol><li>继承 HttpServlet </li><li>重写 doGet、doPost 方法</li></ol><h3 id="HttpServlet-原理"><a href="#HttpServlet-原理" class="headerlink" title="HttpServlet 原理"></a>HttpServlet 原理</h3><p>获取请求方式，根据不同的请求方式调用不同的方法。</p><h2 id="Servlet-urlPatterns-配置"><a href="#Servlet-urlPatterns-配置" class="headerlink" title="Servlet urlPatterns 配置"></a>Servlet urlPatterns 配置</h2><ul><li>Servlet 要想被访问，必须配置 urlPattern（访问路径）</li></ul><ol><li>一个 Servlet 可以配置多个 urlPattern</li></ol><p><code>@WebServlet(urlPatterns = &#123;&quot;/demo1&quot;, &quot;demo2&quot;&#125;)</code> </p><ol start="2"><li>urlPattern 配置规则</li></ol><ul><li>精确匹配</li></ul><p>配置路径：<code>@WebServlet(&quot;/user/select&quot;)</code> </p><p>访问路径：<a href="http://localhost/user/select">http://localhost:80/user/select</a></p><ul><li>目录匹配</li></ul><p>配置路径：<code>@WebServlet(&quot;/user/*&quot;)</code> </p><p>访问路径：</p><p><a href="http://localhost/user/a">http://localhost:80/user/a</a></p><p><a href="http://localhost/user/b">http://localhost:80/user/b</a> </p><ul><li>扩展名匹配</li></ul><p>配置路径：<code>@WebServlet(&quot;*.do&quot;)</code> </p><blockquote><p>注：扩展名不能以 &#x2F; 开头，否则报错</p></blockquote><p>访问路径：</p><p><a href="http://localhost/a.do">http://localhost:80/a.do</a></p><p><a href="http://localhost/b.do">http://localhost:80/b.do</a></p><ul><li>任意匹配</li></ul><p>配置路径：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/&quot;)</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/*&quot;)</span><span class="comment">// 优先级更高</span></span><br></pre></td></tr></table></figure><p>访问路径：</p><p><a href="http://localhost/aaa.html">http://localhost:80/aaa.html</a></p><p><a href="http://localhost/bbb.do">http://localhost:80/bbb.do</a></p><p><a href="http://localhost/ccc">http://localhost:80/ccc</a></p><h3 id="和-的区别"><a href="#和-的区别" class="headerlink" title="&#x2F; 和 &#x2F;* 的区别"></a>&#x2F; 和 &#x2F;* 的区别</h3><ul><li>当项目中的 Servlet 配置了 “&#x2F;“，会覆盖掉 tomcat 中的 DefaultServlet，当其他的 urlPattern 都匹配不上的时候，会走这个 Servlet</li><li>当项目中配置了 “&#x2F;*”，意味着匹配任意访问路径</li></ul><p>配置 “&#x2F;“ 会覆盖默认 Servlet，令静态资源无法访问，所以不推荐这项配置。</p><p>Servlet 优先级：</p><p>精确路径 &gt; 目录路径 &gt; 扩展名路径 &gt; &#x2F;* &gt; &#x2F;</p><h2 id="XML-方式编写-Servlet"><a href="#XML-方式编写-Servlet" class="headerlink" title="XML 方式编写 Servlet"></a>XML 方式编写 Servlet</h2><p>Servlet 在 3.0版本之后开始支持注解配置，3.0版本之前支支持 XML 配置文件的配置方式</p><ul><li><p>步骤：</p><ul><li>编写 Servlet 类</li><li>在 web.xml 中配置该 Servlet</li></ul>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>demo5<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.itheima.web.servlet.ServletDemo5<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>demo5<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/demo5<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>web.xml 文件中 <a href="http://java.sun.com/dtd/web-app_2_3.dtd">http://java.sun.com/dtd/web-app_2_3.dtd</a> 报错：将连接加入到 settings -&gt; Language &amp; Frameworks -&gt; 按加号将添加输入进去</p><h1 id="Request-Response"><a href="#Request-Response" class="headerlink" title="Request &amp; Response"></a>Request &amp; Response</h1><p>请求 与 响应</p><p>Servlet service方法中的两个参数。</p><ul><li>Request：获取请求数据</li><li>Response：设置响应数据，不需要自己返回</li></ul><p>小例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo6</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 使用 request 对象 获取请求数据，数据格式：http://localhost:5443/demo6?name=zhangsan</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 response 对象 设置响应数据</span></span><br><span class="line">        resp.setHeader(<span class="string">&quot;content-type&quot;</span>, <span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        resp.getWriter().write(<span class="string">&quot;&lt;h1&gt;&quot;</span>+name+<span class="string">&quot;，欢迎您！&quot;</span>+<span class="string">&quot;&lt;/h1&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;POST……&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h2><h3 id="Request-继承体系"><a href="#Request-继承体系" class="headerlink" title="Request 继承体系"></a>Request 继承体系</h3><ul><li>ServletRequest – Java 提供的请求对象根接口</li><li>HttpServletRequest – Java 提供的对 Http 协议封装的请求对象接口</li><li>RequestFacade – Tomcat 定义的实现类</li></ul><ol><li>Tomcat 需要解析请求数据，封装为 Request 对象，并且创建 Request 对象传递到 service 方法中</li><li>使用 Request 对象。查阅 Java EE API 文档的 HttpServletRequest 接口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出 request 信息</span></span><br><span class="line">System.out.println(req);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出信息：</span></span><br><span class="line">org.apache.catalina.connector.RequestFacade@6aa0a56d</span><br></pre></td></tr></table></figure><h3 id="Request-获取请求数据"><a href="#Request-获取请求数据" class="headerlink" title="Request 获取请求数据"></a>Request 获取请求数据</h3><p>请求数据划分</p><ol><li>请求行</li></ol><p>组成：请求方式 + 资源路径 + 参数 + 协议</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET/request-demo/req1?username=zhangsan HTTP/1.1</span><br></pre></td></tr></table></figure><ul><li>String getMethod()：获取请求方式：GET</li><li>String getContextPath()：获取虚拟目录（项目访问路径）：&#x2F;request-demo</li><li>StringBuffer getRequestURL()：（统一资源定位符）：<a href="http://localhost:8080/request-demo/req1">http://localhost:8080/request-demo/req1</a></li><li>String getrequestURI()：获取URI（统一资源标识符）：&#x2F;request-demo&#x2F;req1</li><li>String getQueryString()：获取请求参数（GET方式）：username&#x3D;zhangsan&amp;password&#x3D;123</li></ul><ol start="2"><li>请求头</li></ol><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 Chrome/91.0.4472.106</span><br></pre></td></tr></table></figure><ul><li>String getHeader(String name)：根据请求头名称，获取值</li></ul><ol start="3"><li>请求体</li></ol><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username=superbaby&amp;password=123</span><br></pre></td></tr></table></figure><ul><li>ServletInputStream getInputStream()：获取字节输入流</li><li>BufferReader getReader()：获取字符输入流</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo7</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取请求内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> req</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resp</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ServletException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">/* 请求行 */</span></span><br><span class="line">        <span class="comment">// String getMethod()：获取请求方式：GET</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> req.getMethod();</span><br><span class="line">        System.out.println(method);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// String getContextPath()：获取虚拟目录（项目访问路径）：/tomcat-demo1</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">contextPath</span> <span class="operator">=</span> req.getContextPath();</span><br><span class="line">        System.out.println(contextPath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// StringBuffer getRequestURL()：获取 URL（统一资源定位符）：http://localhost:8080/tomcat-demo1/req1</span></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">url</span> <span class="operator">=</span> req.getRequestURL();</span><br><span class="line">        System.out.println(url);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// String getRequestURI()：获取 URI（统一资源标识符）：/tomcat-demo1/req1</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">uri</span> <span class="operator">=</span> req.getRequestURI();</span><br><span class="line">        System.out.println(uri);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// String getQueryString()：获取请求参数（GET方式）：username=zhangsan&amp;password=123</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">query</span> <span class="operator">=</span> req.getQueryString();</span><br><span class="line">        System.out.println(query);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 请求头 */</span></span><br><span class="line">        <span class="comment">// String getHeader()：获取请求头：user-Agent：表示浏览器版本</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">userAgent</span> <span class="operator">=</span> req.getHeader(<span class="string">&quot;user-Agent&quot;</span>);</span><br><span class="line">        System.out.println(userAgent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * doPost方法可以调用 doGet方法实现简化相同操作功能</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> req</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resp</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ServletException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">/* 请求体（POST专有） */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// doGet(req, resp);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 获取的是 text数据（文本数据）。使用字符流；否则使用字节流</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> req.getReader();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 读取数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> br.readLine();</span><br><span class="line">        System.out.println(line);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;如果GET和POST请求的处理逻辑一样，可以直接在doPost方法中调用doPost方法，不用再多写一遍。&#x3D;&#x3D; </p><h3 id="Request-通用方式获取请求参数"><a href="#Request-通用方式获取请求参数" class="headerlink" title="Request 通用方式获取请求参数"></a>Request 通用方式获取请求参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在这里一并解决请求参数中文乱码的问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestDemo8</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// Get 请求逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;GET……&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 获取所有参数的Map集合</span></span><br><span class="line">        System.out.println(<span class="string">&quot;解决前：&quot;</span>);</span><br><span class="line">        Map&lt;String, String[]&gt; map = req.getParameterMap();</span><br><span class="line">        <span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">            <span class="comment">// 输出格式：1username: zhangSan</span></span><br><span class="line">            System.out.print(key + <span class="string">&quot;: &quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取值</span></span><br><span class="line">            String[] values = map.get(key);</span><br><span class="line">            <span class="keyword">if</span> (values != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (String value : values) &#123;</span><br><span class="line">                    System.out.print(value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;\n---------------&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 根据 key获取参数值，数组</span></span><br><span class="line">        String[] hobbies = req.getParameterValues(<span class="string">&quot;hobby&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (hobbies != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String hobby : hobbies) &#123;</span><br><span class="line">                System.out.println(hobby);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 根据 key获取单个参数的值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;解决后：&quot;</span>);</span><br><span class="line">        <span class="comment">// GET和 POST的通用解决方式，使用插件放开这句，使用本地 tomcat 则注释，不然结果会相反</span></span><br><span class="line">        <span class="comment">// username = new String(username.getBytes(StandardCharsets.ISO_8859_1), StandardCharsets.UTF_8);</span></span><br><span class="line">        System.out.println(<span class="string">&quot;username: &quot;</span> + username);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;password&quot;</span> + password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// POST 请求逻辑</span></span><br><span class="line">        <span class="comment">// 解决 POST 乱码</span></span><br><span class="line">        <span class="comment">// req.setCharacterEncoding(&quot;UTF-8&quot;);</span></span><br><span class="line">        System.out.println(<span class="string">&quot;POST……&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>POST 与 GET 切换之前需要运行 maven package。</p><h4 id="使用小工具提高创建-Servlet-的效率"><a href="#使用小工具提高创建-Servlet-的效率" class="headerlink" title="使用小工具提高创建 Servlet 的效率"></a>使用小工具提高创建 Servlet 的效率</h4><p>IDEA 社区版用不了</p><p>专业版配置：</p><p>settings -&gt; File and Code Templates -&gt; other -&gt; web -&gt; Servlet Annotated Class.java</p><p>配置如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/$&#123;Entity_Name&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">$</span>&#123;Class_Name&#125; <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="请求参数中文乱码"><a href="#请求参数中文乱码" class="headerlink" title="请求参数中文乱码"></a>请求参数中文乱码</h3><ul><li>POST 方式请求</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="comment">// POST 请求逻辑</span></span><br><span class="line">    <span class="comment">// 解决 POST 乱码</span></span><br><span class="line">    req.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;POST……&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.doGet(req, resp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过设置编码格式为宽字符集。</p><ul><li>GET 和 POST 的通用解决方式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.net.URLDecoder;</span><br><span class="line"><span class="keyword">import</span> java.net.URLEncoder;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">URLDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;张三&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. URL编码（不处理异常，抛出）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">encode</span> <span class="operator">=</span> URLEncoder.encode(name, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        System.out.println(encode);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. URL解码(ISO-8859-1是Tomcat的默认解码方式）</span></span><br><span class="line">        <span class="comment">// String decode = URLDecoder.decode(encode,&quot;utf-8&quot;);</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">decode</span> <span class="operator">=</span> URLDecoder.decode(encode, <span class="string">&quot;ISO-8859-1&quot;</span>);</span><br><span class="line">        System.out.println(decode);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 Tomcat 的解码转为字节码再转回 utf-8 编码方式下的字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(decode.getBytes(StandardCharsets.ISO_8859_1), StandardCharsets.UTF_8);</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Request-请求转发"><a href="#Request-请求转发" class="headerlink" title="Request 请求转发"></a>Request 请求转发</h3><p>一种在服务器内部的资源跳转方式</p><p><code>request.setRequestDispatchar(&quot;资源 B 路径&quot;).forward(request, response);</code> </p><h4 id="请求转发资源间共享数据"><a href="#请求转发资源间共享数据" class="headerlink" title="请求转发资源间共享数据"></a>请求转发资源间共享数据</h4><ul><li>void setAttribute(String name, Object o)：存储数据到 request域中</li><li>Object getAttribute(String name)：根据 key 获取 相应的 属性值</li><li>void removeAttribute()：根据 key 删除该键值对</li></ul><h4 id="请求转发的特点"><a href="#请求转发的特点" class="headerlink" title="请求转发的特点"></a>请求转发的特点</h4><ul><li>浏览器地址栏不发生变化</li><li>只能转发到当前服务器的内部资源</li><li>一次请求，可以在转发的资源见使用 request 共享数据</li></ul><p>Http 请求的特点中有一条是：请求与请求之间相互独立，资源不能共享。但是使用 Java Servlet 技术弥补了这个缺点。</p><h2 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h2><h3 id="Response-继承体系"><a href="#Response-继承体系" class="headerlink" title="Response 继承体系"></a>Response 继承体系</h3><ul><li>ServletResponse – Java提供的请求对象根接口</li><li>HttpServletResponse – Java 提供的对 Http 协议封装的请求对象</li><li>ResponseFacade – Tomcat 定义的实现类</li></ul><h3 id="设置响应数据"><a href="#设置响应数据" class="headerlink" title="设置响应数据"></a>设置响应数据</h3><ol><li>响应行</li></ol><p><code>HTTP/1.1 200 OK</code> </p><p>版本不需要自己去设置，需要设置的只有响应状态码</p><p><code>void setStatus(int sc)：设置响应状态码</code> </p><ol start="2"><li>响应头</li></ol><p><code>Content-Type: text/html</code> </p><p><code>void setHeader(String key, String value)：设置响应头键值对</code> </p><ol start="3"><li>响应体</li></ol><p><code>&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;：text/html 格式的响应体</code> </p><p><code>PrintWriter getWriter()：获取字符输出流</code> </p><p><code>ServletoutputStream getOutputStream()：获取字节输出流</code> </p><p>本章开头的第一个例子已经介绍了响应数据的设置方法（教程没有提供案例）。</p><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>一种资源跳转的方式</p><p>实现方式：</p><ol><li>分步实现</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 设置响应状态码</span></span><br><span class="line">resp.setStatus(<span class="number">302</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 设置响应头，需要添加虚拟路径</span></span><br><span class="line">resp.setHeader(<span class="string">&quot;Location&quot;</span>, <span class="string">&quot;/tomcat-demo1/resp2&quot;</span>);</span><br></pre></td></tr></table></figure><ol start="2"><li>偷懒写法</li></ol><p><code>resp.sendRedirect(&quot;/tomcat-demo1/resp2&quot;);</code>  </p><p>重定向特点：</p><ul><li>浏览器地址栏路径栏发生变化</li><li>可以重定向到任意位置的资源（服务器内部、外部均可）</li><li>两次请求，不能再多个资源使用 request 共享数据</li></ul><h4 id="资源路径问题"><a href="#资源路径问题" class="headerlink" title="资源路径问题"></a>资源路径问题</h4><ul><li><p>浏览器使用：需要加虚拟路径（项目访问路径）</p></li><li><p>服务器使用：不需要加虚拟路径</p></li><li><p><code>&lt;a href=&quot;路径&quot; &gt; </code> 加虚拟目录</p></li><li><p><code>&lt;form action=&quot;路径&quot; &gt;</code>   加虚拟路径</p></li><li><p><code>response.getRequestDispatcher(&quot;路径&quot;)</code> 不加虚拟加路径</p></li><li><p><code>response.sendRedirect(&quot;路径&quot;)</code>  加虚拟路径</p></li></ul><h4 id="动态获取虚拟路径"><a href="#动态获取虚拟路径" class="headerlink" title="动态获取虚拟路径"></a>动态获取虚拟路径</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态获取虚拟路径</span></span><br><span class="line"><span class="type">String</span> <span class="variable">contextPath</span> <span class="operator">=</span> req.getContextPath();</span><br><span class="line">resp.sendRedirect(contextPath + <span class="string">&quot;/resp2&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="响应字符数据"><a href="#响应字符数据" class="headerlink" title="响应字符数据"></a>响应字符数据</h3><p>使用</p><ol><li>通过 Response 对下对象获取字符输出流</li></ol><p><code>PrintWriter writer = resp.getWriter();</code> </p><ol start="2"><li>写数据</li></ol><p><code>writer.write(&quot;aaa&quot;);</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 响应字符数据：设置字符数据的响应体</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResponseDemo3</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 不写这一句也可以识别出 HTML标签</span></span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 获取字符输出流，设置编码格式</span></span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> resp.getWriter();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 设置 Content-Type，展示网页页面</span></span><br><span class="line">        <span class="comment">// resp.setHeader(&quot;Content-Type&quot;, &quot;text/html&quot;);</span></span><br><span class="line">        writer.write(<span class="string">&quot;&lt;h1&gt;张三&lt;/h1&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不需要关闭流</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在高版本的 tomcat 中，不设置 Content-Type 为 text&#x2F;html 也是可以识别得出 html 标签的，但是需要 设置 response 的字符集为 GBK。</p><ul><li>这里的流不需要关闭，随着响应结束，response 对象被销毁，有服务器自行关闭</li><li>出现中文数据乱码的原因是 tomcat 默认编码是 ISO-8859-1。</li></ul><p>可以使用下面一行代码同时设置响应行格式以及字符集：</p><p><code>resp.setContentType(&quot;text/html;charset=utf-8&quot;);</code> </p><h3 id="响应字节数据"><a href="#响应字节数据" class="headerlink" title="响应字节数据"></a>响应字节数据</h3><p>使用：</p><ol><li>通过使用 Response 对象获取字符输出流</li></ol><p><code>ServletOutputStream os = resp.getOutputStream();</code> </p><ol start="2"><li>写数据</li></ol><p><code>os.write(字节数据);</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 响应字节数据：设置字节数据的响应体</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/resp4&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResponseDemo4</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 1. 读取文件</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;C:\\Users\\33257\\Pictures\\bigpic\\a.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 获取 Response 对象字节输出流</span></span><br><span class="line">        <span class="type">ServletOutputStream</span> <span class="variable">os</span> <span class="operator">=</span> resp.getOutputStream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 完成流的 copy（对拷）</span></span><br><span class="line"><span class="comment">//        byte[] buff = new byte[1024];</span></span><br><span class="line"><span class="comment">//        int len = 0;</span></span><br><span class="line"><span class="comment">//        while ((len = file.read(buff)) != -1) &#123;</span></span><br><span class="line"><span class="comment">//            os.write(buff, 0, len);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        os.close();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用工具类完成流的 copy</span></span><br><span class="line">        IOUtils.copy(file, os);</span><br><span class="line"></span><br><span class="line">        file.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>IOUtils 工具类导入</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用数据流对拷的方法：copy</p><p><code>IOUtils.copy(FileInputStream, ServletOutputStream);</code> </p><h3 id="用户登录注册"><a href="#用户登录注册" class="headerlink" title="用户登录注册"></a>用户登录注册</h3><p>流程说明：</p><ol><li>用户填写用户名密码，提交到 LoginServlet</li><li>在 LoginServlet 中使用 Mybatis 查询数据库，验证用户名密码是否正确</li><li>如果正确，响应登录成功，反之，响应登录失败</li></ol><p>算是简单的登录接口</p><p>pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--   tomcat 插件   --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">port</span>&gt;</span>80<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- 启动之后：http://localhost:80/Demo --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">path</span>&gt;</span>/Demo<span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.20<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>mybatis-config.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;UTF-8&#x27;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org/DTD Mapper 3.0 //EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span> &gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.example.pojo&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 连接池信息 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql:///db1?useSSL=false<span class="symbol">&amp;amp;</span>useServerPrepStmts=true<span class="symbol">&amp;amp;</span>serverTimezone=UTC&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.example.mapper&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>UserMapper</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Insert;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Param;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Select;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用用户名密码判断用户是否存在</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username 用户名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> password 密码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> User</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Select(&quot;select * from user where username = #&#123;username&#125; and password = #&#123;password&#125;&quot;)</span></span><br><span class="line">    User <span class="title function_">select</span><span class="params">(<span class="meta">@Param(&quot;username&quot;)</span> String username, <span class="meta">@Param(&quot;password&quot;)</span>String password)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;select * from user where username = #&#123;username&#125;&quot;)</span></span><br><span class="line">    User <span class="title function_">selectByUsername</span><span class="params">(String username)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert(&quot;insert into user values(null, #&#123;username&#125;, #&#123;password&#125;)&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">insertUser</span><span class="params">(User user)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;UTF-8&#x27;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org/DTD Mapper 3.0 EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.example.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>登录：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/ServletDemo1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo1</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 属性与页面部件对应</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// mybatis 使用</span></span><br><span class="line">        <span class="comment">// 1. 获取 SqlSessionFactory对象</span></span><br><span class="line"><span class="comment">//        String resource = &quot;mybatis-config.xml&quot;;</span></span><br><span class="line"><span class="comment">//        InputStream in = Resources.getResourceAsStream(resource);</span></span><br><span class="line"><span class="comment">//        SqlSessionFactory ssf = new SqlSessionFactoryBuilder().build(in);</span></span><br><span class="line"></span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> SqlSessionFactoryUtil.getSqlSessionFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 获取 SqlSession</span></span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 Mapper</span></span><br><span class="line">        <span class="type">UserMapper</span> <span class="variable">userMapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用方法</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.select(username, password);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 response格式</span></span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> resp.getWriter();</span><br><span class="line">        <span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">            writer.write(<span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">            writer.write(<span class="string">&quot;登录失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/ServletDemo2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo2</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setUsername(username);</span><br><span class="line">        user.setPassword(password);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 SqlSessionFactory 对象</span></span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> SqlSessionFactoryUtil.getSqlSessionFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 获取 SqlSession</span></span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 Mapper</span></span><br><span class="line">        <span class="type">UserMapper</span> <span class="variable">userMapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行方法，获取返回值</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> userMapper.selectByUsername(username);</span><br><span class="line">        <span class="keyword">if</span> (u != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 数据库中已有此人</span></span><br><span class="line">            resp.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">            <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> resp.getWriter();</span><br><span class="line">            writer.write(<span class="string">&quot;用户名已存在&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 数据库中没有此人，执行添加</span></span><br><span class="line">            userMapper.insertUser(user);</span><br><span class="line">            sqlSession.close();</span><br><span class="line">        &#125;</span><br><span class="line">        sqlSession.commit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SqlSessionFactoryUtil</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.io.Resources;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取sqlSession的工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SqlSessionFactoryUtil</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            in = Resources.getResourceAsStream(resource);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        sqlSessionFactory = <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(in);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SqlSessionFactory <span class="title function_">getSqlSessionFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>为什么没有一步到位返回 SqlSession 对象或者将获取 SqlSession 对象的代码一起封装？</li></ul><p>封装 SqlSession 对象意味着返回的都将是同一个 SqlSession 对象，也就是所有的代码使用的是同一个连接。</p><ol><li><p>抽取 SqlSesionFactory 工具类，实现代码复用</p></li><li><p>不再创建多个 SqlSessionFactory，提高资源利用率</p></li></ol><h1 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h1><ul><li><p>Java Server Page，服务端页面</p></li><li><p>一种 <font size=5 color=Red>过时的</font> 动态网页技术，其中即可以定义HTML、CSS、JS 等静态内容，还可以定义 Java 代码提供的动态内容</p></li><li><p>JSP &#x3D; HTML + Java，用于简化开发</p></li><li><p>本质上是一个 Servlet</p></li></ul><blockquote><p> Tomcat会自动将 jsp 文件转换成 java 文件，编译运行之后的 .class 文件。</p></blockquote><h2 id="脚本书写"><a href="#脚本书写" class="headerlink" title="脚本书写"></a>脚本书写</h2><p>作用：在 JSP 页面内定义 Java 代码</p><p>分类：</p><ol><li><p>&lt;% … %&gt;：内容会放到 _jspService() 方法中</p></li><li><p>&lt;%&#x3D; … %&gt;：内容会放到 out.print() 中，作为 out.print() 的参数</p></li><li><p>&lt;%! … %&gt;：内容会放到 _jspService() 方法之外，被类包含</p></li></ol><p>缺点：</p><ul><li>书写麻烦</li><li>阅读麻烦</li><li>复杂度高，依赖项多</li><li>占用磁盘空间（java文件和class文件）</li><li>调试困难</li><li>耦合程度高</li></ul><h2 id="EL-表达式"><a href="#EL-表达式" class="headerlink" title="EL 表达式"></a>EL 表达式</h2><ul><li>Expression Language 表达式语言，用于简化 JSP 页面内代码</li></ul><p>主要用于获取数据</p><ul><li><p>语法：${expression}：获取于中存储的 key 为 expression 的数据</p></li><li><p>Java web 中的四大域对象</p></li></ul><ol><li>page：当前页面有效</li><li>request：当前请求有效</li><li>session：当前会话有效</li><li>application：当前应用有效</li></ol><p>EL表达式获取数据，会依次从四个域中寻找，直至找到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/Demo1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo1</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 1. 数据</span></span><br><span class="line">        List&lt;Brand&gt; brands = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        brands.add(<span class="keyword">new</span> <span class="title class_">Brand</span>(<span class="number">1</span>, <span class="string">&quot;三只松鼠&quot;</span>,<span class="string">&quot;三只松鼠&quot;</span>, <span class="number">100</span>, <span class="string">&quot;好吃不上火&quot;</span>, <span class="number">1</span>));</span><br><span class="line">        brands.add(<span class="keyword">new</span> <span class="title class_">Brand</span>(<span class="number">2</span>, <span class="string">&quot;锤子&quot;</span>,<span class="string">&quot;锤子科技&quot;</span>, <span class="number">200</span>, <span class="string">&quot;创造&quot;</span>, <span class="number">0</span>));</span><br><span class="line">        brands.add(<span class="keyword">new</span> <span class="title class_">Brand</span>(<span class="number">3</span>, <span class="string">&quot;小米&quot;</span>,<span class="string">&quot;小米科技有限公司&quot;</span>, <span class="number">1000</span>, <span class="string">&quot;为发烧而生&quot;</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 存储到 request 中，转发</span></span><br><span class="line">        req.setAttribute(<span class="string">&quot;brands&quot;</span>, brands);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 请求转发到 El.jsp</span></span><br><span class="line">        req.getRequestDispatcher(<span class="string">&quot;/El.jsp&quot;</span>).forward(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    $&#123;brands&#125;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="JSTL"><a href="#JSTL" class="headerlink" title="JSTL"></a>JSTL</h2><p>Java Server Page Standard Tag Library，使用标签取代 JSP 页面上的 Java 代码</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:<span class="keyword">if</span> test=<span class="string">&quot;$&#123;flag == 1&#125;&quot;</span>&gt;男&lt;/c:<span class="keyword">if</span>&gt;</span><br><span class="line">&lt;c:<span class="keyword">if</span> test=<span class="string">&quot;$&#123;flag == 2&#125;&quot;</span>&gt;女&lt;/c:<span class="keyword">if</span>&gt;</span><br></pre></td></tr></table></figure><p>$\textcolor{Green}{&lt;c:if&gt;</c:if>}$ 标签与在 Java 程序中使用的 if 语句作用相同</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;%@ taglib prefix=<span class="string">&quot;c&quot;</span> uri=<span class="string">&quot;http://java.sun.com/jsp/jstl/core&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;%-- c:<span class="keyword">if</span> 用于逻辑判断，替换 Java 的 <span class="keyword">if</span>-<span class="keyword">else</span> 代码块 --%&gt;</span><br><span class="line">    &lt;c:<span class="keyword">if</span> test=<span class="string">&quot;$&#123;status == true&#125;&quot;</span>&gt;</span><br><span class="line">        &lt;h1&gt;<span class="literal">true</span>&lt;/h1&gt;</span><br><span class="line">    &lt;/c:<span class="keyword">if</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;c:<span class="keyword">if</span> test=<span class="string">&quot;$&#123;status == false&#125;&quot;</span>&gt;</span><br><span class="line">        &lt;h2&gt;<span class="literal">false</span>&lt;/h2&gt;</span><br><span class="line">    &lt;/c:<span class="keyword">if</span>&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>dependencies</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--   jstl标签依赖     --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>taglibs<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>standard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><font size=4 color=purple>$&lt;c:foreach&gt;$</font> 基础迭代标签</p><p>相当于 enhanced for 循环</p><ul><li>items：被遍历的容器</li><li>var：遍历产生的临时变量</li><li>varStatus：遍历状态对象<ul><li>index：从 0 开始</li><li>count：从 1 开始</li></ul></li></ul><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;%@ taglib prefix=<span class="string">&quot;c&quot;</span> uri=<span class="string">&quot;http://java.sun.com/jsp/jstl/core&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;%-- c:<span class="keyword">if</span> 用于逻辑判断，替换 Java 的 <span class="keyword">if</span>-<span class="keyword">else</span> 代码块 --%&gt;</span><br><span class="line">    &lt;c:<span class="keyword">if</span> test=<span class="string">&quot;$&#123;status == true&#125;&quot;</span>&gt;</span><br><span class="line">        &lt;h1&gt;<span class="literal">true</span>&lt;/h1&gt;</span><br><span class="line">    &lt;/c:<span class="keyword">if</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;c:<span class="keyword">if</span> test=<span class="string">&quot;$&#123;status == false&#125;&quot;</span>&gt;</span><br><span class="line">        &lt;h2&gt;<span class="literal">false</span>&lt;/h2&gt;</span><br><span class="line">    &lt;/c:<span class="keyword">if</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;input type=<span class="string">&quot;button&quot;</span> value=<span class="string">&quot;新增&quot;</span>&gt; &lt;br&gt;</span><br><span class="line">    &lt;hr&gt;</span><br><span class="line">    &lt;table border=<span class="string">&quot;1&quot;</span> cellspacing=<span class="string">&quot;0&quot;</span> width=<span class="string">&quot;800&quot;</span>&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;th&gt;序号&lt;/th&gt;</span><br><span class="line">            &lt;th&gt;品牌名&lt;/th&gt;</span><br><span class="line">            &lt;th&gt;企业名&lt;/th&gt;</span><br><span class="line">            &lt;th&gt;排序&lt;/th&gt;</span><br><span class="line">            &lt;th&gt;描述&lt;/th&gt;</span><br><span class="line">            &lt;th&gt;状态&lt;/th&gt;</span><br><span class="line">            &lt;th&gt;操作&lt;/th&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line"></span><br><span class="line">        &lt;c:forEach items=<span class="string">&quot;$&#123;brands&#125;&quot;</span> <span class="keyword">var</span>=<span class="string">&quot;brand&quot;</span> varStatus=<span class="string">&quot;sequence&quot;</span>&gt;</span><br><span class="line">        &lt;tr align=<span class="string">&quot;center&quot;</span>&gt;</span><br><span class="line">            &lt;td&gt;</span><br><span class="line">                    $&#123;sequence.count&#125;</span><br><span class="line">            &lt;/td&gt;</span><br><span class="line">            &lt;td&gt;</span><br><span class="line">                    $&#123;brand.brandName&#125;</span><br><span class="line">            &lt;/td&gt;</span><br><span class="line">            &lt;td&gt;</span><br><span class="line">                    $&#123;brand.companyName&#125;</span><br><span class="line">            &lt;/td&gt;</span><br><span class="line">            &lt;td&gt;</span><br><span class="line">                    $&#123;brand.ordered&#125;</span><br><span class="line">            &lt;/td&gt;</span><br><span class="line">            &lt;td&gt;</span><br><span class="line">                    $&#123;brand.description&#125;</span><br><span class="line">            &lt;/td&gt;</span><br><span class="line">            &lt;td&gt;</span><br><span class="line">                &lt;c:<span class="keyword">if</span> test=<span class="string">&quot;$&#123;brand.status == 1&#125;&quot;</span>&gt;</span><br><span class="line">                    启用</span><br><span class="line">                &lt;/c:<span class="keyword">if</span>&gt;</span><br><span class="line">                &lt;c:<span class="keyword">if</span> test=<span class="string">&quot;$&#123;brand.status == 0&#125;&quot;</span>&gt;</span><br><span class="line">                    禁用</span><br><span class="line">                &lt;/c:<span class="keyword">if</span>&gt;</span><br><span class="line">            &lt;/td&gt;</span><br><span class="line">            &lt;td&gt;&lt;a href=<span class="string">&quot;#&quot;</span>&gt;修改&lt;/a&gt;  &lt;a href=<span class="string">&quot;#&quot;</span>&gt;删除&lt;/a&gt;&lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">        &lt;/c:forEach&gt;</span><br><span class="line">    &lt;/table&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>其他遍历方式：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;%-- 与普通 <span class="keyword">for</span> 循环相同，变量 i 从 <span class="number">0</span> 开始，步长为 <span class="number">1</span>，终点是 <span class="number">10</span> --%&gt;</span><br><span class="line">&lt;c:foreach begin=<span class="string">&quot;0&quot;</span> end=<span class="string">&quot;10&quot;</span> step=<span class="string">&quot;1&quot;</span> <span class="keyword">var</span>=<span class="string">&quot;i&quot;</span>&gt;</span><br><span class="line">    $&#123;i&#125;</span><br><span class="line">&lt;/c:foreach&gt;</span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意这里是 小于等于</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    Syetem.out.print(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font size=4 color=purple>$&lt;c:foreach&gt;$</font> 可用于分页。</p><h2 id="MVC-模式及其架构"><a href="#MVC-模式及其架构" class="headerlink" title="MVC 模式及其架构"></a>MVC 模式及其架构</h2><p>jsp 的引入使得前后端代码耦合程度更加严重，MVC 模式是一种分层开发的模式，其中：</p><ul><li>M：Model，业务模型，处理业务</li><li>V：View，视图，界面展示</li><li>C：Controller，控制器，处理请求，调用模型和视图</li></ul><p>浏览器请求控制器，控制器通过将模型返回的数据传递到视图层，达到在视图层展示数据的效果。</p><p>优点：</p><ul><li>职责单一，互不影响</li><li>有利于分工协作</li><li>有利于组件重用（代码复用）</li></ul><p>三层架构：</p><ul><li>表现层：接受请求，封装数据，调用业务逻辑层，响应数据（Controller、View）[Servlet、JSP]</li><li>业务逻辑层：对业务逻辑进行封装，组合数据访问层中基本功能，形成复杂的业务逻辑功能（注册功能的实现：查询是否存在，存在返回提示，不存在则插入）</li><li>数据访问层（持久层）：对数据库的 CRUD 基本操作（增删改查）[mybatis]</li></ul><p>MVC 的代码结构：</p><ul><li>表现层：com.example.web&#x2F;controller                                                    springMVC</li><li>业务逻辑层：com.example.service                                                                  spring</li><li>数据访问层：com.example.dao&#x2F;mapper（Data Access Object）                  MyBatis</li></ul><h2 id="完成品牌案例增删改查"><a href="#完成品牌案例增删改查" class="headerlink" title="完成品牌案例增删改查"></a>完成品牌案例增删改查</h2><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><h4 id="Mapper-Dao"><a href="#Mapper-Dao" class="headerlink" title="Mapper &#x2F; Dao"></a>Mapper &#x2F; Dao</h4><p>BrandMapper 接口–提供数据库增删改查的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BrandMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询所有品牌</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Select(&quot;select * from tb_brand&quot;)</span></span><br><span class="line">    <span class="meta">@ResultMap(&quot;brandResultMap&quot;)</span></span><br><span class="line">    List&lt;Brand&gt; <span class="title function_">selectAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BrandMapper.xml–mybatis 查询配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;UTF-8&#x27;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org/DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.example.mapper.BrandMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;brandResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;brand&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;brand_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;brandName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;company_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;companyName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h4><p>BrandService–使用 SQL 的层面，有大量可复用的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BrandService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> SqlSessionFactoryUtil.getSqlSessionFactory();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询所有品牌的信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Brand&gt; <span class="title function_">selectAll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 调用 BrandMapper.selectAll方法</span></span><br><span class="line">        <span class="comment">// 获取 SqlSession</span></span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">        <span class="comment">// 获取 Mapper</span></span><br><span class="line">        <span class="type">BrandMapper</span> <span class="variable">brandMapper</span> <span class="operator">=</span> sqlSession.getMapper(BrandMapper.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查询</span></span><br><span class="line">        List&lt;Brand&gt; brands = brandMapper.selectAll();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> brands;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Servlet-1"><a href="#Servlet-1" class="headerlink" title="Servlet"></a>Servlet</h4><p>SelectAllServlet–查询所有信息的 Servlet，添加所有信息到请求中，将请求转发到 brands.jsp </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/selectAllServlet&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectAllServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">BrandService</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BrandService</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 1. 调用 BrandService完成查询</span></span><br><span class="line">        List&lt;Brand&gt; brands = service.selectAll();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 请求转发</span></span><br><span class="line">        req.setAttribute(<span class="string">&quot;brands&quot;</span>, brands);</span><br><span class="line">        req.getRequestDispatcher(<span class="string">&quot;/brands.jsp&quot;</span>).forward(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用了 selectAll 方法，并且将返回的数据发送到了 brands.jsp 中。</p><h4 id="View"><a href="#View" class="headerlink" title="View"></a>View</h4><p>brands.jsp–相当于是一个 Servlet，主要作用是展示所有数据。</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;%@ taglib prefix=<span class="string">&quot;c&quot;</span> uri=<span class="string">&quot;http://java.sun.com/jsp/jstl/core&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;%-- c:<span class="keyword">if</span> 用于逻辑判断，替换 Java 的 <span class="keyword">if</span>-<span class="keyword">else</span> 代码块 --%&gt;</span><br><span class="line">&lt;c:<span class="keyword">if</span> test=<span class="string">&quot;$&#123;status == true&#125;&quot;</span>&gt;</span><br><span class="line">    &lt;h1&gt;<span class="literal">true</span>&lt;/h1&gt;</span><br><span class="line">&lt;/c:<span class="keyword">if</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;c:<span class="keyword">if</span> test=<span class="string">&quot;$&#123;status == false&#125;&quot;</span>&gt;</span><br><span class="line">    &lt;h2&gt;<span class="literal">false</span>&lt;/h2&gt;</span><br><span class="line">&lt;/c:<span class="keyword">if</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;input type=<span class="string">&quot;button&quot;</span> value=<span class="string">&quot;新增&quot;</span>&gt; &lt;br&gt;</span><br><span class="line">&lt;hr&gt;</span><br><span class="line">&lt;table border=<span class="string">&quot;1&quot;</span> cellspacing=<span class="string">&quot;0&quot;</span> width=<span class="string">&quot;80%&quot;</span>&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;th&gt;序号&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;品牌名&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;企业名&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;排序&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;描述&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;状态&lt;/th&gt;</span><br><span class="line">        &lt;th width=<span class="string">&quot;100&quot;</span>&gt;操作&lt;/th&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line"></span><br><span class="line">    &lt;c:forEach items=<span class="string">&quot;$&#123;brands&#125;&quot;</span> <span class="keyword">var</span>=<span class="string">&quot;brand&quot;</span> varStatus=<span class="string">&quot;sequence&quot;</span>&gt;</span><br><span class="line">        &lt;tr align=<span class="string">&quot;center&quot;</span>&gt;</span><br><span class="line">            &lt;td&gt;</span><br><span class="line">                    $&#123;sequence.count&#125;</span><br><span class="line">            &lt;/td&gt;</span><br><span class="line">            &lt;td&gt;</span><br><span class="line">                    $&#123;brand.brandName&#125;</span><br><span class="line">            &lt;/td&gt;</span><br><span class="line">            &lt;td&gt;</span><br><span class="line">                    $&#123;brand.companyName&#125;</span><br><span class="line">            &lt;/td&gt;</span><br><span class="line">            &lt;td&gt;</span><br><span class="line">                    $&#123;brand.ordered&#125;</span><br><span class="line">            &lt;/td&gt;</span><br><span class="line">            &lt;td&gt;</span><br><span class="line">                    $&#123;brand.description&#125;</span><br><span class="line">            &lt;/td&gt;</span><br><span class="line">            &lt;td&gt;</span><br><span class="line">                &lt;c:<span class="keyword">if</span> test=<span class="string">&quot;$&#123;brand.status == 1&#125;&quot;</span>&gt;</span><br><span class="line">                    启用</span><br><span class="line">                &lt;/c:<span class="keyword">if</span>&gt;</span><br><span class="line">                &lt;c:<span class="keyword">if</span> test=<span class="string">&quot;$&#123;brand.status == 0&#125;&quot;</span>&gt;</span><br><span class="line">                    禁用</span><br><span class="line">                &lt;/c:<span class="keyword">if</span>&gt;</span><br><span class="line">            &lt;/td&gt;</span><br><span class="line">            &lt;%-- 精髓 --%&gt;</span><br><span class="line">            &lt;td&gt;&lt;a href=<span class="string">&quot;/brand-demo/selectByIdServlet?id=$&#123;brand.id&#125;&quot;</span>&gt;修改&lt;/a&gt;</span><br><span class="line">                &lt;a href=<span class="string">&quot;/brand-demo/deleteServlet?id=$&#123;brand.id&#125;&quot;</span>&gt;删除&lt;/a&gt;&lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">    &lt;/c:forEach&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    document.querySelector(<span class="string">&quot;input&quot;</span>).onclick = function() &#123;</span><br><span class="line">        location.href = <span class="string">&quot;/brand-demo/addBrand.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>使用了 JSTL 和 EL 表达式。</p><h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3><h4 id="Mapper-Dao-1"><a href="#Mapper-Dao-1" class="headerlink" title="Mapper &#x2F; Dao"></a>Mapper &#x2F; Dao</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BrandMapper</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入品牌信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> brand</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Insert(&quot;insert into tb_brand values(null, #&#123;brandName&#125;, #&#123;companyName&#125;, #&#123;ordered&#125;, #&#123;description&#125;, #&#123;status&#125;)&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Brand brand)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数占位符名称与类对象属性名一致。</p><h4 id="Controller-1"><a href="#Controller-1" class="headerlink" title="Controller"></a>Controller</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BrandService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> SqlSessionFactoryUtil.getSqlSessionFactory();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向数据库中添加数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> brand</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Brand brand)</span> &#123;</span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">        <span class="type">BrandMapper</span> <span class="variable">brandMapper</span> <span class="operator">=</span> sqlSession.getMapper(BrandMapper.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用方法</span></span><br><span class="line">        brandMapper.add(brand);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交事务，释放资源</span></span><br><span class="line">        sqlSession.commit();</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接收 Brand 对象，调用 add 方法</p><h4 id="Servlet-2"><a href="#Servlet-2" class="headerlink" title="Servlet"></a>Servlet</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/addServlet&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AddServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">BrandService</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BrandService</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 是 post 请求，所以使用 post 方式</span></span><br><span class="line">        req.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 接收表单提交的数据，封装对象</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">brandName</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;brandName&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">companyName</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;companyName&quot;</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">ordered</span> <span class="operator">=</span> Long.parseLong(req.getParameter(<span class="string">&quot;ordered&quot;</span>));</span><br><span class="line">        <span class="type">String</span> <span class="variable">description</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;description&quot;</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">status</span> <span class="operator">=</span> Long.parseLong(req.getParameter(<span class="string">&quot;status&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">Brand</span> <span class="variable">brand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Brand</span>(brandName, companyName, ordered, description, status);</span><br><span class="line"></span><br><span class="line">        service.add(brand);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转发到查询所有信息的 Servlet</span></span><br><span class="line">        req.getRequestDispatcher(<span class="string">&quot;/selectAllServlet&quot;</span>).forward(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建 BrandService 类对象 brandService，接收参数，构造 Brand 类对象传给 brandService，用于添加数据。</p><h4 id="View-1"><a href="#View-1" class="headerlink" title="View"></a>View</h4><p>addBrand.jsp</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: <span class="number">33257</span></span><br><span class="line">  Date: <span class="number">2022</span>/<span class="number">7</span>/<span class="number">24</span></span><br><span class="line">  Time: <span class="number">20</span>:<span class="number">47</span></span><br><span class="line">  To change <span class="built_in">this</span> template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;addBrand&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;h3&gt;添加品牌&lt;/h3&gt;</span><br><span class="line">    &lt;form action=<span class="string">&quot;/brand-demo/addServlet &quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">        品牌名称：&lt;input name=<span class="string">&quot;brandName&quot;</span> /&gt; &lt;br&gt;</span><br><span class="line">        企业名称：&lt;input name=<span class="string">&quot;companyName&quot;</span> /&gt; &lt;br&gt;</span><br><span class="line">        排序：&lt;input name=<span class="string">&quot;ordered&quot;</span> /&gt; &lt;br&gt;</span><br><span class="line">        描述信息：&lt;textarea rows=<span class="string">&quot;5&quot;</span> cols=<span class="string">&quot;20&quot;</span> name=<span class="string">&quot;description&quot;</span>&gt;&lt;/textarea&gt; &lt;br&gt;</span><br><span class="line">        状态：</span><br><span class="line">        &lt;input type=<span class="string">&quot;radio&quot;</span> name=<span class="string">&quot;status&quot;</span> value=<span class="string">&quot;0&quot;</span> /&gt; 禁用</span><br><span class="line">        &lt;input type=<span class="string">&quot;radio&quot;</span> name=<span class="string">&quot;status&quot;</span> value=<span class="string">&quot;1&quot;</span> /&gt; 启用 &lt;br&gt;</span><br><span class="line"></span><br><span class="line">        &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;提交&quot;</span> /&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><h4 id="Mapper-Dao-2"><a href="#Mapper-Dao-2" class="headerlink" title="Mapper &#x2F; Dao"></a>Mapper &#x2F; Dao</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BrandMapper</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按照 id 查询信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Select(&quot;select * from tb_brand where id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@ResultMap(&quot;brandResultMap&quot;)</span></span><br><span class="line">    Brand <span class="title function_">selectById</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> brand Brand 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Update(&quot;update tb_brand set brand_name = #&#123;brandName&#125;, company_name = #&#123;companyName&#125;, ordered = #&#123;ordered&#125;, description = #&#123;description&#125;, status = #&#123;status&#125; where id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Brand brand)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个接口方法，按 id 返回待修改的 Brand 对象，在 Servlet 中将 Brand 发送给 update.jsp，回显数据，修改提交，请求最终 selectAllServlet -&gt; brands.jsp。</p><h4 id="Controller-2"><a href="#Controller-2" class="headerlink" title="Controller"></a>Controller</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BrandService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> SqlSessionFactoryUtil.getSqlSessionFactory();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用 id 查询数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Brand <span class="title function_">selectById</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 Mapper</span></span><br><span class="line">        <span class="type">BrandMapper</span> <span class="variable">brandMapper</span> <span class="operator">=</span> sqlSession.getMapper(BrandMapper.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">Brand</span> <span class="variable">brand</span> <span class="operator">=</span> brandMapper.selectById(id);</span><br><span class="line"></span><br><span class="line">        sqlSession.close();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> brand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> brand</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Brand brand)</span> &#123;</span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 Mapper</span></span><br><span class="line">        <span class="type">BrandMapper</span> <span class="variable">brandMapper</span> <span class="operator">=</span> sqlSession.getMapper(BrandMapper.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用方法</span></span><br><span class="line">        brandMapper.update(brand);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交事务</span></span><br><span class="line">        sqlSession.commit();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Sevlet"><a href="#Sevlet" class="headerlink" title="Sevlet"></a>Sevlet</h4><p>SelectByIdServlet–将 id 交给 BrandService，将获得的数据转发给 update.jsp</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/selectByIdServlet&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectByIdServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">BrandService</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BrandService</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 1. 接收提交的id</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 调用 service 进行查询</span></span><br><span class="line">        <span class="type">Brand</span> <span class="variable">brand</span> <span class="operator">=</span> service.selectById(Integer.valueOf(id));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 请求转发</span></span><br><span class="line">        req.setAttribute(<span class="string">&quot;brand&quot;</span>, brand);</span><br><span class="line">        req.getRequestDispatcher(<span class="string">&quot;/update.jsp&quot;</span>).forward(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UpdateServlet–封装 Brand 对象，传给 BrandService，请求转发给 selectAllServlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/updateServlet&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UpdateServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">BrandService</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BrandService</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 是 post 请求，所以使用 post 方式</span></span><br><span class="line">        req.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 接收表单提交的数据，封装对象</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">        System.out.println(id);</span><br><span class="line">        <span class="type">String</span> <span class="variable">brandName</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;brandName&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">companyName</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;companyName&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ordered</span> <span class="operator">=</span> Integer.parseInt(req.getParameter(<span class="string">&quot;ordered&quot;</span>));</span><br><span class="line">        <span class="type">String</span> <span class="variable">description</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;description&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">status</span> <span class="operator">=</span> Integer.parseInt(req.getParameter(<span class="string">&quot;status&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">Brand</span> <span class="variable">brand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Brand</span>(Integer.valueOf(id), brandName, companyName, ordered, description, status);</span><br><span class="line"></span><br><span class="line">        service.update(brand);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转发到查询所有信息的 Servlet</span></span><br><span class="line">        req.getRequestDispatcher(<span class="string">&quot;/selectAllServlet&quot;</span>).forward(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="View-2"><a href="#View-2" class="headerlink" title="View"></a>View</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: <span class="number">33257</span></span><br><span class="line">  Date: <span class="number">2022</span>/<span class="number">7</span>/<span class="number">24</span></span><br><span class="line">  Time: <span class="number">20</span>:<span class="number">47</span></span><br><span class="line">  To change <span class="built_in">this</span> template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;%@ taglib prefix=<span class="string">&quot;c&quot;</span> uri=<span class="string">&quot;http://java.sun.com/jsp/jstl/core&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;addBrand&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;h3&gt;添加品牌&lt;/h3&gt;</span><br><span class="line">    &lt;form action=<span class="string">&quot;/brand-demo/updateServlet &quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;hidden&quot;</span> value=<span class="string">&quot;$&#123;brand.id&#125;&quot;</span> name=<span class="string">&quot;id&quot;</span> /&gt;</span><br><span class="line">        品牌名称：&lt;input name=<span class="string">&quot;brandName&quot;</span> value=<span class="string">&quot;$&#123;brand.brandName&#125;&quot;</span> /&gt; &lt;br&gt;</span><br><span class="line">        企业名称：&lt;input name=<span class="string">&quot;companyName&quot;</span> value=<span class="string">&quot;$&#123;brand.companyName&#125;&quot;</span> /&gt; &lt;br&gt;</span><br><span class="line">        排序：&lt;input name=<span class="string">&quot;ordered&quot;</span> value=<span class="string">&quot;$&#123;brand.ordered&#125;&quot;</span> /&gt; &lt;br&gt;</span><br><span class="line">        描述信息：&lt;textarea rows=<span class="string">&quot;5&quot;</span> cols=<span class="string">&quot;20&quot;</span> name=<span class="string">&quot;description&quot;</span>&gt;$&#123;brand.description&#125;&lt;/textarea&gt; &lt;br&gt;</span><br><span class="line">        状态：</span><br><span class="line">        &lt;c:<span class="keyword">if</span> test=<span class="string">&quot;$&#123;brand.status == 0&#125;&quot;</span>&gt;</span><br><span class="line">            &lt;input type=<span class="string">&quot;radio&quot;</span> name=<span class="string">&quot;status&quot;</span> value=<span class="string">&quot;0&quot;</span> checked /&gt;禁用</span><br><span class="line">            &lt;input type=<span class="string">&quot;radio&quot;</span> name=<span class="string">&quot;status&quot;</span> value=<span class="string">&quot;1&quot;</span> /&gt; 启用</span><br><span class="line">        &lt;/c:<span class="keyword">if</span>&gt;</span><br><span class="line"></span><br><span class="line">        &lt;c:<span class="keyword">if</span> test=<span class="string">&quot;$&#123;brand.status == 1&#125;&quot;</span>&gt;</span><br><span class="line">            &lt;input type=<span class="string">&quot;radio&quot;</span> name=<span class="string">&quot;status&quot;</span> value=<span class="string">&quot;0&quot;</span> /&gt;禁用</span><br><span class="line">            &lt;input type=<span class="string">&quot;radio&quot;</span> name=<span class="string">&quot;status&quot;</span> value=<span class="string">&quot;1&quot;</span> checked /&gt; 启用</span><br><span class="line">        &lt;/c:<span class="keyword">if</span>&gt;</span><br><span class="line"></span><br><span class="line">        &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;提交&quot;</span> /&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><h4 id="Mapper-Dao-3"><a href="#Mapper-Dao-3" class="headerlink" title="Mapper &#x2F; Dao"></a>Mapper &#x2F; Dao</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BrandMapper</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 编号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Delete(&quot;delete from tb_brand where id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Controller-3"><a href="#Controller-3" class="headerlink" title="Controller"></a>Controller</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BrandService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> SqlSessionFactoryUtil.getSqlSessionFactory();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 编号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">        <span class="type">BrandMapper</span> <span class="variable">brandMapper</span> <span class="operator">=</span> sqlSession.getMapper(BrandMapper.class);</span><br><span class="line">        brandMapper.delete(id);</span><br><span class="line"></span><br><span class="line">        sqlSession.commit();</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Servlet-3"><a href="#Servlet-3" class="headerlink" title="Servlet"></a>Servlet</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/deleteServlet&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeleteServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">BrandService</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BrandService</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 设置编码格式</span></span><br><span class="line">        req.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"></span><br><span class="line">        service.delete(Integer.parseInt(id));</span><br><span class="line"></span><br><span class="line">        req.getRequestDispatcher(<span class="string">&quot;/selectAllServlet&quot;</span>).forward(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Cookie-Session"><a href="#Cookie-Session" class="headerlink" title="Cookie &amp; Session"></a>Cookie &amp; Session</h1><p>会话– 用户打开浏览器，访问 web 服务器的资源，会话建立，直到有一方断开连接，会话结束。在一次会话中可以包含多次请求和响应。</p><p>会话跟踪 – 一种维护浏览器状态的方法，服务器需要识别多次请求是否来自于同一浏览器，以便在同一次会话中的多次请求间共享数据。</p><p>服务器自身是没有办法识别不同请求是否来自于同一浏览器，因为 HTTP 协议是无状态的，每次浏览器向服务器请求时，服务器都会将请求是为心得请求，因此需要会话跟踪技术实现会话内数据共享。</p><p>客户端会话技术–Cookie将数据存放到浏览器中</p><p>服务端会话技术–Session将数据存放到服务端 Servlet 中</p><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><h3 id="Cookie-使用"><a href="#Cookie-使用" class="headerlink" title="Cookie 使用"></a>Cookie 使用</h3><p>Cookie：客户端会话技术，将数据保存到客户端，以后每次请求都携带 Cookie 数据进行访问</p><h4 id="发送"><a href="#发送" class="headerlink" title="发送"></a>发送</h4><ol><li>创建 Cookie 对象，设置数据</li></ol><p><code>Cookie cookie = new Cookie(&quot;key&quot;, &quot;value&quot;);</code> </p><ol start="2"><li>发送 Cookie 到客户端，使用 response 对象</li></ol><p><code>response.addCookie(cookie);</code> </p><h4 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h4><p>只能一次性获取所有的 Cookie，需要在循环中找到目标</p><ol><li>获取 Cookie</li></ol><p><code>Cookie[] cookies = req.getCookies();</code> </p><ol start="2"><li>遍历数组，获取数据</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Cookie c : cookies) &#123;</span><br><span class="line">    <span class="keyword">if</span> (c.getName().equals(<span class="string">&quot;username&quot;</span>)) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> c.getValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Cookie-原理"><a href="#Cookie-原理" class="headerlink" title="Cookie 原理"></a>Cookie 原理</h3><p>Cookie 的实现基于 HTTP 协议</p><ul><li>响应头：set-cookie</li><li>请求头：cookie</li></ul><h3 id="Cookie-使用细节"><a href="#Cookie-使用细节" class="headerlink" title="Cookie 使用细节"></a>Cookie 使用细节</h3><ul><li>生命周期<ul><li>默认情况下，Cookie 储存在浏览器内存中，当浏览器关闭，内存释放，Cookie被销毁（无法实现记住密码效果）</li><li>Cookie.setMaxAge(int seconds)：设置 Cookie 生存时效<ul><li>正数：将 Cookie 写入浏览器所在的电脑磁盘，持久化存储，到时间自动删除</li><li>负数：默认值，Cookie 在当前浏览器内存中，当浏览器关闭，Cookie 自动销毁</li><li>0：删除对应 Cookie</li></ul></li></ul></li><li>存储中文<ul><li>Cookie 不能直接存储中文（转码到其他字符集存储，使用时转回中文）</li><li>如果需要存储中文数据，则使用 URL 编码（URLEncoder.encode(vlaue, “UTF-8”);）</li></ul></li></ul><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><ul><li><p>服务端会话跟踪技术：将数据保存在服务端</p></li><li><p>使用</p></li></ul><ol><li>获取 Session 对象： <code>HttpSession session = req.getSession();</code> </li><li>Session 对象功能</li></ol><ul><li>void setAttribute(String name, Object o);           用于存储数据</li><li>Object getAttribute(String name);                         依键获取对应的值</li><li>void removeAttribute(String name);                     依键删除键值对</li></ul><p>同一会话（浏览器相同）中，不同的 Servlet 获取的 HttpSession 是同一个（session地址相同），不同的浏览器访问不到同一个session。</p><h3 id="Session-原理"><a href="#Session-原理" class="headerlink" title="Session 原理"></a>Session 原理</h3><p>Session 是基于 Cookie实现的（下面这个描述还是很混乱）</p><blockquote><p>第一次获取 Session 时，这个 Session 对象被 tomcat 赋予了唯一的标识：id，假设此 id 为 10，并且此 Session 中存储了一些数据，tomcat 在 Servlet 只往 Session 对象存储数据而没有进行释放的情况下，会向客户端浏览器作出响应，自动向 Session 的 id 作为一个 cookie 发送到浏览器，于是 tomcat 会在响应响应请求时发送带有 Set-cookie:JSESSION&#x3D;10 的响应头，然后浏览器将 JSESSIONID&#x3D;10 存储到内存中（关闭浏览器，内存释放），下一次请求时会带着 JSESSIONID&#x3D;10 的信息访问服务端（Servlet），使用的是 Cookie 头：Cookie:JSESSIONID&#x3D;10。第二次获取 Session 时，tomcat 回寻找有无 JSESSION 对应的 Session，有则直接使用，没有则重新创建。</p></blockquote><p>打开浏览器，按 F12，找到 Network -&gt; header 查看 cookie 中的 JSESSION 的 id</p><p>demo1: Set-cookie: xxxdemo2: Cookie: xxx</p><h3 id="Session-细节"><a href="#Session-细节" class="headerlink" title="Session 细节"></a>Session 细节</h3><h4 id="Session-钝化、活化"><a href="#Session-钝化、活化" class="headerlink" title="Session 钝化、活化"></a>Session 钝化、活化</h4><p>服务器重启，Session 中的数据是否还在？</p><ul><li>钝化：在服务器正常关闭后，Tomcat 会自动将 Session 数据序列化并写入磁盘（target&#x2F;tomcat&#x2F;work&#x2F;tomcat&#x2F;SESSION.ser）</li><li>活化：重启服务器后，Tomcat 从文件加载数据到 Session 中并删除该文件</li></ul><h4 id="Session-销毁"><a href="#Session-销毁" class="headerlink" title="Session 销毁"></a>Session 销毁</h4><ul><li>默认：无操作 30 分钟后自动销毁</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在 web.xml 中写入下面配置信息，改动数字即可修改时间 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>30<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>调用 Session 对象的 invalidate() 方法，立即销毁 Session 对象</li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>Cookie 与 Session 都是用来完成一次会话内多次请求键数据共享的</p><p>区别：</p><ol><li>存储位置：Cookie 将数据存储在客户端，Session 将数据存储在服务端</li><li>安全性：将数据存放在服务端的 Session 安全性更高</li><li>数据大小：Cookie 最大 3KB，Session 没有大小限制</li><li>存储时间：Cookie 可以长期存储，Session 默认 30 分钟</li><li>服务器性能：Cookie 不占用服务器哦资源，Session 占用服务器资源</li></ol><ul><li>偏好设置 – 需要长时间存储：Cookie</li><li>购物车数据 – 需要长时间保存，不太需要保密，Cookie</li><li>用户信息，用户隐私 – 需要保密，Session</li><li>记住密码 – Cookie</li><li>验证码 – 防止暴力注册，需要保护，Session</li></ul><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="用户登录"><a href="#用户登录" class="headerlink" title="用户登录"></a>用户登录</h3><table><thead><tr><th>层级</th><th>操作</th></tr></thead><tbody><tr><td>Dao</td><td>User Select(String username, String password)</td></tr><tr><td>Service</td><td>LoginService，调用 userapper.select(username, password)</td></tr><tr><td>Web</td><td>接收用户名和密码、调用 service 查询 user、判断 user 是否为空</td></tr></tbody></table><h4 id="Dao"><a href="#Dao" class="headerlink" title="Dao"></a>Dao</h4><p>UserMapper 接口文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;select * from user where username = #&#123;username&#125; and password = #&#123;password&#125;&quot;)</span></span><br><span class="line">    User <span class="title function_">select</span><span class="params">(<span class="meta">@Param(&quot;username&quot;)</span>String username, <span class="meta">@Param(&quot;password&quot;)</span>String password)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;select * from user where username = #&#123;username&#125;&quot;)</span></span><br><span class="line">    User <span class="title function_">selectByUsername</span><span class="params">(String username)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserMapper 配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;UTF-8&#x27;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org/DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.example.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h4><p>获取 SqlSessionFactory 对象，获取 SqlSession 对象，执行 SQL</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> SqlSessionFactoryUtil.getSqlSessionFactory();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">login</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> factory.openSession();</span><br><span class="line">        <span class="type">UserMapper</span> <span class="variable">userMapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.select(username, password);</span><br><span class="line">        sqlSession.close();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/loginServlet&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">UserService</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserService</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 获取用户名和密码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用方法</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> service.login(username, password);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 登录成功</span></span><br><span class="line"></span><br><span class="line">            <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> req.getSession();</span><br><span class="line">            session.setAttribute(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                以前使用的方法是，拿到数据之后，转发请求</span></span><br><span class="line"><span class="comment">                req.setAttribute(&quot;user&quot;, user);</span></span><br><span class="line"><span class="comment">                req.getRequestDispatcher(&quot;/selectAllServlet&quot;).forward(req, resp);</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 重定向到指定页面</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">contextPath</span> <span class="operator">=</span> req.getContextPath();</span><br><span class="line">            resp.sendRedirect(contextPath + <span class="string">&quot;/selectAllServlet&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 登录失败</span></span><br><span class="line">            req.setAttribute(<span class="string">&quot;login_msg&quot;</span>, <span class="string">&quot;用户名或密码错误&quot;</span>);</span><br><span class="line"></span><br><span class="line">            req.getRequestDispatcher(<span class="string">&quot;login.jsp&quot;</span>).forward(req, resp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有使用 JSTL</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;Login&lt;/title&gt;</span><br><span class="line">    &lt;link href=<span class="string">&quot;css/login.css&quot;</span> rel=<span class="string">&quot;stylesheet&quot;</span>&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id=<span class="string">&quot;loginDiv&quot;</span> style=<span class="string">&quot;height: 350px&quot;</span>&gt;</span><br><span class="line">    &lt;form action=<span class="string">&quot;/brand-demo/loginServlet&quot;</span> id=<span class="string">&quot;form&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">        &lt;!-- 登录成功的情况下这里没有任何数据，一个空的 div，高度为 <span class="number">0</span> --&gt;</span><br><span class="line">        &lt;h1 id=<span class="string">&quot;loginMsg&quot;</span>&gt;LOGIN IN&lt;/h1&gt;</span><br><span class="line">        &lt;div id=<span class="string">&quot;errorMsg&quot;</span>&gt;$&#123;login_msg&#125; $&#123;register_msg&#125;&lt;/div&gt;</span><br><span class="line">        &lt;p&gt;Username:&lt;label <span class="keyword">for</span>=<span class="string">&quot;username&quot;</span>&gt;&lt;/label&gt;&lt;input id=<span class="string">&quot;username&quot;</span> name=<span class="string">&quot;username&quot;</span> value=<span class="string">&quot;$&#123;cookie.username.value&#125;&quot;</span> type=<span class="string">&quot;text&quot;</span> required /&gt;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">        &lt;p&gt;Password:&lt;label <span class="keyword">for</span>=<span class="string">&quot;password&quot;</span>&gt;&lt;/label&gt;&lt;input id=<span class="string">&quot;password&quot;</span> name=<span class="string">&quot;password&quot;</span> value=<span class="string">&quot;$&#123;cookie.password.value&#125;&quot;</span> type=<span class="string">&quot;password&quot;</span> required /&gt;&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;Remember:&lt;label <span class="keyword">for</span>=<span class="string">&quot;remember&quot;</span>&gt;&lt;/label&gt;&lt;input id=<span class="string">&quot;remember&quot;</span> name=<span class="string">&quot;remember&quot;</span> value=<span class="string">&quot;1&quot;</span> type=<span class="string">&quot;checkbox&quot;</span>&gt;&lt;/p&gt;</span><br><span class="line">        &lt;div id=<span class="string">&quot;subDiv&quot;</span>&gt;</span><br><span class="line">            &lt;input type=<span class="string">&quot;submit&quot;</span> class=<span class="string">&quot;button&quot;</span> value=<span class="string">&quot;login up&quot;</span>&gt;</span><br><span class="line">            &lt;input type=<span class="string">&quot;reset&quot;</span> class=<span class="string">&quot;button&quot;</span> value=<span class="string">&quot;reset&quot;</span>&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;</span><br><span class="line">            &lt;%-- 跳转到注册页面 --%&gt;</span><br><span class="line">            &lt;a href=<span class="string">&quot;register.jsp&quot;</span>&gt;没有账号？&lt;/a&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="用户注册"><a href="#用户注册" class="headerlink" title="用户注册"></a>用户注册</h3><h4 id="Mapper-Dao-4"><a href="#Mapper-Dao-4" class="headerlink" title="Mapper &#x2F; Dao"></a>Mapper &#x2F; Dao</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;select * from user where username = #&#123;username&#125; and password = #&#123;password&#125;&quot;)</span></span><br><span class="line">    User <span class="title function_">select</span><span class="params">(<span class="meta">@Param(&quot;username&quot;)</span>String username, <span class="meta">@Param(&quot;password&quot;)</span>String password)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;select * from user where username = #&#123;username&#125;&quot;)</span></span><br><span class="line">    User <span class="title function_">selectByUsername</span><span class="params">(String username)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert(&quot;insert into user values(null, #&#123;username&#125;, #&#123;password&#125;)&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="meta">@Param(&quot;username&quot;)</span>String username, <span class="meta">@Param(&quot;password&quot;)</span>String password)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Service-1"><a href="#Service-1" class="headerlink" title="Service"></a>Service</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> SqlSessionFactoryUtil.getSqlSessionFactory();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">login</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> factory.openSession();</span><br><span class="line">        <span class="type">UserMapper</span> <span class="variable">userMapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.select(username, password);</span><br><span class="line">        sqlSession.close();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">selectByUsername</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> factory.openSession();</span><br><span class="line">        <span class="type">UserMapper</span> <span class="variable">userMapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.selectByUsername(username);</span><br><span class="line"></span><br><span class="line">        sqlSession.close();</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> factory.openSession();</span><br><span class="line">        <span class="type">UserMapper</span> <span class="variable">userMapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line">        userMapper.add(username, password);</span><br><span class="line"></span><br><span class="line">        sqlSession.commit();</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">register</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="built_in">this</span>.selectByUsername(username);</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.add(username, password);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// user 为空说明注册成功</span></span><br><span class="line">        <span class="keyword">return</span> user == <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Web-1"><a href="#Web-1" class="headerlink" title="Web"></a>Web</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/checkCodeServlet&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CheckCodeServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">ServletOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> resp.getOutputStream();</span><br><span class="line">        <span class="comment">// 宽度、高度、输出流、验证码长度</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">verifyCode</span> <span class="operator">=</span> CheckCodeUtil.outputVerifyImage(<span class="number">100</span>, <span class="number">50</span>, outputStream, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将验证码结果存到 Session 中</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> req.getSession();</span><br><span class="line">        session.setAttribute(<span class="string">&quot;verifyCode&quot;</span>, verifyCode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>验证码生成之后，交给其他 Servlet 进行获取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/registerServlet&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegisterServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">checkCode</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;checkCode&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserService</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> service.register(username, password);</span><br><span class="line"></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> req.getSession();</span><br><span class="line">        <span class="type">String</span> <span class="variable">verifyCode</span> <span class="operator">=</span> (String)session.getAttribute(<span class="string">&quot;verifyCode&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (verifyCode.equalsIgnoreCase(checkCode)) &#123;</span><br><span class="line">            <span class="comment">// 不允许注册</span></span><br><span class="line">            req.setAttribute(<span class="string">&quot;register_msg&quot;</span>, <span class="string">&quot;验证码错误&quot;</span>);</span><br><span class="line">            req.getRequestDispatcher(<span class="string">&quot;/register.jsp&quot;</span>).forward(req, resp);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里返回是不影响的，前端可以不断请求，会反复执行这个方法</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="comment">// 跳转登录页面</span></span><br><span class="line">            req.setAttribute(<span class="string">&quot;register_msg&quot;</span>, <span class="string">&quot;注册成功，请登录&quot;</span>);</span><br><span class="line">            req.getRequestDispatcher(<span class="string">&quot;/login.jsp&quot;</span>).forward(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 注册失败，登录页面</span></span><br><span class="line">            req.setAttribute(<span class="string">&quot;register_msg&quot;</span>, <span class="string">&quot;用户名已存在&quot;</span>);</span><br><span class="line">            req.getRequestDispatcher(<span class="string">&quot;/register.jsp&quot;</span>).forward(req, resp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="View-3"><a href="#View-3" class="headerlink" title="View"></a>View</h4><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;欢迎注册&lt;/title&gt;</span><br><span class="line">    &lt;link href=<span class="string">&quot;css/register.css&quot;</span> rel=<span class="string">&quot;stylesheet&quot;</span>&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=<span class="string">&quot;form-div&quot;</span>&gt;</span><br><span class="line">    &lt;div class=<span class="string">&quot;reg-content&quot;</span>&gt;</span><br><span class="line">        &lt;h1&gt;欢迎注册&lt;/h1&gt;</span><br><span class="line">        &lt;span&gt;已有帐号？&lt;/span&gt; &lt;a href=<span class="string">&quot;login.html&quot;</span>&gt;登录&lt;/a&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;form id=<span class="string">&quot;reg-form&quot;</span> action=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/registerServlet&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">        &lt;table&gt;</span><br><span class="line"></span><br><span class="line">            &lt;tr&gt;</span><br><span class="line">                &lt;td&gt;用户名&lt;/td&gt;</span><br><span class="line">                &lt;td class=<span class="string">&quot;inputs&quot;</span>&gt;</span><br><span class="line">                    &lt;label <span class="keyword">for</span>=<span class="string">&quot;username&quot;</span>&gt;&lt;/label&gt;&lt;input name=<span class="string">&quot;username&quot;</span> type=<span class="string">&quot;text&quot;</span> id=<span class="string">&quot;username&quot;</span> required&gt;</span><br><span class="line">                    &lt;br&gt;</span><br><span class="line">                    &lt;span id=<span class="string">&quot;username_err&quot;</span> class=<span class="string">&quot;err_msg&quot;</span>&gt;$&#123;register_msg&#125;&lt;/span&gt;</span><br><span class="line">                &lt;/td&gt;</span><br><span class="line"></span><br><span class="line">            &lt;/tr&gt;</span><br><span class="line"></span><br><span class="line">            &lt;tr&gt;</span><br><span class="line">                &lt;td&gt;密码&lt;/td&gt;</span><br><span class="line">                &lt;td class=<span class="string">&quot;inputs&quot;</span>&gt;</span><br><span class="line">                    &lt;label <span class="keyword">for</span>=<span class="string">&quot;password&quot;</span>&gt;&lt;/label&gt;&lt;input name=<span class="string">&quot;password&quot;</span> type=<span class="string">&quot;password&quot;</span> id=<span class="string">&quot;password&quot;</span> required&gt;</span><br><span class="line">                    &lt;br&gt;</span><br><span class="line">                    &lt;span id=<span class="string">&quot;password_err&quot;</span> class=<span class="string">&quot;err_msg&quot;</span> style=<span class="string">&quot;display: none&quot;</span>&gt;密码格式有误&lt;/span&gt;</span><br><span class="line">                &lt;/td&gt;</span><br><span class="line">            &lt;/tr&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &lt;tr&gt;</span><br><span class="line">                &lt;td&gt;验证码&lt;/td&gt;</span><br><span class="line">                &lt;td class=<span class="string">&quot;inputs&quot;</span>&gt;</span><br><span class="line">                    &lt;label <span class="keyword">for</span>=<span class="string">&quot;checkCode&quot;</span>&gt;&lt;/label&gt;&lt;input name=<span class="string">&quot;checkCode&quot;</span> type=<span class="string">&quot;text&quot;</span> id=<span class="string">&quot;checkCode&quot;</span>&gt;</span><br><span class="line">                    &lt;img id=<span class="string">&quot;checkImg&quot;</span> src=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/checkCodeServlet&quot;</span> alt=<span class="string">&quot;#&quot;</span>&gt;</span><br><span class="line">                    &lt;%-- href中 填入 register.jsp 虽然可以，但是会把输入数据刷掉 --%&gt;</span><br><span class="line">                    &lt;a href=<span class="string">&quot;#&quot;</span> id=<span class="string">&quot;changeImg&quot;</span>&gt;看不清？&lt;/a&gt;</span><br><span class="line">                &lt;/td&gt;</span><br><span class="line">            &lt;/tr&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/table&gt;</span><br><span class="line"></span><br><span class="line">        &lt;div class=<span class="string">&quot;buttons&quot;</span>&gt;</span><br><span class="line">            &lt;input value=<span class="string">&quot;注 册&quot;</span> type=<span class="string">&quot;submit&quot;</span> id=<span class="string">&quot;reg_btn&quot;</span>&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;br class=<span class="string">&quot;clear&quot;</span>&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    document.querySelector(<span class="string">&quot;#changeImg&quot;</span>).onclick = function() &#123;</span><br><span class="line">        <span class="comment">// 获取时间毫秒值</span></span><br><span class="line">        document.querySelector(<span class="string">&quot;#checkImg&quot;</span>).src = <span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/checkCodeServlet?&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>().getMilliseconds();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 点击图片刷新验证码</span></span><br><span class="line">    document.querySelector(<span class="string">&quot;#checkImg&quot;</span>).onclick = function () &#123;</span><br><span class="line">        <span class="built_in">this</span>.src = <span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/checkCodeServlet?&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>().getMilliseconds();</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h4 id="验证码生成工具类："><a href="#验证码生成工具类：" class="headerlink" title="验证码生成工具类："></a>验证码生成工具类：</h4><p>CheckCodeUtil</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.imageio.ImageIO;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.geom.AffineTransform;</span><br><span class="line"><span class="keyword">import</span> java.awt.image.BufferedImage;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成验证码工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CheckCodeUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">VERIFY_CODES</span> <span class="operator">=</span> <span class="string">&quot;123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输出随机验证码图片流,并返回验证码值（一般传入输出流，响应response页面端，Web项目用的较多）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> width 宽度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> height 高度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> os 输出流</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> verifySize 验证码长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 验证码数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">outputVerifyImage</span><span class="params">(<span class="type">int</span> width, <span class="type">int</span> height, OutputStream os, <span class="type">int</span> verifySize)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">verifyCode</span> <span class="operator">=</span> generateVerifyCode(verifySize);</span><br><span class="line">        outputImage(width, height, os, verifyCode);</span><br><span class="line">        <span class="keyword">return</span> verifyCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用系统默认字符源生成验证码</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> verifySize 验证码长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">generateVerifyCode</span><span class="params">(<span class="type">int</span> verifySize)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> generateVerifyCode(verifySize, VERIFY_CODES);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用指定源生成验证码</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> verifySize 验证码长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sources    验证码字符源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">generateVerifyCode</span><span class="params">(<span class="type">int</span> verifySize, String sources)</span> &#123;</span><br><span class="line">        <span class="comment">// 未设定展示源的字码，赋默认值大写字母+数字</span></span><br><span class="line">        <span class="keyword">if</span> (sources == <span class="literal">null</span> || sources.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            sources = VERIFY_CODES;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">codesLen</span> <span class="operator">=</span> sources.length();</span><br><span class="line">        <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(System.currentTimeMillis());</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">verifyCode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(verifySize);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; verifySize; i++) &#123;</span><br><span class="line">            verifyCode.append(sources.charAt(rand.nextInt(codesLen - <span class="number">1</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> verifyCode.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成随机验证码文件,并返回验证码值 (生成图片形式，用的较少)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> w</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> h</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> outputFile</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> verifySize</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">outputVerifyImage</span><span class="params">(<span class="type">int</span> w, <span class="type">int</span> h, File outputFile, <span class="type">int</span> verifySize)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">verifyCode</span> <span class="operator">=</span> generateVerifyCode(verifySize);</span><br><span class="line">        outputImage(w, h, outputFile, verifyCode);</span><br><span class="line">        <span class="keyword">return</span> verifyCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成指定验证码图像文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> w</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> h</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> outputFile</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> code</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">outputImage</span><span class="params">(<span class="type">int</span> w, <span class="type">int</span> h, File outputFile, String code)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (outputFile == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">File</span> <span class="variable">dir</span> <span class="operator">=</span> outputFile.getParentFile();</span><br><span class="line">        <span class="comment">//文件不存在</span></span><br><span class="line">        <span class="keyword">if</span> (!dir.exists()) &#123;</span><br><span class="line">            <span class="comment">//创建</span></span><br><span class="line">            dir.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            outputFile.createNewFile();</span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(outputFile);</span><br><span class="line">            outputImage(w, h, fos, code);</span><br><span class="line">            fos.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输出指定验证码图片流</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> w</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> h</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> os</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> code</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">outputImage</span><span class="params">(<span class="type">int</span> w, <span class="type">int</span> h, OutputStream os, String code)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">verifySize</span> <span class="operator">=</span> code.length();</span><br><span class="line">        <span class="type">BufferedImage</span> <span class="variable">image</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedImage</span>(w, h, BufferedImage.TYPE_INT_RGB);</span><br><span class="line">        <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="type">Graphics2D</span> <span class="variable">g2</span> <span class="operator">=</span> image.createGraphics();</span><br><span class="line">        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建颜色集合，使用java.awt包下的类</span></span><br><span class="line">        Color[] colors = <span class="keyword">new</span> <span class="title class_">Color</span>[<span class="number">5</span>];</span><br><span class="line">        Color[] colorSpaces = <span class="keyword">new</span> <span class="title class_">Color</span>[]&#123;Color.WHITE, Color.CYAN,</span><br><span class="line">                Color.GRAY, Color.LIGHT_GRAY, Color.MAGENTA, Color.ORANGE,</span><br><span class="line">                Color.PINK, Color.YELLOW&#125;;</span><br><span class="line">        <span class="type">float</span>[] fractions = <span class="keyword">new</span> <span class="title class_">float</span>[colors.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; colors.length; i++) &#123;</span><br><span class="line">            colors[i] = colorSpaces[rand.nextInt(colorSpaces.length)];</span><br><span class="line">            fractions[i] = rand.nextFloat();</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(fractions);</span><br><span class="line">        <span class="comment">// 设置边框色</span></span><br><span class="line">        g2.setColor(Color.GRAY);</span><br><span class="line">        g2.fillRect(<span class="number">0</span>, <span class="number">0</span>, w, h);</span><br><span class="line"></span><br><span class="line">        <span class="type">Color</span> <span class="variable">c</span> <span class="operator">=</span> getRandColor(<span class="number">200</span>, <span class="number">250</span>);</span><br><span class="line">        <span class="comment">// 设置背景色</span></span><br><span class="line">        g2.setColor(c);</span><br><span class="line">        g2.fillRect(<span class="number">0</span>, <span class="number">2</span>, w, h - <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绘制干扰线</span></span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="comment">// 设置线条的颜色</span></span><br><span class="line">        g2.setColor(getRandColor(<span class="number">160</span>, <span class="number">200</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> random.nextInt(w - <span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> random.nextInt(h - <span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">xl</span> <span class="operator">=</span> random.nextInt(<span class="number">6</span>) + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">yl</span> <span class="operator">=</span> random.nextInt(<span class="number">12</span>) + <span class="number">1</span>;</span><br><span class="line">            g2.drawLine(x, y, x + xl + <span class="number">40</span>, y + yl + <span class="number">20</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加噪点</span></span><br><span class="line">        <span class="comment">// 噪声率</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">yawpRate</span> <span class="operator">=</span> <span class="number">0.05f</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">area</span> <span class="operator">=</span> (<span class="type">int</span>) (yawpRate * w * h);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; area; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> random.nextInt(w);</span><br><span class="line">            <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> random.nextInt(h);</span><br><span class="line">            <span class="comment">// 获取随机颜色</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">rgb</span> <span class="operator">=</span> getRandomIntColor();</span><br><span class="line">            image.setRGB(x, y, rgb);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加图片扭曲</span></span><br><span class="line">        shear(g2, w, h, c);</span><br><span class="line"></span><br><span class="line">        g2.setColor(getRandColor(<span class="number">100</span>, <span class="number">160</span>));</span><br><span class="line">        <span class="type">int</span> <span class="variable">fontSize</span> <span class="operator">=</span> h - <span class="number">4</span>;</span><br><span class="line">        <span class="type">Font</span> <span class="variable">font</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Font</span>(<span class="string">&quot;Algerian&quot;</span>, Font.ITALIC, fontSize);</span><br><span class="line">        g2.setFont(font);</span><br><span class="line">        <span class="type">char</span>[] chars = code.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; verifySize; i++) &#123;</span><br><span class="line">            <span class="type">AffineTransform</span> <span class="variable">affine</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AffineTransform</span>();</span><br><span class="line">            affine.setToRotation(Math.PI / <span class="number">4</span> * rand.nextDouble() * (rand.nextBoolean() ? <span class="number">1</span> : -<span class="number">1</span>), (w / verifySize) * i + fontSize / <span class="number">2</span>, h / <span class="number">2</span>);</span><br><span class="line">            g2.setTransform(affine);</span><br><span class="line">            g2.drawChars(chars, i, <span class="number">1</span>, ((w - <span class="number">10</span>) / verifySize) * i + <span class="number">5</span>, h / <span class="number">2</span> + fontSize / <span class="number">2</span> - <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        g2.dispose();</span><br><span class="line">        ImageIO.write(image, <span class="string">&quot;jpg&quot;</span>, os);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 随机颜色</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fc</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bc</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Color <span class="title function_">getRandColor</span><span class="params">(<span class="type">int</span> fc, <span class="type">int</span> bc)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (fc &gt; <span class="number">255</span>) &#123;</span><br><span class="line">            fc = <span class="number">255</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bc &gt; <span class="number">255</span>) &#123;</span><br><span class="line">            bc = <span class="number">255</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> fc + random.nextInt(bc - fc);</span><br><span class="line">        <span class="type">int</span> <span class="variable">g</span> <span class="operator">=</span> fc + random.nextInt(bc - fc);</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> fc + random.nextInt(bc - fc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Color</span>(r, g, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getRandomIntColor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] rgb = getRandomRgb();</span><br><span class="line">        <span class="type">int</span> <span class="variable">color</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> c : rgb) &#123;</span><br><span class="line">            color = color &lt;&lt; <span class="number">8</span>;</span><br><span class="line">            color = color | c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] getRandomRgb() &#123;</span><br><span class="line">        <span class="type">int</span>[] rgb = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            rgb[i] = random.nextInt(<span class="number">255</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rgb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shear</span><span class="params">(Graphics g, <span class="type">int</span> w1, <span class="type">int</span> h1, Color color)</span> &#123;</span><br><span class="line">        shearX(g, w1, h1, color);</span><br><span class="line">        shearY(g, w1, h1, color);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shearX</span><span class="params">(Graphics g, <span class="type">int</span> w1, <span class="type">int</span> h1, Color color)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">period</span> <span class="operator">=</span> random.nextInt(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">borderGap</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">frames</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">phase</span> <span class="operator">=</span> random.nextInt(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; h1; i++) &#123;</span><br><span class="line">            <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> (<span class="type">double</span>) (period &gt;&gt; <span class="number">1</span>)</span><br><span class="line">                    * Math.sin((<span class="type">double</span>) i / (<span class="type">double</span>) period</span><br><span class="line">                    + (<span class="number">6.2831853071795862D</span> * (<span class="type">double</span>) phase)</span><br><span class="line">                    / (<span class="type">double</span>) frames);</span><br><span class="line">            g.copyArea(<span class="number">0</span>, i, w1, <span class="number">1</span>, (<span class="type">int</span>) d, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (borderGap) &#123;</span><br><span class="line">                g.setColor(color);</span><br><span class="line">                g.drawLine((<span class="type">int</span>) d, i, <span class="number">0</span>, i);</span><br><span class="line">                g.drawLine((<span class="type">int</span>) d + w1, i, w1, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shearY</span><span class="params">(Graphics g, <span class="type">int</span> w1, <span class="type">int</span> h1, Color color)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">period</span> <span class="operator">=</span> random.nextInt(<span class="number">40</span>) + <span class="number">10</span>; <span class="comment">// 50;</span></span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">borderGap</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">frames</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">phase</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; w1; i++) &#123;</span><br><span class="line">            <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> (<span class="type">double</span>) (period &gt;&gt; <span class="number">1</span>)</span><br><span class="line">                    * Math.sin((<span class="type">double</span>) i / (<span class="type">double</span>) period</span><br><span class="line">                    + (<span class="number">6.2831853071795862D</span> * (<span class="type">double</span>) phase)</span><br><span class="line">                    / (<span class="type">double</span>) frames);</span><br><span class="line">            g.copyArea(i, <span class="number">0</span>, <span class="number">1</span>, h1, <span class="number">0</span>, (<span class="type">int</span>) d);</span><br><span class="line">            <span class="keyword">if</span> (borderGap) &#123;</span><br><span class="line">                g.setColor(color);</span><br><span class="line">                g.drawLine(i, (<span class="type">int</span>) d, i, <span class="number">0</span>);</span><br><span class="line">                g.drawLine(i, (<span class="type">int</span>) d + h1, i, h1);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h1><ul><li><p>表示过滤器，是 Java Web 三大组件（Servlet、Filter、Listener）之一</p></li><li><p>过滤器可以把对资源的请求拦截下来，从而实现一些特殊的功能</p></li><li><p>过滤器一般完成一些通用的操作，比如：权限控制、统一编码处理、敏感字符处理等等</p></li></ul><blockquote><p> 在 Servlet 中包含很多对编码格式的处理，比如获取字符串输出流、tomcat 编码转码等。</p></blockquote><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><ol><li>定义类，实现 Filter 接口并重写其所有方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.web.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebFilter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebFilter(&quot;/*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilterDemo</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;filter放行...&quot;</span>);</span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>配置 Filter 拦截资源的路径，在类上定义 @WebFilter</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拦截所有请求</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebFilter(&quot;/*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilterDemo</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;filter放行...&quot;</span>);</span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>在 doFilter 中输出一句话之后放行</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;filter放行...&quot;</span>);</span><br><span class="line">filterChain.doFilter(servletRequest, servletResponse);</span><br></pre></td></tr></table></figure><h2 id="Filter-执行流程"><a href="#Filter-执行流程" class="headerlink" title="Filter 执行流程"></a>Filter 执行流程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[放行前的逻辑]--&gt;B[放行]--&gt;C[Servlet/JSP]--&gt;D[放行后的逻辑]</span><br></pre></td></tr></table></figure><blockquote><p>Filter 相当于在拦截过程中调用了 Servlet 或者 JSP，也就是说是调用了 Servlet&#x2F;JSP 这个模块</p></blockquote><ul><li>放行前需要执行 HttpServletRequest 编码逻辑</li><li>放行后处理 HttpServletResponse</li></ul><h2 id="Filter-拦截路径配置和拦截器链"><a href="#Filter-拦截路径配置和拦截器链" class="headerlink" title="Filter 拦截路径配置和拦截器链"></a>Filter 拦截路径配置和拦截器链</h2><ul><li>Filter可以根据需求，配置不同的拦截资源路径</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter(&quot;/*&quot;)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilterDemo</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;&#125;</span><br></pre></td></tr></table></figure><ol><li><p>拦截具体的资源：index.jsp 只有访问 index.jsp 时才会被拦截</p></li><li><p>目录拦截：&#x2F;user&#x2F;* 拦截 &#x2F;user 路径下所有请求</p></li><li><p>后缀名拦截：*.jsp 拦截所有页面请求</p></li><li><p>拦截所有：&#x2F;* 拦截服务器所有请求</p></li></ol><p>一个 Web 应用，可以配置多个过滤器，多个过滤器组成过滤器链。</p><p>过滤器链中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[宽泛拦截]--&gt;B[狭隘拦截]--&gt;C[Servle/JSP]--&gt;D[狭隘拦截]--&gt;E[宽泛拦截]</span><br></pre></td></tr></table></figure><blockquote><p> 注册配置的Filter，优先按照过滤器类名字符串的自然排序（strCompare）</p><p>注册后将 User 对象放进 Session</p></blockquote><ol><li><p>不拦截与登录相关的资源</p></li><li><p>登录 -&gt; 放行</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HttpServletRequest</span> <span class="variable">req</span> <span class="operator">=</span> (HttpServletRequest) </span><br></pre></td></tr></table></figure><h2 id="过滤器尝试"><a href="#过滤器尝试" class="headerlink" title="过滤器尝试"></a>过滤器尝试</h2><p>brand-demo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.web.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebFilter;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSession;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拦截所有请求</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebFilter(&quot;/*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">req</span> <span class="operator">=</span> (HttpServletRequest) servletRequest;</span><br><span class="line">        <span class="comment">// 未登录不允许查看其它页面，但是要给登录注册页面的资源放行</span></span><br><span class="line">        String[] urls = &#123;<span class="string">&quot;imgs/&quot;</span>, <span class="string">&quot;css/&quot;</span>, <span class="string">&quot;/login.jsp&quot;</span>, <span class="string">&quot;/register.jsp&quot;</span>, <span class="string">&quot;loginServlet&quot;</span>, <span class="string">&quot;/checkCodeServlet&quot;</span>, <span class="string">&quot;/register&quot;</span>, <span class="string">&quot;/registerServlet&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> req.getRequestURI();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String u : urls) &#123;</span><br><span class="line">            <span class="keyword">if</span> (url.contains(u)) &#123;</span><br><span class="line">                <span class="comment">// 给登录注册页面的资源放行</span></span><br><span class="line">                filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果已经存了相关信息就说明已经登录</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> req.getSession();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">user</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">            filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            req.setAttribute(<span class="string">&quot;login_msg&quot;</span>, <span class="string">&quot;您尚未登陆&quot;</span>);</span><br><span class="line">            req.getRequestDispatcher(<span class="string">&quot;/login.jsp&quot;</span>).forward(servletRequest, servletResponse);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h1><p><strong>分类</strong> </p><table><thead><tr><th>名称</th><th>作用</th></tr></thead><tbody><tr><td>ServletContextListener</td><td>监听 ServletContext 对象的创建与销毁</td></tr><tr><td>ServletContextAttributeListener</td><td>监听 ServletContextAttribute 对象的创建与销毁</td></tr><tr><td>HttpServletListener</td><td>监听 HttpServlet 对象的创建与销毁</td></tr><tr><td>HttpServletAttributeListener</td><td>监听 HttpServletAttribute 对象的创建与销毁</td></tr><tr><td>HttpServletActivationListener</td><td>监听 HttpServletActivation 对象的创建与销毁</td></tr><tr><td>ServletRequestListener</td><td>监听 ServletRequest 对象的创建与销毁</td></tr><tr><td>ServletRequestAttributeListener</td><td>监听 ServletRequestAttribute 对象的创建与销毁</td></tr></tbody></table><p><font size=5 color=red>现在已经很少使用</font> </p><h1 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h1><h2 id="Ajax-入门"><a href="#Ajax-入门" class="headerlink" title="Ajax 入门"></a>Ajax 入门</h2><p>AJAX（Asynchronous JavaScript And XML)：异步的 JavaScript 和 XML </p><p>作用</p><ol><li>与服务器进行数据交换，通过AJAX 可以给服务器发送请求，并获取服务器响应的数据</li></ol><blockquote><p>至此，已经可以使用 HTML + AJAX 替代 JSP 了。</p><p>后端主要处理：Servlet + Service + Mapper&#x2F;DAO + DataBase</p></blockquote><ol start="2"><li>异步交互：可以在不刷新整个页面的情况下与数据库进行交换数据并更新部分网页的技术，如：搜索建议、用户名是否可用校验等</li></ol><h3 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h3><pre><code>同步刷新时只能等待，异步刷新（局部刷新）过程中可以有去他操作。</code></pre><h3 id="Ajax-使用"><a href="#Ajax-使用" class="headerlink" title="Ajax 使用"></a>Ajax 使用</h3><ol><li>AjaxServlet，使用 response 输出字符串</li><li>创建 XMLHttpResquest 对象</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xmlhttp;</span><br><span class="line"><span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">XMLHttpRequest</span>) &#123;</span><br><span class="line">    xmlhttp = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// code for IE5、IE6</span></span><br><span class="line">    xmlhttp = <span class="keyword">new</span> <span class="title class_">ActiveXObject</span>(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>向服务器发送请求</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xmlhttp.<span class="title function_">oppen</span>(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;url&quot;</span>);</span><br><span class="line">xmlhttp.<span class="title function_">send</span>();</span><br></pre></td></tr></table></figure><ol start="4"><li>获取服务器响应数据</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xmlhttp.<span class="title function_">onreadystatechange</span>() = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (xmlhttp.<span class="property">readyState</span> == <span class="number">4</span> &amp;&amp; xmlhttp.<span class="property">status</span> == <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(xmlhttp.<span class="property">responseText</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检验用户名是否已经存在：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/selectUserServlet&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectUserServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">UserService</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserService</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;GET&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        System.out.println(username);</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> service.selectByUsername(username);</span><br><span class="line">        <span class="keyword">if</span> (u != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 存在返回 true</span></span><br><span class="line">            resp.getWriter().write(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resp.getWriter().write(<span class="string">&quot;false&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;POST&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原生 ajax：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#username&quot;</span>).<span class="property">onblur</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> xhttp;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">XMLHttpRequest</span>) &#123;</span><br><span class="line">        xhttp = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// code for IE5 IE6</span></span><br><span class="line">        xhttp = <span class="keyword">new</span> <span class="title class_">ActiveXObject</span>(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不用加函数调用符</span></span><br><span class="line">    xhttp.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;http://localhost/ajax-demo/selectUserServlet?username=&quot;</span> + <span class="variable language_">this</span>.<span class="property">value</span>);</span><br><span class="line">    xhttp.<span class="title function_">send</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取响应</span></span><br><span class="line">    xhttp.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">readyState</span> == <span class="number">4</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">status</span> == <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">response</span> == <span class="string">&quot;true&quot;</span>) &#123;</span><br><span class="line">                <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;username_err&quot;</span>).<span class="property">style</span>.<span class="property">display</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;username_err&quot;</span>).<span class="property">style</span>.<span class="property">display</span> = <span class="string">&quot;none&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h2><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>在 HTML 中的使用方法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/axios/dist/axios.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 基础使用方式</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// axios(&#123;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//     method: &quot;get&quot;,</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//     url: &quot;http://localhost/ajax-demo/axiosServlet?username=zhangsan&quot;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// &#125;).then(function(resp) &#123;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//     alert(resp.data);</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// &#125;)</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// axios(&#123;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//     method: &quot;post&quot;,</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//     url: &quot;http://localhost/ajax-demo/axiosServlet?username=zhangsan&quot;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// &#125;).then(function(resp) &#123;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//     alert(resp.data);</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// &#125;)</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 使用 Axios 请求方式别名</span></span></span><br><span class="line"><span class="language-javascript">    axios.<span class="title function_">get</span>(<span class="string">&quot;http://localhost/ajax-demo/axiosServlet?username=zhangsan&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">        .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">resp</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>(resp.<span class="property">data</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    axios.<span class="title function_">post</span>(<span class="string">&quot;http://localhost/ajax-demo/axiosServlet&quot;</span>, <span class="string">&quot;username=zhangSan&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">        .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">resp</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>(resp.<span class="property">data</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/axiosServlet&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AxiosServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;GET&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        System.out.println(username);</span><br><span class="line"></span><br><span class="line">        resp.getWriter().write(<span class="string">&quot;Hello Axios&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;POST&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 HTML 页面中使用 axios 请求别名发送请求，在 Servlet 中使用通用方式处理请求。</p><h3 id="Axios-请求方式别名"><a href="#Axios-请求方式别名" class="headerlink" title="Axios 请求方式别名"></a>Axios 请求方式别名</h3><ul><li>axios.get(url[,config])</li></ul><p>具有相同用法的的还有 delete、和蔼的、options</p><ul><li>axios.post(url[,data[,config]])</li></ul><p>具有相同用法的还有 put、patch</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">axios.<span class="title function_">get</span>(<span class="string">&quot;http://localhost/ajax-demo/axiosServlet?username=zhangsan&quot;</span>)</span><br><span class="line">      .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">resp</span>) &#123;</span><br><span class="line">      <span class="title function_">alert</span>(resp.<span class="property">data</span>);</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">axios.<span class="title function_">post</span>(<span class="string">&quot;http://localhost/ajax-demo/axiosServlet&quot;</span>, <span class="string">&quot;username=zhangSan&quot;</span>)</span><br><span class="line">     .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">resp</span>) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(resp.<span class="property">data</span>);</span><br><span class="line">     &#125;)</span><br></pre></td></tr></table></figure><h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><h2 id="JSON-数据与-Java-对象转换"><a href="#JSON-数据与-Java-对象转换" class="headerlink" title="JSON 数据与 Java 对象转换"></a>JSON 数据与 Java 对象转换</h2><p>使用阿里巴巴提供的 Java 语言编写的高性能完善的 JSON库 Fastjson，是目前 Java 语言最快的 JSON 库，可以实现 Java 对象和 JSON 字符串的相互转换。</p><ol><li>导入 Maven 坐标</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.62<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>Java 对象转 JSON 对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">jsonStr</span> <span class="operator">=</span> JSON.toJSONString(obj);</span><br></pre></td></tr></table></figure><ol start="3"><li>JSON 对象转 Java 对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> JSON.parseObject(jsonStr, User.class);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FastJsonDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、将 Java 对象转为 JSON 字符串</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setId(<span class="number">1</span>);</span><br><span class="line">        user.setName(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        user.setPassword(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> JSON.toJSONString(user);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        <span class="comment">// &#123;&quot;id&quot;:1,&quot;name&quot;:&quot;admin&quot;,&quot;password&quot;:&quot;admin&quot;&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、将 JSON 字符串转换为 Java 对象</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> JSON.parseObject(<span class="string">&quot;&#123;\&quot;id\&quot;:1,\&quot;name\&quot;:\&quot;admin\&quot;,\&quot;password\&quot;:\&quot;admin\&quot;&#125;&quot;</span>, User.class);</span><br><span class="line">        System.out.println(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Axios-JSON"><a href="#Axios-JSON" class="headerlink" title="Axios + JSON"></a>Axios + JSON</h1><ul><li>集合数据转为 JSON 字符串的操作叫做序列化，将 JSON 字符串转为 Java 对象的操作叫反序列化</li><li>将 JSON 数据响应回给浏览器，一定要设置响应数据的类型以及字符集</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/selectAllBrandServlet&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">selectAllBrandServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">BrandService</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BrandService</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// text/json</span></span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/json;charset=utf-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Brand&gt; brands = service.seletAllBrand();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonStr</span> <span class="operator">=</span> JSON.toJSONString(brands);</span><br><span class="line">        System.out.println(jsonStr);</span><br><span class="line"></span><br><span class="line">        resp.getWriter().write(jsonStr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前端页面发送请求以及处理数据（使用 Vue + element-ui 则没有那么麻烦）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        axios.<span class="title function_">get</span>(<span class="string">&quot;http://localhost/axios-json-demo/selectAllBrandServlet&quot;</span>)</span><br><span class="line">            .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">resp</span>) &#123;</span><br><span class="line">                <span class="keyword">let</span> brands = resp.<span class="property">data</span>;</span><br><span class="line">                <span class="keyword">let</span> tableData = <span class="string">&quot; &lt;tr&gt;\n&quot;</span> + <span class="string">&quot; &lt;th&gt;序号&lt;/th&gt;\n&quot;</span> + <span class="string">&quot; &lt;th&gt;品牌名称&lt;/th&gt;\n&quot;</span> + <span class="string">&quot; &lt;th&gt;企业名称&lt;/th&gt;\n&quot;</span> + <span class="string">&quot; &lt;th&gt;排序&lt;/th&gt;\n&quot;</span> + <span class="string">&quot; &lt;th&gt;品牌介绍&lt;/th&gt;\n&quot;</span> + <span class="string">&quot; &lt;th&gt;状态&lt;/th&gt;\n&quot;</span> + <span class="string">&quot; &lt;th&gt;操作&lt;/th&gt;\n&quot;</span> + <span class="string">&quot; &lt;/tr&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> brands) &#123;</span><br><span class="line">                    tableData += <span class="string">&quot;\n&quot;</span> + <span class="string">&quot; &lt;tr align=\&quot;center\&quot;&gt;\n&quot;</span> + <span class="string">&quot; &lt;td&gt;&quot;</span> + <span class="built_in">parseInt</span>(brands[i].<span class="property">id</span>) + <span class="string">&quot;&lt;/td&gt;\n&quot;</span> + <span class="string">&quot; &lt;td&gt;&quot;</span> + brands[i].<span class="property">brandName</span> + <span class="string">&quot;&lt;/td&gt;\n&quot;</span> + <span class="string">&quot; &lt;td&gt;&quot;</span> + brands[i].<span class="property">companyName</span> + <span class="string">&quot;&lt;/td&gt;\n&quot;</span> + <span class="string">&quot; &lt;td&gt;&quot;</span> + brands[i].<span class="property">ordered</span> + <span class="string">&quot;&lt;/td&gt;\n&quot;</span> + <span class="string">&quot; &lt;td&gt;&quot;</span> + brands[i].<span class="property">description</span> + <span class="string">&quot;&lt;/td&gt;\n&quot;</span> + <span class="string">&quot; &lt;td&gt;&quot;</span> + brands[i].<span class="property">status</span> + <span class="string">&quot;&lt;/td&gt;\n&quot;</span> + <span class="string">&quot;\n&quot;</span> + <span class="string">&quot; &lt;td&gt;&lt;a href=\&quot;#\&quot;&gt;修改&lt;/a&gt; &lt;a href=\&quot;#\&quot;&gt;删除&lt;/a&gt;&lt;/td&gt;\n&quot;</span> + <span class="string">&quot; &lt;/tr&gt;&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;table&quot;</span>).<span class="property">innerHTML</span> = tableData;</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++</title>
      <link href="/2022/04/11/C++/"/>
      <url>/2022/04/11/C++/</url>
      
        <content type="html"><![CDATA[<h1 id="核心篇"><a href="#核心篇" class="headerlink" title="核心篇"></a>核心篇</h1><h2 id="The-Basics"><a href="#The-Basics" class="headerlink" title="The Basics"></a>The Basics</h2><h3 id="Scope-and-Lifetime"><a href="#Scope-and-Lifetime" class="headerlink" title="Scope and Lifetime"></a>Scope and Lifetime</h3><p>• <strong>Local scope:</strong>  </p><p>A name declared in a function (§1.4) or lambda (§5.5) is called a local name. Its scope extends from its point of declaration to the end of the block in which its declaration occurs. A block is delimited by a { } pair. Function argument names are considered local names.</p><p>• <strong>Class scope:</strong> </p><p> A name is called a member name (or a class member name) if it is defifined in a class (§2.2, §2.3, Chapter 4), outside any function (§1.4), lambda (§5.5), or enum class (§2.5). Its scope extends from the opening { of its enclosing declaration to the end of that declaration.</p><p>• <strong>Namespace scope:</strong>  </p><p>A name is called a namespace member name if it is defifined in a namespace (§3.3) outside any function, lambda (§5.5), class (§2.2, §2.3, Chapter 4), or enumclass (§2.5). Its scope extends from the point of declaration to the end of its namespace.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">-1</span> ;</span><br><span class="line">cout &lt;&lt; ::cnt &lt;&lt; endl;<span class="comment">// 输出全局</span></span><br><span class="line">cout &lt;&lt; cnt &lt;&lt; endl;<span class="comment">// 输出局部</span></span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure><p><strong>Note：</strong> </p><p>An object must be constructed (initialized) before it is used and will be destroyed at the end of its scope. For a namespace object the point of destruction is the end of the program. For a member, the point of destruction is determined by the point of destruction of the object of which it is a member. An object created by new ‘‘lives’’ until destroyed by delete 562. User-Degined Types</p><h2 id="几个关键字"><a href="#几个关键字" class="headerlink" title="几个关键字"></a>几个关键字</h2><h3 id="Constants"><a href="#Constants" class="headerlink" title="Constants"></a>Constants</h3><p><strong>Const:</strong> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">const: meaning roughly &quot;I promise not to change this value.&quot; This is used primarily to specify interfaces, so that data can be passed to functions without fear of it being modified.the compiler enforces the promise made by const</span></span><br><span class="line"><span class="comment">意思是大致是 “保证不会改变这个值。” 这主要用于指定接口，以便数据可以传递给函数而不用担心它被修改。编译器强制执行Const</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>Contexptr:</strong> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">constexpr: meaning roughly &quot;to be evaluated at compile time.’&quot; This is used primarily to specify constants, to allow lacement of data in read-only memory (where it is unlikely to be corrupted) and for performance.</span></span><br><span class="line"><span class="comment">含义大致“在编译时进行评估。”这主要用于指定常量，以允许在只读存储器中放置数据（不太可能损坏）和性能。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>Sample:</strong> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> dmv = <span class="number">17</span>; <span class="comment">// dmv is a named constant</span></span><br><span class="line"><span class="type">int</span> var = <span class="number">17</span>; <span class="comment">// var is not a constant</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">double</span> max1 = <span class="number">1.4</span>∗<span class="built_in">square</span>(dmv); <span class="comment">// OK if square(17) is a constant expression</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">double</span> max2 = <span class="number">1.4</span>∗<span class="built_in">square</span>(var); <span class="comment">// error : var is not a constant expression</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> max3 = <span class="number">1.4</span>∗<span class="built_in">square</span>(var); <span class="comment">// OK, may be evaluated at run time</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">sum</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">double</span>&gt;&amp;)</span></span>; <span class="comment">// sum will not modify its argument (§1.8)</span></span><br><span class="line">vector&lt;<span class="type">double</span>&gt; v &#123;<span class="number">1.2</span>, <span class="number">3.4</span>, <span class="number">4.5</span>&#125;; <span class="comment">// v is not a constant</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> s1 = <span class="built_in">sum</span>(v); <span class="comment">// OK: evaluated at run time</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">double</span> s2 = <span class="built_in">sum</span>(v); <span class="comment">// error : sum(v) not constant expression</span></span><br></pre></td></tr></table></figure><h3 id="2-2-类型转换"><a href="#2-2-类型转换" class="headerlink" title="2.2 类型转换"></a>2.2 类型转换</h3><p>C++自动执行的类型转换：</p><ul><li>将一种算数类型的值赋给另一种算术类型bian</li><li>表达式中包含不同的类型时，C++将对值进行转换</li><li>将参数传递给函数时，C++将对值进行转换</li></ul><p><strong>初始化和赋值进行的转换：</strong> </p><ul><li>从 int 到 float、double、这些空间比原始空间大的，一般不会出问题</li><li>从 double、float 等到 int 的转换会出现截断，造成数据丢失</li><li>将一个值赋给取值范围更大的类型通常不会导致什么问题</li></ul><p><strong>潜在的数值转换问题：</strong> </p><table><thead><tr><th align="left">转换</th><th>潜在的问题</th></tr></thead><tbody><tr><td align="left">将较大浮点类型转换为较小的浮点类型，如将double转换成float</td><td>精度（有效数位）降低值可能超出目标类型的范围，在这种情况下。结果将是不确定的</td></tr><tr><td align="left">将浮点类型转换为整型</td><td>小数部分丢失，原来的值可能超出目标类型的取值范围，在这种情况下，结果将是不确定的（较小的值只是截断小数部分）</td></tr><tr><td align="left">将较大的整型转换为较小的整型，如将long转换为short</td><td>原来的值可能超出目标类型的范围，通常只复制右边的字节（低位）</td></tr></tbody></table><p>将0赋给bool变量时，将被转换为false，而非零值将被转换为true。</p><p><strong>以 { } 方式进行初始化时进行的转换（C++11)：</strong>  </p><p>C++将使用大括号的初始化称为初始化列表（list-initialization），因为这种初始化常用于给更复杂的数据类型提供值列表。与使用赋值运算符的初始化方式相比，它对类型转换的要求更严格。具体地说，列表初始化不允许缩窄（narrowing），及变量的类型可能无法表示赋给它的值。例如，不允许将浮点型转换成整型。在不同的整型之间或将整型转换成浮点型可能被允许，条件是编译器知道目标变量能够正确的存储赋给它的值。例如：将long变量初始化为int值，因为long总是至少和int一样长；相反方向的转换也可能被允许，只要int变量能够存储赋给它的long常量。</p><p><strong>表达式中的转换：</strong> </p><p>当同一个表达式中包含两种不同的算术类型时，C++将执行两种类型转换：</p><ol><li>一些类型在出现时便会自行转换；</li><li>有些类型在与其他类型同时出现在表达式中时将被转换。</li></ol><ul><li>自动转换：</li></ul><p> 在计算表达式时，C++将bool、char、unsigned char、signed char和short值转换为int。具体地说，true将被转换成1，false将被转换成0.这些转换被称为整型提升（integral promotion）（通常将int类型选择为计算机最自然的类型，这意味着计算机使用这种类型时，运算速度可能最快）。</p><ul><li>另外一些整型提升：如果short比int短，则unsigned int类型将被转换为int；如果两种类型的长度相同，则unsigned short类型将被转换为unsigned int。这种规则确保了在对unsignedshort进行提升时不会损失数据。同样地，wchar_t将被提升为下列类型中第一个宽度足够存储wchar_t取值范围的类型：int、unsigned int、long或者unsigned long。</li><li>将不同类型进行算术运算时，也会进行一些转换，例如将int和float相加时（使用的是双精度浮点型运算方式）。当运算涉及两种类型时，较小的类型将被转换为较大的类型。</li><li>校验表：<ol><li>如果有一个操作数的类型是long double，则将另一个操作数转换为long double。</li><li>否则，如果有一个操作数的类型是double，则将另一个操作数转换为double。</li><li>否则，如果有一个操作数的类型是float，则将另一个操作数的类型转换为float。</li><li>否则，说明操作数都是整型，因此执行整型提升。</li><li>在这种情况下，如果两个操作数都是由符号或无符号的，且其中一个操作数的级别比另一个低，则转换为级别高的类型。</li><li>如果一个操作数位有符号的，另一个操作数位无符号的，且无符号操作数的级别比有符号操作数高，则将有符号操作数转换为无符号操作数所属的类型。</li><li>否则，如果有符号类型可表示无符号类型的所有可能取值，则将无符号操作数转换为有符号操作数所属的类型</li><li>否则，将两个操作数都转换为有符号类型的无符号版本。</li></ol></li></ul><p><strong>传递参数时的转换：</strong> </p><p>传递参数时的类型转换通常由C++函数原型控制。然而，也可以取消原型对参数传递的控制，尽管这样做并不明智。在这种情况下，C++将对char和short欸行（signed和unsigned）应用整型提升。另外，为保持与传统C语言中大量代码的兼容性，再将参数传递给取消原型对参数传递控制的函数时，C++将float参数提升为double。</p><p><strong>强制类型转换：</strong> </p><p>C++还允许通过强制类型转换机制显式地进行类型转换，（C++认识到，必须有类型转换，而又时又需要推翻这些规则）。强制类型转换的格式有两种。例如，为将存储在变量thron中的int值转换为long类型，可以使用下属表达式中的一种：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">long</span>) thron;<span class="comment">// returns a type long conversion of thron</span></span><br><span class="line"><span class="built_in">long</span> (thron);<span class="comment">// returns a type long conversion of thron</span></span><br></pre></td></tr></table></figure><p>强制类型转换并不会修改变量本身，而是创建一个新的指定类型的值，可以在表达式中使用这个值。比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="built_in">int</span>(<span class="string">&#x27;Q&#x27;</span>); <span class="comment">//displays the integer code for &#x27;Q&#x27;</span></span><br></pre></td></tr></table></figure><p>强制类型转换地通用格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(typeName) value;<span class="comment">// converts value to typeName type</span></span><br><span class="line"><span class="built_in">typeName</span> (value)<span class="comment">// call opaerator() overload functuion, converts value to typeName type</span></span><br></pre></td></tr></table></figure><p>第一种格式来自C语言，第二种格式是纯粹的C++。新格式的想法时，要让强制类型转换就像是函数调用（其实就是函数调用，调用的是运算符 () 重载函数）。这样对内置类型地强制转换就像是位用户定义的类设计的类型转换。</p><h3 id="2-3-User-defined-data-type"><a href="#2-3-User-defined-data-type" class="headerlink" title="2.3 User_defined data type"></a>2.3 User_defined data type</h3><p><strong>Structures:</strong> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">The first step in building a new type is often to organize the elements it needs into a data structure,</span></span><br><span class="line"><span class="comment">a struct:</span></span><br><span class="line"><span class="comment">struct Vector &#123;</span></span><br><span class="line"><span class="comment">int sz; // number of elements</span></span><br><span class="line"><span class="comment">double∗ elem; // pointer to elements</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">We use . (dot) to access struct members through a name (and through a reference) and −&gt; to</span></span><br><span class="line"><span class="comment">access struct members through a pointer.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>Classes：</strong> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Having the data specified separately from the operations on it has advantages, such as the ability to</span></span><br><span class="line"><span class="comment">use the data in arbitrary ways. However, a tighter connection between the representation and the</span></span><br><span class="line"><span class="comment">operations is needed for a user-defined type to have all the properties expected of a ‘‘real type.’’ In</span></span><br><span class="line"><span class="comment">particular, we often want to keep the representation inaccessible to users, so as to ease use, guarantee consistent use of the data, and allow us to later improve the representation. To do that we have</span></span><br><span class="line"><span class="comment">to distinguish between the interface to a type (to be used by all) and its implementation (which has</span></span><br><span class="line"><span class="comment">access to the otherwise inaccessible data). The language mechanism for that is called a class. A</span></span><br><span class="line"><span class="comment">class is defined to have a set of members, which can be data, function, or type members. The interface is defined by the public members of a class, and private members are accessible only through</span></span><br><span class="line"><span class="comment">that interface.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>Unions:</strong> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">A union is a struct in which all members are allocated at the same address so that the union occupies only as much space as its largest member. Naturally, a union can hold a value for only one</span></span><br><span class="line"><span class="comment">member at a time. For example, consider a symbol table entry that holds a name and a value:</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Type</span> &#123; str, num &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Entry</span> &#123;</span><br><span class="line"><span class="type">char</span>∗ name;</span><br><span class="line">Type t;</span><br><span class="line"><span class="type">char</span>∗ s; <span class="comment">// use s if t==str</span></span><br><span class="line"><span class="type">int</span> i; <span class="comment">// use i if t==num</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Entry∗ p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p−&gt;t == str)</span><br><span class="line">cout &lt;&lt; p−&gt;s;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Maintaining the correspondence between a type field (here, t) and the type held in a union is error-prone. To avoid errors, one can encapsulate a union so that the correspondence between a type field and access to the union members is guaranteed. At the application level, abstractions relying on such tagged unions are common and useful, but use of &quot;naked&quot; unions is best minimized.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>Enumerations:</strong> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Enumerations are used to represent small sets of integer values. They are used to make code more readable and less error-prone than it would have been had the symbolic (and mnemonic) enumerator names not been used.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">By default, an enum class has only assignment, initialization, and comparisons (e.g., == and &lt; )defined</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">If you don’t want to explicitly qualify enumerator names and want enumerator values to be ints (without the need for an explicit conversion), you can remove the class from enum class to get a &quot;plain&quot; enum. The enumerators from a &quot;plain&quot; enum are entered into the same scope as the name of their enum and implicitly converts to their integer value.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">By default, the integer values of enumerators starts with 0 and increases by one for each additional enumerator. The &quot;plain&quot; enums hav e been in C++ (and C) from the earliest days, so even though they are less well behaved, they are common in current code.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 红、黄、蓝、白、黑 五种颜色的球若干，每次取三个，每次去出的三个球颜色都不同的情况满足要求</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Display</span><span class="params">(<span class="type">int</span> color)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">color_set</span>&#123; red, yellow, blue, white, black &#125;;    <span class="comment">// 可以在定义枚举提示声明枚举变量</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = red; i &lt;= black; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = red; j &lt;= black; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i != j)  <span class="comment">// 前两个球颜色不一样再继续判断</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(k = red; k  &lt;= black; k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(i != k &amp;&amp; j != k)</span><br><span class="line">                    &#123;</span><br><span class="line">                        cout &lt;&lt; ++count;</span><br><span class="line">                        cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">15</span>);</span><br><span class="line">                        <span class="built_in">Display</span>(i);</span><br><span class="line">                        cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">15</span>);</span><br><span class="line">                        <span class="built_in">Display</span>(j);</span><br><span class="line">                        cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">15</span>);</span><br><span class="line">                        <span class="built_in">Display</span>(k);</span><br><span class="line">                        cout &lt;&lt; endl;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Display</span><span class="params">(<span class="type">int</span> color)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(color)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>: cout &lt;&lt; <span class="string">&quot;black&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: cout &lt;&lt; <span class="string">&quot;white&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: cout &lt;&lt; <span class="string">&quot;blue&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: cout &lt;&lt; <span class="string">&quot;yellow&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: cout &lt;&lt; <span class="string">&quot;red&quot;</span>;  <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: cout &lt;&lt; <span class="string">&quot;Wrong color!&quot;</span> &lt;&lt; endl; <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-指针与OOP原理"><a href="#2-4-指针与OOP原理" class="headerlink" title="2.4 指针与OOP原理"></a>2.4 指针与OOP原理</h3><p>面向对象编程与传统的过程性编程的区别在于，OOP强调的是在运行阶段（而不是在编译阶段）进行决策。运行阶段指的是程序正在运行时，编译阶段指的是编译器将程序结合起来时。运行阶段决策就好比度假时，训责参观那些经典取决于天气和当时的心情；而编译阶段决策更像不管在什么条件下，都坚持预先设定的日程安排。</p><p>运行阶段决策体供了灵活性，可以根据当时的情况进行调整。例如，考虑为数组分配内存的情况。传统的方法是声明一个数组。要在C++中声明数组，必须指定数组的长度。因此，数组长度在程序编译时就设定好了；这就是编译阶段决策。</p><p>程序员可能认为，在80%的情况下，一个包含20个元素的数组就足够了，但程序有时需要处理200个元素。为了安全起见，使用了一个包含200个元素的数组。这样，程序在大多数情况下都浪费了内存。OOP通过将这样的决策推迟到运行阶段进行，使程序更灵活。在程序运行后，可以这次告诉它只需要20个元素，而还可以下次告诉它需要205个元素。</p><p>总之，使用OOP时，可以在运行阶段确定数组长度。为使用这种方法，语言必须允许在程序运行时创建数组。C++采取的方法是，使用关键字new请求正确数量的内存以及指针来追踪新分。配的内存的位置。</p><p>在运行阶段做决策并非OOP独有的，但是用C++编写这样的代码比C语言简单。</p><p>​    </p><h2 id="程序的内存模型"><a href="#程序的内存模型" class="headerlink" title="程序的内存模型"></a>程序的内存模型</h2><p>a. 代码区：存放函数体的二进制代码，由操作系统进行管理</p><p>b.全局区：存放全局变量、静态变量以及常量</p><p>c.栈  区：由编译器自动分配释放，存放函数的参数值、局部变量等</p><p>d.堆  区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收</p><p><img src="https://s2.loli.net/2023/03/25/Bwo1nzFTvKCDaNh.jpg" alt="内存分区模型"></p><h3 id="程序执行前"><a href="#程序执行前" class="headerlink" title="程序执行前"></a>程序执行前</h3><p><img src="https://s2.loli.net/2023/03/25/XFYZC3pj5Mqi2ze.png" alt="程序执行前"></p><p><strong>代码区和全局区</strong> </p><p>局部常量（const修饰的局部变量）和局部变量都不在全局区内</p><p>常量区中存放const修饰的全局变量和字符串常量</p><h3 id="代码执行过程后"><a href="#代码执行过程后" class="headerlink" title="代码执行过程后"></a>代码执行过程后</h3><p><strong>栈区</strong> </p><p> <img src="https://s2.loli.net/2023/03/25/frGMSoFXnJHbqcC.png" alt="栈区"></p><p>形参和局部变量也是存放在栈区中</p><p><strong>堆区</strong> </p><p><img src="https://s2.loli.net/2023/03/25/HGIj3whTRl7kX6Y.png" alt="堆区"> </p><h3 id="使用new操作符"><a href="#使用new操作符" class="headerlink" title="使用new操作符"></a>使用new操作符</h3><p><strong>基础语法：</strong> </p><p>使用new的方法：</p><p>创建单个数据：数据类型* 指针名 &#x3D; new 数据类型(数值)；</p><p>创建数组：数据类型* 指针名 &#x3D; new 数据类型[数据个数]；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//堆区的数据由程序员管理开辟释放，如果想要释放队却的数据则可以使用关键字delete</span><br><span class="line">//delete p;</span><br><span class="line">//cout &lt;&lt; *p &lt;&lt; endl;//使用了delete清除数据之后再进行输出操作会出现warning，在运行中程序异常中断,因为内存已释放，禁止非法访问</span><br><span class="line">//释放数组空间的操作：delete后面加[]</span><br><span class="line">//delete[] arr;</span><br></pre></td></tr></table></figure><p><strong>释放空间的方式</strong> </p><p>如果是单个数据则仅需delete 数据名 以分号结尾即可</p><p>如果是整个数组则需要delete[] 数组指针 以分号结尾</p><p><strong>特性</strong> ：定位new运算符</p><p>通常，new负责在堆中找到一个足以满足要求的内存块。new运算符还有另一种变体，被称为定位new运算符，它能让程序员指定要使用的位置。程序员可能使用这种特性来设置其内存管理规程，处理需要通过特定地址访问的硬件或在特定位置创建对象。</p><p>要使用定位new运算符特性，首先需要包含头文件new，它提供了这种版本的bew运算符原型；然后将new运算符用于提供了地址的参数，除需要指定参数外，句法与常规new运算符相同。具体地说，使用new定位运算符时，变量后面可以有方括号，也可以没有。下面演示new运算符的4种用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;new&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">chaff</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> dross[<span class="number">20</span>];</span><br><span class="line">  <span class="type">int</span> slag;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">char</span> buffer1[<span class="number">50</span>];</span><br><span class="line"><span class="type">char</span> buffer2[<span class="number">500</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    chaff *p1, *p2;</span><br><span class="line">    <span class="type">int</span> *p3, *p4;</span><br><span class="line">    <span class="comment">// first, the regular forms of new</span></span><br><span class="line">    p1 = <span class="keyword">new</span> chaff;<span class="comment">// place structure in heap</span></span><br><span class="line">    p3 = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">20</span>];<span class="comment">//place int array in heap</span></span><br><span class="line">    <span class="comment">// now, the two forms of placement new</span></span><br><span class="line">    p2 = <span class="built_in">new</span> (buffer1) chaff;<span class="comment">// place structure in buffer1</span></span><br><span class="line">    p4 = <span class="built_in">new</span> (buffer2) <span class="type">int</span>[<span class="number">20</span>];<span class="comment">// place int array in buffer2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>使用两个静态数组来定位new运算符提供内存空间。因此，上述代码从buffer1中分配空间给结构chaff，从buffer2中分配空间给一个包含20个元素的int数组。</code></pre><h3 id="自动存储、静态存储和动态存储"><a href="#自动存储、静态存储和动态存储" class="headerlink" title="自动存储、静态存储和动态存储"></a>自动存储、静态存储和动态存储</h3><ol><li>自动存储</li></ol><p> 在函数内部定义的常规变量使用自动存储空间，被称为自动变量（局部变量，声明时可以省略auto关键字），他们在所属函数被调用时产生，在该函数结束时消亡。</p><p> 自动变量通常存储在栈中。这意味着执行代码块时，其中的变量依次加入到栈中，而在离开代码块时，将按相反的顺序释放这些变量，这被称为后进先出（LIFO）。因此。在程序执行过程中，栈不断的增大和缩小。</p><ol start="2"><li>静态存储</li></ol><p>静态存储是整个程序执行期间都存在的存储方式。使变量成为静态的方式有两种：一种是在函数外面定义它；另一种是在声明时使用关键字static：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">double</span> fee = <span class="number">56.50</span>;</span><br></pre></td></tr></table></figure><p>在K&amp;R C中，只能初始化静态数组和静态结构，而C++ Release 2.0（及后续版本） 和 ANSI C中，也可以初始化自动数组和自动结构。</p><p>自动存储和静态存储的关键在于：这些方法严格地限制了变量的寿命。变量可能存在于程序的整个生命周期（静态变量），也可能只是在特定函数被执行时存在（自动变量）。</p><ol start="3"><li>动态存储</li></ol><p>new 和 delete 运算符提供了一种比自动变量和静态变量更灵活的方式。他们管理了一个内存池，这在C++中被称为自由存储空间（free store）或堆（heap）。该内存池同用于静态变量和自动变量的内存是自动分开的。new和delete让程序员对程序和使用内存有更大的控制权。然而，内存管理也更复杂了。在栈中，自动添加和删除机制使得占用的内存总是连续的但new和delete的互相影响可能导致占用的自由存储区不连续，这使得追踪新分配的位置更困难。</p><p><strong>栈、堆和内存泄露</strong> </p><p> 如果使用new运算符在自由存储空间（或堆）上创建变量之后，没有调用delete，则即使包含指针的内存由于作用域规则和对象生命周期的原因被释放，在自由存储空间上动态分配的变量或结构也将继续存在。实际上，将会无法访问自由存储空间中的结构，因为指向这些内存的指针无效。这导致内存泄漏被泄漏的内容将在程序的整个生命周期内都不可使用；这些内训被分配出去，但无法收回。极端情况（不过不常见）使，内存泄漏可能非常严重，以致于应用程序可用的内存被耗尽，出现内存耗尽错误，导致程序崩溃。另外，这种泄露还会给一些操作系统或在相同的内存空间中运行的应用程序带来负面影响，导致他们崩溃。</p><p> 即使是最好的程序员和软件公司，也可能导致内存泄漏。要避免内存泄露，最好是养成一种习惯，即同时使用new和delete运算符，在自由存储空间上动态分配内存，随后便释放它。C++智能指针有助于完成这种事情。</p><p><strong>注意：</strong> 指针是功能强大的C++工具之一，但也最危险，因为他们执行对计算机不太友好的操作，如使用未经初始化的指针来访问内存或者试图释放同一个内存块两次。另外，在通过实践习惯指针表示法和指针概念之前，指针时容易引起迷惑的。由于指针式C++编程的重要组成部分，后续会更加深入的讨论它。</p><p><strong>基于范围的for循环</strong> </p><p>C++11新增了一种循环，基于范围的（range_based）的for循环。这简化了一种常见的循环任务：对数组（或容器类，如vector和array）的每个元素执行相同的操作，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> prices[<span class="number">5</span>] = &#123; <span class="number">4.99</span>, <span class="number">10.99</span>, <span class="number">6.87</span>, <span class="number">7.99</span>, <span class="number">8.49</span> &#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">double</span> x : prices)</span><br><span class="line">cout &lt;&lt; x &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p> 其中，x最初表示数组prices的第一个元素。显示第一个元素后，不断执行循环，而x依次表示数组的其他元素。因此，上述代码i显示全部5个元素，每个元素各占一行。总之，该循环显示数组中的各个值。</p><p> 要修改数组的元素，需要使用不同的循环变量语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">double</span> &amp;x : prices)</span><br><span class="line">x *= <span class="number">0.80</span>;<span class="comment">// 20% off for sale</span></span><br></pre></td></tr></table></figure><p> 符号&amp;表明x是一个引用变量，这种声明让接下来的代码能够修改数组的内容，而第一种语法不能。这种用法主要是用在各种模板容器的遍历中。</p><h2 id="cin-get-ch-与cin-get"><a href="#cin-get-ch-与cin-get" class="headerlink" title="cin.get(ch)与cin.get()"></a>cin.get(ch)与cin.get()</h2><table><thead><tr><th>属性</th><th>cin.get(ch)</th><th>ch &#x3D; cin.get()</th></tr></thead><tbody><tr><td>传递输入字符的方式</td><td>赋给参数ch</td><td>将函数返回值赋给ch</td></tr><tr><td>用于字符输入时函数的返回值</td><td>istream对象（执行bool转换后为true）</td><td>int类型的字符串编码</td></tr><tr><td>达到EOF时函数的返回值</td><td>istream对象（执行bool转换后为false）</td><td>EOF</td></tr></tbody></table><pre><code>使用字符参数版本更符合对象方式，因为其返回值是istream对象。这意味着可以将他们拼接起来。</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cin.<span class="built_in">get</span>(ch1).<span class="built_in">get</span>(ch2);<span class="comment">// 这种方式也是可行的</span></span><br></pre></td></tr></table></figure><p>因为函数调用cin.get(ch1)返回一个cin对象，然后便可以通过该对象调用get(ch2)。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><h3 id="引用的基础语法"><a href="#引用的基础语法" class="headerlink" title="引用的基础语法"></a>引用的基础语法</h3><ol><li>int a&#x3D;10;</li><li>int &amp;b&#x3D;a;</li><li>b&#x3D;20;</li><li>cout &lt;&lt; a     &lt;&lt;endl;&#x2F;&#x2F;输出为20</li></ol><p>引用相当于给数据添加了一个别名或者叫绰号，通过引用进行的操作都是对地址的操作，对b进行赋值操作后，a的值也会改变（内存是同一块）</p><h3 id="引用的注意事项"><a href="#引用的注意事项" class="headerlink" title="引用的注意事项"></a>引用的注意事项</h3><ol><li>引用必须初始化</li><li>引用一旦初始化就不得更改，只要做了a的引用就不能再成为b的引用</li></ol><p>注意：如果引用了函数中定义的的局部变量，对其的第一次输出操作可以正常执行，但是超过一次，输出将为随机数</p><h3 id="引用作为函数的参数（形参）"><a href="#引用作为函数的参数（形参）" class="headerlink" title="引用作为函数的参数（形参）"></a>引用作为函数的参数（形参）</h3><p>在函数中进行交换数值的操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap03</span><span class="params">(<span class="type">int</span>&amp; a,<span class="type">int</span>&amp; b)</span></span></span><br><span class="line"><span class="function"><span class="comment">//这里是接收形参的操作，也是进行引用的操作，只是“绰号与原名相同”</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;由于进行过一次交换操作，下面一次交换的结果应与第一次相同&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;swap03形参:&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;swap03形参:&quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">swap03</span>(a, b);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;swap03实参:&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;swap03实参:&quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>能够实现交换两个数的数值的目的</p><h3 id="引用做函数的返回值"><a href="#引用做函数的返回值" class="headerlink" title="引用做函数的返回值"></a>引用做函数的返回值</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//引用做函数的返回值</span></span><br><span class="line"><span class="comment">//1.不要返回局部变量的引用</span></span><br><span class="line"><span class="comment">//2.函数的调用可以作为左值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1 */</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;<span class="comment">//局部变量，储存在栈区，程序运行结束后由操作系统回收内存</span></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2 */</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> a = <span class="number">10</span>;<span class="comment">//静态变量，储存于全局区，生存周期较长</span></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.局部变量引用做函数返回值</span></span><br><span class="line">    <span class="type">int</span>&amp; ref = <span class="built_in">test01</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ref=&quot;</span> &lt;&lt; ref &lt;&lt; endl;<span class="comment">//编译器保留的</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ref=&quot;</span> &lt;&lt; ref &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; endl;<span class="comment">//输出随机数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>&amp; ret = <span class="built_in">test02</span>();<span class="comment">//使用引用接收返回值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ret=&quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ret=&quot;</span> &lt;&lt; ret&lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>() = <span class="number">1000</span>;<span class="comment">//函数返回值是个引用，进行赋值操作后，输出的是赋给的值</span></span><br><span class="line">    <span class="comment">//（这样的赋值操作是直接对内存中存储的值进行更改），因此ret的值会随之改变</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ret=&quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ret=&quot;</span> &lt;&lt; ret &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引用的本质"><a href="#引用的本质" class="headerlink" title="引用的本质"></a>引用的本质</h3><p>引用的本质在C++内部实现是一个指针常量</p><p>C++推荐使用引用，因为语法比较简单，实质上引用本身也是指针，只不过一些不容易理解的指针操作都由编译器代替我们做了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发现是引用即将其转换为：int* const ref = &amp;a;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>&amp; ref)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ref = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自动转换为 int* const ref = &amp;a; 常量指针是指向的地址不可改，这里解释了引用不可更改的原因</span></span><br><span class="line"><span class="type">int</span>&amp; ref = a;</span><br><span class="line"></span><br><span class="line">ref = <span class="number">20</span>;<span class="comment">//内部发现ref是引用，自动转换为：*ref=20。</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ref:&quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">func</span>(a);</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CV-限定符"><a href="#CV-限定符" class="headerlink" title="CV-限定符"></a>CV-限定符</h3><p><strong>const使用方式</strong> </p><p><img src="https://s2.loli.net/2023/03/25/bt43VWGzN76ULfy.png" alt="const使用方式"> </p><p>将引用参数声明为常量数据的引用的理由：</p><ul><li>使用const可以避免无意中修改数据的编程错误</li><li>使用const引用使函数能够处理const和非const实参，否则将只接受非const数据</li><li>使用const引用使函数能够正确生成并使用临时变量</li></ul><p><strong>volatile使用方式</strong> </p><p>菜鸟教程：<a href="https://www.runoob.com/w3cnote/c-volatile-keyword.html">https://www.runoob.com/w3cnote/c-volatile-keyword.html</a></p><p>volatile产生的主要原因是操作系统会偏向于将经常使用的值存入寄存器，这种情况下数据的读取速度会更快，但是由于变量可能会在任何时候发生变化（如，在其它程序的影响下，多线程情况下等），所以为了避免使用时拿到的值不是变量的真实值，需要告诉操作系统，每次使用这个值的时候都从内存读取，而不是从寄存器中取。</p><h3 id="常量引用"><a href="#常量引用" class="headerlink" title="常量引用"></a>常量引用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用场景：用来修饰函数形参，防止误操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShowValue</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//val=1000;//添加了const以后会报错，但是加了const以后，可以不用担心变量的值在函数内被无端改变</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;val=&quot;</span> &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//int&amp; ref = a;//这里是可以的，只是如果不同数据类型的变量名相同会导致程序运行失败。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//int&amp; ref=10;//错误，引用的必须是合适的内存地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//const int&amp; ref = 10;</span></span><br><span class="line">    <span class="comment">//正确，但是其实是两步操作。</span></span><br><span class="line">    <span class="comment">//1.int temp = 10;</span></span><br><span class="line">    <span class="comment">//2.const int&amp; ref = &amp;temp;//需要理解常量指针是偏向于 “指针” ，而不是偏向于常量。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//ref = 20;//错误，</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>&amp; ref = a;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ref=&quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">ShowValue</span>(a);<span class="comment">//ShowValue(ref);</span></span><br><span class="line">    <span class="comment">//再次输出查看值是否改变</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ref=&quot;</span> &lt;&lt; ref &lt;&lt; endl;<span class="comment">//输出a还是ref是没有区别的</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/03/25/WekYUpNq7QjvZis.png" alt="const使用理由"></p><h2 id="Classes-and-Objects"><a href="#Classes-and-Objects" class="headerlink" title="Classes and Objects"></a>Classes and Objects</h2><ul><li>C++面向对象的三大特性：封装，继承，多态。</li><li>C++中认为一切都可以视为对象，对象有属性和行为</li></ul><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p><strong>意义：</strong> </p><ul><li>将属性作和行为作为一个整体，表示生活中的事物；</li><li>将属性和行为加以权限控制</li><li>意义一的体现形式：创建圆类，创建一个具体的圆，进行相关的操作。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="number">3.14</span>;<span class="comment">//#define PI 3.14</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建圆这个类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">circle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//访问权限</span></span><br><span class="line">    <span class="comment">//公共权限</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="comment">//半径</span></span><br><span class="line">    <span class="type">double</span> r;<span class="comment">//或者 int r;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取圆的周长的函数</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">calculate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * PI * r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;              &lt;&lt;&lt;------注意这个分号</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//通过圆这个类，创建一个具体的圆</span></span><br><span class="line">    circle c1;</span><br><span class="line">    c1.r = <span class="number">10</span>;          &lt;---调用类中元素的方式</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;圆的周长为：&quot;</span> &lt;&lt; c1.<span class="built_in">calculate</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-内联函数"><a href="#C-内联函数" class="headerlink" title="C++内联函数"></a>C++内联函数</h3><p>  内联函数时C++为提高程序运行速度所做的一项改进。常规函数与内联函数之间的主要区别不在于编写方式。而在于C++编译器如何将他们组合到程序中。要了解他们之间的区别，必须深入到程序内部。</p><p>  编译过程的最终产品时可执行程序——由一组机器语言指令组成。运行程序时，操作系统将这些指令载入到计算机的内存中，因此每一条指令都有特定的地址。计算机随后将逐步执行这些指令。有时（如有循环或分支语句时），将跳过一些指令，向前或向后跳到特定地址。常规函数调用也是程序跳到另一个地址（函数的地址），并在函数结束时返回。典型实现：执行到函数调用指令时，程序将在函数调用后立即存储该指令的内存地址，并将参数复制到堆栈中（为此保留的内存块），跳到标记函数的起点的内存单元，执行函数代码（也许还需将返回值放入到寄存器中），然后跳回到地址被保存的指令处。来回跳跃位置意味着以前使用函数时，需要一定的开销。</p><p>  C++内联函数提供了另一种选择。内联函数的编译代码与其他程序代码“内联“起来了。也就是说，编译器将使用相应的代码替换函数调用，程序无需跳转到另一个位置执行代码，再调回来。因此，内联函数的运行速度比常规函数稍快，但代价是需要占用更多的内存。<strong>如果程序在10个不同的地方来回调用同一个内联函数，则程序将包含该函数代码的10个副本（使用函数体替换函数调用，占用代码区内存）</strong>。</p><p>  应有选择地使用内联函数。如果执行函数代码的时间比处理函数调用机制的时间长，则节省的时间将只占整个过程的很小一部分。如果大妈执行的时间很短，则内联函数调用就可以节省非内联函数调用使用的大部分时间。另一方面，由于这个过程相当快，因此尽管节省了该过程的大部分时间，但节省的时间绝对值并不大，除非该函数经常被调用。</p><pre><code>要使用这些特性，必须采取下属措施之一：</code></pre><ul><li><p>函数声明前加上关键字inline</p></li><li><p>函数定义前加上关键字inline</p><p>通常做法是省略原型，将&#x2F;个定义（即函数头和所有函数代码）放在本应提供原型的地方。程序员请求将函数作为内联函数时，编译器不一定会满足这种请求。它可能认为该函数过大或者注意到函数调用了自己（内联函数不能递归），因此，部将其作为内联函数；而头屑编译器没有启用或实现这种特性。</p></li></ul><h3 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h3><ul><li>Public: 成员类内类外均可访问</li><li>Protected: 成员类内可访问，类外不可访问</li><li>Private: 成员类内可访问，类外不可访问</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">访问权限：</span></span><br><span class="line"><span class="comment">1、公共权限 public 成员类内可用，类外也可用</span></span><br><span class="line"><span class="comment">2、受保护权限 protected 成员类内可用，类外不可用</span></span><br><span class="line"><span class="comment">3、私有权限 private 成员类内可访问，类外不可访问</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">indvl</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string name;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">string car;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> pwd = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span><span class="comment">//函数也可以添加属性</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">name = <span class="string">&quot;zs&quot;</span>;</span><br><span class="line">car = <span class="string">&quot;桂C 0987&quot;</span>;</span><br><span class="line">pwd = <span class="number">12345</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">indvl p1;</span><br><span class="line">p1.name = <span class="string">&quot;zhangsan&quot;</span>;</span><br><span class="line"><span class="comment">//p1.car = &quot;贵C 0987&quot;;不可访问</span></span><br><span class="line"><span class="comment">//p1.pwd = 23456;不可访问</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Structures-and-Classes"><a href="#Structures-and-Classes" class="headerlink" title="Structures and Classes"></a>Structures and Classes</h3><ul><li>struct默认访问权限为public</li><li>class默认访问权限为private</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct默认访问权限为public</span></span><br><span class="line"><span class="comment">class默认访问权限为private</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">p</span></span><br><span class="line">&#123;</span><br><span class="line">string p_name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">stu</span></span><br><span class="line">&#123;</span><br><span class="line">string s_name;</span><br><span class="line"><span class="type">int</span> age = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">p</span> p1;</span><br><span class="line">p1.p_name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">stu</span> s1;</span><br><span class="line"><span class="comment">//s1.s_name = &quot;李思思&quot;;//不可访问</span></span><br><span class="line"><span class="comment">//s1.age = 18;//不可访问</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类设置为私有"><a href="#类设置为私有" class="headerlink" title="类设置为私有"></a>类设置为私有</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">成员属性设置为私有的优点：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1、可以自己控制读写权限(由程序员控制)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2、对于写可以检测数据的有效性</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>虽然在类外不能直接访问类内成员，但是可以通过定义具有public属性的函数来对类内元素进行访问</p><ul><li>函数一：设置元素的值</li><li>函数二：获取或接收元素的值</li></ul><p>类中元素使用“.”调用与结构体类似；类中函数的调用方式与类中元素的调用一致。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">成员属性设置为私有：</span></span><br><span class="line"><span class="comment">1、可以自己控制读写权限(由程序员控制)</span></span><br><span class="line"><span class="comment">2、对于写可以检测数据的有效性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设计一个人的“类”</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">indvl</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">//姓名 要求可读可写</span></span><br><span class="line">string i_name;</span><br><span class="line"><span class="comment">//年龄 要求只读 -&gt; 可读可写</span></span><br><span class="line"><span class="type">int</span> i_age = <span class="number">0</span>;<span class="comment">//一般都需要初始化，否则输出为乱码；</span></span><br><span class="line"><span class="comment">//爱人 要求只写</span></span><br><span class="line">string i_lover;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//设置姓名</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_name</span><span class="params">(string name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">i_name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取姓名</span></span><br><span class="line"><span class="function">string <span class="title">get_name</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> i_name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置年龄</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_age</span><span class="params">(<span class="type">int</span> age)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (age &gt;= <span class="number">0</span> &amp;&amp; age &lt;= <span class="number">150</span>)</span><br><span class="line">&#123;</span><br><span class="line">i_age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*i_age = 0;*/</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;这是个老妖精！&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取年龄</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_age</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">i_age = <span class="number">18</span>;<span class="comment">//默认值</span></span><br><span class="line"><span class="keyword">return</span> i_age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置爱人</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_lover</span><span class="params">(string lover)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">i_lover = lover;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">indvl p;</span><br><span class="line">p.<span class="built_in">set_name</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名为：&quot;</span> &lt;&lt; p.<span class="built_in">get_name</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;年龄为：&quot;</span> &lt;&lt; p.<span class="built_in">get_age</span>() &lt;&lt; endl;<span class="comment">//不允许直接改年龄，只能读</span></span><br><span class="line"></span><br><span class="line">p.<span class="built_in">set_lover</span>(<span class="string">&quot;王冰冰&quot;</span>);</span><br><span class="line"><span class="comment">//cout&lt;&lt; &quot;爱人是：&quot; &lt;&lt; p.i_lover &lt;&lt; endl;禁止访问i_lover</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-5-案例"><a href="#5-5-案例" class="headerlink" title="5.5 案例"></a>5.5 案例</h3><h4 id="5-5-1-立方体"><a href="#5-5-1-立方体" class="headerlink" title="5.5.1 立方体"></a>5.5.1 立方体</h4><ul><li>判断两个立方体相等的方式为判断两个立方体的体积和表面积是否同时相等</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">立方体设计：</span></span><br><span class="line"><span class="comment">1、创建立方体类</span></span><br><span class="line"><span class="comment">2、设计属性和行为</span></span><br><span class="line"><span class="comment">3、分别利用全局函数和成员函数判断两个立方体是否相等</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cube</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//公共权限，提供对类中元素和函数的调用</span></span><br><span class="line">    <span class="comment">//设置长</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_len</span><span class="params">(<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_l = len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//读取长</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_len</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置宽</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_wid</span><span class="params">(<span class="type">int</span> wid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_w = wid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//读取宽</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_wid</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置高</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_hei</span><span class="params">(<span class="type">int</span> hei)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_h = hei;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//读取高</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_hei</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算表面积</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">calculate_S</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">2</span> * m_l * m_h + <span class="number">2</span> * m_l * m_w + <span class="number">2</span> * m_w * m_h);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">calculate_V</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (m_l * m_w * m_h);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//成员函数判断是否相等</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">judgement_c_m</span><span class="params">(Cube &amp;c1,Cube &amp;c2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (c1.s == c2.s &amp;&amp; c1.v == c2.v)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_l;</span><br><span class="line">    <span class="type">int</span> m_w;</span><br><span class="line">    <span class="type">int</span> m_h;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> s;</span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line">&#125;;<span class="comment">//根据实际开发经验，要求类内元素访问权限为私有</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">equal</span><span class="params">(<span class="type">int</span> s1,<span class="type">int</span> s2,<span class="type">int</span> v1,<span class="type">int</span> v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s1 == s2 &amp;&amp; v1 == v2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Cube c1;<span class="comment">//立方体一</span></span><br><span class="line"></span><br><span class="line">    c1.<span class="built_in">set_len</span>(<span class="number">10</span>);</span><br><span class="line">    c1.<span class="built_in">set_wid</span>(<span class="number">10</span>);</span><br><span class="line">    c1.<span class="built_in">set_hei</span>(<span class="number">20</span>);</span><br><span class="line">    c1.s = c1.<span class="built_in">calculate_S</span>();</span><br><span class="line">    c1.v = c1.<span class="built_in">calculate_V</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;表面积为：&quot;</span> &lt;&lt; c1.s &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;体积为：&quot;</span> &lt;&lt; c1.v &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Cube c2;<span class="comment">//立方体二</span></span><br><span class="line"></span><br><span class="line">    c2.<span class="built_in">set_len</span>(<span class="number">10</span>);</span><br><span class="line">    c2.<span class="built_in">set_wid</span>(<span class="number">10</span>);</span><br><span class="line">    c2.<span class="built_in">set_hei</span>(<span class="number">18</span>);</span><br><span class="line">    c2.s = c2.<span class="built_in">calculate_S</span>();</span><br><span class="line">    c2.v = c2.<span class="built_in">calculate_V</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;表面积为：&quot;</span> &lt;&lt; c2.s &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;体积为：&quot;</span> &lt;&lt; c2.v &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> rst = <span class="built_in">equal</span>(c1.s, c1.v, c2.s, c2.v);</span><br><span class="line">    <span class="keyword">if</span> (rst)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;全局函数：两个立方体是相等的&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;全局函数：两个立方体不相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rst = c2.<span class="built_in">judgement_c_m</span>(c1,c2);<span class="comment">//终究是函数，直接调用，跟输入和计算都顺序无关</span></span><br><span class="line">    <span class="keyword">if</span> (rst)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;类内函数：两个立方体是相等的&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;类内函数：两个立方体不相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-5-2-点和圆的位置关系"><a href="#5-5-2-点和圆的位置关系" class="headerlink" title="5.5.2 点和圆的位置关系"></a>5.5.2 点和圆的位置关系</h4><p><strong>主要思想为：</strong> </p><ul><li>类中调用其他类：圆类调用点类（圆心）。</li><li>类的内容信息（如类中函数声明、类名、访问权限等）一般放在“.h”头文件中，通过包含头文件可以同样可以实现目标。</li><li>类中函数的具体实现可以另存在如“circle.cpp”和“point.cpp”中，而且“circle.cpp”和“point.cpp”必须调用“.h”头文件而主函数所在的文件中不需要调用“circle.cpp”和“point.cpp”</li></ul><p>point.h</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Point</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">//设置横坐标</span><br><span class="line">void Set_X(int x);</span><br><span class="line"></span><br><span class="line">//接收横坐标</span><br><span class="line">int Get_X();</span><br><span class="line"></span><br><span class="line">//设置纵坐标</span><br><span class="line">void Set_Y(int y);</span><br><span class="line"></span><br><span class="line">//接收纵坐标</span><br><span class="line">int Get_Y();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">int m_X;</span><br><span class="line">int m_Y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>point.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;06 point.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置横坐标</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Point::Set_X</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_X = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接收横坐标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Point::Get_X</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_X;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置纵坐标</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Point::Set_Y</span><span class="params">(<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_Y = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接收纵坐标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Point::Get_Y</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_Y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>circle.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;06 point.h&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//设置半径</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Set_R</span><span class="params">(<span class="type">int</span> r)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收半径</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Get_R</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置圆心</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Set_Center</span><span class="params">(Point center)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收圆心</span></span><br><span class="line"><span class="function">Point <span class="title">Get_Center</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_R;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以类为类中成员</span></span><br><span class="line">Point m_center;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>点和圆的位置关系.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;06 point.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;06 circle.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//企业开发中往往将类中的权限设为私有</span></span><br><span class="line"><span class="comment">//如果需要进行必要的访问则可以选择设置接口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//class Point</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//public:</span></span><br><span class="line"><span class="comment">////设置横坐标</span></span><br><span class="line"><span class="comment">//void Set_X(int x)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//m_X = x;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">////接收横坐标</span></span><br><span class="line"><span class="comment">//int Get_X()</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//return m_X;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">////设置纵坐标</span></span><br><span class="line"><span class="comment">//void Set_Y(int y)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//m_Y = y;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">////接收纵坐标</span></span><br><span class="line"><span class="comment">//int Get_Y()</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//return m_Y;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//private:</span></span><br><span class="line"><span class="comment">//int m_X;</span></span><br><span class="line"><span class="comment">//int m_Y;</span></span><br><span class="line"><span class="comment">//&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//class Circle</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//public:</span></span><br><span class="line"><span class="comment">////设置半径</span></span><br><span class="line"><span class="comment">//void Set_R(int r)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//m_R = r;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">////接收半径</span></span><br><span class="line"><span class="comment">//int Get_R()</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//return m_R;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">////设置圆心</span></span><br><span class="line"><span class="comment">//void Set_Center(Point center)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//m_center = center;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">////接收圆心</span></span><br><span class="line"><span class="comment">//Point Get_Center()</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//return m_center;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//private:</span></span><br><span class="line"><span class="comment">//int m_R;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">////以类为类中成员</span></span><br><span class="line"><span class="comment">//Point m_center;</span></span><br><span class="line"><span class="comment">//&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断点和圆的位置关系</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Position</span><span class="params">(Circle &amp;c,Point &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> dt;</span><br><span class="line"><span class="type">int</span> dr;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算两点之间距离的平方的关系</span></span><br><span class="line">dt = (c.<span class="built_in">Get_Center</span>().<span class="built_in">Get_X</span>() - p.<span class="built_in">Get_X</span>()) * (c.<span class="built_in">Get_Center</span>().<span class="built_in">Get_X</span>() - p.<span class="built_in">Get_X</span>())+</span><br><span class="line">(c.<span class="built_in">Get_Center</span>().<span class="built_in">Get_Y</span>() - p.<span class="built_in">Get_Y</span>()) * (c.<span class="built_in">Get_Center</span>().<span class="built_in">Get_Y</span>() - p.<span class="built_in">Get_Y</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算半径的平方</span></span><br><span class="line">dr = c.<span class="built_in">Get_R</span>() * c.<span class="built_in">Get_R</span>();</span><br><span class="line"><span class="comment">//判断关系</span></span><br><span class="line"><span class="keyword">if</span> (dt==dr)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;点在圆上&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (dt &gt; dr)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;点在圆外&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;点在圆内&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建一个圆</span></span><br><span class="line">Circle c;</span><br><span class="line">c.<span class="built_in">Set_R</span>(<span class="number">10</span>);</span><br><span class="line">Point center;</span><br><span class="line">center.<span class="built_in">Set_X</span>(<span class="number">10</span>);</span><br><span class="line">center.<span class="built_in">Set_Y</span>(<span class="number">0</span>);</span><br><span class="line">c.<span class="built_in">Set_Center</span>(center);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个点（圆内）</span></span><br><span class="line">Point p1;</span><br><span class="line">p1.<span class="built_in">Set_X</span>(<span class="number">10</span>);</span><br><span class="line">p1.<span class="built_in">Set_Y</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建第二个点（圆外）</span></span><br><span class="line">Point p2;</span><br><span class="line">p2.<span class="built_in">Set_X</span>(<span class="number">10</span>);</span><br><span class="line">p2.<span class="built_in">Set_Y</span>(<span class="number">11</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建第三个点（圆上）</span></span><br><span class="line">Point p3;</span><br><span class="line">p3.<span class="built_in">Set_X</span>(<span class="number">10</span>);</span><br><span class="line">p3.<span class="built_in">Set_Y</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断点和圆的位置关系</span></span><br><span class="line"><span class="built_in">Position</span>(c,p1);</span><br><span class="line"><span class="built_in">Position</span>(c,p2);</span><br><span class="line"><span class="built_in">Position</span>(c,p3);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-6-对象特性"><a href="#5-6-对象特性" class="headerlink" title="5.6 对象特性"></a>5.6 对象特性</h3><h4 id="5-6-1-构造函数和析构函数"><a href="#5-6-1-构造函数和析构函数" class="headerlink" title="5.6.1 构造函数和析构函数"></a>5.6.1 构造函数和析构函数</h4><p>（1）构造函数 初始化类 没有返回值不写void</p><ul><li>构造函数的名称与类名一致可以有参数，可以发生重载</li><li>创建类的时候会对进行调用而且只调用一次</li></ul><p>（2）析构函数 进行清理操作 没有返回值不写void</p><ul><li>析构函数的名称与类名一致 在名称前面加~</li><li>析构函数不可以有参数 不能发生重载</li><li>对象在销毁前会对析构函数进行调用而且只调用一次</li></ul><p><strong>注意：</strong> </p><ul><li>构造函数和析构函数都是一定会有的实现，如果程序员不写，那么编译器会自动生成空实现的构造函数和析构函数    </li><li>对于建立在不通过代码区域的对象来说析构函数的调用时机不同</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象的初始化和清理</span></span><br><span class="line"><span class="comment">//1、构造函数进行初始化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 1.构造函数 初始化类 没有返回值不写void</span></span><br><span class="line"><span class="comment">// 构造函数的名称与类名一致可以有参数，可以发生重载</span></span><br><span class="line"><span class="comment">// 创建类的时候会对进行调用而且只调用一次</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person构造函数的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2.析构函数 进行清理操作 没有返回值不写void</span></span><br><span class="line"><span class="comment">// 析构函数的名称与类名一致 在名称前面加~</span></span><br><span class="line"><span class="comment">// 析构函数不可以有参数 不能发生重载</span></span><br><span class="line"><span class="comment">// 对象在销毁前会对析构函数进行调用而且只调用一次</span></span><br><span class="line">~<span class="built_in">Person</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person析构函数的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数和析构函数都是一定会有的实现，如果程序员不写，那么编译器会自动生成空实现的构造函数和析构函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person p;<span class="comment">//建立在栈上的数据在函数运行完之后即被释放</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//Person p;//对于建立在不通过代码区域的对象来说析构函数的调用时机不同</span></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造函数的分类及调用"><a href="#构造函数的分类及调用" class="headerlink" title="构造函数的分类及调用"></a>构造函数的分类及调用</h4><p><strong>分类：</strong>  </p><ul><li>按照参数可以分为   有参构造和无参构造（默认构造）</li><li>按照类型可以分为   普通构造和拷贝构造</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数的分类及调用</span></span><br><span class="line"><span class="comment">//分类</span></span><br><span class="line"><span class="comment">//按照参数可以分为   有参构造和无参构造（默认构造）</span></span><br><span class="line"><span class="comment">//按照类型可以分为   普通构造和拷贝构造</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">man</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//普通构造：</span></span><br><span class="line"><span class="comment">//无参构造</span></span><br><span class="line"><span class="built_in">man</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;man构造函数的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//有参构造</span></span><br><span class="line"><span class="built_in">man</span>(<span class="type">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">age = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拷贝构造函数（只做复制不做修改所以使用const，传输地址所以使用引用）</span></span><br><span class="line"><span class="built_in">man</span>(<span class="type">const</span> man &amp;m)</span><br><span class="line">&#123;</span><br><span class="line">age = m.age;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;man拷贝构造函数的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">man</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;man析构函数的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> age=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//1.括号法</span></span><br><span class="line"><span class="comment">//man m1;//默认构造函数调用</span></span><br><span class="line"><span class="comment">//man m2(10);//调用有参构造函数</span></span><br><span class="line"><span class="comment">//man m3(m2);//调用拷贝构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意事项1：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 调用默认构造函数时不要加()，如果使用“Man m1();”的话，编译器自动认为这给语句为函数声明</span></span><br><span class="line"><span class="comment">* 返回值为man的一个类，函数名为m1。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;m2的年龄为：&quot; &lt;&lt; m2.age &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">////输出结果均为10</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;m3的年龄为：&quot; &lt;&lt; m3.age &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.显示法</span></span><br><span class="line">man m1;</span><br><span class="line">man m2=<span class="built_in">man</span>(<span class="number">10</span>);<span class="comment">//有参构造</span></span><br><span class="line">man m3 = <span class="built_in">man</span>(m2);<span class="comment">//拷贝构造</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名对象:</span></span><br><span class="line"><span class="comment">// man(10);//特点：当前行结束后系统立即处理匿名对象</span></span><br><span class="line"><span class="comment">// cout &lt;&lt; &quot;aaa&quot; &lt;&lt; endl;//会看到打印aaa之前有默认构造函数以及默认析构函数的调用痕迹（输出）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意事项2：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 不要用拷贝构造函数初始化匿名对象</span></span><br><span class="line"><span class="comment">* 例如：“man(m3);”针对此行代码，编译器会认为man(m3)等价于man m3；（对象声明）</span></span><br><span class="line"><span class="comment">*又因为上文中已经定义了m3所以会提示重定义</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.隐式转换法</span></span><br><span class="line">man m4 = <span class="number">10</span>;<span class="comment">//实质上等价于man m4 = man(10); 发生有参构造函数调用</span></span><br><span class="line">man m5 = m4;<span class="comment">//拷贝构造</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> </p><ul><li>注意事项1：  <ul><li>调用默认构造函数时不要加()，如果使用“Man m1();”的话，编译器自动认为这给语句为函数声明</li><li>返回值为man的一个类，函数名为m1。</li></ul></li><li>注意事项2：<ul><li>不要用拷贝构造函数初始化匿名对象</li><li>例如：“man(m3);”针对此行代码，编译器会认为man(m3)等价于man m3；（对象声明）</li><li>又因为上文中已经定义了m3所以会提示重定义</li></ul></li></ul><h4 id="拷贝构造函数的使用时机"><a href="#拷贝构造函数的使用时机" class="headerlink" title="拷贝构造函数的使用时机"></a>拷贝构造函数的使用时机</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">man</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">man</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;man默认构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">man</span>(<span class="type">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">m_age = a;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;man有参构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">man</span>(<span class="type">const</span> man &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">m_age = p.m_age;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;man拷贝构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">man</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;man析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> m_age = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拷贝构造函数调用时机</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.使用一个已经创建完毕的对象来初始化一个新对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">man <span class="title">m1</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">man <span class="title">m2</span><span class="params">(m1)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;m1的年龄：&quot;</span> &lt;&lt; m1.m_age &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;m2的年龄：&quot;</span> &lt;&lt; m2.m_age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.值传递的方式给函数参数传值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(man m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;test02()调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">man m;<span class="comment">//调用默认构造和析构函数</span></span><br><span class="line"><span class="built_in">func</span>(m);<span class="comment">//调用拷贝构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.值传递方式返回局部对象</span></span><br><span class="line"><span class="function">man <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">man m_1;<span class="comment">//局部变量，函数结束即回收空间</span></span><br><span class="line">cout &lt;&lt; &amp;m_1 &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> m_1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">man m = <span class="built_in">func1</span>();<span class="comment">//m_1已经被回收，所以这个m的地址跟m_1的地址绝对不同</span></span><br><span class="line">cout &lt;&lt; &amp;m &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*test01();</span></span><br><span class="line"><span class="comment">test02();*/</span></span><br><span class="line"><span class="built_in">test03</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造函数调用规则"><a href="#构造函数调用规则" class="headerlink" title="构造函数调用规则"></a>构造函数调用规则</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数的调用规则</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.创建一个类，C++编译器至少给这个类添加三个函数</span></span><br><span class="line"><span class="comment">构造函数（空实现）</span></span><br><span class="line"><span class="comment">析构函数（空实现）</span></span><br><span class="line"><span class="comment">拷贝构造函数（值拷贝）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2.如果创建了有参构造函数，编译器将不再提供无参构造函数，但是依然提供拷贝构造函数</span></span><br><span class="line"><span class="comment">如果写了拷贝构造函数编译器将不再提供其他普通构造函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">man</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/*man()</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; &quot;man默认构造函数调用&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">man</span>(<span class="type">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">m_age = a;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;man有参构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">man</span>(<span class="type">const</span> man&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">m_age = p.m_age;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;man拷贝构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">man</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;man析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> m_age = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//void test01()</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//man m;</span></span><br><span class="line"><span class="comment">//m.m_age = 18;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//man m1(m);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;m1的年龄为：&quot; &lt;&lt; m1.m_age &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">man <span class="title">m2</span><span class="params">(<span class="number">28</span>)</span></span>;</span><br><span class="line"><span class="function">man <span class="title">p</span><span class="params">(m2)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*test01();*/</span></span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-6-5-深拷贝与浅拷贝"><a href="#5-6-5-深拷贝与浅拷贝" class="headerlink" title="5.6.5 深拷贝与浅拷贝"></a>5.6.5 深拷贝与浅拷贝</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> m_age = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span>* height = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p><strong>浅拷贝：</strong> </p><p>指的是在拷贝对象时，只进行简单的赋值操作，这种行为带来的影响是：如果对象中包含建立在堆区的数据，并且使用指针指向这块内存地址，浅拷贝操作只是将这块内存的地址复制过来，但是并没有独立开辟空间。两个对象中只要有一个对指针的值进行了改动，另一个也会跟着受到牵连。析构会对这一块内存重复释放。</p><p><strong>深拷贝：</strong> </p><p>使用new操作符或者malloc函数在堆区开辟数据，使指针成员指向这块内存。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">man</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">man</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;man默认构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">man</span>(<span class="type">int</span> a , <span class="type">int</span> Height)</span><br><span class="line">&#123;</span><br><span class="line">m_age = a;</span><br><span class="line">height = <span class="keyword">new</span> <span class="built_in">int</span>(Height);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;man有参构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">解决方案是给复制后的值另new一块内存单元，将相同的数据被存储到不同的内存中之后，</span></span><br><span class="line"><span class="comment">再执行析构函数就不会有任何问题了</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">man</span>(<span class="type">const</span> man&amp; m)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;man 拷贝构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//height = m.height;//编译器的默认浅拷贝实现</span></span><br><span class="line">m_age = m.m_age;</span><br><span class="line"><span class="comment">//深拷贝操作：</span></span><br><span class="line">height = <span class="keyword">new</span> <span class="built_in">int</span>(*m.height);<span class="comment">//括号里的必须是数据，不能是地址。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">man</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//析构代码，将程序员在堆区上开辟的空间释放掉</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   浅拷贝的操作是将指针指向的地址拷贝下来，其带来的问题是堆区的内存有被重复释放的可能</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">*触发断点的原理是：堆区上的数据被释放的过程是遵循后进先出的原则的，</span></span><br><span class="line"><span class="comment">*   当析构函数判断出m2.height不为空时即释放内存中的内容，此内存单元被置为不可访问的状态，m2.height被置为空</span></span><br><span class="line"><span class="comment">*   但是m1.height不为空，此时程序还需要再对m1.height进行一次释放，</span></span><br><span class="line"><span class="comment">*   此时的操作被编译器认作非法操作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (height != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> height;</span><br><span class="line">height = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;man析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m_age = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span>* height = <span class="literal">NULL</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">man <span class="title">m1</span><span class="params">(<span class="number">18</span>, <span class="number">170</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;m1的年龄为：&quot;</span> &lt;&lt; m1.m_age &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;m1的身高为：&quot;</span> &lt;&lt; *m1.height &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="function">man <span class="title">m2</span><span class="params">(m1)</span></span>;<span class="comment">//在程序员没有写拷贝构造函数的情况下成功实现了拷贝构造的功能，虽然只是简单的复制操作，此即为浅拷贝</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;m2的年龄为：&quot;</span> &lt;&lt; m2.m_age &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;m2的身高为：&quot;</span> &lt;&lt; *m2.height &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造函数初始化列表"><a href="#构造函数初始化列表" class="headerlink" title="构造函数初始化列表"></a>构造函数初始化列表</h4><p>本质上是在构造函数调用成员类型的构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">indavl</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//traditional initializing mathod</span></span><br><span class="line"><span class="comment">/*indavl(int a, int b, int c)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">m_a = a;</span></span><br><span class="line"><span class="comment">m_b = b;</span></span><br><span class="line"><span class="comment">m_c = c;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化列表法</span></span><br><span class="line"><span class="comment">//构造函数形参列表之后给冒号</span></span><br><span class="line"><span class="built_in">indavl</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c) :<span class="built_in">m_a</span>(a), <span class="built_in">m_b</span>(b), <span class="built_in">m_c</span>(c)<span class="comment">//灵活赋值</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m_a;</span><br><span class="line"><span class="type">int</span> m_b;</span><br><span class="line"><span class="type">int</span> m_c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*indavl i1(10, 20, 30);*/</span></span><br><span class="line"><span class="function">indavl <span class="title">i1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; i1.m_a &lt;&lt;endl &lt;&lt; i1.m_b &lt;&lt; endl  &lt;&lt; i1.m_c &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-6-7-类作为其它类的成员"><a href="#5-6-7-类作为其它类的成员" class="headerlink" title="5.6.7 类作为其它类的成员"></a>5.6.7 类作为其它类的成员</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Phone</span>(string Mp_name)</span><br><span class="line">&#123;</span><br><span class="line">m_pname = Mp_name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Phone</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Phone的析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string m_pname;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">//Phone m_Phone = pName;等价于Phone(pName);</span></span><br><span class="line"><span class="built_in">Person</span>(string name, string pName): <span class="built_in">m_Name</span>(name),<span class="built_in">m_Phone</span>(pName)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person的构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Person</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person的析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string m_Name;</span><br><span class="line">Phone m_Phone;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当将其他类作为类的成员的时候，需要先构造类对象再构造自身</span></span><br><span class="line"><span class="comment">//析构的顺序是相反的，即先释放自身类的对象随后释放成员类的对象</span></span><br><span class="line"><span class="comment">//类似先进后出，先出后进</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;苹果MAX&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot;拿着&quot;</span> &lt;&lt; p.m_Phone.m_pname &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-6-8-静态成员变量"><a href="#5-6-8-静态成员变量" class="headerlink" title="5.6.8 静态成员变量"></a>5.6.8 静态成员变量</h4><p><strong>静态成员变量：</strong> </p><ol><li>所有对象共享同一套数据</li><li>编译阶段分配内存</li><li>类内声明，类外初始化</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">静态成员变量：</span></span><br><span class="line"><span class="comment">1、所有对象共享同一套数据</span></span><br><span class="line"><span class="comment">2、编译阶段分配内存</span></span><br><span class="line"><span class="comment">3、类内声明，类外初始化</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//静态成员变量：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">num</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//默认为私有属性</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//类内声明</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_a;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">//静态成员变量也有访问权限，与其他所有私有成员一样类外不可访问</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类外初始化</span></span><br><span class="line"><span class="type">int</span> num::m_a = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> num::m_b = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">num p;</span><br><span class="line">cout &lt;&lt; p.m_a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">num p2;</span><br><span class="line">p2.m_a = <span class="number">200</span>;</span><br><span class="line">cout &lt;&lt; p.m_a &lt;&lt; endl;<span class="comment">//200</span></span><br><span class="line">cout &lt;&lt; p2.m_a &lt;&lt; endl;<span class="comment">//200</span></span><br><span class="line"><span class="comment">//数据共有，一个改变，其余的也会随之改变</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//静态成员变量不属于某一个对象，而是所有对象共享一份数据</span></span><br><span class="line"><span class="comment">//访问方式:</span></span><br><span class="line"><span class="comment">//1、通过对象进行访问</span></span><br><span class="line">num n1;</span><br><span class="line">cout &lt;&lt; n1.m_a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、通过类名进行访问</span></span><br><span class="line">cout &lt;&lt; num::m_a &lt;&lt; endl;</span><br><span class="line"><span class="comment">//cout &lt;&lt; num::m_b &lt;&lt; endl;//不可访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-6-9-静态成员函数"><a href="#5-6-9-静态成员函数" class="headerlink" title="5.6.9 静态成员函数"></a>5.6.9 静态成员函数</h4><p><strong>静态成员函数：</strong> </p><ol><li>所有对象共用一个函数</li><li>静态成员函数只能访问静态成员变量</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">静态成员函数：</span></span><br><span class="line"><span class="comment">1、所有对象共用一个函数</span></span><br><span class="line"><span class="comment">2、静态成员函数只能访问静态成员变量，没有this指针</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">num</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//静态成员函数</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//静态成员函数能够访问静态成员变量</span></span><br><span class="line">m_a = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//m_b = 200;//静态成员函数不可访问非静态成员变量</span></span><br><span class="line"><span class="comment">//因为静态成员函数无法区分是哪个对象的m_b（静态成员变量共用数据，非静态成员变量与之不同）；</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;静态成员函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_a;</span><br><span class="line"><span class="type">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num::m_a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//1、通过对象访问</span></span><br><span class="line">num p;</span><br><span class="line">p.<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、通过类名访问</span></span><br><span class="line">num::<span class="built_in">func</span>();</span><br><span class="line"><span class="comment">//私有属性类外不可访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-6-10-C-对象模型"><a href="#5-6-10-C-对象模型" class="headerlink" title="5.6.10 C++对象模型"></a>5.6.10 C++对象模型</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//成员函数和成员变量是分开存储的</span></span><br><span class="line"><span class="comment">// 静态成员函数和静态成员变量只有一份，所以它不是任何一个对象的私有属性</span></span><br><span class="line"><span class="comment">// 空对象占用的空间为 1 bit</span></span><br><span class="line">   <span class="comment">// C++会给每个空的对象分配一字节的空间，目的是区分空的对象在内存中的位置</span></span><br><span class="line">   <span class="comment">// 每个空对象都应该有一个独一无二的内存地址</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数和成员变量是分开存储的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">empty_class</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态成员函数和静态成员变量只有一份，所以它不是任何一个对象的私有属性</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">num</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> m_a;<span class="comment">//非静态成员函数，属于类上</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_b;<span class="comment">//静态成员变量，不属于类上的元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;&#125;<span class="comment">//非静态成员函数，不属于类上</span></span><br><span class="line">     </span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;&#125;<span class="comment">//静态成员函数，不属于类上</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">empty_class e;</span><br><span class="line"><span class="comment">//空对象占用的空间为1bit</span></span><br><span class="line">    <span class="comment">//C++会给每个空的对象分配一字节的空间，目的是区分空的对象在内存中的位置</span></span><br><span class="line">    <span class="comment">//每个空对象都应该有一个独一无二的内存地址</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;size of an empty class is &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(e) &lt;&lt; endl;<span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">num n;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;size of n is &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(n) &lt;&lt; endl;<span class="comment">//4</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-6-11-this指针"><a href="#5-6-11-this指针" class="headerlink" title="5.6.11 this指针"></a>5.6.11 this指针</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 每一个非静态成员函数只会诞生一份函数实例，即多个对象会共用同一串代码</span></span><br><span class="line"><span class="comment">* 这一节主要解决：被不同对象调用的同一串代码如何判断是哪一个对象调用的自己</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*this指针指向被调成员函数所属对象</span></span><br><span class="line"><span class="comment">*this指针是隐含在所有非静态成员函数内的一种指针，即静态成员函数中没有this指针</span></span><br><span class="line"><span class="comment">*无需声明，直接调用即可</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* this指针的用途</span></span><br><span class="line"><span class="comment">* 1、当形参与成员函数名相同时，可以使用this指针来区分</span></span><br><span class="line"><span class="comment">* 2、在类的非静态成员函数下返回对象本身，可使用return *this</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">num</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">num</span>(<span class="type">int</span> value)<span class="comment">//添加this指针之后形参和赋值号右边的值被视为同一个变量</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//value = value;//无法输出正常值</span></span><br><span class="line"><span class="comment">//this指针指向被调成员函数所属对象</span></span><br><span class="line"><span class="keyword">this</span>-&gt;value = value;<span class="comment">//this指向的变量与类内的value属性被视为同一类变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">num&amp; <span class="title">func</span><span class="params">(num&amp; p)</span><span class="comment">//引用的实质即为根据内存找单元改内容，不加地址符改不动数值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; value;</span><br><span class="line"><span class="keyword">this</span>-&gt;value += p.value;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">//返回本身的话，p-&gt;age的值返回为增加后的值，再次调用则在原来的基础上再加</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、解决命名冲突问题</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">num <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1的值为：&quot;</span> &lt;&lt; p1.value &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、返回对象本身使用*this</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">num <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">num <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链式编程思想</span></span><br><span class="line">p2.<span class="built_in">func</span>(p1).<span class="built_in">func</span>(p1).<span class="built_in">func</span>(p1);<span class="comment">//把别人的值加到自身</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p2的值为：&quot;</span> &lt;&lt; p2.value &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-6-12-空指针调用成员函数"><a href="#5-6-12-空指针调用成员函数" class="headerlink" title="5.6.12  空指针调用成员函数"></a>5.6.12  空指针调用成员函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//空指针调用成员函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">num</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;this is a function inside num class.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里的value对于空指针来说是未开辟的，访问操作非法</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;value is &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;value &lt;&lt; endl;<span class="comment">//value等价于this-&gt;value</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">num* p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">p-&gt;<span class="built_in">func1</span>();<span class="comment">//单独正常输出，因为这一行代码没有涉及到内存空间问题</span></span><br><span class="line"></span><br><span class="line">p-&gt;<span class="built_in">func2</span>();<span class="comment">//因为p为空，没有分配内存地址就去访问内存当然会崩</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-6-13-const修饰成员函数"><a href="#5-6-13-const修饰成员函数" class="headerlink" title="5.6.13 const修饰成员函数"></a>5.6.13 const修饰成员函数</h4><p>常指针函数：</p><ul><li>1、成员函数加const之后称为常函数</li><li>2、常函数内部不可修改成员</li><li>3、成员属性声明时加关键字mutable后，在常函数内部依然可以修改成员属性</li></ul><p>常对象：</p><ul><li>1、声明对象前加const称该对象为常对象</li><li>2、常对象只能调用常函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 常指针函数：</span></span><br><span class="line"><span class="comment">* 1、成员函数加const之后称为常函数</span></span><br><span class="line"><span class="comment">* 2、常函数内部不可修改成员</span></span><br><span class="line"><span class="comment">* 3、成员属性声明时加关键字mutable后，在常函数内部依然可以修改成员属性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 常对象：</span></span><br><span class="line"><span class="comment">* 1、声明对象前加const称该对象为常对象</span></span><br><span class="line"><span class="comment">* 2、常对象只能调用常函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">num</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">//this指针的本质是一个常量指针，不能修改指向</span></span><br><span class="line"><span class="comment">//const num* const this//指针指向的值以及指针指向都不可改动</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span><span class="type">const</span><span class="comment">//加在其他位置都不合适，所以干脆放在了后面</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//在没有加const之前在函数内部修改成员属性直接使用类似value = 100;/this-&gt;value = 0;的操作即可</span></span><br><span class="line"><span class="comment">//添加const之后this-&gt;value = 0;为非法操作</span></span><br><span class="line"><span class="comment">//this = NULL;也是非法操作</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_a = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;类内普通成员函数的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> value;</span><br><span class="line"><span class="keyword">mutable</span> <span class="type">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">num p;</span><br><span class="line"><span class="comment">//p.display();//未提供构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">const</span> num p1;<span class="comment">//对象前面加const变为常对象</span></span><br><span class="line"><span class="comment">//p1.value = 100;//不可修改</span></span><br><span class="line">p1.m_a = <span class="number">100</span>;<span class="comment">//m_a是特殊值，常对象下也可以修改</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//常对象只能调用常函数</span></span><br><span class="line">p1.<span class="built_in">display</span>();</span><br><span class="line"><span class="comment">//p1.func();</span></span><br><span class="line"><span class="comment">//如果常对象可以调用普通成员函数，而普通成员函数内部又对属性进行了未知修改，则会给程序员的工作增加负担</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><p>引用一篇个人觉得非常好的博客<a href="https://blog.csdn.net/qq_42683011/article/details/102087764%EF%BC%8C%E4%BB%A5%E4%B8%8B%E5%86%85%E5%AE%B9%E5%9F%BA%E6%9C%AC%E4%B8%8A%E8%BD%AC%E8%87%AA%E6%AD%A4%E5%8D%9A%E5%AE%A2%E3%80%82">https://blog.csdn.net/qq_42683011/article/details/102087764，以下内容基本上转自此博客。</a></p><p><strong>重载</strong> </p><p>是指同一可访问区内被声明的几个具有不同参数列（参数的类型，个数，顺序不同）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型。</p><p><strong>重写：</strong> </p><p>是指派生类中存在重新定义的函数。其函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致。只有函数体不同（花括号内），派生类调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有virtual修饰。</p><p><strong>重载和重写的区别：</strong><br>（1）范围区别：重写和被重写的函数在不同的类中，重载和被重载的函数在同一类中。</p><p>（2）参数区别：重写与被重写的函数参数列表一定相同，重载和被重载的函数参数列表一定不同。</p><p>（3）virtual的区别：重写的基类函数必须要有virtual修饰，重载函数和被重载函数可以被virtual修饰，也可以没有。</p><p><strong>Advice：</strong> </p><ul><li>有些运算符必须作为类成员被重载(下面具体说明)</li><li>复合赋值运算符(+&#x3D;, -&#x3D;, *&#x3D;, &#x2F;&#x3D;, %&#x3D;等), 通常来说应该作为类成员, 但C++标准没有强制</li><li>改变对象状态的运算符, 与给定类型密切相关的运算符(如++自增,–-自减, *解引用), 通常作为类成员</li><li>具有对称性的运算符(即左右操作数互换后不影响重载运算符内部操作的, 如算数运算符, 关系运算符等)通常作为普通函数或友元函数</li></ul><p><strong>限制：</strong> </p><ul><li>实际上，operator能重载的运算符只有运算符对操作数的操作，不能改变其他东西。</li></ul><ol><li>operator重载相应的运算符时仍需要遵守其原定语法，不能将双目运算符重载为单目运算符（实际上也是编译器判定参数的一个标准），也不能修改运算符的优先级；</li><li>重载运算符时不能覆盖原有运算，即操作数中必须有一个自建类型，这虽然限制了操作性，但保护了程序的正常执行；</li><li>只能重载原有运算符，不能创建新的运算符，比如**之类的；</li><li>不能重载特定运算符</li></ol><p><img src="https://s2.loli.net/2023/03/25/cQuy72A5lLCB31U.png" alt="运算符表"></p><ol><li><p>必须作为类成员函数的运算符重载：</p><p><strong>C++规定，&#x3D; 赋值运算符，[]下标运算符，()函数调用运算符，-&gt;指针访问成员运算符，只能是类的成员不能定义为全局函数然后声明为友元。</strong> </p><p>因为，对于static静态成员函数，由于没有this指针，只能访问到类的static静态成员，导致无法对类对象进行操作，而对于友元函数，编译器在类中寻找是否存在自建的 operator&#x3D; 时，判定条件为是否有显式（explicit）地提供一个以本类或本类的引用为参数的运算符重载函数，而友元函数不属于类所有，所以编译器在类中找不到用户自定义的 operator&#x3D; 函数，会自动生成默认的 operator&#x3D; 函数，这样，在调用时会产生冲突（两个都合适，不知道调用哪个），所以C++限制了 operator&#x3D; 的重载位置（只能在类内）；</p></li><li><p>重载运算符无法保留一些运算符原有的特性</p><ol><li>&amp;&amp;以及||，这两个运算符对算子的操作顺序无法保留；</li><li>&amp;&amp;以及||，这两个运算符的重载版本无法保留原有的短路求值属性；</li></ol></li></ol><p><strong>不该重载的韵运算符：</strong> </p><p><strong>包含与（&amp;&amp;）、或（||）、还有 取地址符（&amp;），因为在C++中已经定义了其对类对象那的操作，重载该运算符会导致其失去一部分功能，为类的使用者带来麻烦。</strong> </p><p><strong>参数：</strong> </p><p>一般的，以赋值运算符的重载版本为例，其参数是所在类的 const 类型的引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Person &amp;p)<span class="comment">//返回引用类型避免再次调用拷贝构造函数创建副本</span></span><br></pre></td></tr></table></figure><p>添加const是因为：</p><ul><li>我们不希望传入的赋值模板在这个函数中遇到任何修改</li><li>加上const，对于函数而言，它能够接受 const 和 非const 类型的参数，如果不加 const 就只能接受 非const类型的参数</li></ul><p>使用引用的原因：</p><ul><li>避免在调用时对实参的拷贝（以传过来的参数为模板创建的临时变量）</li></ul><p><strong>返回值：</strong> </p><p>一般地，返回值是被赋值者的引用（但有时返回左值还是右值需要深究），即*this</p><ul><li>直接返回引用，避免再次发生拷贝（以返回对象为模板创建的临时变量）</li><li>更重要的是，根据赋值运算符从左到右的结合律，可以实现连续赋值，体现的是C++的链式编程思想，如果返回的是值，则执行连续赋值操作后得到的是匿名副本（不可改变的右值），再重复赋值操作就会出错</li></ul><p><strong>调用时机：</strong> </p><p>当使用运算符而非基本对象时，编译器会根据调用的运算符和操作数类型查找相应的重载运算符函数，如果找不到就会出错，需要格外注意的情况：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Peron p1;</span><br><span class="line">Person p2;</span><br><span class="line">p2 = p1;<span class="comment">// 调用赋值运算符</span></span><br><span class="line">Person p3 = p1; <span class="comment">// 调用拷贝构造函数</span></span><br></pre></td></tr></table></figure><p>运算符的操作在类对象的定义中通常被编译器link到类的初始化，从而与真正的运算符重载无缘。</p><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p><strong>作用：</strong> </p><ul><li>不同的函数函数名可以相同，提高复用性，但是函数实现的作用应当相似</li></ul><p><strong>函数重载应当满足的条件：</strong> </p><ol><li>同一个作用域下</li><li>函数名相同</li><li>参数名不同，参数个数不同或者参数顺序不同</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 引用作为重载条件</span></span><br><span class="line"><span class="comment">//2. 函数重载遇到函数默认值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 引用作为重载条件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>&amp; a)</span><span class="comment">//接收的是地址</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func(int&amp; a)的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//int 和 const int 的类型是不一样的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.2</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; a)</span><span class="comment">//接收常量</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func(const int&amp; a)的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 函数重载遇到函数默认值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a)</span><span class="comment">//没有默认参数值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func(int a)的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.2</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b=<span class="number">10</span>)</span><span class="comment">//有默认参数值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func(int a,int b=10)的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    //调用函数1.1：func(int&amp; a)</span></span><br><span class="line"><span class="comment">    int a = 10;</span></span><br><span class="line"><span class="comment">    func(a);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//func(10);//调用1.2：(const int&amp; a), 由于int&amp; a 与 10（常量） 一定不可能相等，所以只能调用函数1.2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//func2(10);//报错，无法运行，这句话可以调用2.1，也可以调用2.2，因含有二义性发生错误</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//func2(10,20);//调用函数2.2，因为有2.2参数传输到函数里</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*函数2.1无法在其他函数保留的情况下单独被调用*/</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p><strong>注意：</strong> </p><ul><li>1、如果没有运算符重载不能实现将两个一般情况下不满足直接相加的数据进行加运算，比如：新建数据类型，不满足加法运算的数据类型。编译器会报错，“没有与这些操作数匹配的’+’（或其他）运算符，操作类型为 Data +  Data（Data为类）”</li><li>2、运算符重载只能对自定义数据类型进行定义运算规则，默认可以进行运算的数据类型之间的运算不可改变（int+int,string+string）</li><li>3、运算符重载不可滥用（加中写减）</li></ul><p><strong>operator 重载运算符方式:</strong><br>既然是用于自建类型的运算, 则其可以有两种定义方式:</p><ul><li><p>作为自建类型的成员函数, 定义在类的内部</p><p>此时operator的参数数目比具体重载的运算符操作数数目少一, 因为此时使用的一个隐含参数为* this, 并将其作为左操作数(第一个操作数)<br>如果需要将* this作为右操作数, 只能将operator作为友元函数</p></li><li><p>作为自建类型的友元函数, 定义在类的内部或外部</p><p>此时operator的参数数目与具体重载的运算符操作数数目相同<br>​</p></li></ul><h4 id="重载-运算符"><a href="#重载-运算符" class="headerlink" title="重载 + 运算符"></a>重载 + 运算符</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加号运算符重载</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 复习函数重载的内容：</span></span><br><span class="line"><span class="comment">* 不同函数使用相同名称通过重新定义实现不同的功能，重载的条件可以是引用（int 和 const int 的类型是不一样的，“数据类型  &amp;”和普通的“数据类型”也是不一样的），参数个数不同，参数数据类型不同，但是不能以函数的返回值类型为标准实现函数重载</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//1、成员函数实现函数重载</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//成员函数实现重载</span></span><br><span class="line"><span class="comment">/*Data operator+(Data &amp;d)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">Data temp;</span></span><br><span class="line"><span class="comment">temp.m_a = this-&gt;m_a + d.m_a;</span></span><br><span class="line"><span class="comment">temp.m_b = this-&gt;m_b + d.m_b;</span></span><br><span class="line"><span class="comment">return temp;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m_a;</span><br><span class="line"><span class="type">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、全局函数实现函数重载</span></span><br><span class="line">Data <span class="keyword">operator</span>+(<span class="type">const</span> Data &amp;d1, <span class="type">const</span> Data &amp;d2)</span><br><span class="line">&#123;</span><br><span class="line">Data temp;</span><br><span class="line">temp.m_a = d1.m_a + d2.m_a;</span><br><span class="line">temp.m_b = d1.m_b + d2.m_b;</span><br><span class="line">cout &lt;&lt; temp.m_a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; temp.m_b &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运算符重载中的函数重载</span></span><br><span class="line">Data <span class="keyword">operator</span>+(<span class="type">const</span> Data&amp; d1, <span class="type">int</span> num)</span><br><span class="line">&#123;</span><br><span class="line">Data temp;</span><br><span class="line">temp.m_a = d1.m_a + num;</span><br><span class="line">temp.m_b = d1.m_b + num;</span><br><span class="line">cout &lt;&lt; temp.m_a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; temp.m_b &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Data d1;</span><br><span class="line">d1.m_a = <span class="number">7</span>;</span><br><span class="line">d1.m_b = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">Data d2;</span><br><span class="line">d2.m_a = <span class="number">8</span>;</span><br><span class="line">d2.m_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Data d3 = d1 + d2;//报错：没有与这些操作数匹配的&#x27;+&#x27;运算符，操作类型为 Data +  Data</span></span><br><span class="line"></span><br><span class="line">Data d3;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 成员函数实现重载：</span></span><br><span class="line"><span class="comment">*d3 = d1.operator+(d2);</span></span><br><span class="line"><span class="comment">*实质是调用p1成员函数operator+，传入d2，实现d3 = d1 + d2;的操作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*全局函数实现重载：</span></span><br><span class="line"><span class="comment">* 注意函数的位置，这里使用的如果是全局函数则需要保证全局函数在teat01之前实现</span></span><br><span class="line"><span class="comment">*可以使用d3 = operator+(d1, d2);实质是调用全局函数直接操作；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">d3 = d1 + d2;</span><br><span class="line"></span><br><span class="line">Data d4 = d1 + <span class="number">10</span>;<span class="comment">//Data d4 = operator+(d1, 10);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 注意：</span></span><br><span class="line"><span class="comment">* 1、如果没有运算符重载不能实现将两个一般情况下不满足直接相加的数据进行加运算</span></span><br><span class="line"><span class="comment">* 2、运算符重载只能对自定义数据类型进行定义运算规则，默认可以进行运算的数据类型之间的运算不可改变（int+int,string+string）</span></span><br><span class="line"><span class="comment">* 3、运算符重载不可滥用（加中写减）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> 原先说比较偏向于使用全局函数重载的版本是因为：原以为成员函数重载版本在调用时一定要使用operator+，但是实际上并不是这样，成员函数也可以 p1 + p2 。</p><p>至于主流为什么使用全局函数重载版本，C++标准规定，成员函数中进行的运算，对象只能位于运算符左边，即 obj.age + n; 这种形式</p><h4 id="重载-和-运算符"><a href="#重载-和-运算符" class="headerlink" title="重载 &lt;&lt; 和 &gt;&gt; 运算符"></a>重载 &lt;&lt; 和 &gt;&gt; 运算符</h4><p>由于I&#x2F;O操作通常需要读写对象的参与，且自建成员通常为右操作数，所以重载运算符一般设置为友元函数（成员函数中，如果需要类内成员变量参与运算，类内成员必须在运算符的左侧）。</p><p>这类重载函数通常需要使用C++ IO库成员，但是I&#x2F;O对象无法被拷贝或者赋值，所有的操作只能通过指针过着引用来完成，所以函数参数和返回值通常是IO对象的引用（IO对象的引用引用相当于给IO对象起别名，未必一定要叫 cout 和 cin）。</p><p>另外，由于向流中写入或读取数据会导致流的状态发生变化，所以重载运算符的函数中无法使用const类型的IO成员</p><p><strong>重载 &lt;&lt; 运算符：</strong> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, <span class="type">const</span> person&amp; p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//默认构造函数，或提供接口</span></span><br><span class="line"><span class="built_in">person</span>(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line">m_a = a;</span><br><span class="line">m_b = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">//利用成员函数进行插入运算符的重载，得到的调用形式是p &lt;&lt; cout;与原先的想法不一致，代码有问题</span></span><br><span class="line"><span class="comment">/*void operator&lt;&lt;(ostream cout)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="type">int</span> m_a;</span><br><span class="line"><span class="type">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数无法帮助我们达到目的，所以选择使用全局函数</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;cout,<span class="type">const</span> person&amp; p)</span><br><span class="line"><span class="comment">//cout是输出流对象，全局只能有一个。以引用的形式调用</span></span><br><span class="line"><span class="comment">//引用的本质是给元素起别名，所以cout也可以写成out</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;m_a= &quot;</span> &lt;&lt; p.m_a &lt;&lt; <span class="string">&quot;\t m_b= &quot;</span> &lt;&lt; p.m_b &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//cout &lt;&lt; p1;//没有与这些操作数匹配的 &quot;&lt;&lt;&quot; 运算符，没有这样的输出方式，需要重载</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//链式编程，输出后返回cout，可以实现不断地往后追加</span></span><br><span class="line">cout &lt;&lt; p1 &lt;&lt; <span class="string">&quot;Hello world!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>重载 &gt;&gt; 运算符：</strong> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这个也比较简单，只是需要注意分界字符的问题（空格等）</span></span><br><span class="line"><span class="comment">在重载函数中分别输入自定义数据类型的成员</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>总结：</strong> </p><ul><li><p>为了与通常习惯相近，我比较偏好设置 &lt;&lt; 和 &gt;&gt; 运算符重载版本为友元函数，并且，由于在函数中不用修改传入参数的值，所以将函数的第二个参数设置为const类型。</p></li><li><p>针对&gt;&gt;的重载运算符:<br>由于输入的特殊性, 在重载运算符函数中有必要考虑可能的输入失败的情况并作出补救措施(如重置成初始状态)<br>判断方法可以通过IO成员内置的标识符来判定（eofbit, failbit, goodbit）。常见的错误有:</p><ul><li>流中含有错误类型的数据时读取操作可能失败</li><li>、当读取到文件末尾或遇到流中的其他错误</li></ul></li></ul><p>在类对象的输出中，应该尽可能少的进行格式化输出，而将这个任务交给类的使用者，使其更加自如地使用这个类。 </p><h4 id="重载-运算符-1"><a href="#重载-运算符-1" class="headerlink" title="重载 ++ 运算符"></a>重载 ++ 运算符</h4><ul><li>对于前置++运算符的重载，要求其参数为空</li><li>对于后置版本的++运算符重载，要求其参数只有一个，并且必须是int</li></ul><p>作用是为了区分前置和后置版本，同时告诉编译器这个运算符后面是有参数的，这样编译器才知道这是后置版本，编译器在调用后置版本的重载运算符时候传入一个0给形参，但是一般不会使用到这个值，所以一般不提供标识符</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//自增运算符重载</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myinteger</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, Myinteger myint);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Myinteger</span>()<span class="comment">//稍加改动即可以作为接口使用</span></span><br><span class="line">&#123;</span><br><span class="line">num = <span class="number">0</span>;<span class="comment">//构造函数初始化数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载前置++运算符</span></span><br><span class="line"><span class="comment">//返回引用是为了能够实现多次自增操作，这里体现的是值传递和址传递的区别（形参和实参）</span></span><br><span class="line"><span class="comment">//对地址进行操作才能保证有效自增（数据被记录）</span></span><br><span class="line">Myinteger&amp; <span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//先对数据进行自增</span></span><br><span class="line">num++;</span><br><span class="line"><span class="comment">//然后返回自身，返回的是引用说明在下一次参与运算时拿到的是引用</span></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载后置++运算符</span></span><br><span class="line"><span class="comment">//注意函数重载的条件：void operator++(int)   int作为占位参数，可以将前置和后置区分开，返回值类型不能作为函数重载的条件</span></span><br><span class="line">Myinteger <span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//1、记录当前值</span></span><br><span class="line">Myinteger temp = *<span class="keyword">this</span>;</span><br><span class="line"><span class="comment">//2、自增</span></span><br><span class="line">num++;</span><br><span class="line"><span class="comment">//3、返回记录值</span></span><br><span class="line"><span class="keyword">return</span> temp;<span class="comment">// 局部变量，出了函数就销毁，不可返回引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为了保证输出的时候cout在左侧，使用全局函数，并且为了能够实现打印类内私有元素的目的使用了友元技术</span></span><br><span class="line"><span class="comment">//重载插入运算符</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, Myinteger myint)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; myint.num &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Myinteger myint;</span><br><span class="line">cout &lt;&lt; ++(++myint) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; myint++ &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; myint &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>前置递增返回引用，后置递增返回值</li><li>i &#x3D; 1, cout &lt;&lt; ++i + ++i &lt;&lt; endl;      &#x2F;&#x2F; 6 因为返回的是引用</li></ul><h4 id="重载-–-运算符"><a href="#重载-–-运算符" class="headerlink" title="重载 – 运算符"></a>重载 – 运算符</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myinteger</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, Myinteger myint);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Myinteger</span>()</span><br><span class="line">&#123;</span><br><span class="line">num = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前置--</span></span><br><span class="line">Myinteger&amp; <span class="keyword">operator</span>--()</span><br><span class="line">&#123;</span><br><span class="line">num--;<span class="comment">//这是编译器认识的数据类型，可以进行自减操作</span></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后置--</span></span><br><span class="line">Myinteger <span class="keyword">operator</span>--(<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">Myinteger temp = *<span class="keyword">this</span>;</span><br><span class="line">num--;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, Myinteger myint)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; myint.num &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Myinteger myint;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;test01&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; myint &lt;&lt; endl;<span class="comment">//myint 的数据类型是 Myinteger，必须重载运算符，不然无法输出</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; myint-- &lt;&lt; endl;//如果想要</span></span><br><span class="line">cout &lt;&lt; --(--myint) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; myint &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后置运算符重载之后会使得原有定义的 -- 失效</span></span><br><span class="line"><span class="comment">//重载后的 -- 需要左值，这一点与自增一样</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Myinteger myint;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;test02&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; myint &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; (myint--)-- &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; myint &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="重载-运算符-2"><a href="#重载-运算符-2" class="headerlink" title="重载 &#x3D; 运算符"></a>重载 &#x3D; 运算符</h4><p><strong>必须要作为类内成员函数进行重载的</strong> </p><p>为了解决对象之间的相互赋值中出现的浅拷贝问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> age)<span class="comment">//浅拷贝将m_age的地址和值全复制了过去，析构的时候重复释放内存空间</span></span><br><span class="line">&#123;</span><br><span class="line">m_age = <span class="keyword">new</span> <span class="built_in">int</span>(age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Person</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_age;</span><br><span class="line">m_age = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Person &amp;p)<span class="comment">//返回引用类型避免再次调用拷贝构造函数创建副本</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//判断赋值号右边元素在堆区是否有数据，有则释放；所以this指向的是赋值号右边的元素</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;未知身份的人的年龄&quot;</span> &lt;&lt; *<span class="keyword">this</span> -&gt; m_age &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">this</span> -&gt; m_age;<span class="comment">//delete m_age;</span></span><br><span class="line"><span class="keyword">this</span> -&gt; m_age = <span class="literal">NULL</span>;<span class="comment">//m_age = NULL;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span> -&gt; m_age = <span class="keyword">new</span> <span class="built_in">int</span>(*p.m_age);</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> *m_age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="number">30</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1.m_age = &quot;</span> &lt;&lt; *p1.m_age &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p2.m_age = &quot;</span> &lt;&lt; *p2.m_age &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p3.m_age = &quot;</span> &lt;&lt; *p3.m_age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">p3 = p2 = p1;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1.m_age = &quot;</span> &lt;&lt; *p1.m_age &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p2.m_age = &quot;</span> &lt;&lt; *p2.m_age &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p3.m_age = &quot;</span> &lt;&lt; *p3.m_age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> c = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">c = b = a;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回值是对象引用，另外，对于赋值运算符重载函数，我们要避免自赋值情况（即自己给自己赋值）的发生，一般地，我们通过比较赋值者与被赋值者的地址是否相同来判断两者是否是同一对象（正如例1中的if (this !&#x3D; &amp;str)一句）。</p><p>​     为什么要避免自赋值呢？</p><p> ①为了效率。显然，自己给自己赋值完全是毫无意义的无用功，特别地，对于基类数据成员间的赋值，还会调用基类的赋值运算符重载函数，开销是很大的。如果我们一旦判定是自赋值，就立即return *this，会避免对其它函数的调用。</p><p>②如果类的数据成员中含有指针，自赋值有时会导致灾难性的后果。对于指针间的赋值（注意这里指的是指针所指内容间的赋值，这里假设用_p给p赋值），先要将p所指向的空间delete掉（为什么要这么做呢？因为指针p所指的空间通常是new来的，如果在为p重新分配空间前没有将p原来的空间delete掉，会造成内存泄露），然后再为p重新分配空间，将_p所指的内容拷贝到p所指的空间。如果是自赋值，那么p和_p是同一指针，在赋值操作前对p的delete操作，将导致p所指的数据同时被销毁。那么重新赋值时，拿什么来赋？</p><p>​    所以，对于赋值运算符重载函数，一定要先检查是否是自赋值，如果是，直接return *this。</p><p>转自<a href="https://www.cnblogs.com/zpcdbky/p/5027481.html">https://www.cnblogs.com/zpcdbky/p/5027481.html</a></p><h4 id="重载-运算符-3"><a href="#重载-运算符-3" class="headerlink" title="重载 &#x3D;&#x3D; 运算符"></a>重载 &#x3D;&#x3D; 运算符</h4><p><strong>算术和关系运算符：</strong> </p><ul><li>算术和关系运算符通常为对称性的，一般情况下重载为非成员函数</li><li>由于不需要对两操作数作出修改，所以两参数一般设置为const引用</li><li>由于计算结果会产生一个新值，独立于两操作数之外，所以通常存储在临时的局部变量中，最后返回该变量</li><li>较为方便的做法是：先重载相应的复合赋值运算符，再使用它来定义算术运算符（运算结果需要接收，使用赋值运算符），这种复用的思想也可以用在其他的重载运算符中：通常是在一类运算符中定义了某一个，而后用其定义其他的重载运算符，并且也应该重载该类中其他运算符</li><li>对于赋值运算符，类似于类的拷贝构造函数有一个非常需要注意的点就是要避免浅拷贝（进行深拷贝, 如在拷贝函数中申请新的内存等）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line">m_name = name;</span><br><span class="line">m_age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(Person&amp; p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span> -&gt; m_name == p.m_name &amp;&amp; <span class="keyword">this</span> -&gt; m_age == p.m_age)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(Person&amp; p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_name == p.m_name &amp;&amp; <span class="keyword">this</span>-&gt;m_age == p.m_age)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string m_name;</span><br><span class="line"><span class="type">int</span> m_age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;Jerry&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p1 == p2)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1 和 p2 是相等的&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1 和 p2 是不相等的&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span>(p1 != p2)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1 和 p2 是不相等的&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1 和 p2 是相等的&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="函数调用-运算符重载"><a href="#函数调用-运算符重载" class="headerlink" title="函数调用 () 运算符重载"></a>函数调用 () 运算符重载</h4><ul><li>函数调用运算符也能重载（只能作为成员函数）</li><li>由于重载后的函数对象使用方式非常像函数调用，因此又被称为仿函数</li><li>函数对象没有固定写法，非常灵活（可以定义在结构体中，也可以作为内中公有成员）</li><li>函数对象既可以像函数一样使用类对象，并向其传递特定数目和类型的参数，编译器会调用不同的重载函数完成相应的操作，并且是唯一一种支持参数缺省的运算符重载</li><li>通常，函数对象中的数据成员被用于定制operator() 函数调用运算符中的一些操作，并且函数对象经常作为泛型编程的实参被传递（水很深）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//仿函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> string text)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; text &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">const</span> string text)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; text &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MyPrint myprint;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//myprint()(&quot;Hello world!&quot;);//错误：无法使用给定参数列表调用 函数 &quot;MyPrint::operator()&quot;</span></span><br><span class="line"><span class="built_in">myprint</span>(<span class="string">&quot;Hello world!&quot;</span>);<span class="comment">// 因为使用起来非常像函数调用，所以叫做仿函数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">MyPrint</span>()(<span class="string">&quot;Hello world!&quot;</span>); <span class="comment">// 匿名对象，传入字符串，调用默认拷贝构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Print</span>(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//仿函数是灵活的，有很多使用场景所以没有固定的写法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyAddition</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="type">int</span> num1, <span class="type">const</span> <span class="type">int</span> num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//函数重载旨在使用同一个函数名不同的函数体实现不同的功能</span></span><br><span class="line"><span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MyAddition case01;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="built_in">case01</span>(<span class="number">100</span>, <span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匿名函数对象</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;匿名函数对象MyAddition()(100, 100)：&quot;</span> &lt;&lt; <span class="built_in">MyAddition</span>()(<span class="number">100</span>, <span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="下标运算符-重载"><a href="#下标运算符-重载" class="headerlink" title="下标运算符 [] 重载"></a>下标运算符 [] 重载</h4><ul><li><strong>必须作为成员函数重载</strong>  </li><li>通常返回所访问元素的引用（提供修改操作，与原生版本相同）</li><li>最好是同时定义下标运算符重载的常量版本和非常量版本，即返回值为 const 常量引用 和 非常量引用的版本</li></ul><h4 id="成员访问-运算符"><a href="#成员访问-运算符" class="headerlink" title="成员访问 -&gt; 运算符"></a>成员访问 -&gt; 运算符</h4><p><strong>注意：</strong>  </p><ul><li><p>这个箭头与解引用运算符一样，都是单目运算符，尽管看起来像双目运算符，但其右操作数并不是表达式，而是对用类成员的一个标识符，编译器将通过此标识符获取特定成员</p></li><li><p>通常情况下，解引用标识符*与箭头标示符-&gt;一同作为成员函数</p></li><li><p>通常情况下，<strong>这两个运算符的重载函数设置为底层const，并将返回值设置为非const的成员引用</strong> </p><p><strong>因为成员访问通常不会修改类对象，但是调用方有权修改返回的值</strong>  </p></li><li><p><strong>对于箭头运算符的重载，其返回值必须是某个对象，或指向某个对象的指针，其余情况都会报错</strong> </p></li><li><p>使用箭头运算符时，有且仅有两种情况，任何其他类型的左操作数都会报错</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pointer为指向类对象的指针. 此时两条语句等效</span></span><br><span class="line">pointer-&gt;member;<span class="comment">//编译器调用的是-&gt; 的内置版本, 与重载版本无关</span></span><br><span class="line">*(pointer).member;</span><br><span class="line"></span><br><span class="line"><span class="comment">//pointer为某个类的对象时:</span></span><br><span class="line">pointer-&gt;member; <span class="comment">//此时编译器调用的才是重载运算符版本</span></span><br><span class="line"><span class="comment">//相当于:</span></span><br><span class="line">pointer.<span class="keyword">operator</span>-&gt;()  -&gt;member; <span class="comment">//对, 就是这么一个奇葩玩意</span></span><br><span class="line"><span class="comment">//相当于调用了-&gt;的重载函数, 并将它的返回值在做了一次-&gt;运算</span></span><br></pre></td></tr></table></figure><p>此时有两种情况：</p><ol><li>如果箭头运算符重载函数返回的是指向该类的指针，则呈现的是上面描述的第一种情况</li><li>如果箭头运算符重载函数返回的是该类的某个成员（有可能时类对象自身的引用），且这个成员中也重载了operator-&gt;，则继续调用该成员中的重载版本，否则将报错，因为内置的operator-&gt;的左操作数不可以是指针以外的对象。</li></ol><p>想要让operator-&gt;正常结束调用过程，就只能是第一种情况，箭头运算符重载函数找到了出口，出口的情况有两种，一是重载函数返回的是相同类的指针，正常出程序，二是函数返回是另一个的类的引用，但是该类也重载了箭头运算符，再调用该类的箭头运算符（出得了就出程序，出不了就继续上述情况，结果要么是出了程序，要么是因为返回的是引用继续调用（无限或有限地递归调用），或者因为返回的某个类没有重载箭头运算符而报错）</p><p>找到了一个比较绕的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #include &lt;iostream&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// using namespace std;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// class myClass</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// public:</span></span><br><span class="line"><span class="comment">//     myClass &amp;operator-&gt;()</span></span><br><span class="line"><span class="comment">//     &#123;</span></span><br><span class="line"><span class="comment">//         cout &lt;&lt; &quot;Operator -&gt; Overload\n&quot;;</span></span><br><span class="line"><span class="comment">//         return *this;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     void action()</span></span><br><span class="line"><span class="comment">//     &#123;</span></span><br><span class="line"><span class="comment">//         //do something...</span></span><br><span class="line"><span class="comment">//         return;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// int main()</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     myClass obj;</span></span><br><span class="line"><span class="comment">//     obj-&gt;action(); // 报错 circular pointer delegation detected (循环指针)</span></span><br><span class="line"><span class="comment">//     return 0;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Origin</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Wrapper</span></span><br><span class="line">&#123;</span><br><span class="line">    Origin *orig;</span><br><span class="line">    Origin *<span class="keyword">operator</span>-&gt;() <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> orig;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Wrapper2</span></span><br><span class="line">&#123;</span><br><span class="line">    Wrapper *wrap;<span class="comment">// 如果下面的函数返回自身就会死在循环递归里（返回的是引用），如果wrap没有重载箭头运算符就会报错</span></span><br><span class="line">    Wrapper &amp;<span class="keyword">operator</span>-&gt;() <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> *wrap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Origin o;</span><br><span class="line">    o.a = <span class="number">7</span>;</span><br><span class="line">    Wrapper w;</span><br><span class="line">    w.orig = &amp;o;</span><br><span class="line">    Wrapper2 w2;</span><br><span class="line">    w2.wrap = &amp;w;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;&amp;o.a\t\t\t\t&quot;</span> &lt;&lt; &amp;o.a &lt;&lt; std::endl;<span class="comment">// 输出a的地址</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;&amp;wrap\t\t\t\t&quot;</span> &lt;&lt; w2.wrap &lt;&lt; std::endl;<span class="comment">// 输出wrap的地址，与w的地址相同</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;&amp;w\t\t\t\t&quot;</span> &lt;&lt; &amp;w &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;w-&gt;a&quot;</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;\t\t\t\t&quot;</span> &lt;&lt; w-&gt;a &lt;&lt; std::endl; <span class="comment">// w.operator-&gt;().operator-&gt;()-&gt;a，从Wrapper2.operator-&gt;()，到 Wrapperoperator-&gt;() 再调用内置的箭头运算符出循环</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;w.operator-&gt;()&quot;</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;\t\t\t&quot;</span> &lt;&lt; w.<span class="keyword">operator</span>-&gt;() &lt;&lt; std::endl; <span class="comment">// 返回的是orig，即&amp;o</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;w.operator-&gt;()-&gt;a&quot;</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;\t\t&quot;</span> &lt;&lt; w.<span class="keyword">operator</span>-&gt;()-&gt;a &lt;&lt; std::endl;<span class="comment">// 结合上面一句，这里经过Wrapper.operator-&gt;() 再调用默认的箭头运算符 输出 a</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;w2-&gt;a&quot;</span><span class="comment">// Wrapper2.operator-&gt;() 再 Wrapper.operator-&gt;() 最后默认的箭头运算符</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;\t\t\t\t&quot;</span> &lt;&lt; w2-&gt;a &lt;&lt; std::endl; </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;&amp;w2.operator-&gt;()&quot;</span><span class="comment">// &amp;orig 即 &amp;o</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;\t\t&quot;</span> &lt;&lt; &amp;w2.<span class="keyword">operator</span>-&gt;() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;w2.operator-&gt;()-&gt;a&quot;</span><span class="comment">// 同 w.operator-&gt;()-&gt;a， 同 w-&gt;a</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;\t\t&quot;</span> &lt;&lt; w2.<span class="keyword">operator</span>-&gt;()-&gt;a &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;w2.operator-&gt;().operator-&gt;()&quot;</span><span class="comment">// 返回orig，即 &amp;o</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; w2.<span class="keyword">operator</span>-&gt;().<span class="keyword">operator</span>-&gt;() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;w2.operator-&gt;().operator-&gt;()-&gt;a&quot;</span><span class="comment">// 即 w-&gt;a</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; w2.<span class="keyword">operator</span>-&gt;().<span class="keyword">operator</span>-&gt;()-&gt;a &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>上述代码来源于下方博文：</strong> <a href="https://blog.csdn.net/u013009575/article/details/19246353">https://blog.csdn.net/u013009575/article/details/19246353</a></p><p><img src="https://s2.loli.net/2023/03/25/ZUifA5hqznLVM3l.jpg" alt="箭头运算符重载"> </p><h4 id="合适的重载运算符的时机"><a href="#合适的重载运算符的时机" class="headerlink" title="合适的重载运算符的时机"></a><strong>合适的重载运算符的时机</strong></h4><p>重载函数为类服务，自然也要从类的整体设计上考虑和使用该重载何种运算符，何时应该使用成员函数：通常当某些类的早些操作在逻辑上与对应的运算符相关，则更应该设置为重载运算符的形式：</p><ul><li>对类执行IO操作，通常重载的 &gt;&gt; 和 &lt;&lt; 使其与内置数据类型的IO一致</li><li>对类执行关系操作，包括 &gt;、&lt;、&lt;&#x3D;、&gt;&#x3D;、&#x3D;&#x3D;、!&#x3D;六种</li></ul><p>如果没有特殊需要，重载这些运算符时，参数与返回值的设置最好与内置版本相兼容，符合用户使用习惯，更不容易出错</p><p><strong>重载运算符的本意是为了方便使用：</strong> </p><p>一切都是建立在对原有运算符的功能的理解上的，如果一个操作在功能上存在一定的二义性，或者与常规的理解有一定的偏差，则此时不应该扭曲原有运算符的含义与逻辑（不应该重载），转而使用一个成员函数并在函数名上给出提示更能方便使用。</p><p><strong>关于运算符重载函数的匹配：</strong> </p><ul><li>运算符重载在C++中同样作为函数来使用，所以仍然遵循函数的匹配模式</li></ul><p>但是总体上来说，运算符重载函数的候选集合比普通重载函数要大：当操作数中有自定义数据类型时，函数匹配列表中的候选函数应该包括该运算符的非成员重载版本（+、-、*、&#x2F; 等）以及内置版本，且如果运算符左侧操作数是自定义类型，则还要包括该类中定义的成员函数重载版本</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="继承的基础语法"><a href="#继承的基础语法" class="headerlink" title="继承的基础语法"></a>继承的基础语法</h3><p><strong>继承的好处：</strong> </p><ul><li>提高代码复用性</li></ul><p><strong>语法：</strong> </p><p>class class_son :  inheritance_method base_class</p><p>子类 – 派生类</p><p>父类 – 基类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过编码保存，GB2312</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BasePage</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;黑马程序员网、搜索、登录/注册...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;C++、Java、Python、Javascript...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;帮助中心、联系我们、站内导航、商业合作...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Java</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Java学习视频...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cpp</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;C++学习视频...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Python</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Python学习视频...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Java ja;</span><br><span class="line">    Cpp cpp;</span><br><span class="line">    Python py;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Java页面\n&quot;</span> &lt;&lt; endl;</span><br><span class="line">    ja.<span class="built_in">header</span>();</span><br><span class="line">    ja.<span class="built_in">left</span>();</span><br><span class="line">    ja.<span class="built_in">content</span>();</span><br><span class="line">    ja.<span class="built_in">footer</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&lt;!------------分割线------------!&gt;\n&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;C++页面\n&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cpp.<span class="built_in">header</span>();</span><br><span class="line">    cpp.<span class="built_in">left</span>();</span><br><span class="line">    cpp.<span class="built_in">content</span>();</span><br><span class="line">    cpp.<span class="built_in">footer</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&lt;!------------分割线------------!&gt;\n&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Python页面\n&quot;</span> &lt;&lt; endl;</span><br><span class="line">    py.<span class="built_in">header</span>();</span><br><span class="line">    py.<span class="built_in">left</span>();</span><br><span class="line">    py.<span class="built_in">content</span>();</span><br><span class="line">    py.<span class="built_in">footer</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&lt;!------------分割线------------!&gt;\n&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>派生类中的成员包括两部分：</strong> </p><ol><li>从基类继承过来的，运算符重载无法继承，除非父类提供从子类到父类的构造函数</li><li>自己增加的成员</li></ol><ul><li>从基类中继承属性体现了共用性，而子类中新增成员属性则体现了子类的个性</li></ul><h3 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h3><p><img src="https://s2.loli.net/2023/03/25/doajmtYqeQsBXDK.png" alt="继承方式"> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BasePage</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_a;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> m_b;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_a = <span class="number">10</span>;<span class="comment">//基类中的公共权限 到子类中依然是公共属性</span></span><br><span class="line">m_b = <span class="number">20</span>;<span class="comment">//基类中的保护权限 到子类中也是公共属性</span></span><br><span class="line"><span class="comment">//m_c = 30;//基类中的私有权限 子类继承得到，访问不到</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保护继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span> : <span class="keyword">protected</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_a = <span class="number">100</span>;<span class="comment">//基类中的公共权限在保护继承中变为保护权限</span></span><br><span class="line">m_b = <span class="number">200</span>;</span><br><span class="line"><span class="comment">//m_c = 300;//基类中的私有权限 子类继承得到，访问不到</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son3</span> : <span class="keyword">private</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_a = <span class="number">100</span>;<span class="comment">//父类公共成员和保护成员经过私有继承到子类中变为私有成员</span></span><br><span class="line">m_b = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//m_c = 100;//无法访问</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Grandson</span> : <span class="keyword">public</span> Son3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*m_a = 200;Son3中的属性均为私有，即使继承得到也无法访问</span></span><br><span class="line"><span class="comment">m_b = 200;</span></span><br><span class="line"><span class="comment">m_c = 200;*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son1 s1;</span><br><span class="line">s1.m_a = <span class="number">100</span>;<span class="comment">//公共权限类外可以访问</span></span><br><span class="line"><span class="comment">//s1.m_b = 200;//保护权限类外不可访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son2 s1;</span><br><span class="line"><span class="comment">/*s1.m_a = 1000;</span></span><br><span class="line"><span class="comment">* 均为保护属性，类外不可访问</span></span><br><span class="line"><span class="comment">s1.m_b = 1000; */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son3 s1;</span><br><span class="line"><span class="comment">/*s1.m_a = 1000;</span></span><br><span class="line"><span class="comment">* 访问不到 </span></span><br><span class="line"><span class="comment">s1.m_b = 1000;*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"><span class="built_in">test03</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承中的对象模型"><a href="#继承中的对象模型" class="headerlink" title="继承中的对象模型"></a>继承中的对象模型</h3><p><strong>从基类中继承的成员，有哪些属于派生类？</strong> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_a;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> m_b;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用developer command prompt for VS 2019 查看对象模型</span></span><br><span class="line"><span class="comment">//跳转盘符进入文件所在文件夹</span></span><br><span class="line"><span class="comment">//输入dir查看文件夹信息</span></span><br><span class="line"><span class="comment">//输入 cl /d1 reportSingleClassLayou类名（例如：Son1） 文件名，按下回车查看类信息</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//子类可以继承但是无法访问</span></span><br><span class="line"><span class="comment">//输出为16，父类中所有非静态成员都会被子类继承</span></span><br><span class="line"><span class="comment">//父类的私有属性成员被隐藏了，虽然访问不到，但是确实被继承了</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;size of Son1 = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Son1) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>基类中的所有属性都可以被继承，但是访问得到的才是自己的，访问不到的都是基类的</strong> </p><h3 id="继承中构造和析构顺序"><a href="#继承中构造和析构顺序" class="headerlink" title="继承中构造和析构顺序"></a>继承中构造和析构顺序</h3><p>在学习模板的时候，说过，要先知道父类的类型才能给子类分配空间，跟这里应该有一些关系</p><p><strong>子类创建对象时，会调用子类本身的构造函数，也会调用父类的构造函数</strong> </p><p><strong>问题：</strong> 父类和子类的构造和析构顺序？</p><p>“白发人送黑发人”，构造时，先调用父类构造，析构时，先调用子类析构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承中的构造和析构顺序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base的构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Base</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base的析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Son</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son的构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Son</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son的析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//Base b;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">继承中的构造和析构顺序如下：</span></span><br><span class="line"><span class="comment">与调用无关，先构造父类，再构造子类，程序结束时先析构子类，最后析构父类</span></span><br><span class="line"><span class="comment">“白发人送黑发人系列”</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Son s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> 继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</p><h3 id="继承中同名成员的处理方式"><a href="#继承中同名成员的处理方式" class="headerlink" title="继承中同名成员的处理方式"></a>继承中同名成员的处理方式</h3><p><strong>问题：</strong> 当子类和父类有同名成员，如何通过子类对象访问到父类中的同名数据？</p><ul><li>子类中的成员直接使用一般方式访问其中成员即可</li><li>子类想要拿到父类的成员则需要在访问时加上作用域</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承中同名成员的处理方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_a = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base下 func() 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base下 func(int a) 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_a = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*void func()</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; &quot;Son下 func() 调用&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同名成员属性</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son s;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son的m_a的值：&quot;</span> &lt;&lt; s.m_a &lt;&lt; endl;<span class="comment">//最直接输出的一定是自己的，因为拿自己的才最容易</span></span><br><span class="line"><span class="comment">//如果想要通过子类访问父类中的同名成员一定要加 作用域</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son继承来的Base的m_a的值：&quot;</span> &lt;&lt; s.Base::m_a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同名成员函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son s;</span><br><span class="line">s.<span class="built_in">func</span>();<span class="comment">//就算此时Son中并没有定义func()，这句也是可以执行的，因为不存在歧义性，如果发生了重名，调用的也会是Son中的那一个</span></span><br><span class="line">s.Base::<span class="built_in">func</span>();<span class="comment">//调用Base中的func()</span></span><br><span class="line">s.Base::<span class="built_in">func</span>(<span class="number">100</span>);<span class="comment">//调用父类中重载后的函数func(int a)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果子类中出现于父类中同名的函数，子类的同名函数会将继承过来的所有同名函数，包括重载函数</span></span><br><span class="line"><span class="comment">//如果想要访问到父类中隐藏的同名函数需要加 作用域</span></span><br><span class="line">s.Base::<span class="built_in">func</span>(<span class="number">100</span>);</span><br><span class="line"><span class="comment">//为了不因为歧义发生莫名其妙的错误，建议只要调用父类中的成员函数都加上作用域</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> </p><ol><li>子类对象可以直接访问到子类中同名成员</li><li>子类对象加作用域可以访问到父类同名成员</li><li>当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名</li></ol><p>函数</p><h3 id="继承同名静态成员的处理方式"><a href="#继承同名静态成员的处理方式" class="headerlink" title="继承同名静态成员的处理方式"></a>继承同名静态成员的处理方式</h3><p><strong>问题：</strong> 继承中同名的静态成员变量在子类对象上应该如何进行访问？</p><p>与其余同名成员的访问方式一致，访问子类的只需要直接访问，访问基类的则需要加作用域</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_a;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base - static void func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base - static void func(int a)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Base::m_a = <span class="number">100</span>;<span class="comment">//静态成员变量类外赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_a;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son - static void func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Son:: m_a = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同名静态成员变量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//1、通过对象访问静态成员变量</span></span><br><span class="line">Son s1;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;\n通过对象访问静态成员变量&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son 下 m_a：&quot;</span> &lt;&lt; s1.m_a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base 下 m_a：&quot;</span> &lt;&lt; s1.Base::m_a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、通过类访问静态成员变量</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;\n通过类访问静态成员变量&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son 下 m_a：&quot;</span> &lt;&lt; Son::m_a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base 下 m_a：&quot;</span> &lt;&lt; Son::Base::m_a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同名静态成员函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son s2;</span><br><span class="line"><span class="comment">//1、通过对象访问静态成员变量</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;\n通过对象访问静态成员函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">s2.<span class="built_in">func</span>();</span><br><span class="line">s2.Base::<span class="built_in">func</span>();</span><br><span class="line">s2.Base::<span class="built_in">func</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、通过类访问静态成员变量</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;\n通过类访问静态成员函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">Son::<span class="built_in">func</span>();</span><br><span class="line">Son::Base::<span class="built_in">func</span>();</span><br><span class="line">Son::Base::<span class="built_in">func</span>(<span class="number">100</span>);</span><br><span class="line"><span class="comment">//子类中有同名静态成员  会使得继承过来的父类中的静态成员被隐藏</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> 同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类</p><p>名）</p><h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><p>C++允许<strong>一个类继承多个类</strong> </p><p>语法： class 子类 ：继承方式 父类1 ， 继承方式 父类2…</p><p>多继承可能会引发父类中有同名成员出现，需要加作用域区分</p><p><strong>C++实际开发中不建议用多继承</strong> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Base1</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_a = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Base2</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_a = <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多继承</span></span><br><span class="line"><span class="comment">//语法：子类 : 继承方式 父类1, 继承方式 父类2...</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Son</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_c = <span class="number">300</span>;</span><br><span class="line">m_d = <span class="number">400</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m_c;</span><br><span class="line"><span class="type">int</span> m_d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son s;</span><br><span class="line"><span class="comment">//如果多个父类中出现了同名成员，访问时需要添加作用域</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Size of Son = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(s) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base1 m_a:&quot;</span> &lt;&lt; s.Base1::m_a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base2 m_a:&quot;</span> &lt;&lt; s.Base2::m_a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>  多继承中如果父类中出现了同名情况，子类使用时候要加作用域</p><h3 id="菱形继承（Diamond-inheritance）"><a href="#菱形继承（Diamond-inheritance）" class="headerlink" title="菱形继承（Diamond inheritance）"></a>菱形继承（Diamond inheritance）</h3><p><strong>菱形继承概念：</strong> </p><ul><li>两个派生类继承同一个基类，又有某个类同时继承者两个派生类</li></ul><p>这种继承被称为菱形继承，或者钻石继承，典型的菱形继承案例：</p><p><img src="https://s2.loli.net/2023/03/25/LnPCFME5rui8Tyx.png" alt="菱形继承之前"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 问题：*/</span></span><br><span class="line"><span class="number">1.</span> 羊继承了动物的数据，驼同样继承了动物的数据，当羊驼使用数据时，就会产生二义性。</span><br><span class="line"><span class="number">2.</span> 羊驼继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Camel</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sheep</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Alpaca</span> : <span class="keyword">public</span> Camel, <span class="keyword">public</span> Sheep&#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用虚继承之后Animal类被称为虚基类，Sheep类和Camel类被称为基类</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Alpaca A;</span><br><span class="line"></span><br><span class="line">A.Sheep::m_age = <span class="number">18</span>;</span><br><span class="line">A.Camel::m_age = <span class="number">28</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当菱形继承时，两个父类拥有同名数据，需要使用作用域加以区分</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A.Sheep::m_age = &quot;</span> &lt;&lt; A.Sheep::m_age &lt;&lt; endl;<span class="comment">//没有使用虚继承之前输出18 28</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A.Camel::m_age = &quot;</span> &lt;&lt; A.Camel::m_age &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A.m_age = &quot;</span> &lt;&lt; A.m_age &lt;&lt; endl;<span class="comment">//使用虚继承之后不会再报错，而且上面三行代码输出结果一致且均为28</span></span><br><span class="line"><span class="comment">// 生物的年龄是确定的，唯一的，所以多个年龄就造成了空间浪费</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/03/25/ghKOsa2pNnqCjey.png" alt="虚继承之前"></p><p>Sheep中从Animal继承了一份age，Camel从Animal继承了一份age，经过Alpaca继承Sheep和Camel之后，Alpaca有父类的两个ge，以及自己的两个age，但它本身只需要一个，所以产生了资源浪费。</p><p><img src="https://s2.loli.net/2023/03/25/NrWKgpQtMEdiGsa.png" alt="虚继承之后"></p><p><img src="https://s2.loli.net/2023/03/25/leRkQJDoijV5MBs.png" alt="虚继承实现原理"></p><p>虚继承使派生类除了继承基类成员作为自己的成员之外，内部还会有一份内存来保存哪些是基类的成员。当 <strong>Alpaca</strong> 继承 <strong>Sheep</strong> 和 <strong>Camel</strong> 之后，编译器根据虚继承多出来的内存，查到 <strong>Sheep</strong> 和 <strong>Camel</strong> 拥有共同的基类的成员，就不会从 <strong>Sheep</strong> 和  <strong>Camel</strong>  中继承这些，而是直接从共同的基类中继承成员，也就是说，<strong>Alpaca</strong>直接继承<strong>Animal</strong>的成员，然后再继承 <strong>Sheep</strong> 和 <strong>Camel</strong> 各自新增的成员（带有Sheep和Camel自身属性的age）。</p><p>这样， <strong>Alpaca</strong> 就不会从  <strong>Sheep</strong> 和 <strong>Camel</strong> 那里多继承两份age，但是，这样也导致Alpaca中所有age属性一致（改一个全部都会变），Alpaca拿不到基类中的年龄。</p><p><strong>总结：</strong> </p><ul><li>菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义</li><li>利用虚继承相对而言可以解决菱形继承问题</li></ul><p>关于C++虚继承的内存模型</p><blockquote><p>参考 <a href="https://blog.csdn.net/m0_37973607/article/details/90599495">https://blog.csdn.net/m0_37973607/article/details/90599495</a></p></blockquote><blockquote><p>还有一篇 <a href="https://zhuanlan.zhihu.com/p/41309205">https://zhuanlan.zhihu.com/p/41309205</a></p></blockquote><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><p><strong>多态分为两类：</strong> </p><ul><li>静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名</li><li>动态多态: 派生类和虚函数实现运行时多态</li></ul><p><strong>函数名联编</strong></p><ul><li>将源代码中的函数调用解释为执行特定的函数代码块被称为函数名联编</li></ul><p><strong>早期联编与晚期联编</strong> </p><p>在C++中，由于函数重载的缘故，联编这项任务变得比C语言更加复杂。编译器必须查看函数参数以及函数名才能确定使用哪个函数。</p><ul><li>C&#x2F;C++编译器可以在编译过程完成这种联编，在编译过程中进行的联编被称为静态联编（static binding），又称为早期联编（early binding）【编译器对非虚函数使用静态联编】；</li><li>虚函数使得联编这项任务更加困难，使用哪一个函数是不能在编译时确定的，因为编译器不知道用户将选择哪种类型的对象。所以编译器必须能够在程序运行时选择正确的虚方法代码，这被称为动态联编（dynamic binding），又称为晚期联编（late binding）。</li></ul><p><strong>虚成员函数与动态联编</strong> </p><p>方面动态联编使程序员能够重新定义类方法，而静态联编在这很差。没有摒弃静态联编的原因有两个——效率和概念模型。</p><ul><li>效率<ul><li>为使程序能够在运行阶段进行决策，必须采取一些方法来追踪基类指针或引用指向的对象模型，这增加了额外的开销（如果类不会用作基类，则不需要动态联编，在这些情况下使用静态联编更合理，效率也更高），由于静态联编的效率更高，因此被设置为C++的默认选择，Strousstrup说，C++的指导原则之一是，不要为不使用的特性付出代价（内存或处理时间），仅当程序设计确实需要虚函数时，才使用它们。</li></ul></li><li>概念模型<ul><li>在设计类时，可能包含一些不在派生类重新定义的成员函数，不将该函数设置为虚函数，有两方面好处——效率更高且仅将那些预期被重新定义的方法声明为虚的。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动物类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Bark</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;动物叫&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Bark</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;小猫叫&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Bark</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;犬吠&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 动态多态需要满足的条件</span></span><br><span class="line"><span class="comment">1、有继承关系</span></span><br><span class="line"><span class="comment">2、子类重写父类虚函数（重写和重载不一样，重载是说函数名一样参数不同。重写是指函数名一样，参数列表一样。而且子类中重写的同名函数也是可以加virtual关键字的，并且不会对输出有影响）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">动态多态使用：</span></span><br><span class="line"><span class="comment">父类的指针或者引用 指向子类的对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//无论这里使用的是对象、引用又或者是指针，属于函数地址早绑定，在编译阶段就已经确定了函数的地址</span></span><br><span class="line"><span class="comment">//如果是想要让“小猫”说话就应该让地址晚绑定，即需要在程序运行阶段确定函数地址，需要在基类的同名函数定义前加入virtual关键字</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">barking</span><span class="params">(Animal &amp;animal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">animal.<span class="built_in">Bark</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Cat cat;</span><br><span class="line"><span class="built_in">barking</span>(cat);</span><br><span class="line"></span><br><span class="line">Dog dog;</span><br><span class="line"><span class="built_in">barking</span>(dog);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//添加virtual关键字之前输出为1（空类），添加virtual关键字之后输出4，4是一个指针变量的大小</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Size of class Animal = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Animal) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> </p><p>多态满足条件</p><ul><li>有继承关系且子类重写父类中的虚函数</li></ul><p>多态使用条件</p><ul><li>父类指针或引用指向子类对象</li></ul><p>重写：函数返回值类型 函数名 参数列表 完全一致称为重写</p><h3 id="二元运算计算器类"><a href="#二元运算计算器类" class="headerlink" title="二元运算计算器类"></a>二元运算计算器类</h3><p><strong>案例描述：</strong> </p><ul><li>分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类</li></ul><p><strong>多态的优点：</strong> </p><ul><li>代码组织结构清晰</li><li>可读性强</li><li>利于前期和后期的扩展以及维护</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Calculator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">float</span> <span class="title">Result</span><span class="params">(<span class="type">char</span> op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (op)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line"><span class="keyword">return</span> num1 + num2;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line"><span class="keyword">return</span> num1 - num2;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line"><span class="keyword">return</span> num1 * num2;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line"><span class="keyword">return</span> (<span class="type">float</span>) num1 / num2;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;输入错误！&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> num1 = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> num2 = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Calculator c;</span><br><span class="line">c.num1 = <span class="number">10</span>;</span><br><span class="line">c.num2 = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;普通实现&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; c.num1 &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; c.num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">Result</span>(<span class="string">&#x27;+&#x27;</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; c.num1 &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; c.num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">Result</span>(<span class="string">&#x27;-&#x27;</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; c.num1 &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; c.num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">Result</span>(<span class="string">&#x27;*&#x27;</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; c.num1 &lt;&lt; <span class="string">&quot; / &quot;</span> &lt;&lt; c.num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">Result</span>(<span class="string">&#x27;/&#x27;</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">float</span> <span class="title">Result</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m_num1 = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> m_num2 = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddCalaulator</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">Result</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_num1 + m_num2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubCalculator</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">Result</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_num1 - m_num2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MultiCalaulator</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">Result</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_num1 * m_num2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExCalculator</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">Result</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="type">float</span>) m_num1 / m_num2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Remainder</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">Result</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_num1 % m_num2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">浮点型数据不能进行取余运算，函数重写必须保证派生类成员函数返回值类型、函数名、参数表与基类一致</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;多态实现&quot;</span> &lt;&lt; endl;</span><br><span class="line">Base *ptr = <span class="keyword">new</span> AddCalaulator;</span><br><span class="line">ptr -&gt; m_num1 = <span class="number">10</span>;</span><br><span class="line">ptr -&gt; m_num2 = <span class="number">30</span>;</span><br><span class="line">cout &lt;&lt; ptr -&gt; m_num1 &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; ptr -&gt; m_num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; ptr -&gt; <span class="built_in">Result</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> ptr;</span><br><span class="line"></span><br><span class="line">ptr = <span class="keyword">new</span> SubCalculator;</span><br><span class="line">ptr -&gt; m_num1 = <span class="number">10</span>;</span><br><span class="line">ptr -&gt; m_num2 = <span class="number">30</span>;</span><br><span class="line">cout &lt;&lt; ptr -&gt; m_num1 &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; ptr -&gt; m_num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; ptr -&gt; <span class="built_in">Result</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> ptr;</span><br><span class="line"></span><br><span class="line">ptr = <span class="keyword">new</span> MultiCalaulator;</span><br><span class="line">ptr -&gt; m_num1 = <span class="number">10</span>;</span><br><span class="line">ptr -&gt; m_num2 = <span class="number">30</span>;</span><br><span class="line">cout &lt;&lt; ptr -&gt; m_num1 &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; ptr -&gt; m_num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; ptr -&gt; <span class="built_in">Result</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> ptr;</span><br><span class="line"></span><br><span class="line">ptr = <span class="keyword">new</span> ExCalculator;</span><br><span class="line">ptr -&gt; m_num1 = <span class="number">10</span>;</span><br><span class="line">ptr -&gt; m_num2 = <span class="number">30</span>;</span><br><span class="line">cout &lt;&lt; ptr -&gt; m_num1 &lt;&lt; <span class="string">&quot; / &quot;</span> &lt;&lt; ptr -&gt; m_num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; ptr -&gt; <span class="built_in">Result</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> ptr;</span><br><span class="line"></span><br><span class="line">ptr = <span class="keyword">new</span> Remainder;</span><br><span class="line">ptr-&gt;m_num1 = <span class="number">10</span>;</span><br><span class="line">ptr-&gt;m_num2 = <span class="number">30</span>;</span><br><span class="line">cout &lt;&lt; ptr -&gt; m_num1 &lt;&lt; <span class="string">&quot; % &quot;</span> &lt;&lt; ptr -&gt; m_num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; ptr -&gt; <span class="built_in">Result</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> ptr;</span><br><span class="line">ptr = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> C++开发提倡利用多态设计程序架构，因为多态优点很多</p><p><strong>虚函数的工作原理</strong> </p><p>C++规定了虚函数的行为，但将实现方法留给了编译器作者。</p><p>通常，编译器处理虚函数的方法是：给每个对象添加一个隐藏成员。隐藏成员中保存了一个指向函数地址数组的指针。这种数组被称为虚函数表（virtual function table， vtable）。虚函数表中存储了为类对象进行声明的虚函数地址。例如，基类对象包含一个指针，该指针指向基类中所有虚函数的地址表。派生类对象将包含一个独立地址表的指针。如果派生类提供了虚函数的新定义，该虚函数表将保存新函数的地址；如果派生类没有重新定义虚函数，该vtbl将保存函数原始版本的地址。如果派生类定义了新的虚函数，则该函数需要在对象中添加1个地址成员，只是表的大小不同而已。</p><p>调用虚函数时，恒旭将查看存储在对象中的vtbl地址，然后转向相应的函数地址表。</p><p>总之，使用虚函数时，在内存和执行速度方面有一定的成本，包括：</p><ul><li><p>每个对象都增大，增大量为存储地址的空间；</p></li><li><p>对于每个类，编译器都创建一个虚函数地址表（数组）；</p></li><li><p>对于每个函数调用，都需要执行一项额外的操作，即到表中查找地址。</p><p>虽然非虚函数的效率比虚函数稍高，但不具备动态联编功能。</p></li></ul><h3 id="有关虚函数的注意事项"><a href="#有关虚函数的注意事项" class="headerlink" title="有关虚函数的注意事项"></a>有关虚函数的注意事项</h3><ul><li>在基类方法声明中使用关键字virtual可使该方法在基类以及所有派生类（包括从派生类派生出来的类）中是虚的；</li><li>如果使用指向对象的引用或指针来调用虚方法，程序将使用对象类型定义的方法，而不是用为引用或指针类型定义的方法。这成为动态联编或晚期联编。这种行为非常重要，因为这样基类指针或引用可以指向派生类对象；</li><li>如果定义的类将被用作基类，则应将那些要在派生类中重新定义的类方法声明为虚的。</li></ul><p><strong>1. 构造函数</strong>  </p><p>构造函数不能是虚函数，创建派生类对象时，将调用派生类的构造函数，而不是积累的构造函数，然后，派生类的构造函数将使用积累的一个构造函数，这种顺序不同于继承机制。因此，派生类不继承基类的构造函数，所以类构造函数声明为虚的没有什么意义。</p><p><strong>2. 析构函数</strong> </p><p>析构函数应当是虚函数，除非类不用作基类。例如，假设Employee是基类，Singer是派生类，并添加一个char *成员，该成员指向由new分配的内存。当Singer对象过期时，必须调用~Singer() 析构函数来释放内存。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Employee *pe = <span class="keyword">new</span> Singer;<span class="comment">// legal because Employee is base for Singer</span></span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line"><span class="keyword">delete</span> pe;<span class="comment">// ~Employee() or Singer()?</span></span><br></pre></td></tr></table></figure><p>如果使用默认的静态联编，delete语句将调用<del>Employee()析构函数。这将释放由Singer对象中的Employee部分指向的内存，但不会释放新的类成员指向的内存，然后，调用</del>Employee()</p><p>析构函数来释放Employee组件指向的内存。</p><p>这意味着，即使基类不需要显式析构函数提供服务，也不应依赖于默认构造函数，而应提供虚析构函数，即使它不执行任何操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vitual ~<span class="built_in">BaseClass</span>()&#123; &#125;</span><br></pre></td></tr></table></figure><pre><code>另外，给类定义一个虚析构函数并非错误，即使这个类不用做基类；这只是一个效率方面的问题。</code></pre><p><strong>3. 友元</strong> </p><p>友元不能是虚函数，因为有缘不是类成员，而只有成员才能是虚函数。如果由于这个原因引起了设计问题，可以通过让友元函数使用虚成员函数来解决问题。</p><p><strong>4. 没有重新定义</strong> </p><p>如果派生类中没有重新定义函数，将使用该函数的基类版本，例外的情况是基类版本是隐藏的。</p><p><strong>5. 重新定义将隐藏方法</strong> </p><pre><code>假设创建了如下所示的代码：</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dwelling</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">showperks</span><span class="params">(<span class="type">int</span> a)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hovel</span> : <span class="keyword">public</span> Dwelling</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">showperks</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这将导致问题没可能会出现类似瞎买你这样的编译器警告：</p><p><code> wranning: Hovel::showperks(void) hides Dwelling::showperks(int)</code></p><p>也可能不会出现警告。但不管结果怎样，代码将具有如下含义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hovel trump;</span><br><span class="line">trump.<span class="built_in">showperks</span>();<span class="comment">// valid</span></span><br><span class="line">trump.<span class="built_in">hoeperks</span>(<span class="number">5</span>);<span class="comment">// invalid</span></span><br></pre></td></tr></table></figure><p>新定义将showperks() 定义为一个不接受任何参数的函数。重新定义不会生成函数的两个重载版本，而是隐藏了接受一个int 参数的积累八本。总之，重新定义继承的方法并不是重载。如果重新定义派生类中的函数，将不只是使用相同的函数参数列表覆盖基类声明，无论参数列表是否相同，该操作将隐藏所有的同名基类方法。</p><p>这引出了两条经验规则：第一，如果重新定义继承的方法，应确保与原来的原型完全相同，但如果返回类型是基类引用或指针，则可以修改为指向派生类的引用或指针（这种例外是新出现的）。这种特性被称为返回类型协变（covariance of return type)，因为允许返回类型随类类型变化而变化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dwelling</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// a base method</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Dwelling&amp; <span class="title">build</span><span class="params">(<span class="type">int</span> n)</span></span>;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hovel</span> : <span class="keyword">public</span> Dwelling</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// a derived method with a covariant return type</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Hovel&amp; <span class="title">build</span><span class="params">(<span class="type">int</span> n)</span></span>;<span class="comment">// same function signature</span></span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意，这种例外只适用于返回值，而不适用于参数。</p><p>第二，如果基类方法被重载了，则应在派生类中重新定义所有的基类版本。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dwelling</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// three overloaded showperks()</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">showperks</span><span class="params">(<span class="type">int</span> a)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">showperks</span><span class="params">(<span class="type">double</span> x)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">showperks</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hovel</span> : <span class="keyword">public</span> Dwelling</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// three redefined showperks()</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">showperks</span><span class="params">(<span class="type">int</span> a)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">showperks</span><span class="params">(<span class="type">double</span> x)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">showperks</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果只重新定义一个版本，则另外两个版本将被隐藏，派生类对象将无法使用它们。注意，如果不需要修改，则新定义可只调用基类版本：</p><p><code>void Hovel::showperks() const &#123; Dwelling::showperks(); &#125;</code></p><h3 id="纯虚函数和抽象基类"><a href="#纯虚函数和抽象基类" class="headerlink" title="纯虚函数和抽象基类"></a>纯虚函数和抽象基类</h3><p>在多态中，通常父类中虚函数的实现是提供接口的，主要都是调用子类重写的内容，因此可以将虚函数改为<strong>纯虚函数</strong> </p><p>纯虚函数语法：$virtual 返回值类型 函数名 （参数列表）&#x3D; 0 ;$</p><p>当类中有了纯虚函数，这个类也称为 <code>抽象基类</code></p><p><strong>抽象基类特点：</strong> </p><ul><li>无法实例化对象</li><li>子类必须重写抽象基类中的纯虚函数，否则也属于抽象基类</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="comment">//纯虚函数如下，此类为抽象基类 Abstract base class</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Result</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> num1 = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> num2 = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">next_geneation</span> : Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Result</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;这个函数是基类纯虚函数的重写&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">other_func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;这个函数不是父类函数的重写&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//Base b;//报错：不允许使用抽象基类“Base”的对象</span></span><br><span class="line"><span class="comment">//next_geneation n;//同样报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Base b1;//抽象基</span></span><br><span class="line">    类还是不允许实例化对象，但是派生类可以正常实例化对象</span><br><span class="line">next_geneation m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="制作drinks"><a href="#制作drinks" class="headerlink" title="制作drinks"></a>制作drinks</h3><p><strong>案例描述：</strong> </p><ul><li>制作饮品的大致流程为：煮水 - 冲泡 - 倒入杯中 - 加入辅料</li><li>利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Abstractcheif</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">What_to_do</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="comment">//烧水</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="comment">//冲调</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="comment">//倒水</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Pour</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="comment">//调味</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Flavour</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体制作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Make_Drink</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">What_to_do</span>();</span><br><span class="line"><span class="built_in">Boil</span>();</span><br><span class="line"><span class="built_in">Brew</span>();</span><br><span class="line"><span class="built_in">Pour</span>();</span><br><span class="line"><span class="built_in">Flavour</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Coffee</span> : <span class="keyword">public</span> Abstractcheif</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">What_to_do</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;给阿姨倒杯卡布奇诺&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//烧水</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;煮百岁山&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//冲调</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;冲泡咖啡&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//倒水</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Pour</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;倒入杯中&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调味</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Flavour</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;加入方糖、牛奶和可可&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tea</span> : <span class="keyword">public</span> Abstractcheif</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">What_to_do</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;保温杯里泡枸杞&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//烧水</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;煮农夫山泉&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//冲调</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;放入茶叶、换水&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//倒水</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Pour</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;沏茶&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调味</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Flavour</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;加入枸杞、金银花和甘草&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Do_work</span><span class="params">(Abstractcheif *abc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">abc -&gt; <span class="built_in">Make_Drink</span>();</span><br><span class="line"><span class="keyword">delete</span> abc;</span><br><span class="line">abc = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">Do_work</span>(<span class="keyword">new</span> Coffee);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">Do_work</span>(<span class="keyword">new</span> Tea);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="虚析构和纯虚析构"><a href="#虚析构和纯虚析构" class="headerlink" title="虚析构和纯虚析构"></a>虚析构和纯虚析构</h3><p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p><p>解决方式：将父类中的析构函数改为<strong>虚析构或者纯虚析构</strong> </p><p><strong>虚析构和纯虚析构共性：</strong> </p><ul><li>可以解决父类指针释放子类对象</li><li>都需要有具体的函数实现</li></ul><p><strong>虚析构和纯虚析构区别：</strong> </p><ul><li>如果是纯虚析构，该类属于抽象类，无法实例化对象</li></ul><p><strong>虚析构语法：</strong> </p><blockquote><p>virtual ~类名(){}</p></blockquote><p><strong>纯虚析构语法：</strong> </p><blockquote><p>virtual ~类名() &#x3D; 0;</p></blockquote><blockquote><p>类名::~类名(){}</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Animal</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Animal 构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Speak</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用虚析构解决 父类指针指向子类对象时内存释放不干净的问题</span></span><br><span class="line"><span class="comment">/*virtual ~Animal()</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; &quot;Animal 虚析构函数调用&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() = <span class="number">0</span>;<span class="comment">//纯虚析构函数也需要代码实现，因为父类在堆区可能会有数据，也需要删除</span></span><br><span class="line"><span class="comment">//纯虚析构函数也属于纯虚函数，Animal类即为抽象类无法实例化对象</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Animal :: ~<span class="built_in">Animal</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Animal 纯虚析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Cat</span>(string name)</span><br><span class="line">&#123;</span><br><span class="line">m_name = <span class="keyword">new</span> <span class="built_in">string</span>(name);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Cat 构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; *m_name &lt;&lt; <span class="string">&quot;猫在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Cat</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Cat 析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">string *m_name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Animal *animal = <span class="keyword">new</span> <span class="built_in">Cat</span>(<span class="string">&quot;Tom&quot;</span>);<span class="comment">//父类指针指向子类对象触发多态</span></span><br><span class="line">animal -&gt; <span class="built_in">Speak</span>();<span class="comment">//不使用-&gt;调用而使用.调用会报错</span></span><br><span class="line"><span class="comment">//父类指针销毁时不会调用子类的析构函数，如果子类在堆区有对象，会导致内存泄漏</span></span><br><span class="line"><span class="keyword">delete</span> animal;</span><br><span class="line">animal = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">没有虚析构的输出：</span></span><br><span class="line"><span class="comment">Animal 构造函数调用</span></span><br><span class="line"><span class="comment">Cat 构造函数调用</span></span><br><span class="line"><span class="comment">Tom猫在说话</span></span><br><span class="line"><span class="comment">Animal 析构函数调用</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">虚析构之后输出：</span></span><br><span class="line"><span class="comment">Animal 构造函数调用</span></span><br><span class="line"><span class="comment">Cat 构造函数调用</span></span><br><span class="line"><span class="comment">Tom猫在说话</span></span><br><span class="line"><span class="comment">Cat 析构函数调用</span></span><br><span class="line"><span class="comment">Animal 析构函数调用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> </p><ol><li>虚析构或纯虚析构就是用来解决通过父类指针释放子类对象</li><li>如果子类中没有堆区数据，可以不写为虚析构或纯虚析构</li><li>拥有纯虚析构函数的类也属于抽象类</li></ol><h3 id="计算机组装"><a href="#计算机组装" class="headerlink" title="计算机组装"></a>计算机组装</h3><p><strong>案例描述：</strong> </p><ul><li>电脑主要组成部件为 CPU（用于计算），显卡（用于显示），内存条（用于存储）</li><li>将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如Intel厂商和Lenovo厂商</li><li>创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口</li><li>测试时组装三台不同的电脑进行工作</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//抽象CPU类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPU</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//抽象的计算函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">calculate</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//抽象显卡类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VideoCard</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//抽象的显示函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//抽象内存条类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Memory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//抽象的存储函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">storage</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//电脑类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Computer</span>(CPU *cpu, VideoCard *vc, Memory *mem)</span><br><span class="line">&#123;</span><br><span class="line">m_cpu = cpu;</span><br><span class="line">m_vc = vc;</span><br><span class="line">m_mem = mem;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//提供工作的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//让零件工作起来，调用接口</span></span><br><span class="line">m_cpu-&gt;<span class="built_in">calculate</span>();</span><br><span class="line">m_vc-&gt;<span class="built_in">display</span>();</span><br><span class="line">m_mem-&gt;<span class="built_in">storage</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//提供析构函数 释放3个电脑零件</span></span><br><span class="line">~<span class="built_in">Computer</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//释放CPU零件</span></span><br><span class="line"><span class="keyword">if</span> (m_cpu != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_cpu;</span><br><span class="line">m_cpu = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//释放显卡零件</span></span><br><span class="line"><span class="keyword">if</span> (m_vc != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_vc;</span><br><span class="line">m_vc = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//释放内存条零件</span></span><br><span class="line"><span class="keyword">if</span> (m_mem != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_mem;</span><br><span class="line">m_mem = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">CPU *m_cpu; <span class="comment">//CPU的零件指针</span></span><br><span class="line">VideoCard *m_vc; <span class="comment">//显卡零件指针</span></span><br><span class="line">Memory *m_mem; <span class="comment">//内存条零件指针</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//具体厂商</span></span><br><span class="line"><span class="comment">//Intel厂商</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelCPU</span> : <span class="keyword">public</span> CPU</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">calculate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Intel的CPU开始计算了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelVideoCard</span> : <span class="keyword">public</span> VideoCard</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Intel的显卡开始显示了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelMemory</span> : <span class="keyword">public</span> Memory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">storage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Intel的内存条开始存储了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Lenovo厂商</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LenovoCPU</span> : <span class="keyword">public</span> CPU</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">calculate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Lenovo的CPU开始计算了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LenovoVideoCard</span> : <span class="keyword">public</span> VideoCard</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Lenovo的显卡开始显示了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LenovoMemory</span> : <span class="keyword">public</span> Memory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">storage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Lenovo的内存条开始存储了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//第一台电脑零件</span></span><br><span class="line">CPU *intelCpu = <span class="keyword">new</span> IntelCPU;</span><br><span class="line">VideoCard *intelCard = <span class="keyword">new</span> IntelVideoCard;</span><br><span class="line">Memory *intelMem = <span class="keyword">new</span> IntelMemory;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;第一台电脑开始工作：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//创建第一台电脑</span></span><br><span class="line">Computer *computer1 = <span class="keyword">new</span> <span class="built_in">Computer</span>(intelCpu, intelCard, intelMem);</span><br><span class="line">computer1-&gt;<span class="built_in">work</span>();</span><br><span class="line"><span class="keyword">delete</span> computer1;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;-----------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;第二台电脑开始工作：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//第二台电脑组装</span></span><br><span class="line">Computer *computer2 = <span class="keyword">new</span> <span class="built_in">Computer</span>(<span class="keyword">new</span> LenovoCPU, <span class="keyword">new</span> LenovoVideoCard, <span class="keyword">new</span> LenovoMemory);</span><br><span class="line">;</span><br><span class="line">computer2-&gt;<span class="built_in">work</span>();</span><br><span class="line"><span class="keyword">delete</span> computer2;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;-----------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;第三台电脑开始工作：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//第三台电脑组装</span></span><br><span class="line">Computer *computer3 = <span class="keyword">new</span> <span class="built_in">Computer</span>(<span class="keyword">new</span> LenovoCPU, <span class="keyword">new</span> IntelVideoCard, <span class="keyword">new</span> LenovoMemory);</span><br><span class="line">;</span><br><span class="line">computer3-&gt;<span class="built_in">work</span>();</span><br><span class="line"><span class="keyword">delete</span> computer3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类设计回顾"><a href="#类设计回顾" class="headerlink" title="类设计回顾"></a>类设计回顾</h3><h4 id="编译器生成的成员函数"><a href="#编译器生成的成员函数" class="headerlink" title="编译器生成的成员函数"></a>编译器生成的成员函数</h4><p><strong>1. 默认拷贝构造函数</strong> </p><p>默认构造函数要么没有参数，要么所有的参数都有默认值。如果没有定义任何构造函数，编译器将定义默认构造函数，使程序员能够创建对象。</p><p>自动生成的默认构造函数的一项功能是，调用基类的默认构造函数以及调用本身是对象的成员所属类的默认构造函数。</p><p>另外，如果派生类构造函数的成员初始化列表中没有显式调用基类构造函数，则编译器将使用基类的默认构造函数，则编译器将使用基类的默认构造函数来构造派生类对象的基类部分。在这种情况下，如果基类没有提供构造函数，将导致编译阶段错误。</p><p>如果定义了某种构造函数，编译器将不会提供默认构造函数。在这种情况下，如果需要使用默认构造函数，则必须自己提供。</p><p>提供构造函数的动机之一是确保对象总能被正确的初始化。另外，如果包含汉指针成员则必须初始化这些成员。因此，最好提供一个现实默认构造函数，将所有的类数据成员都初始化为合理的值。</p><p>如下情况下，需要使用复制构造函数：</p><ul><li><p>将新对象初始化为一个同类对象</p></li><li><p>按值将对象传递给函数</p></li><li><p>函数按值返回对象</p></li><li><p>编译器生成临时对象</p></li></ul><blockquote><p>在某些情况下，成员初始化是不合适的。例如，使用new初始化的指针成员通常要求深拷贝。</p></blockquote><p><strong>3. 赋值运算符</strong> </p><ul><li><strong>必须作为类内成员函数进行重载的</strong></li></ul><p>默认的赋值操作运算符用于处理同类对象之间的赋值。不要降幅至于吃u实话混淆了。如果语句创建新的对象，则要初始；如果语句修改已有对象的值，则是赋值。</p><p>默认赋值为成员赋值，如果成员时是对象，则默认成员赋值将使用相应类的赋值运算符。如果需要显式定义复制构造函数，基于相同的原因，也需要显式定义赋值运算符（返回值为对应类对象的引用）。</p><h4 id="其它的类方法"><a href="#其它的类方法" class="headerlink" title="其它的类方法"></a>其它的类方法</h4><p><strong>1. 构造函数</strong> </p><pre><code>构造函数不同于其他类方法。因为它创建新对象，而其他类方法只是被现有的对象调用。这是构造函数不被继承的原因之一。继承意味着派生类对象可以使用基类方法，然而，构造函数在完成其工作之前，对象并不存在。</code></pre><p><strong>2. 析构函数</strong>  </p><pre><code>一定要定义显示析构函数来释放类构造函数使用new 分配的所有内存。并完成类对象所需的任何特殊的清理工作。对于积累，即使它不需要析构函数，也应提供一个析构函数。</code></pre><p><strong>3. 转换</strong> </p><pre><code>使用一个参数就可以调用的构造函数定义了从参数类型到类类型的转换。如：</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Star</span>(<span class="type">const</span> <span class="type">char</span> *)<span class="comment">// converts char * to Star</span></span><br><span class="line"><span class="built_in">Star</span>(<span class="type">const</span> Spectral &amp;, <span class="type">int</span> members = <span class="number">1</span>)<span class="comment">// converts Spectral to Star</span></span><br></pre></td></tr></table></figure><pre><code>将可转换的类型传递给以类为参数的函数时，将调用转换构造函数。例如，下如下代码中：</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Star north;</span><br><span class="line">north = <span class="string">&quot;polaris&quot;</span>;</span><br></pre></td></tr></table></figure><pre><code>第二条语句将Star::operator=(const Star &amp;) 函数，使用Star::Star( const char * ) 生成一个Star对象，该对象将被用作上述赋值运算符函数的参数。这里假设没有定义将 char * 赋给Star 的赋值运算符。在一个带参数的构造函数原型中使用explicit 将禁止进行隐式转换。但仍允许显式转换。</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Star</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Star</span><span class="params">( <span class="type">const</span> <span class="type">char</span> * )</span></span>;</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">Star north;</span><br><span class="line">north = <span class="string">&quot;polaris&quot;</span>;<span class="comment">// not allowed</span></span><br><span class="line">north = <span class="built_in">Star</span>(<span class="string">&quot;Polaris&quot;</span>);<span class="comment">// allowed，使用匿名对象调用编译生成的赋值运算符进行赋值操作</span></span><br></pre></td></tr></table></figure><pre><code>要将类对象转换为其他类型，应定义转换函数。转换函数可以是没有参数的类成员函数，也可以是返回值被声明为目标类型的类成员函数。即使没有声明返回值类型，函数也应返回所需的转换值。下面是一些示例：</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Star::<span class="keyword">operator</span> <span class="title">double</span> <span class="params">()</span> </span>&#123; <span class="comment">// do sonmething &#125;// converts Star to double</span></span><br><span class="line">Star::<span class="keyword">operator</span> <span class="type">const</span> <span class="type">char</span> * () &#123; <span class="comment">// do somethiong &#125;// converts Star to const char </span></span><br></pre></td></tr></table></figure><pre><code>应力值的使用这样的函数，仅当它们有帮助时才使用。另外，对于某些类，包含转换函数将增加代码的二义性。例如，假设已经为Vector （矢量）定义了 double 转换，并编写了下面的代码：</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vector <span class="title">ius</span><span class="params">(<span class="number">6.0</span>, <span class="number">0.0</span>)</span></span>;</span><br><span class="line">Vector ius = ius + <span class="number">20.2</span>;<span class="comment">// amibiguous</span></span><br></pre></td></tr></table></figure><pre><code>编译器可以将ius 转换为double 并使用假发，或将20.2 转换成Vector（使用构造函数之一）并使用Vector 加法。但除了指出二义性外，它什么也不做。C++11支持将关键字explicit 用于转换函数。与构造函数一样explicit 允许使用强制类型转换进行显示转换，但不允许隐式转换。</code></pre><p><strong>4. 按值传递对象与传递引用</strong> </p><pre><code>通常，编写使用对象作为参数的函数时，应按引用而不是安置来传递对象。这样做的原因之一是为了提高效率。按值传递对象涉及到生成临时拷贝，即调用复制构造函数，然后调用析构函数调用这些函数需要时间，复制大量对象比传递引用花费的时间要多得多。如果函数不修改对象，应将参数声明为const 引用。按引用传递对象的另一个原因是，在继承使用虚函数时，被定义为接受基类引用参数的函数可以接受派生类。</code></pre><p><strong>5. 返回对象和返回引用</strong> </p><pre><code>有些类方法返回对象（某些成员函数，比如加运算符重载函数），而另一些则返回引用（赋值运算符重载函数）。有时方法必须返回对象，但是可以不返回对象，则应返回引用。</code></pre><p><strong>6.  使用const</strong> </p><ul><li><p>应当特别注意，可以使用它来确保不修改参数</p></li><li><p>使用const 来确保不修改调用它的对象</p><p>通常，可以将返回引用的函数放在赋值语句的左侧，这实际上意味着可以将值赋给引用的对象。但可以使用const 来确保引用或指针返回的值不能用于修改对象中的数据：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> Stock &amp; <span class="title">Stock::topval</span><span class="params">(<span class="type">const</span> Stock &amp;s)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( s.total &gt; total_val )</span><br><span class="line">    <span class="keyword">return</span> s;<span class="comment">// arguement obj</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">// invoking obj</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>该方法返回对this 或s 的引用。因为this 和 s 都被声明为const ，所以函数不能对他们进行修改，这意味着返回的引用也必须被声明为const。  注意，如果函数将参数声明为指向const 的引用或指针，则不能将该参数传递给另一个函数，除非后者也确保了参数也不会被修改。</code></pre></li></ul><h4 id="公有继承的考虑因素"><a href="#公有继承的考虑因素" class="headerlink" title="公有继承的考虑因素"></a>公有继承的考虑因素</h4><pre><code>通常，在程序使用继承时，有很多问题需要注意。</code></pre><p><strong>1. is-a 关系</strong> </p><p>要遵循is-a关系。如果派生类不是一种特殊的类，则不要使用共有派生。例如，不应从Brain类派生出 Programmer类。如果要指出程序员有大脑，应将Brain类对象作为Programmer类的成员。</p><p>在某些情况下，最好的办法可能是创建包含纯虚函数的抽象数据类，并从它派生出其他的类。</p><p>表示 is-a 关系最好的方式之一是，无需进行显式类型转换，基类指针或引用就可以指向派生类对象，反过来是行不通的。向下强制转换可能有意义，也可能没有。</p><p><strong>2. 什么不能被继承</strong> </p><ul><li><p>构造函数是不能被继承的，即创建派生类对象时，必须调用派生类构造函数（可以初始化列表，调用基类构造函数）</p></li><li><p>析构函数也是不能继承的</p></li><li><p>赋值运算符也是不能继承的</p></li></ul><p>C++11 新增了一种让程序员能够继承构造函数的机制，但默认仍不能继承构造函数。</p><p><strong>3. 赋值运算符</strong> </p><ul><li>如果类构造函数使用new 来初始化指针，则需要提供一个显式赋值运算符。</li></ul><p><strong>4. 私有成员和保护乘员</strong> </p><p>对派生类而言，保护成员类似于公有成员，但对于外部来说，保护成员与私有成员类似。派生类可以直接访问基类的保护乘员，但只能通过基类的成员函数来访问私有成员。因此，将基类成员设置为私有的可以提高安全性，而将它们设置为保护成员则可以简化代码编写工作，并提高访问速度。Stroustrup指出，使用私有数据比使用保护数据更好，但是保护方法很有用。</p><p><strong>5. 虚方法</strong> </p><p>设计基类时，必须确定是否将类方法声明为虚的。如果重新定义则在基类中将方法设置为虚。</p><p><strong>6. 析构函数</strong> </p><pre><code>基类的析构函数应当是虚方法，如此，当通过指向对象的基类指针或引用来删除派生对象时，程序首先调用派生类的析构函数，然后调用基类的析构函数，而不仅仅是调用基类的析构函数。</code></pre><p><strong>7. 友元函数</strong> </p><pre><code>由于友元函数并非类成员，因此不能被继承。程序员如果想要派生类的友元函数能够使用基类的友元函数。为此，可以通过强制类型转换将派生类引用或指针转换为基类引用或指针，然后使用转换后的指针或引用来调用基类的友元函数：</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="type">const</span> hasDMA ＆hs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// type cast to match operator&lt;&lt;(ostream &amp; , const hasDMA &amp;)</span></span><br><span class="line">    os &lt;&lt; (<span class="type">const</span> baseDMA &amp;)hs;</span><br><span class="line">    os &lt;&lt; <span class="string">&quot;Style: &quot;</span> &lt;&lt; hs.style &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>或者使用dynamic_cast&lt;&gt;来进行强制转换：</code></pre><p><code>os &lt;&lt; dynamic_cast&lt;const baseDMA &amp;&gt; (hs);</code></p><p><strong>8. 有关使用基类方法的说明</strong> </p><pre><code>以公有派生的类的对象可以通过多种方式来调用基类的方法</code></pre><ul><li>派生类对象自动使用继承而来的基类方法。如果派生类没有重新定义该方法</li><li>派生类的构造函数自动调用基类的构造函数（初始化列表）</li><li>派生类的构造函数自动调用基类的默认构造函数，如果没有在成员初始化列表中指定其他构造函数</li><li>派生类构造函数显式地调用成员初始化列表中的指定的基类构造函数</li><li>派生类方法可以使用作用域解析运算符来调用公有的和受保护的基类方法</li><li>派生类的友元函数可以通过强制类型转换，将派生类引用或指针转换为基类引用或指针，然后使该引用或指针来调用基类的友元函数。（派生-&gt;基类，特殊处理派生类中的新增属性）</li></ul><h4 id="成员函数属性"><a href="#成员函数属性" class="headerlink" title="成员函数属性"></a>成员函数属性</h4><table><thead><tr><th align="center">函数</th><th align="center">能否继承</th><th align="center">成员还是友元</th><th align="center">默认能否生成</th><th align="center">能否为虚函数</th><th align="center">是否可以有返回值</th></tr></thead><tbody><tr><td align="center">构造函数</td><td align="center">否</td><td align="center">成员</td><td align="center">能</td><td align="center">否</td><td align="center">否</td></tr><tr><td align="center">析构函数</td><td align="center">否</td><td align="center">成员</td><td align="center">能</td><td align="center">能</td><td align="center">否</td></tr><tr><td align="center">&#x3D;</td><td align="center">否</td><td align="center">成员</td><td align="center">能</td><td align="center">能</td><td align="center">能</td></tr><tr><td align="center">&amp;</td><td align="center">能</td><td align="center">任意</td><td align="center">能</td><td align="center">能</td><td align="center">能</td></tr><tr><td align="center">转换函数</td><td align="center">能</td><td align="center">成员</td><td align="center">否</td><td align="center">能</td><td align="center">否</td></tr><tr><td align="center">()</td><td align="center">能</td><td align="center">成员</td><td align="center">否</td><td align="center">能</td><td align="center">能</td></tr><tr><td align="center">[]</td><td align="center">能</td><td align="center">成员</td><td align="center">否</td><td align="center">能</td><td align="center">能</td></tr><tr><td align="center">-&gt;</td><td align="center">能</td><td align="center">成员</td><td align="center">否</td><td align="center">能</td><td align="center">能</td></tr><tr><td align="center">op&#x3D;</td><td align="center">能</td><td align="center">任意</td><td align="center">否</td><td align="center">能</td><td align="center">能</td></tr><tr><td align="center">new</td><td align="center">能</td><td align="center">静态成员</td><td align="center">否</td><td align="center">否</td><td align="center">void*</td></tr><tr><td align="center">delete</td><td align="center">能</td><td align="center">静态成员</td><td align="center">否</td><td align="center">否</td><td align="center">void</td></tr><tr><td align="center">其他运算符</td><td align="center">能</td><td align="center">任意</td><td align="center">否</td><td align="center">能</td><td align="center">能</td></tr><tr><td align="center">其他成员</td><td align="center">能</td><td align="center">成员</td><td align="center">否</td><td align="center">能</td><td align="center">能</td></tr><tr><td align="center">友元</td><td align="center">否</td><td align="center">友元</td><td align="center">否</td><td align="center">否</td><td align="center">能</td></tr></tbody></table><p><strong>要特别注意转换函数</strong> ，严格来说它没有返回值，要返回的类型就是其函数名</p><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><h3 id="简单文件输入-输出"><a href="#简单文件输入-输出" class="headerlink" title="简单文件输入&#x2F;输出"></a>简单文件输入&#x2F;输出</h3><pre><code>**对于文件输入**，C++使用类似于cout的东西，如下是一些有关于cout用于控制台输出的基本事实，为文件输出做准备：</code></pre><ul><li><p>必须包含iostream头文件</p></li><li><p>头文件iostream定义了一个用来处理输出的ostream类</p></li><li><p>头文件iostream声明了一个名为cout的ostream对象</p></li><li><p>必须指明名称空间std</p></li><li><p>可以结合使用cout和运算符&lt;&lt;来显示各种类型的数据（文件输出与此相同）</p></li><li><p>必须包含头文件fstream</p></li><li><p>头文件定义了一个用于处理文件输出的ofstream类</p></li><li><p>需要声明一个或多个ofstream对象，并以自己喜欢的方式命名，条件是遵守常见的命名规则</p></li><li><p>必须指明名称空间std（为引用ofstream，必须使用using编译指令或前缀std::）</p></li><li><p>需要将ofstream对象与文件关联起来。为此，方法之一是使用open()方法</p></li><li><p>使用完文件后，应使用close()方法将其关闭</p></li><li><p>可结合ofstream对象和运算符&lt;&lt;来输出各种类型的数据</p><p><strong>注意</strong>，方法open()接受一个C-style的字符串，如果文件名定义为string类型，则open()方法参数应该是stringName.c_str()。</p><p>并且默认写入状态是覆盖原有内容。</p><p>  <strong>对于文本文件输入</strong>，它是基于控制台输入的。控制台输入涉及多个方面，下面总结这些方面：</p></li><li><p>必须包含头文件iostream</p></li><li><p>头文件iostream定义了一个用于处理输入的istream类</p></li><li><p>头文件iostream声明了一个名为cin的istream对象</p></li><li><p>必须指明名称空间std</p></li><li><p>可以结合使用cin和运算符&gt;&gt;来读取各种类型的数据</p></li><li><p>可以使用cin和get()方法来读取一个字符，使用cin和getline()来读取一行字符</p></li><li><p>可以结合使用cin和eof()，fail()方法来判断输入是否成功</p></li><li><p>对象cin本身被用作测试条件时，如果最后一个读取操作成功，它将被转换为bool值true，否则将被转换为false</p><p>文件输出与其极其相似：</p></li><li><p>必须包含头文件fstream</p></li><li><p>头文件fstream定义了一个用于处理输入的ifstream类</p></li><li><p>需要声明一个或多个ifstream对象，并以自己喜欢的方式命名对象，条件是遵守常用命名规则</p></li><li><p>必须指明名称空间std</p></li><li><p>需要将ifstream对象与文件关联起来，方法之一是使用open()方法</p></li><li><p>使用完文件后，应使用close()方法将其关闭</p></li><li><p>可结合使用ifstream对象和运算符&gt;&gt;来读取各种类型的数据</p></li><li><p>可以使用ifstream对象和get()方法来读取一个字符，使用ifstream对象和getline()来读取一行字符</p></li><li><p>可以结合使用ifstream和eof()、fail()等方法来判断输入是否成功</p></li><li><p>ifstream对象本身被用作测试条件时，如果最后一个读取操作成功，它将被转换为bool值true，否则将被转换为false</p></li></ul><p>包含头文件 <fstream></p><p>文件类型：</p><ul><li>文本文件</li><li>二进制文件</li></ul><p>文件操作的类别：</p><ul><li>ofstream写文件</li><li>ifstream         读文件</li><li>fstream          读写操作</li></ul><h3 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h3><ol><li>头文件</li><li>创建写入流对象             ofstream ofs;</li><li>打开文件                          ofs.open(“文件路径”, 打开方式);</li><li>写数据                ofs &gt;&gt; “data”;</li><li>关闭文件               ofs.close();</li></ol><table><thead><tr><th>文件打开方式</th><th>解释</th></tr></thead><tbody><tr><td>ios::in</td><td>读模式打开文件</td></tr><tr><td>ios::out</td><td>写模式打开文件</td></tr><tr><td>ios::ate</td><td>初始位置：文件尾（追加模式），打开时指针在文件尾， 可以通过seekp等操作移动指针位置。</td></tr><tr><td>ios::app</td><td>追加方式写文件，每次写操作都在文件尾</td></tr><tr><td>ios::trunc</td><td>覆盖模式，重新创建文件</td></tr><tr><td>ios::binary</td><td>二进制模式打开</td></tr></tbody></table><p>文件打开方式可以配合使用，模式与模式之间使用 | 分隔</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. #include &lt;fstream&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. create fstream obj</span></span><br><span class="line">    ofstream ofs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. pattern open file</span></span><br><span class="line">    ofs.<span class="built_in">open</span>(<span class="string">&quot;01_test.txt&quot;</span>, ios::out);   <span class="comment">// C-style string </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. write something into file</span></span><br><span class="line">    ofs &lt;&lt; <span class="string">&quot;姓名：张三 &quot;</span> &lt;&lt; <span class="string">&quot;年龄：19&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. close file</span></span><br><span class="line">    ofs.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ALL DONE&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. #include &lt;fstream&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. create fstream obj </span></span><br><span class="line">    ifstream ifs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. open file with ios::in and judge op success</span></span><br><span class="line">    ifs.<span class="built_in">open</span>(<span class="string">&quot;01_test.txt&quot;</span>, ios::in);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Fialed to open file&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. read file</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// method one</span></span><br><span class="line">    <span class="comment">// char buf[1024] = &#123; 0 &#125;;</span></span><br><span class="line">    <span class="comment">// while (ifs &gt;&gt; buf)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// &#125; </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// mothod two </span></span><br><span class="line">    <span class="comment">// char buf[1024] = &#123; 0 &#125;;</span></span><br><span class="line">    <span class="comment">// while (ifs.getline(buf, 1024))  // char*, max size, one char-one bit</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// method three</span></span><br><span class="line">    <span class="comment">// string buf;</span></span><br><span class="line">    <span class="comment">// while (getline(ifs, buf))   // overloaded getline(cin, string);</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// method four</span></span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span> (ifs.<span class="built_in">get</span>(ch) &amp;&amp; ch != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; ch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. close file</span></span><br><span class="line">    ifs.<span class="built_in">close</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ALL DONE&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二进制写文件"><a href="#二进制写文件" class="headerlink" title="二进制写文件"></a>二进制写文件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// string.c_str();</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>(string n, <span class="type">int</span> a) : <span class="built_in">name</span>(n), <span class="built_in">age</span>(a) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. #include &lt;fstream&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. create ifstream obj</span></span><br><span class="line">    ofstream ofs;</span><br><span class="line">    <span class="comment">// 3. open file</span></span><br><span class="line">    ofs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::out | ios::binary);</span><br><span class="line">    <span class="comment">// 4. write</span></span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;张三&quot;</span>, <span class="number">78</span>)</span></span>;</span><br><span class="line">    ofs.<span class="built_in">write</span>((<span class="type">const</span> <span class="type">char</span>*)&amp;p, <span class="built_in">sizeof</span>(p));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. close file</span></span><br><span class="line">    ofs.<span class="built_in">close</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ALL DONE&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二进制读文件"><a href="#二进制读文件" class="headerlink" title="二进制读文件"></a>二进制读文件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// string.c_str();</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>(string n, <span class="type">int</span> a) : <span class="built_in">name</span>(n), <span class="built_in">age</span>(a) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. #include &lt;fstream&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. create ifstream obj</span></span><br><span class="line">    ofstream ofs;</span><br><span class="line">    ifstream ifs;</span><br><span class="line">    <span class="comment">// 3. open file</span></span><br><span class="line">    ofs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::out | ios::binary);</span><br><span class="line">    <span class="comment">// 4. write</span></span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;张三&quot;</span>, <span class="number">78</span>)</span></span>;</span><br><span class="line">    ofs.<span class="built_in">write</span>((<span class="type">const</span> <span class="type">char</span>*)&amp;p, <span class="built_in">sizeof</span>(p));</span><br><span class="line"></span><br><span class="line">    Person p1;</span><br><span class="line">    ifs.<span class="built_in">read</span>((<span class="type">char</span> *)&amp;p1, <span class="built_in">sizeof</span>(p));</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; p1.name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p1.age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. close file</span></span><br><span class="line">    ofs.<span class="built_in">close</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ALL DONE&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>涉及到编码，事情变得异常复杂，所以不建议二进制读写</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>程序有时会遇到运行阶段错误，导致程序无法正常的运行下去。例如，程序请求打开一个不可用的文件，请求过多内存，或者遭遇不可忍受的值。通常，程序员会试图预防这些意外情况。C++异常为处理这种情况提供了一种强大而灵活的工具。异常是比较新的C++功能，有些老的编译器可能没有实现。另外，有些编译器默认关闭这种特性，需要手动启用。</p><p>一种比较为大众所熟知的情况是：计算两个数的算术平均数，即</p><blockquote><p>2.0 * x * y &#x2F; ( x + y)</p></blockquote><p>如果 y 与 x 互为相反数，则上述公式将导致被零除——一种不被允许的运算，很多新式编译器通过生成一个表示无穷大的特殊浮点数来处理，cout将这种值显示为Inf、inf、INF或类似的东西；而其他编译器可能生成在发生被零除时崩溃的程序。最好编写在所有系统上都以相同的受控方式运行的代码。</p><h3 id="调用abort"><a href="#调用abort" class="headerlink" title="调用abort ()"></a>调用abort ()</h3><p>对上述提到的问题，处理方式之一是：如果两参数互为相反数，则调用abort()函数，其原型位于头文件<cstdlib>中，其典型实现是向标准错误流发送消息 abnormal program termination（程序异常终止），然后终止程序。它还返回一个随实现而异的值，告诉操作系统（如果程序是由另一个进程调用的，则告诉父进程），处理失败。abort()函数是否刷新文件缓冲区（用于存储读写到文件中的数据的内存区域）取决于实现。如果愿意，也可以使用exit()，该函数刷新文件缓冲区，但不显示消息。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// error1.cpp - using the abort() function</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">hmean</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == -b)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;untenable arguments to hmean()\n&quot;</span>;</span><br><span class="line">        std::<span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2.0</span> * a * b / (a + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> x, y, z;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter two numbers: &quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (std::cin &gt;&gt; x &gt;&gt; y)</span><br><span class="line">    &#123;</span><br><span class="line">        z = <span class="built_in">hmean</span>(x, y);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Harmonic mean of &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; z &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Enter next set of numbers &lt;q to quit&gt;: &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Bye!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3 6 </span></span><br><span class="line"><span class="comment">10 -10</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>为避免异常终止，程序应在调用hmean()函数之前检查x和y的值。然而，依靠程序员来执行这种检查是不安全的。</p><h3 id="返回错误码"><a href="#返回错误码" class="headerlink" title="返回错误码"></a>返回错误码</h3><p>一种比异常终止更灵活的方法是，使用函数的返回值来指出问题。例如，istream类的 get(void)成员通常返回下一个输入字符的ASCII码，但达到文件尾时，将返回特殊值EOF，对于hmean()来说，这种方法不管用。任何数值都是有效的返回值，因此不存在可用于指出问题的特殊值。在这种情况下，可使用指针参数或指针引用来将值返回给调用程序，并使用函数的返回值来指出是成功了还是失败了，另外还给函数该函数增加了第三个参数，用于提供答案。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// error2.cpp - returning an error code</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cfloat&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hmean</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b, <span class="type">double</span> *ans)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == -b)</span><br><span class="line">    &#123;</span><br><span class="line">        *ans = DBL_MAX;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        *ans = <span class="number">2.0</span> * a * b / (a + b);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> x, y, z;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter two numbers: &quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (std::cin &gt;&gt; x &gt;&gt; y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">hmean</span>(x, y, &amp;z))</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Harmonic mean of &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; z &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;One value should not be the negative of the other - try again&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Enter next set of numbers &lt;a to quit&gt;: &quot;</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Bye!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序设计避免了错误输入的恶果，让用户能够继续输入。当然，设计确实依靠用户检查函数返回值，这项工作是程序员不常做的。C++ primer plus 这本书罗列的程序中都没有检查cout是否成功输出的。</p><p>第三个参数可以是指针或者引用。对内置类型的数据，很多程序员偏向于使用指针，因为这样可以明显地看出是哪一个参数用于提供答案。</p><p>另一种在某一个地方存储返回条件的方法是使用一个全局变量。可能出现问题的函数可以在出现问题时将该全局变量设置为特定的值，而调用程序检查该变量。传统的C语言数学库就是使用这种方法，它使用的全局变量名为errno。当然，必须确保其他函数没有将该全局变量用于其它目的。</p><h3 id="异常机制"><a href="#异常机制" class="headerlink" title="异常机制"></a>异常机制</h3><p>C++异常是对程序运行过程中发生的异常情况（例如被零除）的一种响应。异常提供了将控制权从程序的一部分传递到另一部分的途径，对异常的处理有三部分：</p><ul><li>引发异常</li><li>使用处理程序捕捉异常</li><li>使用try块</li></ul><p>程序在出现问题时引发异常。修改调用abort()函数的程序，使hmean引发异常，而不是调用abort()函数。throw语句实际上是跳转，即命令程序跳到另一语句。throw关键字表示引发异常，紧随其后的值（例如字符串或对象）指出了异常的特征。</p><p>程序使用异常处理程序（exception handler）来捕捉异常，异常处理程序位于要处理问题的程序中。catch关键字表示捕获异常。处理程序以关键字catch开头，随后是位于括号中的类型声明，它指出了异常处理程序要响应的异常类型；然后是一个用花括号括起的代码块，指出要采取的措施。catch关键字和异常类型用作标签，指出当异常被引发时，程序应当跳到该位置执行。</p><pre><code>try块标识其中特定的异常可能被激活的代码块，它后面跟一个或多个catch块。try块是由关键字try指示的，关键字try的后面是一个由花括号括起的代码块，表明需要注意这些代码引发的异常。</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// error3.cpp - using an exception</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">hmean</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == -b)</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&quot;bad hmean() argumrnts: a = -b not allowed&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2.0</span> * a * b / (a + b); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> x, y, z;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter two numbers: &quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (std::cin &gt;&gt; x &gt;&gt; y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;   <span class="comment">// start of try block</span></span><br><span class="line">            z = <span class="built_in">hmean</span>(x, y);</span><br><span class="line">        &#125;   <span class="comment">// end of try block</span></span><br><span class="line">        <span class="built_in">catch</span> (<span class="type">const</span> <span class="type">char</span> *s)   <span class="comment">// start of exception handler</span></span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; s &lt;&lt; std::endl;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Enter a new pair of numbers: &quot;</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;   <span class="comment">// end of exception handler</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Harmonic mean of &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; z &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Enter next set of numbers &lt;q to quit&gt;: &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Bye!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="将对象作为异常类型"><a href="#将对象作为异常类型" class="headerlink" title="将对象作为异常类型"></a>将对象作为异常类型</h3><p>通常，引发异常的函数将传递一个对象。这样做的优点之一是，可以在使用不同的异常类型来区分不同的函数在不同情况下引发的异常。另外，对象可以携带信息，程序员可以根据这些信息来确定引发异常的原因。同时，catch块可以根据这些信息来确定决定采取什么样的措施。</p><p>exc_mean.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// exc_mean.h   exception classes for hmean() gmean()</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">bad_hmean</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> v1;</span><br><span class="line">    <span class="type">double</span> v2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">bad_hmean</span>(<span class="type">double</span> a = <span class="number">0</span>, <span class="type">double</span> b= <span class="number">0</span>):<span class="built_in">v1</span>(a), <span class="built_in">v2</span>(b) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mesg</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">bad_hmean::mesg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;hmean(&quot;</span> &lt;&lt; v1 &lt;&lt; v2 &lt;&lt; <span class="string">&quot;): invalid arguments : a = -b&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">bad_gmean</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> v1;</span><br><span class="line">    <span class="type">double</span> v2;</span><br><span class="line">    <span class="built_in">bad_gmean</span>(<span class="type">double</span> a, <span class="type">double</span> b):<span class="built_in">v1</span>(a), <span class="built_in">v2</span>(b) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">mesg</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">bad_gmean::mesg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;gmean() arguments should be &gt;= 0&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>04_error4.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// error4.cpp using exception classes</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;04_exc_mean.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// function prototypes</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">hmean</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">gmean</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::cin;</span><br><span class="line">    <span class="keyword">using</span> std::cout;</span><br><span class="line">    <span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> x, y, z;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter two numbers: &quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; x &gt;&gt; y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            z = <span class="built_in">hmean</span>(x, y);</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Harmonic mean of &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; z &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Geometric mean of &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;and &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; <span class="built_in">gmean</span>(x, y) &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Enter next set of numbers &lt;q to quit&gt;: &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">catch</span> (bad_hmean &amp;bg)   <span class="comment">// start of catch block</span></span><br><span class="line">        &#123;</span><br><span class="line">            bg.<span class="built_in">mesg</span>();</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Try again.&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">catch</span> (bad_gmean &amp;hg)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; hg.<span class="built_in">mesg</span>();</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Values used &quot;</span> &lt;&lt; hg.v1 &lt;&lt; hg.v2 &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Sorry, you don&#x27;t get to play any more&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;   <span class="comment">// end of catch block</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Bye!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">hmean</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == --b)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">bad_hmean</span>(a, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2.0</span> * a * b / (a + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">hmean</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; <span class="number">0</span> || b &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">bad_gmean</span>(a, b);</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">sqrt</span>(a * b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4 12 </span></span><br><span class="line"><span class="comment">5 -5</span></span><br><span class="line"><span class="comment">5 -2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="异常规范与C-11"><a href="#异常规范与C-11" class="headerlink" title="异常规范与C++11"></a>异常规范与C++11</h3><p>有时候，一种理念看似有前途，但实际使用效果并不好。异常规范（exception specification）就是这样一个例子。这是C++98新增的一项功能，但C++11却将之摒弃，这意味着C++11仍然处于标准之中，但以后可能会从标准中剔除。因此不建议使用。</p><p>忽视异常规范前，至少应该了解它到底是怎样的，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">harm</span><span class="params">(<span class="type">double</span> a)</span> <span class="title">throw</span><span class="params">(bad_thing)</span></span>;<span class="comment">// may throw bad_thing exception</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">marm</span><span class="params">(<span class="type">double</span>)</span> <span class="title">throw</span><span class="params">()</span></span>;<span class="comment">// doesn&#x27;t throw an exception</span></span><br></pre></td></tr></table></figure><p>其中throw()部分就是异常规范，它可能出现在函数原型和函数定义中，可包含类型列表，也可不包含。</p><p>异常规范的作用之一是，告诉用户可能需要使用try块。然而，这项工作也可使用注释轻松完成。异常规范的另一个作用是，让编译器添加执行阶段检查的代码，检查是否违反了异常规范。这很难检查。例如，marm()可能本身不会引发异常，但它可能调用另一个函数，而这个函数调用的另一个函数引发了异常。另外，程序员在编写代码时可能不会有异常，但库更新之后它却会引发异常。总之，编程社区达成的一致意见是，最好不要使用这项新功能。而C++11 也建议忽略异常规范。</p><pre><code>尽管如此，C++11确实支持一种特殊的异常规范：程序员可以使用新增的关键字noexcept指出程序不会发生异常：</code></pre><p><code>double marm() noexcrpt;// marm() doesn&#39;t throw an exception</code> </p><p>有关这种异常规范是否有必要存在和有用存在一些争议，见仁见智。</p><p>vector的构造函数是显式声明了不会出现异常的。</p><h3 id="栈解退"><a href="#栈解退" class="headerlink" title="栈解退"></a>栈解退</h3><p>我觉得其中比较经典的一段话是：C++通常是如何处理函数调用和函数返回的：</p><blockquote><p>C++通常将信息放在栈中来处理函数调用。具体地说，程序将调用函数的指令的地址（返回地址）放到栈中。当被调用的函数执行完毕后，程序将使用改地址来确定从哪里开始继续执行。另外，函数调用将函数参数放到栈中。在栈中，这些函数参数被视为自动变量。如果被调用的函数创建了新的自动变量，则这些变量也将被添加到栈中。如果被调用那个的函数调用了另一个函数，则后者的信息将被添加到栈中，依此类推。当函数结束时，程序流程将跳到该函数被调用是存储的地址处，同时栈顶的元素将被释放。因此，函数通常返回到调用它的函数，依此类推，同时每个函数都在结束时释放其自动变量。如果自动变量是类对象，则类的析构函数将被调用。</p></blockquote><p>现在假设函数由于出现异常（而不是由于返回）而终止，则程序也将释放栈中的内存，但不会在释放栈第一个返回地址后停止，知道找到一个位于try块中返回的地址。随后，控制权将转到块尾的异常处理程序，而不是函数调用后面的第一条语句。这个过程被称为<strong>栈解退</strong>。引发机制的一个非常重要的特性是，和函数返回一样，对于栈中的自动类对象，类的析构函数将被调用。然而，函数仅仅处理该函数放在栈中的对象（堆上创建的对象不会被释放，会引发内存泄漏），而throw语句则处理try块和throw块之间整个函数调用序列放在栈中的对象。如果没有栈解退这种特性，则引发异常后，对于中间函数调用放在栈中的自动类对象，其析构函数不会被调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// error5.cpp - unwinding the stack</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;04_exc_mean.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">demo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string word;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">demo</span>(<span class="type">const</span> std::string &amp;str)</span><br><span class="line">    &#123;</span><br><span class="line">        word = str;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;demo &quot;</span> &lt;&lt; word &lt;&lt; <span class="string">&quot; created\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">demo</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;demo &quot;</span> &lt;&lt; word &lt;&lt; <span class="string">&quot; destroyed\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;demo &quot;</span> &lt;&lt; word &lt;&lt; <span class="string">&quot; lives!\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// function prototypes</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">hmean</span><span class="params">(<span class="type">double</span>, <span class="type">double</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">gmean</span><span class="params">(<span class="type">double</span>, <span class="type">double</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">means</span><span class="params">(<span class="type">double</span>, <span class="type">double</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::cout;</span><br><span class="line">    <span class="keyword">using</span> std::cin;</span><br><span class="line">    <span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> x, y, z;</span><br><span class="line">    <span class="function">demo <span class="title">d1</span><span class="params">(<span class="string">&quot;found in block in main()&quot;</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter two numbers: &quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; x &gt;&gt; y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;   <span class="comment">// start of try block</span></span><br><span class="line">            z = <span class="built_in">hmean</span>(x, y);</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;The mean mean of &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; z &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Enter next pair: &quot;</span>; </span><br><span class="line">        &#125;   <span class="comment">// end of try block</span></span><br><span class="line">        <span class="built_in">catch</span> (bad_hmean &amp;bg)   <span class="comment">// start of exception handler</span></span><br><span class="line">        &#123;</span><br><span class="line">            bg.<span class="built_in">mesg</span>();</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Try again.\n&quot;</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">catch</span> (bad_gmean &amp;hg)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; hg.<span class="built_in">mesg</span>();</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Values used: &quot;</span> &lt;&lt; hg.v1 &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; hg.v2 &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Sorry, you don&#x27;t get to try any more.\n&quot;</span>;</span><br><span class="line">        &#125;   <span class="comment">// end of exception handler</span></span><br><span class="line">        d1.<span class="built_in">show</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Bye!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">hmean</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == -b)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">bad_hmean</span>(a, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2.0</span> * a * b / (a + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">gmean</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; <span class="number">0</span> || b &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">bad_gmean</span>(a, b);</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">sqrt</span>(a * b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">means</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> am, hm, gm;</span><br><span class="line">    <span class="function">demo <span class="title">d2</span><span class="params">(<span class="string">&quot;found in means()&quot;</span>)</span></span>;</span><br><span class="line">    am = (a + b) / <span class="number">2.0</span>;     <span class="comment">// arithmetic mean</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        hm = <span class="built_in">hmean</span>(a, b);</span><br><span class="line">        gm = <span class="built_in">gmean</span>(a, b); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (bad_hmean &amp;bg)</span><br><span class="line">    &#123;</span><br><span class="line">        bg.<span class="built_in">mesg</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Caught in means()\n&quot;</span>;</span><br><span class="line">        <span class="keyword">throw</span>;  <span class="comment">// rethrows the exception   enabled the second catch in main()</span></span><br><span class="line">    &#125;</span><br><span class="line">    d2.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> (am + hm + gm) / <span class="number">3.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/03/25/NIypEaoxbHGe4iQ.png" alt="栈解退"> </p><blockquote><p>在第二次，d2.show() 并没有被执行，因为means()中没有处理bad_gmean异常的机制，所以异常被抛出到主函数中，由第二个catch块解决。</p></blockquote><h3 id="其他异常特性"><a href="#其他异常特性" class="headerlink" title="其他异常特性"></a>其他异常特性</h3><p>虽然throw-catch机制类似于函数参数和函数返回机制。倒是还是有不同之处。其中之一是函数fun()中的返回语句将控制权返回到调用fun()的函数，但throw语句将控制权向上返回到第一个这样的函数：包括能够捕获异常的try-catch组合。比如再上一个例子中，当函数hmean()引发异常时，控制权将传递给函数means()；然而，当gmean()引发异常时，控制权向上传递给main()。</p><p>另一个不同之处是，引发异常时编译器总是创建一个临时拷贝，即使异常规范和catch块中指定的是引用。</p><blockquote><p>一般情况下，在程序异常终止时程序应当将栈中保存的自动变量销毁，使用引用按理说应该会发生错误，但是实际上并没有。</p></blockquote><p>throw会为待抛出的变量创建副本，但是代码中能够使用引用的原因是：</p><ol><li>将引用作为返回值的通常原因是避免创建副本以提高效率</li><li>涉及引用的另一重要特征，基类引用能够hi行派生类对象。假设有一组通过继承关系关联起来的异常类型，则在异常规范中只需列出一个基类引用，它将与任何派生类对象匹配。</li></ol><p>假设有一个一场类层次结构，并要分别处理不同的异常类型，则使用基类引用将能够捕获任何异常对象；而使用派生类引用只能捕获它所属类及从这个类派生而来的对象。引发异常的对象将被第一个与之匹配的catch块捕获。这意味catch块的排列顺序应该与派生顺序相反。</p><blockquote><p>如果有一个异常类继承层次结构，应这样排列catch块：将捕捉位于层次结构最下面的异常类的catch语句放在最前面，将捕获积累一场额catch语句放在最后面。</p><p>因为如果将捕获基类的catch语句放在最前面，第一个catch语句将捕获所有异常类型。</p></blockquote><p>通过正确排列catch快的顺序，让程序员能够再如何处理异常方面有选择的余地。然而如果不知道将要捕获何种类型的异常，则在catch块后面的捕获类型使用省略号来表达捕获任何异常类型。</p><p>如果知道要捕获的异常是何种类型，则可以将捕获所有异常类型的catch块放在所有catch块的最后，类似switch语句中的default。</p><p>可以创建捕获对象而不是引用的处理程序。在catch语句中使用基类对象时，将捕获所有的派生类对象，但派生特性将被去除，因此将使用虚方法的基类版本。</p><h3 id="exception类"><a href="#exception类" class="headerlink" title="exception类"></a>exception类</h3><p>C++异常的主要目的是为设计容错程序提供语言级支持，即异常使得在程序中包含错误处理功能更容易，一面时候采取一些严格的错误处理方式。异常的灵活性和相对方便性激励着程序员在条件允许的情况下在程序设计中加入错误处理功能。总之，异常是这样一种特性：类似于类，可以改变程序员的编程方式。</p><p>较新的C++编译器将一场合并到语言中。例如，为支持该语言，exception头文件定义了exception类，C++可以把它用作其他异常类的基类。代码可以印发exception异常，也可以将exception类作为基类。有一个名为what()的虚拟成员函数，他返回一个字符串，该字符串的特征随实现而异。然而，由于这是一个虚方法，因此可以在从exception派生而来的类中重新定义它：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">bad_mean</span> : <span class="keyword">public</span> std::exception</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">what</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;bad arguments to hmean()&quot;</span>; &#125;</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">bad_gmean</span> : <span class="keyword">public</span> std::exception</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">what</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;bad arguments to gmean()&quot;</span>; &#125;</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果不想以不同的方式处理这些派生而来的一场，可以在同一个基类处理程序中捕获它们：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (std::rxception &amp;e)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面将介绍一些C++库基于exception定义的异常类型</p><ol><li><p>stdexcept 异常类</p><p>头文件 stdexcept定义了其他几个异常类。首先，该文件顶一个 logic_error 和 runtime_error 类，它们都是以公有方式从exception派生而来的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">logic_error</span> : <span class="keyword">public</span> exception</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">logic_error</span><span class="params">(<span class="type">const</span> string &amp;what_arg)</span></span>;</span><br><span class="line"><span class="comment">// something else</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">demain_error</span> : <span class="keyword">public</span> logic_error</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">domain_error</span><span class="params">(<span class="type">const</span> string &amp;what_arg)</span></span>;</span><br><span class="line"><span class="comment">// something else</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><p>这些类的构造函数接受一个string对象作为参数，该参数提供了方法what()以C_style字符串方式返回的字符串数据。</p><p>这两个类被用作两个派生类系列的基类。异常类系列logic_error描述了典型的逻辑错误。总体而言，通过合理的编程可以避免这种错误，但实际上这些错误还是可能发生的。每个类的名称指出了它用于报告的错误类型。</p><ul><li>domain_error;</li><li>invalid_argument;</li><li>length_error;</li><li>out_of_bounds.</li></ul><p>常见的有定义域异常、参数异常（invalid_argument）、越界异常（out_of_bounds）等。</p><p>至于runtime_error异常系列，它们描述了可能在运行期间发生但难以预计和防范的错误。每个类的名称也指出了它用于报告的错误类型。</p><ul><li><p>range_error;</p></li><li><p>overflow_error;</p></li><li><p>underflow_error;</p></li></ul><p>逻辑错误系列表明程序存在可以通过编程修复的问题，而运行时错误则表明程序存在无法避免的问题。所有这些错误类有相同的常规特征，它们之间的主要区别在于：不同的类名让程序员能够分别处理每种异常。另一方面，继承关系使程序员能够一起处理它们。利用继承关系安排catch块，捕获相应的异常。先越界类对象、再逻辑类对象、最后是exception类对象。</p><ol start="2"><li>bad_alloc 异常和 new</li></ol><p>对于使用new 导致的内存分配问题，C++的最新处理方式是让new 引发bad_alloc 异常头文件new 包含bad_alloc类的声明，它是从exception类共有派生而来的。但在以前，当无法分配请求的内存量时，new返回一个空指针（nullptr）。</p><p>   这程序没必要运行，负担较大。</p>   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// newexcp.cpp - the bad_alloc exception</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;new&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span>  <span class="comment">// for exit(),EXIT FALURE</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Bid</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> stuff[<span class="number">20000</span>];</span><br><span class="line">&#125; Big;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Big *pb;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Trying to get a big block of memory:\n&quot;</span>;    </span><br><span class="line">        pb = <span class="keyword">new</span> Big[<span class="number">10000</span>];   <span class="comment">//  1600,000,000 bytes</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Got past the new request:\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(bad_alloc &amp;ba)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Caught the exception!\n&quot;</span>;</span><br><span class="line">        cout &lt;&lt; ba.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Memory successfully allocated\n&quot;</span>;</span><br><span class="line">    pb[<span class="number">0</span>].stuff[<span class="number">0</span>] = <span class="number">4</span>;</span><br><span class="line">    cout &lt;&lt; pb[<span class="number">0</span>].stuff[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span>[] pb;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出现异常时，方法what() 返回字符串”std::bad_alloc” 。</p><ol start="3"><li>空指针和new</li></ol><p>很多代码都是在new在失败时返回空指针时编写的。为处理new的变化，有些编译器提供了一个标记（开关），让用户选择所需的行为。当前，在C++ 标准提供了一种在失败时返回空指针的new，其用法如下：</p>   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *pt = <span class="built_in">new</span> (std::nothrow) <span class="type">int</span>;</span><br><span class="line"><span class="type">int</span> *pa = <span class="built_in">new</span> (std::nothrow) <span class="type">int</span>[<span class="number">500</span>];</span><br></pre></td></tr></table></figure><p>使用这种new，可将上一个例子中的核心代码改为下面所示：</p>   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Bid *pb;</span><br><span class="line"></span><br><span class="line">pb = <span class="built_in">new</span> (std::nothrow) Big[<span class="number">10000</span>]; <span class="comment">// 1600,000,000 bytes</span></span><br><span class="line"><span class="keyword">if</span> (pb == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Could not allocate memory Bye:\n&quot;</span>;</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异常、类和继承"><a href="#异常、类和继承" class="headerlink" title="异常、类和继承"></a>异常、类和继承</h3><p>异常、类和继承以三种方式相关联。首先，可以向标准C++库所做的那样，从一个异常类派生出另一个；其次，可以在类定义中嵌套异常类声明来组合异常；第三，这种嵌套类声明本身可被继承，还可用作基类。</p><pre><code>下面这个头文件声明了一个Sales类，它用于存储一个年份以及一个包含12个月的销售数据的数组。LabeledSales类是从Sales派生而来的，新增了个用于存储数据标签的成员。</code></pre><p><code>Sales.h</code> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="comment">// sales.h - exceptions and inheritance</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sales</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> &#123; MONTHS = <span class="number">12</span> &#125;;   <span class="comment">// could be a static const, can be accessedby LabeledSales</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">bad_index</span> : <span class="keyword">public</span> std::logic_error   <span class="comment">// class LabeledSales can be used in catch block, and only can be used like Sales::bad_index, store and report of out-of-bounds value </span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> bi;  <span class="comment">// bad index value</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">bad_index</span><span class="params">(<span class="type">int</span> ix, <span class="type">const</span> std::string &amp;s = <span class="string">&quot;Index error in Sales object\n&quot;</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">bi_val</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> bi; &#125;</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">bad_index</span>() <span class="keyword">throw</span>() &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Sales</span><span class="params">(<span class="type">int</span> yy = <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="built_in">Sales</span>(<span class="type">int</span> yy, <span class="type">const</span> <span class="type">double</span> *gr, <span class="type">int</span> n);</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Sales</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">year_val</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> year; &#125;</span><br><span class="line">    <span class="keyword">virtual</span> <span class="type">double</span> <span class="keyword">operator</span>[](<span class="type">int</span> i) <span class="type">const</span>;</span><br><span class="line">    <span class="keyword">virtual</span> <span class="type">double</span>&amp; <span class="keyword">operator</span>[](<span class="type">int</span> i);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> gross[MONTHS];</span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LabeledSales</span> : <span class="keyword">public</span> Sales</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">nbad_index</span> : <span class="keyword">public</span> bad_index <span class="comment">// client can access using LabeledSales::nbad_index, inheritor of  bad_index and can store and report LabeledSales&#x27;label</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        std::string lbl;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">nbad_index</span>(<span class="type">const</span> std::string &amp;lb, <span class="type">int</span> ix, <span class="type">const</span> std::string &amp;s = <span class="string">&quot;Index error in LabedledSales object\n&quot;</span>);</span><br><span class="line">        <span class="function"><span class="type">const</span> std::string&amp; <span class="title">label_val</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> lbl; &#125;</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">nbad_index</span>() <span class="keyword">throw</span>() &#123;&#125;    <span class="comment">// similar to throws in java</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">LabeledSales</span><span class="params">(<span class="type">const</span> std::string &amp;lb = <span class="string">&quot;none&quot;</span>, <span class="type">int</span> yy = <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="built_in">LabeledSales</span>(<span class="type">const</span> std::string&amp; lb, <span class="type">int</span> yy, <span class="type">const</span> <span class="type">double</span> *gr, <span class="type">int</span> n);</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">LabeledSales</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> std::string&amp; <span class="title">Label</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> label; &#125;</span><br><span class="line">    <span class="keyword">virtual</span> <span class="type">double</span> <span class="keyword">operator</span>[] (<span class="type">int</span> i) <span class="type">const</span>;</span><br><span class="line">    <span class="keyword">virtual</span> <span class="type">double</span>&amp; <span class="keyword">operator</span>[] (<span class="type">int</span> i);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string label;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in C++98, constructor of exception class used throw(), but not in C++11 </span></span><br></pre></td></tr></table></figure><p>对于被嵌套类的方法，需要使用多个作用域解析符。另外，如果数组索引越界，重载[]运算符的函数将引发异常。</p><p><code>Sales.cpp</code> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sales.cpp - Sales implementation</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Sales.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"></span><br><span class="line">Sales::bad_index::<span class="built_in">bad_index</span>(<span class="type">int</span> ix, <span class="type">const</span> string &amp;s) : std::<span class="built_in">logic_error</span>(s), <span class="built_in">bi</span>(ix) &#123;&#125;</span><br><span class="line"></span><br><span class="line">Sales::<span class="built_in">Sales</span>(<span class="type">int</span> yy)</span><br><span class="line">&#123;</span><br><span class="line">    year = yy;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MONTHS; ++i)</span><br><span class="line">        gross[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Sales::<span class="built_in">Sales</span>(<span class="type">int</span> yy, <span class="type">const</span> <span class="type">double</span> *gr, <span class="type">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    year = yy;</span><br><span class="line">    <span class="type">int</span> lim = (n &lt; MONTHS)? n: MONTHS;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; lim; ++i)</span><br><span class="line">        gross[i] = gr[i];</span><br><span class="line">    <span class="comment">//  for i &gt; n and i &lt; MONTHS</span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; MONTHS; ++i)</span><br><span class="line">        gross[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> Sales::<span class="keyword">operator</span>[] (<span class="type">int</span> i) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= MONTHS)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">bad_index</span>(i);    </span><br><span class="line">    <span class="keyword">return</span> gross[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span>&amp; Sales::<span class="keyword">operator</span>[] (<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= MONTHS)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">bad_index</span>(i);    </span><br><span class="line">    <span class="keyword">return</span> gross[i];</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">LabeledSales::nbad_index::<span class="built_in">nbad_index</span>(<span class="type">const</span> string &amp;lb, <span class="type">int</span> ix, <span class="type">const</span> string &amp;s) :Sales::<span class="built_in">bad_index</span>(ix, s) </span><br><span class="line">&#123;</span><br><span class="line">    lbl = lb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LabeledSales::<span class="built_in">LabeledSales</span>(<span class="type">const</span> string &amp;lb, <span class="type">int</span> yy) : <span class="built_in">Sales</span>(yy)</span><br><span class="line">&#123;</span><br><span class="line">    label = lb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LabeledSales::<span class="built_in">LabeledSales</span>(<span class="type">const</span> string &amp;lb, <span class="type">int</span> yy, <span class="type">const</span> <span class="type">double</span> *gr, <span class="type">int</span> n) : <span class="built_in">Sales</span>(yy, gr, n)</span><br><span class="line">&#123;</span><br><span class="line">    label = lb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> LabeledSales::<span class="keyword">operator</span>[] (<span class="type">int</span> i) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= MONTHS)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">nbad_index</span>(<span class="built_in">Label</span>(), i);</span><br><span class="line">    <span class="keyword">return</span> Sales::<span class="keyword">operator</span>[](i);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">double</span>&amp; LabeledSales::<span class="keyword">operator</span>[](<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= MONTHS)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">nbad_index</span>(<span class="built_in">Label</span>(), i);</span><br><span class="line">    <span class="keyword">return</span> Sales::<span class="keyword">operator</span>[](i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>use_sales.cpp</code> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// use_sales.cpp - nested exceptions</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;07_sales.cpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::cin;</span><br><span class="line">    <span class="keyword">using</span> std::cout;</span><br><span class="line">    <span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> vals1[<span class="number">12</span>] = </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="number">1220</span>, <span class="number">1100</span>, <span class="number">1122</span>, <span class="number">2212</span>, <span class="number">1232</span>, <span class="number">2334</span>, </span><br><span class="line">        <span class="number">2884</span>, <span class="number">2393</span>, <span class="number">3302</span>, <span class="number">2922</span>, <span class="number">3002</span>, <span class="number">3544</span></span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="type">double</span> vals2[<span class="number">12</span>] = </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="number">12</span>, <span class="number">11</span>, <span class="number">22</span>, <span class="number">21</span>, <span class="number">32</span>, <span class="number">34</span>,</span><br><span class="line">        <span class="number">28</span>, <span class="number">29</span>, <span class="number">33</span>, <span class="number">29</span>, <span class="number">32</span>, <span class="number">35</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Sales sales1 &#123; <span class="number">2011</span>, vals1, <span class="number">12</span> &#125;;</span><br><span class="line">    LabeledSales sales2 &#123;<span class="string">&quot;Blogstar&quot;</span>, <span class="number">2012</span>, vals2, <span class="number">12</span> &#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;First try block:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> i ;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Year = &quot;</span> &lt;&lt; sales1.<span class="built_in">year_val</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">12</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; sales1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">6</span> == <span class="number">5</span>)</span><br><span class="line">                cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Year = &quot;</span> &lt;&lt; sales2.<span class="built_in">year_val</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Label = &quot;</span> &lt;&lt; sales2.<span class="built_in">year_val</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= <span class="number">12</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; sales2[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">6</span> == <span class="number">5</span>)</span><br><span class="line">                cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;End of try block 1.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (LabeledSales::nbad_index &amp;bad)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; bad.<span class="built_in">what</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Company: &quot;</span> &lt;&lt; bad.<span class="built_in">label_val</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;bad index: &quot;</span> &lt;&lt; bad.<span class="built_in">bi_val</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (Sales::bad_index &amp;bad)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; bad.<span class="built_in">what</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;bad index: &quot;</span> &lt;&lt; bad.<span class="built_in">bi_val</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\nNext try block:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        sales2[<span class="number">2</span>] = <span class="number">37.5</span>;</span><br><span class="line">        sales1[<span class="number">20</span>] = <span class="number">23345</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;End of try block 2.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (LabeledSales::nbad_index &amp;bad)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; bad.<span class="built_in">what</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Company: &quot;</span> &lt;&lt; bad.<span class="built_in">label_val</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;bad index: &quot;</span> &lt;&lt; bad.<span class="built_in">bi_val</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (Sales::bad_index &amp;bad)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; bad.<span class="built_in">what</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;bad index: &quot;</span> &lt;&lt; bad.<span class="built_in">bi_val</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Done&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面程序在使用Sales和LabeledSales类时，首先尝试超越LabeledSales对象中数组的末尾，然后试图超越Sales对象在sales1中数组的末尾。这些常识实在两个try块中进行的，让程序员能够检测每种异常。</p><h3 id="异常何时会迷失方向"><a href="#异常何时会迷失方向" class="headerlink" title="异常何时会迷失方向"></a>异常何时会迷失方向</h3><pre><code>异常引发后，在两种情况下会导致问题。</code></pre><blockquote><ul><li>异常在函数中引发，如果在继承层次结构中，catch块中的类类型与这个类及其派生类的对象不匹配，则将这种异常称为意外异常；</li><li>当异常不是在函数中引发的（或者函数没有异常规范），如果没有try块或者没有匹配的catch块则将这种异常称为未捕获异常。</li></ul><p>（这种区分方式非常抽象，难以理解）</p><p>C++11虽然摒弃了异常规范，但仍支持它，且现有代码使用了它。</p></blockquote><p>如果它是在带异常规范的函数中引发的，在默认情况下，它将导致程序异常终止，但是可以通过修改程序对意外异常和未捕获异常的反应。</p><ol><li>未捕获异常（没有设计捕获该种异常的catch块或者try块）</li></ol><p>未捕获异常不会导致程序立即异常终止。相反，程序将首先调用函数terminate()。 在默认情况下，terminate()调用abort()函数。可以指定terminate()应调用的函数（而不是abort()）来修改termonate()的这种行为。为此，可以调用set_terminate()函数。set_terminate()和terminate()都是在头文件exception中声明的：</p>   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*terminate_handler)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">terminate_handler <span class="title">set_terminate</span><span class="params">(terminate_handler f)</span> <span class="title">throw</span><span class="params">()</span></span>;<span class="comment">// C++98</span></span><br><span class="line"><span class="function">terminate_handler <span class="title">set_terminate</span><span class="params">(terminate_habdler f)</span> <span class="keyword">noexcept</span></span>;<span class="comment">// C++11</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">terminate</span><span class="params">()</span></span>;<span class="comment">// C++98</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">terminate</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;<span class="comment">// C++11</span></span><br></pre></td></tr></table></figure><p>其中的typedef使terminate_handler成为这样一种类型的名称：指向没有参数和返回值的函数的指针。set_terminate()函数将不带任何参数且返回类型为void的名曾（地址）作为参数，并返回该函数的地址。如果调用了set_terminate()函数多次，则terminate()将调用最后一次set_terminate()调用设置的函数。</p><p>   例：</p>   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myQuit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Terminating due to uncaught exception\n&quot;</span>;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">5</span>);<span class="comment">// 将退出状态值设置为5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在程序的开头，将终止操作指定为调用该函数。</p><p><code>set_terminate(myQuit)   // 这里是一个函数指针或者函数对象，并不是仿函数</code> </p><p>如果在这时出现了一个未捕获的异常，程序将调用terminate()，而后者将调用myQuit()。</p><ol><li>意外异常（有catch块，但是不能捕获该异常）</li></ol><p>通过给函数指定异常规范，可以让函数的用户知道要捕获哪些异常。假设函数的原型如下：</p><p>   <code>double Argh(double, double) throw(out_of_bounds);</code> </p><pre><code>   则可以这样使用函数：</code></pre>   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    x = <span class="built_in">Argh</span>(a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (out_of_bounds &amp;ex)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>知道应捕获哪些异常很有帮助，因为默认情况下，未捕获的一场将导致程序异常终止。</p><p>原则上，异常规范包括函数调用的其他函数引发的异常。例如，如果Argh()调用了其他函数，而在被Argh()调用的函数中引发了某对象异常 ，则这两个函数的异常规范中都应包含该对象。除非自己编写所有的函数，并且特别的仔细。否则无法保证上述工作都以正确完成。</p><p>在开发中使用的可能是老式商业库，而其中的函数没有异常规范。这表明应进一步探讨：如果函数引发了异常规范中没有的异常，情况将如何？这也表明异常规范机制处理起来比较麻烦，这也是C++11将其兵器的原因之一。</p><p>在这种情况下，行为与未捕获异常极其相似。如果遇到意外异常，程序将调用unexpected()函数（这是谁也想不到的函数）这个函数将调用terminate()，后者在默认情况下调用abort()。正如有一个可用于修改terminate()的行为的det_terminate()函数一样，也有一个可以用于修改unexpected()的行为的set_unexpected()函数。这些新函数也是在头文件exception中声明的：</p>   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*unexpected_handler)</span> <span class="params">()</span></span>;</span><br><span class="line"><span class="function">unexpected_handler <span class="title">set_unexpected</span><span class="params">(unexpected_handler f)</span> <span class="title">throw</span><span class="params">()</span></span>;<span class="comment">// C++98</span></span><br><span class="line"><span class="function">unexpected_handler <span class="title">set_unexpected</span><span class="params">(unexpected_handler f)</span> <span class="keyword">noexcept</span></span>;<span class="comment">// C++11</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unexpected</span><span class="params">()</span></span>;<span class="comment">// C++98</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unexpected</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;<span class="comment">// C++11</span></span><br></pre></td></tr></table></figure><p>然而，与提供给set_ter,imate()的函数的行为相比，提供给set_unexpected()的函数的行为受到了更严格的限制。即unexpected_handler函数可以：</p><ul><li><p>通过调用terminate()（默认行为）、abort()或exit()来终止程序；</p></li><li><p>引发异常</p></li></ul><p>引发异常（第二种选择）的结果取决于unexpected_handler函数所引发的异常以及引发意外异常的函数的异常规范：</p><ul><li><p>如果新引发的异常与原来的异常规范匹配，则程序将从哪里开始进行正常处理，即寻找与新引发的异常匹配的catch块。基本上，这种方法将用于预期的异常取代意外异常；</p></li><li><p>如果新引发的异常与原来的异常规范不匹配，且原来的异常规范中包含了std::bad_exception类型，则不匹配的异常将被std::bad_exception异常所取代。</p></li></ul><p>总之，如果要捕获所有的异常（不管是预期的异常还是意外异常），则可以这样做：</p><pre><code> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 设计一个替代函数，将意外异常转换为bad_exception异常，该函数的原型如下：</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myUnexpected</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">bad_exception</span>();<span class="comment">// or just throw</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 仅使用throw，而不指定异常将导致重新引发原来的异常。然而，如果异常规范中包含了这种类型，则该异常将被bad_exception对象所取代，因为std::exception是所有派生而来的异常类的基类。</span></span><br></pre></td></tr></table></figure></code></pre><p>再程序开始的位置，将意外异常操作指定为调用该函数：</p><pre><code>     `set_unexpected(myUnexpected());`             最后，将bad_exception类型包括在异常规范中，并添加如下catch块序列： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">Argh</span><span class="params">(<span class="type">double</span>, <span class="type">double</span>)</span> <span class="title">throw</span><span class="params">(out_of_bounds, bbad_exception)</span></span>;</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    x = <span class="built_in">Argh</span>(a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (out_of_bounds &amp;ex)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (bad_exception &amp;ex)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>如果要使用异常规范就是仿照上面的代码，在抛出异常时抛出基类std::exception类对象。</p><h3 id="有关异常的注意事项"><a href="#有关异常的注意事项" class="headerlink" title="有关异常的注意事项"></a>有关异常的注意事项</h3><p>从前面关于如何使用异常的讨论，应在设计程序时就加入异常处理功能而不是在以后再添加。这样做有一些缺点。例如，使用异常会增加程序的代码，降低程序的运行速度。异常规范不适用于模板，因为模板引发的异常可能随特定的具体化而异。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">string <span class="title">mesd</span><span class="params">(<span class="string">&quot;I&#x27; trapped in an endless loop&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">if</span> (oh_no)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">exception</span>();</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>string类采用动态内存分配。通常，当函数结束时，将为mesg调用string的析构函数。虽然throw语句过早地终止了函数，但它仍然使得析构函数被调用，这要归功于栈解退。因此在这里，内存被正确的管理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> *ar = <span class="keyword">new</span> <span class="type">double</span>[n];</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">if</span> (oh_no)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">exception</span>();</span><br><span class="line">   <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">delete</span>[] ar;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有个问题解退栈时，江山出战中变量ar。但函数过早的终止意味着函数末尾的delete[] 语句被忽略。指针消失了，但它指向的内村快并没有被释放，并且不可访问。总之，这个程序运行发生了内存泄漏。</p><p>这种内存泄漏是可以避免的。例如，可以在引发异常的函数中捕获该异常，在catch块中包含一些清理代码，然后重新引发异常。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test3</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> * ar = <span class="keyword">new</span> <span class="type">double</span>[];</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (oh_no)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">exception</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (exception &amp;ex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> [] ar;</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">delete</span> [] ar;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>除了这种折中的方法，最好是使用智能指针模板。虽然一场对于某些项目极为重要，但它也会增加编程的工作量、增大程序、降低程序的速度。另一方面，不进行错误检查的代价可能非常高。异常处理</code></pre><p>在现代库中，异常处理的复杂程度可能再创新高——主要原因在于文档没有对异常处理例程进行解释或解释的很蹩脚。任何熟练现代操作系统的人都遇到过未处理的异常导致的错误和问题。这些错误背后的程序员通常面临一场艰难的战役，需要不断了解库的复杂性，什么异常将被引发，他们发生的原因和时间，如何处理它们等等。</p><pre><code>程序员新手很快将发现，理解库中异常处理像学习语言本身一样困难，现代录中包含的历程和模式可能像C++语法细节一样陌生而困难。要开发出优秀的软件，必须花时间了解库和类中的复杂内容，就像必须花时间学习C++本身一样。通过库文档和源代码了解的异常和错误处理细节将使程序员和他们的软件受益。</code></pre><h2 id="RTTI"><a href="#RTTI" class="headerlink" title="RTTI"></a>RTTI</h2><p>RTTI是运行阶段类型识别（Runtime Type Identification）的简称。这是新添加到C++中的特性之一，很多老式实现不支持，另一些实现可能包含开关RTTI的编程设置。RTTI旨在为程序在运行阶段确定对象的类型提供一种标准方式。很多类库已经为其类对象实现这种功能的方式，但由于C++内部并不支持，因此各个厂商的机制互不兼容。创建一种RTTI语言标准将使得未来的库能够彼此兼容。</p><h3 id="RTTI的用途"><a href="#RTTI的用途" class="headerlink" title="RTTI的用途"></a>RTTI的用途</h3><ul><li>程序能够使用基类的指针或引用来检查着这些指针或引用所指的对象的实际派生类型。</li><li>RTTI这一机制的出现与C++语言本身有关系，和其他很多语言一样，C++是一种静态类型语言。其数据结构在编译期就确定了，在运行时不可更改。然而，由于面向对象中多态的要求，C++的指针或引用本身的类型可能与它实际代表的类型并不一致。有时我们需要将一个多态指针转换为其实际指向对象的类型，就需要知道运行时的类型信息，这就产生了运行时类型识别的要求。和Java相比，C++想要获得运行时类型信息，只能通过RTTI机制，并且C++最终生成的代码是直接与机器相关的。</li><li>需为何需要知道类型：<ol><li>可能希望调用类方法正确的版本；</li><li>被调函数是类层次结构中所有成员都拥有虚函数，则并不真正需要知道对象的类型。但派生类对象可能包含不是继承而来的方法；</li><li>只有某些类型的对象可以使用该方法，也可能是出于调试的目的，想追踪生成的对象的类型。</li></ol></li></ul><h3 id="RTTI的工作原理"><a href="#RTTI的工作原理" class="headerlink" title="RTTI的工作原理"></a>RTTI的工作原理</h3><ul><li><p>如果可能的话，dynamic_cast 运算符将使用一个指向基类的指针来生成一个指向派生类的最指针；否则，该运算符返回空指针</p></li><li><p>typeid运算符返回一个指出对象的类型的值</p></li><li><p>type_info结构存储了有关特定类型的信息</p></li></ul><p>只能将RTT i用于包含虚函数的类层次结构，原因在于只有对于这种类层次结果，才应该将派生对象的地址赋给基类指针。</p><p>警告：RTTI只适用于包含虚函数的类</p><ol><li>dynamic_cast 运算符</li></ol><p>dynamic_cast运算符是最常用的RTTI组件，它能够回答“是否可以安全地将对象的地址赋给特定的指针”这样的问题。假设有下面这样的类层次结构：</p>   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Grand</span> &#123; <span class="comment">// has virtual mothods &#125;;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Superb</span> : <span class="keyword">public</span> Grand &#123; <span class="comment">// do something &#125;;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Magnificent</span> : <span class="keyword">public</span> Superb &#123; <span class="comment">// do something &#125;;</span></span><br><span class="line"><span class="comment">// 接下来假设有以下指针：</span></span><br><span class="line">Grand *pg = <span class="keyword">new</span> Grand;</span><br><span class="line">Grand *ps = <span class="keyword">new</span> Superb;</span><br><span class="line">Grand *pm = <span class="keyword">new</span> Magnificent;</span><br><span class="line"><span class="comment">// 最后假设有以下类型转换：</span></span><br><span class="line">Magnificent *p1 = (Magnificent *) pm;<span class="comment">// #1</span></span><br><span class="line">Magnificent *p2 = (Magnificent *) pg;<span class="comment">// #2</span></span><br><span class="line">Super *p3 = (Magnificent *) pm;<span class="comment">// #3</span></span><br></pre></td></tr></table></figure><p>根据类声明，上述类型转换全都是安全的，但只有那些指针类型与对象类型（或对象的直接或间接基类的类型才一定是安全的。</p><blockquote><p>说明：<br>类型转换#1是安全的，他将Magnificent类型的指针转换成Magnificent类型的对象。类型转换#2是不安全的，下转型期望基类对象有派生类的特征，这通常是不可能的，Magnificent对象可能包含Grand对象没有的数据成员。#3这种类型转换也是安全的，因为它将派生类对象的地址赋给基类指针。即公有派生确保Magnificent对象同时也是一个Superb对象（直接积累）和一个Grand对象（间接基类）。因此，将Magnificent对象的地址赋给上述三种类型的指针都是安全的。虚函数确保了将这三种指针中的任何一种指向Magnificent对象时，都将调用Magnificent方法（多态的特性）。</p></blockquote><p>与问题“指针指向的是哪种类型的对象”相比，问题“类型转换是否安全”更为通用，也更有用。通常想知道类型的原因在于，知道类型后就知道调用特定方法是否安全。要调用方法，类型并不一定要完全匹配，而可以是定义了方法的虚拟版本的基类类型。且看下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先来了解一下dynamic_cast的语法，该运算符的用法如下，其中pg指向一个对象：</span></span><br><span class="line">Superb *pm = <span class="built_in">dynamic_cast</span>&lt;Superb *&gt;(pg);</span><br></pre></td></tr></table></figure><p>在这里提出了这样的问题：指针pg的类型是否可以被安全的转换为Superb* ？ 如果可以，运算符将返回对象的地址，否则将返回一个nullptr。</p><blockquote><p> 注意：通常，如果指向对象的（*pt）类型为 为Type或者是Type直接或间接派生而来的类型，则下面的表达式将指针pt转换为TYpe类型的指针：<code>dynamic_cast&lt;Type *&gt; (pt); </code> 否则将返回一个空指针</p></blockquote><p>RTTI.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RTTI.cpp - using the RTTI dynamic_cast operator</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Grand</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> hold;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Grand</span>(<span class="type">int</span> h = <span class="number">0</span>) : <span class="built_in">hold</span>(h) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Speak</span><span class="params">()</span> <span class="type">const</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;I am a grand class!\n&quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">Value</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> hold; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Superb</span> : <span class="keyword">public</span> Grand</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Superb</span>(<span class="type">int</span> h = <span class="number">0</span>) : <span class="built_in">Grand</span>(h) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Speak</span><span class="params">()</span> <span class="type">const</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;I am a superb class!\n&quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Say</span><span class="params">()</span> <span class="type">const</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;I hold the superb value of &quot;</span> &lt;&lt; <span class="built_in">Value</span>() &lt;&lt; <span class="string">&quot;!\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Magnificent</span> : <span class="keyword">public</span> Superb</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// call base constructor</span></span><br><span class="line">    <span class="built_in">Magnificent</span>(<span class="type">int</span> h = <span class="number">0</span>, <span class="type">char</span> c= <span class="string">&#x27;A&#x27;</span>) : <span class="built_in">Superb</span>(h), <span class="built_in">ch</span>(c) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Speak</span><span class="params">()</span> <span class="type">const</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Ian a magnificent class!\n&quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Say</span><span class="params">()</span> <span class="type">const</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;I hold the character &quot;</span> &lt;&lt; ch &lt;&lt; <span class="string">&quot; and the integer &quot;</span> &lt;&lt; <span class="built_in">Value</span>() &lt;&lt; <span class="string">&quot;!\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Grand * <span class="title">GetOne</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::<span class="built_in">srand</span>(std::<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">    Grand *pg;</span><br><span class="line">    Superb *ps;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pg = <span class="built_in">GetOne</span>();</span><br><span class="line">        pg-&gt;<span class="built_in">Speak</span>();</span><br><span class="line">        ps = <span class="built_in">dynamic_cast</span>&lt;Superb *&gt;(pg);</span><br><span class="line">        <span class="keyword">if</span> (ps)</span><br><span class="line">            ps-&gt;<span class="built_in">Say</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Grand* <span class="title">GetOne</span><span class="params">()</span> <span class="comment">// generate one of three kinds of objects randomly</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Grand *p;</span><br><span class="line">    <span class="keyword">switch</span> (std::<span class="built_in">rand</span>() % <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: p = <span class="keyword">new</span> <span class="built_in">Grand</span>(std::<span class="built_in">rand</span>() % <span class="number">100</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: p = <span class="keyword">new</span> <span class="built_in">Superb</span>(std::<span class="built_in">rand</span>() % <span class="number">100</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: p = <span class="keyword">new</span> <span class="built_in">Magnificent</span>(std::<span class="built_in">rand</span>() % <span class="number">100</span>, <span class="string">&#x27;A&#x27;</span> + std::<span class="built_in">rand</span>() % <span class="number">26</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>程序说明：<br>Grand定义了一个虚函数Speak()。而其它类都重写了这个虚函数。Superb类定义了一个虚函数Say()，而Magnificent也重新定义了它，程序定义了一个GetOne函数，该函数随机创建这三种类中某种类的对象，并对其进行初始化，然后将地址作为Grand* 指针返回（GetOne函数模拟用户做出决定）循环将该指针赋给Grand* 变量pg，让偶使用pg调用Speak()函数。因为这个函数是虚拟的，所以代码能够正确地调用指向的对象的Speak()版本。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">pg = <span class="built_in">GetOne</span>();</span><br><span class="line">pg-&gt;<span class="built_in">Speak</span>();</span><br><span class="line"><span class="comment">// do something else </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>然而，不能用相同的方式（即使用指向Grand的指针）来调用Say函数。但是却可以使用dynamic_cast运算符来检查是否可将pg的类型安全转换到Superb指针。如果可以对象的类型为Superb或者Magnificent，则可以安全转换。在这两种情况下，都可以安全的调用Say函数</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps = <span class="built_in">dynamic_cast</span>&lt;Superb *&gt;(pg);</span><br><span class="line">        <span class="keyword">if</span> (ps)</span><br><span class="line">            ps-&gt;<span class="built_in">Say</span>();</span><br></pre></td></tr></table></figure><ol start="2"><li>typeid运算符和type_info类<br> typeid运算符使得能够确定两个对象是否为同种类型。它与sizeof有些像，可以接受两种参数</li></ol><ul><li>类名</li><li>结果为对象的表达式<br>typeid运算符返回一个对type_info对象的引用，其中，type_info是在头文件typeinfo中定义的一个类。type_info类重载了<code>==</code>和<code>!=</code>运算符，以便可以使用这些运算符来对类型进行比较。<br>例：pg是一个指向Magnificent对象的指针，则下面的表达式的结果为bool值或者false。<br><code>typeid(Magnificent) == typeid(*pg);</code><br>如果pg是一个空指针，程序将引发bad_typeid异常。该异常是从exception类派生而来的，是在头文件typeinfo中声明的。<br>type_info类的实现随厂商而异，但包含一个name()成员，该函数返回一个随实现而异的字符串：通常是类的名称。例：<br><code>cout &lt;&lt; &quot;Now processing type&quot; &lt;&lt; typeid(*pg).name() &lt;&lt; &quot;.\n&quot;;</code><br>下面是用typeid运算符和name()成员函数。注意：它们都适用于dynamic_cast和virtual函数不能处理的情况。typeid测试用来选择一种操作，因为操作不是类的方法，所以不能通过类指针调用。name()方法语句演示了如何将方法用于调试。注意，程序包含了头文件typeinfo。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RTTI2.cpp - using dynamic_cast, typeid, and type_info</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Grand</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> hold;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Grand</span>(<span class="type">int</span> h = <span class="number">0</span>) : <span class="built_in">hold</span>(h) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Speak</span><span class="params">()</span> <span class="type">const</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;I am a grand class!\n&quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">Value</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> hold; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Superb</span> : <span class="keyword">public</span> Grand</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Superb</span>(<span class="type">int</span> h = <span class="number">0</span>) : <span class="built_in">Grand</span>(h) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Speak</span><span class="params">()</span> <span class="type">const</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;I am a superb class!\n&quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Say</span><span class="params">()</span> <span class="type">const</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;I hold the superb value of &quot;</span> &lt;&lt; <span class="built_in">Value</span>() &lt;&lt; <span class="string">&quot;!\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Magnificent</span> : <span class="keyword">public</span> Superb</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// call base constructor</span></span><br><span class="line">    <span class="built_in">Magnificent</span>(<span class="type">int</span> h = <span class="number">0</span>, <span class="type">char</span> c= <span class="string">&#x27;A&#x27;</span>) : <span class="built_in">Superb</span>(h), <span class="built_in">ch</span>(c) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Speak</span><span class="params">()</span> <span class="type">const</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;I am a magnificent class!\n&quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Say</span><span class="params">()</span> <span class="type">const</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;I hold the character &quot;</span> &lt;&lt; ch &lt;&lt; <span class="string">&quot; and the integer &quot;</span> &lt;&lt; <span class="built_in">Value</span>() &lt;&lt; <span class="string">&quot;!\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Grand * <span class="title">GetOne</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">    Grand *pg;</span><br><span class="line">    Superb *ps;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pg = <span class="built_in">GetOne</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Now processing type &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(*pg).<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot;.\n&quot;</span>;</span><br><span class="line">        pg-&gt;<span class="built_in">Speak</span>();</span><br><span class="line">        ps = <span class="built_in">dynamic_cast</span>&lt;Superb *&gt;(pg);</span><br><span class="line">        <span class="keyword">if</span> (ps)</span><br><span class="line">            ps-&gt;<span class="built_in">Say</span>();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">typeid</span>(Magnificent) == <span class="built_in">typeid</span>(*pg))</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Yes, you&#x27;re really magnificent.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Grand* <span class="title">GetOne</span><span class="params">()</span> <span class="comment">// generate one of three kinds of objects randomly</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Grand *p;</span><br><span class="line">    <span class="keyword">switch</span> (std::<span class="built_in">rand</span>() % <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: p = <span class="keyword">new</span> <span class="built_in">Grand</span>(std::<span class="built_in">rand</span>() % <span class="number">100</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: p = <span class="keyword">new</span> <span class="built_in">Superb</span>(std::<span class="built_in">rand</span>() % <span class="number">100</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: p = <span class="keyword">new</span> <span class="built_in">Magnificent</span>(std::<span class="built_in">rand</span>() % <span class="number">100</span>, <span class="string">&#x27;A&#x27;</span> + std::<span class="built_in">rand</span>() % <span class="number">26</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>与上一个例子大体相同，区别只在主函数中使用了typeid运算符以及其中的name()方法。</code></pre><ol start="3"><li>误用RTTI的例子<br> 应该避免的编程方式：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面是 RTTI.cpp 的核心代码</span></span><br><span class="line">Grand *pg;</span><br><span class="line">    Superb *ps;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pg = <span class="built_in">GetOne</span>();</span><br><span class="line">        pg-&gt;<span class="built_in">Speak</span>();</span><br><span class="line">        ps = <span class="built_in">dynamic_cast</span>&lt;Superb *&gt;(pg);</span><br><span class="line">        <span class="keyword">if</span> (ps)</span><br><span class="line">            ps-&gt;<span class="built_in">Say</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过放弃dynamic_cast和虚函数，而是用typeid运算符，可以将上述代码重新编写为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Grand *pg;</span><br><span class="line">Superb *ps;</span><br><span class="line">Magnificent *pm;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">pg = <span class="built_in">GetOne</span>();</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">typeid</span>(Magnificent) == <span class="built_in">typsid</span>(*pg))</span><br><span class="line">&#123;</span><br><span class="line">pm = (Magnificent *)pg;</span><br><span class="line">pm-&gt;<span class="built_in">Speak</span>();</span><br><span class="line">pm-&gt;<span class="built_in">Say</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">typeid</span>(Superb) == <span class="built_in">typeid</span>(*pg))</span><br><span class="line">&#123;</span><br><span class="line">ps = (Superb *)pg;</span><br><span class="line">ps-&gt;<span class="built_in">Speak</span>();</span><br><span class="line">ps-&gt;<span class="built_in">Say</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">pg-&gt;<span class="built_in">Speak</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码不仅比原来的更难看、更长，而且显式地指定各个类存在严重的缺陷。假设从Magnificent派生出另一个类，后者需要重新定义Speak()和Say()。使用typeid来显式地测试每个类型时，必须修改for循环的带啊吗，添加一个else-if语句，但无需修改原先的版本。下面语句适用于所有从Grand派生出来的类（就是说这种方式并不如使用dynamic_cast运算符判断是否能进行安全转换的方式来的快捷）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps = <span class="built_in">dynamic_cast</span>&lt;Superb *&gt;(pg);</span><br><span class="line">       <span class="keyword">if</span> (ps)</span><br><span class="line">           ps-&gt;<span class="built_in">Say</span>();</span><br></pre></td></tr></table></figure><p>如果发现在扩展的if-else语句系列中使用了typeid，则因考虑是否应该使用虚函数和dynamic_cast。</p><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>在C语言中，有如下例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">double</span> data[<span class="number">200</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Junk</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> junk[<span class="number">100</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Data d = &#123;<span class="number">2.5e33</span>, <span class="number">3.5e-19</span>, <span class="number">20.2e32</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *pch = (<span class="type">char</span> *)(&amp;d); <span class="comment">// type cast #1 - convert to string bingo</span></span><br><span class="line"><span class="type">char</span> ch = <span class="type">char</span>(&amp;d);       <span class="comment">// type cast #2 - convert address to a char error</span></span><br><span class="line">Junk *pj = (Junk *)(&amp;d);  <span class="comment">// type cast #3 - convert to Junk pointer </span></span><br></pre></td></tr></table></figure><p>上述转换在C语言中都是允许的，但是是否有意义，这是不好说的。</p><p>C++中使用了更为严格地限制允许转换的类型，提供了四个类型转换运算符。</p><ul><li>dynamic_cast;</li><li>const_cast;</li><li>static_cast;</li><li>reinterpret_cast.<br>可以根据目的选择一个合适的运算符，而不是使用通用的类型转换。这指出了进行类型转换的原因，并让编译器能够检查程序的行为是否与设计者想法相吻合</li><li>dynamic_cast<br>  当且仅当两个类之间存在继承关系(直接或者间接继承)时,才可以进行上转型(类似于多态,将派生类指针转换为基类指针)。成功返回基类指针，不成则返回空指针。</li><li>const_cast<br>  很类似于mutable，但是mutable的作用是修饰成员变量，使常成员函数能够修改该成员变量的值，或者作用于lambda表达式。这里简单提一下lambda表达式，会在下一篇详细总结。<br>  至于const_cast的作用，它是用于改变值为 const 或者 volatile，语法与dynamic_cast相同，如果类型的其他方面也被修改，则下面的类型转换将出错，复制运算符左边的类型需要与模板类型相匹配：<br>  <code>const_cast &lt;type_name&gt; (expression);</code><br>  有一个例子：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// constcast.cpp - using const_cast&lt;&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">const</span> <span class="type">int</span> *pt, <span class="type">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> pop1 = <span class="number">38383</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> pop2= <span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pop1, pop2; &quot;</span> &lt;&lt; pop1 &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; pop2 &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">change</span>(&amp;pop1, <span class="number">-103</span>);</span><br><span class="line">    <span class="built_in">change</span>(&amp;pop2, <span class="number">-103</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pop1, pop2: &quot;</span> &lt;&lt; pop1 &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; pop2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">const</span> <span class="type">int</span> *pt, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *pc;</span><br><span class="line"></span><br><span class="line">    pc = <span class="built_in">const_cast</span>&lt;<span class="type">int</span> *&gt; (pt);</span><br><span class="line">    *pc += n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，pop2的值始终不会被修改，这是因为const_cast只能修改传入时为const地参数的数据，但是不能改变声明为const的变量，尝试将参数中添加的const删除时，尝试传入const类型参数会报错。</p><ul><li>static_cast<br>语法与前面两个运算符相同：<br><code>static_cast &lt;type-name&gt; (expression);</code><br>仅当type-name是可被隐式转换成expression所属类型或者expression类型可被隐式转换为type-name类型数据时，上述转换才是合法的，否则将报错。<br>派生类到基类的类型转换自不必说，使用这种方式可以完成，但也可以不使用这种方法，但是在不显式指定类型转换的时候，下转型不能实现，但是使用static_cast可以在不显显式指定转换函数的情况下实现下转型。<br>也可以使用static_cast完成枚举类型到整型、整型到浮点型等数值转换。</li><li>reinterpret_cast<br>  reinterpret_cast属于天生危险的运算符。它不允许删除const，但会执行其他令人生厌的操作。又是程序员必须做一些依赖于实现的、令人生厌的操作，使用reinterpret_cast运算符可以简化这种行为的跟踪工作。该运算符的语法与其他的转换运算符并无差异。<br>  例：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">dat</span> &#123; <span class="type">short</span> a; <span class="type">short</span> b; &#125;;</span><br><span class="line"><span class="type">long</span> value = <span class="number">0xA224B118</span>;</span><br><span class="line">dat *pd = <span class="built_in">reinterpret_cast</span>&lt;dat *&gt; (&amp;value);</span><br><span class="line">cout &lt;&lt; hex &lt;&lt; pd-&gt;a;<span class="comment">// display first 2 bytes of value;</span></span><br></pre></td></tr></table></figure><p>通常，这样的转换适用于以来底层实现的编程技术，是不可移植的（不同系统在存储多字节整型时，可能以不同的顺序存储其中的字节）。<br>然而，reinterpret_cast运算符并不支持所有的类型转换。支持宽转换但不支持窄转换，也不能将函数指针转换成数据指针，反之亦然。</p><p>在C++中，普通类型转换也受到限制。基本上，可以执行其他类型转换可执行的操作，加上一些组合，但不能执行其他转换。因此，下面的转换在C语言中是允许的，但在C++中通常不允许，因为对于大多数C++实现，char类型都太小，不能存储指针（地址）：<br><code>char ch = char (&amp;d);// 指针的大小一般是4个字节</code><br>这些限制是合理的，如果不能接受这些限制就只能去写C语言的程序。</p><h1 id="提高篇"><a href="#提高篇" class="headerlink" title="提高篇"></a>提高篇</h1><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><h3 id="函数模板的语法"><a href="#函数模板的语法" class="headerlink" title="函数模板的语法"></a>函数模板的语法</h3><ol><li>C++的一项基础思想就是泛型编程，而模板就是泛型编程中使用的主要技术</li><li>C++的提供了两类模板：函数模板和类模板</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap01</span><span class="params">(T &amp;a, T &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">T temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap02</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">swap01</span>(a, b);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;第一次交换：&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt;  <span class="string">&quot; b = &quot;</span> &lt;&lt; b &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">swap02</span>(a, b);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;第二次交换：&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模板的作用是在写的时候不指定数据类型，在调用的时候由编译器或者操作系统推导数据是什么类型。</p><p>人是懒惰的，我们总是想要对类似的问题进行归纳总结，找出他们的共同点之后，使用同一个手段解决尽可能多的问题，我觉得这就是模板诞生的意义，也是泛型编程产生的初衷。</p><h3 id="函数模板的用法"><a href="#函数模板的用法" class="headerlink" title="函数模板的用法"></a>函数模板的用法</h3><p>因为在模板的使用中又用到了引用，所以需要回去看看引用的使用规范以及注意事项。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function">T <span class="title">Add</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line"><span class="type">char</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//正常的整型数据相加</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">Sum</span>(a, b) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//整型数据与字符型数据相加，隐式转换：字符型转整型，直接相加</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">Sum</span>(a, c) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//所以这里就实锤不能使用引用，自己确定数据的类型，显式指定类型发生隐式类型转换，使用模板</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">Add</span>&lt;<span class="type">int</span>&gt;(a, c) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数模板与普通函数的区别"><a href="#函数模板与普通函数的区别" class="headerlink" title="函数模板与普通函数的区别"></a>函数模板与普通函数的区别</h3><p><strong>普通函数与函数模板区别：</strong> </p><ul><li>普通函数调用时可以发生自动类型转换（隐式类型转换）</li><li>函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换</li><li>如果利用显示指定类型的方式，可以发生隐式类型转换</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyPrint</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;调用普通函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyPrint</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;函数模板重载普通函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyPrint</span><span class="params">(T a, T b, T c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;重载函数模板&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>, c = <span class="number">30</span>;</span><br><span class="line"><span class="type">char</span> ch =<span class="string">&#x27;a&#x27;</span>, op = <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//优先调用普通函数</span></span><br><span class="line"><span class="built_in">MyPrint</span>(a, b);</span><br><span class="line"></span><br><span class="line"><span class="comment">//告诉编译器或者操作系统：我就要调用模板</span></span><br><span class="line">MyPrint&lt;&gt;(a, b);</span><br><span class="line"></span><br><span class="line"><span class="comment">//模板也可以重载的</span></span><br><span class="line"><span class="built_in">MyPrint</span>(a, b, c);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果函数模板是更提供更好的选择，则调用模板</span></span><br><span class="line"><span class="built_in">MyPrint</span>(ch, op);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数模板的局限性"><a href="#函数模板的局限性" class="headerlink" title="函数模板的局限性"></a>函数模板的局限性</h3><ol><li>函数模板并不是万能的；</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="type">void</span> <span class="title">f</span><span class="params">(T a, T b)</span> </span>&#123; a = b; &#125;</span><br></pre></td></tr></table></figure><p>在上述代码中提供的赋值操作，如果传入的a和b是一个数组，就无法实现了</p><ol start="2"><li>对于函数模板，如果使用自定义数据类型进行运算还需要重载赋值运算符、关系运算符等；</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="type">void</span> <span class="title">f</span><span class="params">(T a, T b)</span> </span>&#123; <span class="keyword">if</span>(a &gt; b) &#123; <span class="keyword">do</span> something &#125; &#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，如果T的数据类型传入的是像Person这样的自定义数据类型，也无法正常运行</p><p>因此C++为了解决这种问题，提供模板的重载，可以为这些 <strong>特定的类型</strong> 提供<strong>具体化的模板</strong> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span> -&gt; m_Name = name;</span><br><span class="line"><span class="keyword">this</span> -&gt; m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string m_Name;</span><br><span class="line"><span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//常规函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MyCompare</span><span class="params">(T &amp;a, T &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a == b)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数模板具体化，显示具体化的原型和确定含义的template&lt;&gt;开头，并通过名称来指定类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="function"><span class="type">bool</span> <span class="title">MyCompare</span><span class="params">(Person &amp;p1, Person &amp;p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(p1.m_Age == p2.m_Age &amp;&amp; p1.m_Name == p2.m_Name)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>, b =<span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用内置数据类型直接调用通用的函数模板</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">MyCompare</span>(a, b))</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a == b&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a != b&quot;</span> &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">MyCompare</span>(p1, p2))</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1 == p2&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1 != p2&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><p>类模板作用：</p><ul><li>建立一个通用类，类中的成员 数据类型可以不具体制定，用一个虚拟的类型来代表。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="comment">//类定义</span></span><br><span class="line"><span class="comment">/*或者</span></span><br><span class="line"><span class="comment">template&lt;class T&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>解释：</strong> </p><ol><li>template — 声明创建模板</li><li>typename — 表面其后面的符号是一种数据类型，可以用class代替</li><li>T — 通用的数据类型，名称可以替换，通常为大写字母</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">NameType</span>, <span class="keyword">class</span> <span class="title class_">AgeType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(NameType name, AgeType age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span> -&gt; m_Name = name;</span><br><span class="line"><span class="keyword">this</span> -&gt; m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span> -&gt; m_Name &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; <span class="keyword">this</span> -&gt; m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NameType m_Name;</span><br><span class="line">AgeType m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//指定 NameType 为 string 类型，AgeType 为整型</span></span><br><span class="line">Person&lt;string, <span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;孙悟空&quot;</span>,<span class="number">999</span>);</span><br><span class="line">p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> 类模板和函数模板语法相似，在声明模板template后面加类，此类称为类模板</p><h3 id="类模板与函数模板的区别"><a href="#类模板与函数模板的区别" class="headerlink" title="类模板与函数模板的区别"></a>类模板与函数模板的区别</h3><p>类模板与函数模板区别主要有两点：</p><ol><li><p>类模板没有自动类型推导的使用方式</p></li><li><p>类模板在模板参数列表中可以有默认参数</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">NameType</span>, <span class="keyword">class</span> <span class="title class_">AgeType</span> = <span class="type">int</span>&gt;</span><br><span class="line"><span class="keyword">class</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(NameType name, AgeType age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span> -&gt; m_Name = name;</span><br><span class="line"><span class="keyword">this</span> -&gt; m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; m_Name &lt;&lt; <span class="string">&quot; Age: &quot;</span> &lt;&lt; m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NameType m_Name;</span><br><span class="line">AgeType m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、类模板没有自动推导</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//Person p(&quot;孙悟空&quot;, 999)//错误的原因是类模板没有推导，必须指定类型，目前应该是支持了</span></span><br><span class="line">Person &lt;string, <span class="type">int</span>&gt; <span class="built_in">p</span>(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">999</span>);</span><br><span class="line">p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、类模板在模板列表中可以有默认参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person &lt;string&gt; <span class="built_in">p</span>(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">888</span>);</span><br><span class="line"><span class="comment">//在定义模板的时候说明 AgeType 是整型</span></span><br><span class="line">p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> </p><ul><li>类模板使用只能用显示指定类型方式</li><li>类模板中的模板参数列表可以有默认参数</li></ul><h3 id="类模板中成员函数的被创建时间"><a href="#类模板中成员函数的被创建时间" class="headerlink" title="类模板中成员函数的被创建时间"></a>类模板中成员函数的被创建时间</h3><p><strong>类模板中成员函数和普通类中成员函数创建时机是有区别的：</strong> </p><ul><li>普通类中的成员函数一开始就可以创建</li><li>类模板中的成员函数在调用时才创建</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">cat</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showCat</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;this is a cat.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dog</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showDog</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;this is a dog.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">T obj;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">this</span> -&gt; obj.<span class="built_in">showCat</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">this</span> -&gt; obj.<span class="built_in">showDog</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Animal&lt;cat&gt; c;</span><br><span class="line">c.<span class="built_in">func1</span>();</span><br><span class="line"><span class="comment">//c.func2();//showDog()不是cat的成员。黑马说是因为在模板生成时没有立即生成成员函数，在调用的时候操作系统才会去创建。</span></span><br><span class="line"></span><br><span class="line">Animal&lt;dog&gt; d;</span><br><span class="line">d.<span class="built_in">func2</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>  类模板中的成员函数并不是一开始就创建的，在调用时才去创建</p><h3 id="类模板对象做函数参数"><a href="#类模板对象做函数参数" class="headerlink" title="类模板对象做函数参数"></a>类模板对象做函数参数</h3><p><strong>学习目标：</strong> </p><ul><li>类模板实例化出的对象，向函数传参的方式</li></ul><p>一共有三种传入方式：</p><ul><li>指定传入的类型 — 直接显示对象的数据类型</li><li>参数模板化 — 将对象中的参数变为模板进行传递</li><li>整个类模板化 — 将这个对象类型 模板化进行传递</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">NameType</span>, <span class="keyword">class</span> <span class="title class_">AgeType</span> = <span class="type">int</span>&gt;</span><br><span class="line"><span class="keyword">class</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(NameType name, AgeType age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span> -&gt; m_Name = name;</span><br><span class="line"><span class="keyword">this</span> -&gt; m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShowPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; <span class="keyword">this</span> -&gt; m_Name &lt;&lt; <span class="string">&quot; Age: &quot;</span> &lt;&lt; <span class="keyword">this</span> -&gt; m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NameType m_Name;</span><br><span class="line">AgeType m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、指定传入类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintPerson1</span><span class="params">(Person&lt;string, <span class="type">int</span>&gt; &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">p.<span class="built_in">ShowPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">999</span>)</span></span>;</span><br><span class="line"><span class="built_in">PrintPerson1</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、参数模板化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintPeron2</span><span class="params">(Person&lt;T1, T2&gt; &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">p.<span class="built_in">ShowPerson</span>();</span><br><span class="line"><span class="comment">//使用typeid(名).name()查看变量类型。</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;T1的类型为：&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T1).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;T2的类型为：&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T2).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">888</span>)</span></span>;</span><br><span class="line"><span class="built_in">PrintPeron2</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、模板化整个类</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintPerson3</span><span class="params">(T &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;T的类型为：&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(p).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">p.<span class="built_in">ShowPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;唐僧&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="built_in">PrintPerson3</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"><span class="built_in">test03</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> </p><ul><li>过类模板创建的对象，可以有三种方式向函数中进行传参</li><li>使用比较广泛是第一种：指定传入的类型</li></ul><h3 id="类模板与继承"><a href="#类模板与继承" class="headerlink" title="类模板与继承"></a>类模板与继承</h3><p>当类模板遇到继承时，需要注意：</p><ol><li>当子类继承的父类是一个模板时，子类在声明时需要指出父类中T的类型</li><li>如果不指定，操作系统无法给子类分配空间</li><li>如果想灵活指定父类的类型，子类也需要变成类模板</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">T m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//class inheritor : public Base  //C++编译器需要给子类分配空间，就必须知道父类中T的类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base&lt;<span class="type">int</span>&gt;<span class="comment">//必须指定类型，且指定的是模板基类中属性的类型</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Son</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类模板继承类模板，可以使用T2指定基类T的类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span> : <span class="keyword">public</span> Base&lt;T2&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Son2</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="built_in">typeid</span>(T1).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">typeid</span>(T2).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son2&lt;<span class="type">int</span>, <span class="type">char</span>&gt; child;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> 如果父类是类模板，子类需要指定出父类中T的数据类型</p><h3 id="类模板成员函数类外实现"><a href="#类模板成员函数类外实现" class="headerlink" title="类模板成员函数类外实现"></a>类模板成员函数类外实现</h3><p>成员函数在类外进行书写时：</p><ol><li>先写模板声明（template&lt; class T&gt;；</li><li>再写修饰函数的关键字和返回值类型；</li><li>紧随其后的是带有作用域的函数名以及参数列表。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//掌握类模板成员函数的类外实现</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类模板中成员函数类外书写</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数类内声明</span></span><br><span class="line"><span class="built_in">Person</span>(T1 name, T2 age);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShowPerson</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">T1 m_Name;</span><br><span class="line">T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数类外实现</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line">Person&lt;T1, T2&gt;::<span class="built_in">Person</span>(T1 name, T2 age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span> -&gt; m_Name = name;</span><br><span class="line"><span class="keyword">this</span> -&gt; m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数类外实现</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="comment">//返回值类型写在最前面，随后是作用域加上函数名</span></span><br><span class="line"><span class="type">void</span> Person&lt;T1, T2&gt;::<span class="built_in">ShowPerson</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; <span class="keyword">this</span> -&gt; m_Name &lt;&lt; <span class="string">&quot; Age: &quot;</span> &lt;&lt; <span class="keyword">this</span> -&gt; m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">p.<span class="built_in">ShowPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> 类模板中成员函数类外实现时，需要加上模板参数列表</p><h3 id="类模板分文件编写"><a href="#类模板分文件编写" class="headerlink" title="类模板分文件编写"></a>类模板分文件编写</h3><p><strong>学习目标:</strong> </p><ul><li>掌握类模板成员函数分文件编写产生的问题以及解决方式</li></ul><p><strong>问题:</strong> </p><ul><li>类模板中成员函数是在调用的时候才被创建，分文件编写会发生链接不到的情况</li></ul><p><strong>解决方式:</strong> </p><ul><li>直接包含.cpp源文件</li><li>将声明和实现写在同一个文件中，并更改后缀名为.hpp，这是约定的名称，并不是强制的</li></ul><p>解决方式一：</p><p>声明放进 .h 文件，实现放进 .cpp 文件之后，包含实现所在的 .cpp 文件即可</p><p>“.h”文件内容：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(T1 name, T2 age);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShowPerson</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">T1 m_Name;</span><br><span class="line">T2 m_Age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>“.cpp”文件内容：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//根据逻辑而言，写成员函数一定是指定类，所以包含头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Person.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数类外实现</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line">Person&lt;T1, T2&gt;::<span class="built_in">Person</span>(T1 name, T2 age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数类外实现</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="type">void</span> Person&lt;T1, T2&gt;::<span class="built_in">ShowPerson</span>()</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot; Age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方式二：</p><p>声明与实现写在同一个头文件里，后缀名改为 .hpp 约定俗成的类模板写法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(T1 name, T2 age);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShowPerson</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">T1 m_Name;</span><br><span class="line">T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数类外实现</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line">Person&lt;T1, T2&gt;::<span class="built_in">Person</span>(T1 name, T2 age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数类外实现</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="type">void</span> Person&lt;T1, T2&gt;::<span class="built_in">ShowPerson</span>()</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot; Age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>包含主函数的文件内容：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解决方法</span></span><br><span class="line"><span class="comment">// 1、声明放进 .h 文件，实现放进 .cpp 文件之后，包含 .cpp 文件即可</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Person.cpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、声明与实现写在同一个文件里，后缀名改为 .hpp 约定俗成的类模板写法</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Person.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;tom&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">p.<span class="built_in">ShowPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 主流办法是第二种，将声明和实现写到同一个头文件中，改后缀为.hpp，</p><p> 在boost库中使用最多的就是声明和实现写在一起并改文件后缀为“.hpp”。</p></blockquote><h3 id="类模板与友元"><a href="#类模板与友元" class="headerlink" title="类模板与友元"></a>类模板与友元</h3><p><strong>学习目标:</strong>  </p><ul><li>掌握类模板配合配合友元函数的类内和类外实现</li></ul><p><strong>主要内容：</strong> </p><ul><li>全局函数类内实现 —— 直接在函数内声明友元即可</li><li>全局函数类外实现 —— 需要提前让编译器知道全局函数存在</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数配合友元的类外实现需要先做函数声明</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt; <span class="keyword">class</span> <span class="title class_">Person</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果声明了函数模板，可以将实现写到后面，否则需要将实现体写到类的前面让编译器先看到</span></span><br><span class="line"><span class="comment">//template &lt;class T1, class T2&gt; void PrintPerson2(Person&lt;T1, T2&gt;&amp; p);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这里是将函数写到了类前面，所以不必提前说明</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintPerson2</span><span class="params">(Person&lt;T1, T2&gt;&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;类外实现 —— 姓名：&quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//1、全局函数配合友元——类内实现</span></span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">PrintPerson</span><span class="params">(Person&lt;T1, T2&gt;&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数配合友元——类外实现，需要提前声明</span></span><br><span class="line"><span class="keyword">friend</span> <span class="type">void</span> PrintPerson2&lt;&gt;(Person&lt;T1, T2&gt;&amp; p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Person</span>(T1 name, T2 age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T1 m_Name;</span><br><span class="line">T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、全局函数在类内实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="built_in">PrintPerson</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、全局函数在类外实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;Jerry&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="built_in">PrintPerson</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> 建议全局函数做类内实现，用法简单，而且编译器可以直接识别</p><h3 id="模板综合案例"><a href="#模板综合案例" class="headerlink" title="模板综合案例"></a>模板综合案例</h3><p>案例描述: 实现一个通用的数组类，要求如下：</p><ul><li>可以对内置数据类型以及自定义数据类型的数据进行存储</li><li>将数组中的数据存储到堆区</li><li>构造函数中可以传入数组的容量</li><li>提供对应的拷贝构造函数以及operator&#x3D;防止浅拷贝问题</li><li>提供尾插法和尾删法对数组中的数据进行增加和删除</li><li>可以通过下标的方式访问数组中的元素</li><li>可以获取数组中当前元素个数和数组的容量</li></ul><p>main.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyArray.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print_Int_Array</span><span class="params">(MyArray&lt;<span class="type">int</span>&gt; &amp;arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">Get_Cur</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//重载[]运算符的作用</span></span><br><span class="line">cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//则是内置数据类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">MyArray&lt;<span class="type">int</span>&gt; <span class="title">array1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt; <span class="number">5</span>)</span><br><span class="line">&#123;</span><br><span class="line">array1.<span class="built_in">Insert_tail</span>(i);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">array1.<span class="built_in">Insert</span>(<span class="number">1</span>, i);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;输出array1：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">Print_Int_Array</span>(array1);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;array1的最大容量：&quot;</span> &lt;&lt; array1.<span class="built_in">Get_MAX</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;array1的现有数据个数：&quot;</span> &lt;&lt; array1.<span class="built_in">Get_Cur</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;--------------------------------------------\t\t\t\t\t\n&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="function">MyArray&lt;<span class="type">int</span>&gt; <span class="title">array2</span><span class="params">(array1)</span></span>;</span><br><span class="line"><span class="comment">//删除第一个和最后一个之后还剩下8个元素</span></span><br><span class="line">array2.<span class="built_in">Delete</span>(<span class="number">0</span>);</span><br><span class="line">array2.<span class="built_in">Delete_tail</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;输出array2：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">Print_Int_Array</span>(array2);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;array2的最大容量：&quot;</span> &lt;&lt; array2.<span class="built_in">Get_MAX</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;array2的现有数据个数：&quot;</span> &lt;&lt; array2.<span class="built_in">Get_Cur</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;--------------------------------------------\t\t\t\t\t\n&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Person</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span> -&gt; m_Name = name;</span><br><span class="line"><span class="keyword">this</span> -&gt; m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string m_Name;</span><br><span class="line"><span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintPerson</span><span class="params">(MyArray&lt;Person&gt;&amp; pArr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; pArr.<span class="built_in">Get_Cur</span>(); i++)</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; pArr[i].m_Name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; pArr[i].m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试自定义数据类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建数组</span></span><br><span class="line"><span class="function">MyArray&lt;Person&gt; <span class="title">pArray</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;韩信&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;妲己&quot;</span>, <span class="number">18</span>)</span></span>; </span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;王昭君&quot;</span>, <span class="number">15</span>)</span></span>; </span><br><span class="line"><span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">24</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入数据</span></span><br><span class="line">pArray.<span class="built_in">Insert_tail</span>(p1);</span><br><span class="line">pArray.<span class="built_in">Insert_tail</span>(p2);</span><br><span class="line">pArray.<span class="built_in">Insert_tail</span>(p3);</span><br><span class="line">pArray.<span class="built_in">Insert_tail</span>(p4);</span><br><span class="line">pArray.<span class="built_in">Insert_tail</span>(p5);</span><br><span class="line"></span><br><span class="line"><span class="built_in">PrintPerson</span>(pArray);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;pArray的最大容量：&quot;</span> &lt;&lt; pArray.<span class="built_in">Get_MAX</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;pArray的现有数据个数:&quot;</span> &lt;&lt; pArray.<span class="built_in">Get_Cur</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MyArray.hpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyArray</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数，相当于顺序表初始化的操作</span></span><br><span class="line"><span class="built_in">MyArray</span>(<span class="type">int</span> num)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span> -&gt; MAXNUM = num;</span><br><span class="line"><span class="keyword">this</span> -&gt; CurNum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">this</span> -&gt; elem = <span class="keyword">new</span> T[<span class="keyword">this</span> -&gt; MAXNUM];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拷贝构造函数，使用const是为了防止在函数中对传入的数据进行误操作</span></span><br><span class="line"><span class="built_in">MyArray</span>(<span class="type">const</span> MyArray &amp; MyArray)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span> -&gt; MAXNUM = MyArray.MAXNUM;</span><br><span class="line"><span class="keyword">this</span> -&gt; CurNum = MyArray.CurNum;</span><br><span class="line"><span class="keyword">this</span> -&gt; elem = <span class="keyword">new</span> T[MyArray.MAXNUM];</span><br><span class="line"><span class="comment">//挨个复制</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MyArray.CurNum; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//如果T是对象，而且还包含指针，就必须重载 = 运算符，因为 = 不是构造而是赋值</span></span><br><span class="line"><span class="comment">//内置数据类型可以直接赋值，指针需要深拷贝</span></span><br><span class="line"><span class="keyword">this</span> -&gt; elem[i] = MyArray.elem[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载 = 运算符，防止浅拷贝</span></span><br><span class="line">MyArray&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyArray* MyArray)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span> -&gt; elem)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span>[] <span class="keyword">this</span> -&gt; elem;</span><br><span class="line"><span class="keyword">this</span> -&gt; MAXNUM = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">this</span> -&gt; CurNum = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span> -&gt; MAXNUM = MyArray -&gt; MAXNUM;</span><br><span class="line"><span class="keyword">this</span> -&gt; CurNum = MyArray -&gt; CurNum;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MyArray.CurNum; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;elem[i] = MyArray.elem[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载[]运算符，这样一步是蜜汁操作，提供访问elem域的接口</span></span><br><span class="line">T&amp; <span class="keyword">operator</span>[](<span class="type">int</span> index)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//说是不考虑越界，然用户自己处理异常，但是如果index是负数会比较麻烦</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span> -&gt; elem[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//任意位置插入</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">const</span> <span class="type">int</span> pos, <span class="type">const</span> T &amp;InsData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> -&gt; CurNum == <span class="keyword">this</span> -&gt; MAXNUM)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;空间不足，无法执行插入操作！&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pos &gt; <span class="keyword">this</span> -&gt; CurNum - <span class="number">1</span> || pos &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;插入位置不合法！&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="keyword">this</span> -&gt; CurNum; i &gt; pos; i--)</span><br><span class="line"><span class="keyword">this</span> -&gt; elem[i] = <span class="keyword">this</span> -&gt; elem[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">this</span> -&gt; elem[pos] = InsData;</span><br><span class="line"><span class="keyword">this</span> -&gt; CurNum++;</span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot; &quot; &lt;&lt; InsData &lt;&lt; &quot; 插入成功！&quot; &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾插</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert_tail</span><span class="params">(<span class="type">const</span> T &amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span> -&gt; CurNum == <span class="keyword">this</span> -&gt; MAXNUM)</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">this</span> -&gt; elem[<span class="keyword">this</span> -&gt; CurNum] = val;</span><br><span class="line"><span class="keyword">this</span> -&gt; CurNum++;</span><br><span class="line"><span class="comment">//当匹配到自定义数据类型时，&lt;&lt; 运算符无法输出 val，所以会报错</span></span><br><span class="line"><span class="comment">/*cout &lt;&lt; &quot; &quot; &lt;&lt; val &lt;&lt; &quot; 插入成功！&quot; &lt;&lt; endl;*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//任意位置删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = pos; i &lt; <span class="keyword">this</span> -&gt; CurNum - <span class="number">1</span>; i++)</span><br><span class="line"><span class="keyword">this</span> -&gt; elem[i] = <span class="keyword">this</span> -&gt; elem[i+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">this</span> -&gt; CurNum--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾删</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Delete_tail</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!<span class="keyword">this</span> -&gt; CurNum)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">this</span> -&gt; CurNum--;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//提供获取 private 权限属性的接口</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//最大容量</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Get_MAX</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span> -&gt; MAXNUM;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//当前数据个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Get_Cur</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span> -&gt; CurNum;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//析构函数</span></span><br><span class="line">~<span class="built_in">MyArray</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span>[] <span class="keyword">this</span> -&gt; elem;</span><br><span class="line"><span class="keyword">this</span> -&gt; elem = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">this</span> -&gt; MAXNUM = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">this</span> -&gt; CurNum = <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序表的结构，private权限类内可访问</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> MAXNUM;<span class="comment">//最大容量</span></span><br><span class="line"><span class="type">int</span> CurNum;<span class="comment">//现有元素数量</span></span><br><span class="line">T *elem;<span class="comment">//数据域</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>总结：能够利用所学知识点实现通用的数组</p><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p>智能指针是行为类似于指针的类对象，但这种对象还有其他功能。这一章主要想将智能指针梳理一遍。</p><h3 id="智能指针引入"><a href="#智能指针引入" class="headerlink" title="智能指针引入"></a>智能指针引入</h3><p>先来看一看指针的操作，示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">remodel</span><span class="params">(std::string &amp;str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string *ps = <span class="keyword">new</span> std::<span class="built_in">string</span>(str);</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    str = *ps;</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">// didn&#x27;t delete ps;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在每次调用上面的函数时，该函数都分配队中的内存，但从不回收，从而导致内存泄漏。解决办法是在return语句之前加上一句<code>delete ps;</code><br>然而，凡是涉及“别忘了”的解决办法，很少是最佳的。如果在函数中delete语句之前加上异常规范，在引发异常后，程序异常退出，栈解退会帮助清理栈上的内存，但是堆区的空间在函数结束之后不再可以访问，导致内存泄露。</p><p>这样，我们顺理成章地引出智能指针模板类。</p><ul><li>auto_ptr</li><li>unique_ptr</li><li>shared_ptr</li><li>weak_ptr</li></ul><p>auto_ptr、unique_ptr和shared_ptr都定义了类似指针的对象，可以将new获得（直接或间接）的地址赋给这种对象。当智能指针过期时，其析构函数将使用delete来释放内存。因此，如果将new返回的地址赋给这些对象，将无需记住稍后释放这些内存：在智能指针过期时，这些内存将自动释放（自动调用析构函数）。<br><img src="https://s2.loli.net/2023/03/25/g9TKF6aDUwfdMO7.png" alt="智能指针的行为"><br>上描述的是常规指针与智能指针行为上的差异。</p><p>要创建智能指针对象，必须包含头文件&lt; momory &gt;，该文件模板定义。然后通过常规的模板语法来实例化所需类型的指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">X</span>&gt; <span class="keyword">class</span> <span class="title class_">auto_ptr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">auto_ptr</span><span class="params">(X* p = <span class="number">0</span>)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// something else defined here</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>throw()意味着构造函数不会引发异常，与auto_ptr一样，throw()也被摒弃。因此，请求X类型的auto_ptr将获得一个指向X类型的auto_ptr：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">auto_pre&lt;<span class="type">double</span>&gt; <span class="title">pd</span><span class="params">(<span class="keyword">new</span> <span class="type">double</span>)</span></span>;    <span class="comment">// pd an auto_ptr to double (use in place of double *pd)</span></span><br><span class="line"><span class="function">auto_ptr&lt;string&gt; <span class="title">ps</span><span class="params">(<span class="keyword">new</span> string)</span></span>;    <span class="comment">// ps an auto_ptr to string (use in place of string *ps)</span></span><br></pre></td></tr></table></figure><p>new double 是new返回的指针，指向新分配的内存块。它是构造函数auto_ptr的参数，及对应模板形参中p的实参。其他两种智能指针的声明方式与之一致。<br>修改后的remodel()函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remodel</span><span class="params">(std::string &amp;str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::auto_ptr&lt;std::string&gt; <span class="title">ps</span> <span class="params">(<span class="keyword">new</span> std::string(str))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">weird_thing</span>())</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">exception</span>();</span><br><span class="line">    str = *ps;</span><br><span class="line">    <span class="comment">// delete ps; NO LONGER NEEDED</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到智能指针模板位于名称空间std中。下面的示例演示了如何使用这三种智能指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// smrtptrs.cpp - using three kinds of smart pointers</span></span><br><span class="line"><span class="comment">// requires support of C++11 shared_ptr and unique_ptr</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Report</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string str;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Report</span>(<span class="type">const</span> std::string s) : <span class="built_in">str</span>(s) &#123; std::cout &lt;&lt; <span class="string">&quot;Object create!\n&quot;</span>; &#125;</span><br><span class="line">    ~<span class="built_in">Report</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Object deleted!\n&quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">comment</span><span class="params">()</span> <span class="type">const</span> </span>&#123; std::cout &lt;&lt; str &lt;&lt; <span class="string">&quot;\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::auto_ptr&lt;Report&gt; <span class="title">ps</span> <span class="params">(<span class="keyword">new</span> Report(<span class="string">&quot;using auto_ptr&quot;</span>))</span></span>;</span><br><span class="line">        ps-&gt;<span class="built_in">comment</span>();<span class="comment">// using -&gt; to invoke a member function </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;Report&gt; <span class="title">ps</span> <span class="params">(<span class="keyword">new</span> Report(<span class="string">&quot;using shared_ptr&quot;</span>))</span></span>;</span><br><span class="line">    ps-&gt;<span class="built_in">comment</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="function">std::unique_ptr&lt;Report&gt; <span class="title">ps</span> <span class="params">(<span class="keyword">new</span> Report(<span class="string">&quot;using unique_ptr&quot;</span>))</span></span>;</span><br><span class="line">ps-&gt;<span class="built_in">comment</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在vs code 中std成员里没有auto_ptr，因为C++11将其删除了，在Dev C++中没有shared_ptr和unique_ptr以及weak_ptr，这是因为它的编译器很老，不支持C++11。<br>拼凑出来的结果如下</p><blockquote><p>Object create!<br>using auto_ptr<br>Object deleted!<br>Object create!<br>using shared_ptr<br>Object deleted!<br>Object create!<br>using unique_ptr<br>Object deleted!</p></blockquote><p>所有的智能化指针类都有一个explicit构造函数，该构造函数将指针作为参数，因此不需要自动将指针转换为智能指针对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;<span class="type">double</span>&gt; pd;</span><br><span class="line"><span class="type">double</span> *p_reg = <span class="keyword">new</span> <span class="type">double</span>;</span><br><span class="line">pd = p_reg; <span class="comment">// not allowed (implicit conversion)</span></span><br><span class="line">pd = <span class="built_in">shared_ptr</span>&lt;<span class="type">double</span>&gt; (p_reg);    <span class="comment">// allowed (explicit conversion)</span></span><br><span class="line">shared_ptr&lt;<span class="type">double</span>&gt; pshared = p_reg; <span class="comment">// not allowed (implicit conversion)</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">double</span>&gt; <span class="title">pshared</span><span class="params">(p_reg)</span></span>;  <span class="comment">// allowed (explicit conversion)</span></span><br></pre></td></tr></table></figure><p>智能指针很多方面都类似与常规指针，通过解引用访问成员、将之付给相同类型的常规指针。还可以将智能指针付给相同类型的智能指针对象（将引发问题）。<br><font size=3 color=red>注意</font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">vacation</span><span class="params">(<span class="string">&quot;I wondered lonely like a cloud.&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">shared_ptr&lt;string&gt; <span class="title">pvac</span><span class="params">(&amp;vacation)</span></span>; <span class="comment">// incorrect!</span></span><br></pre></td></tr></table></figure><p>当pvac过期时，delete将用于非堆区的内存，这是不正确的。</p><h3 id="有关智能指针的注意事项"><a href="#有关智能指针的注意事项" class="headerlink" title="有关智能指针的注意事项"></a>有关智能指针的注意事项</h3><p>在实践中发现，如果两个auto_ptr指向了同一块内存，在对象过期、函数结束或者程序结束时，会对同一块内存进行两两次delete操作，这是不能忍受的，这种情况与构造函数中使用了new，但是没有重载赋值运算符的情况极其相似。要避免这种问题，方法有多种：</p><ul><li>定义赋值运算符，使之执行深拷贝，还要避免自赋值（或者在重载赋值运算符的时候参数使用const修饰但是不使用引用）；</li><li>建立所有权，对于特定的对象，只能有一个智能指针可以拥有它，只有拥有对象的智能指针的析构函数会删除该对象，然后转让所有权，这是unique_ptr的策略，但是还要更严格；</li><li>创建只能更高的指针，跟踪引用特定对象的智能指针数，在shared_ptr中，这被称为引用计数，（reference counting），仅当最后一个指针过期时才调用delete。<br>  当然，同样的策略也适用于复制构造函数。</li></ul><h3 id="unique-ptr为何优于auto-ptr"><a href="#unique-ptr为何优于auto-ptr" class="headerlink" title="unique_ptr为何优于auto_ptr"></a>unique_ptr为何优于auto_ptr</h3><p>unique_ptr的拷贝构造函数以及unique_ptr同类型智能指针之间的相互赋值被禁用，但是可以作为函数的返回值，用于某个函数中返回动态申请内存的所有权。本质上是移动拷贝，就是使用std::move()，将对象的所有权转移。</p><p>对象所有权转移后，会留下悬挂指针，再尝试使用该悬挂指针会引发问题。</p><p>unique_ptr作为函数的返回值类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;string&gt; <span class="title">demo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;string&gt; <span class="title">temp</span><span class="params">(<span class="keyword">new</span> string(s))</span></span>;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// and other difinition here</span></span><br><span class="line">unique_ptr&lt;string&gt; ps = <span class="built_in">demo</span>(<span class="string">&quot;Uniquely special&quot;</span>);</span><br></pre></td></tr></table></figure><blockquote><p>解释：demo()返回了一个临时的unique_ptr，然后ps接管了原本归返回的unique_ptr的所有对象，而返回的unique_ptr将被销毁（函数中的temp）这没有问题，所有权正常转让，并且在函数结束后，temp不在能够被访问，所以也没有悬挂指针留下。<br>总之，程序将阻止一个unique_ptr赋给另一个时，如果源unique_ptr是个临时右值，编译器允许这样做；如果源unique_ptr将存在一段时间，编译器将禁止这样做。</p></blockquote><p>仅当以非智能指针方式使用遗弃的智能指针（如解除引用时），这种赋值方式才不安全。要安全地重用这种指针，可给它赋新值。C++的std::move()，让程序员能够将一个unique_ptr赋给另一个。下面有一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">unique_ptr&lt;string&gt; ps1, ps2;</span><br><span class="line">ps1 = <span class="built_in">demo</span>(<span class="string">&quot;uniquely special&quot;</span>);</span><br><span class="line">ps2 = <span class="built_in">demo</span>(<span class="string">&quot; and more&quot;</span>);</span><br><span class="line">cout &lt;&lt; *ps1 &lt;&lt; *ps2 &lt;&lt; endl;</span><br></pre></td></tr></table></figure><blockquote><p>使用move()转让所有权，然后赋新值。</p></blockquote><table><thead><tr><th>智能指针类型</th><th>new</th><th>new[]</th><th>其他</th></tr></thead><tbody><tr><td>auto_ptr</td><td>可</td><td>不可</td><td>不可</td></tr><tr><td>unique_ptr</td><td>可</td><td>可</td><td>不可</td></tr><tr><td>shared_ptr</td><td>可</td><td>不可</td><td>不可</td></tr></tbody></table><h3 id="选择智能指针"><a href="#选择智能指针" class="headerlink" title="选择智能指针"></a>选择智能指针</h3><ul><li>如果要使用多个指向同一个对象的指针则使用shared_ptr；</li><li>如果不需要使用多个指向同一对象的指针则使用unique_ptr（使用new分配内存并返回指向该内存的指针）；</li></ul><p>可以将unique_ptr存储到STL容器中，只要不调用将一个unique_ptr赋值或赋给另一个方法或者算法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">make_int</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">unique_ptr</span>&lt;<span class="type">int</span>&gt; (<span class="keyword">new</span> <span class="built_in">int</span>(n));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(unique_ptr&lt;<span class="type">int</span>&gt; &amp;pt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; *pt &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="type">int</span> size = <span class="number">5</span>;</span><br><span class="line">    vector&lt;unique_ptr&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">vp</span>(size);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vp.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        vp[i] = <span class="built_in">make_int</span>(<span class="built_in">rand</span>() % <span class="number">1000</span>);<span class="comment">// copy temporary unique_ptr</span></span><br><span class="line">    vp.<span class="built_in">push_back</span>(<span class="built_in">make_int</span>(<span class="built_in">rand</span>() % <span class="number">1000</span>));<span class="comment">// ok because arg is temporary</span></span><br><span class="line">    for_each(vp.<span class="built_in">begin</span>(), vp.<span class="built_in">end</span>(), show);<span class="comment">// use for_each()</span></span><br><span class="line">    <span class="comment">// do other things</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的push_back()调用没有问题，因为它返回一个临时的unique_ptr，该unique_ptr被赋给vp中的一个unique_ptr。另外，如果按值而不是按引用给show()传递对象，for_each()语句将非法，因为这将导致使用一个来自vp非临时unique_ptr初始化pi，而这是不允许的。编译器会发现并报告unique_ptr的错误使用。<br>在unique_ptr为右值时，可将其赋给shared_ptr，这与将一个unique_ptr赋给另一个需要满足的条件相同。与前面一样，在下面代码中，make_int()的返回类型是unique_ptr&lt; int &gt;:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">pup</span><span class="params">(make_int(rand() % <span class="number">100</span>))</span></span>; <span class="comment">// ok</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">spp</span><span class="params">(pup)</span></span>;   <span class="comment">// not allowed, pup an lvalue</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">spr</span><span class="params">(make_int(rand() % <span class="number">100</span>))</span></span>;    <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><p>模板shared_ptr包含一个显式构造函数，可用于将右值unique_ptr转换为shared_ptr。shared_ptr将接管原来归unique_ptr所有的对象。<br>在满足unique_ptr要求的条件时，也可以使用auto_tr，但unique_ptr是更好的选择（不用想了，auto_ptr已经被C++11删除了），或者可以考虑使用boost库中提供的scoped_ptr，其与unique_ptr类似。</p><p>博客auto_ptr与unique_ptr<br><a href="https://blog.csdn.net/weixin_40081916/article/details/79377564">https://blog.csdn.net/weixin_40081916/article/details/79377564</a></p><h2 id="STL初识"><a href="#STL初识" class="headerlink" title="STL初识"></a>STL初识</h2><h3 id="STL的诞生"><a href="#STL的诞生" class="headerlink" title="STL的诞生"></a>STL的诞生</h3><ul><li>长久以来，软件界一直希望建立一种可重复利用的东西</li><li>C++的面向对象和泛型编程思想，目的就是复用性的提升</li><li>大多情况下，数据结构和算法都未能有一套标准,导致被迫从事大量重复工作</li><li>为了建立数据结构和算法的一套标准,诞生了STL</li></ul><h3 id="STL基本概念"><a href="#STL基本概念" class="headerlink" title="STL基本概念"></a>STL基本概念</h3><ul><li>STL(Standard Template Library,标准模板库)</li><li>STL 从广义上分为: 容器(container) 算法(algorithm) 迭代器(iterator)</li><li>容器和算法之间通过迭代器进行无缝连接。</li><li>STL 几乎所有的代码都采用了模板类或者模板函数</li></ul><h3 id="STL六大组件"><a href="#STL六大组件" class="headerlink" title="STL六大组件"></a>STL六大组件</h3><p>STL大体分为六大组件，分别是:<strong>容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器</strong></p><ol><li>容器：各种数据结构，如vector、list、deque、set、map等,用来存放数据。</li><li>算法：各种常用的算法，如sort、find、copy、for_each等 </li><li>迭代器：扮演了容器与算法之间的胶合剂。</li><li>仿函数：行为类似函数，可作为算法的某种策略。</li><li>适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。</li><li>空间配置器：负责空间的配置与管理。</li></ol><h3 id="STL中容器、算法、迭代器"><a href="#STL中容器、算法、迭代器" class="headerlink" title="STL中容器、算法、迭代器"></a>STL中容器、算法、迭代器</h3><p><strong>容器：置物之所也</strong></p><p>STL<strong>容器</strong>就是将运用<strong>最广泛的一些数据结构</strong>实现出来</p><p>常用的数据结构：<strong>数组, 链表,树, 栈, 队列, 集合, 映射表 等</strong></p><p>这些容器分为<strong>序列式容器</strong>和<strong>关联式容器</strong>两种:</p><p><strong>序列式容器</strong>:强调值的排序，序列式容器中的每个元素均有固定的位置。 <strong>关联式容器</strong>:二叉树结构，各元素之间没有</p><p>严格的物理上的顺序关系</p><p><strong>算法：问题之解法也</strong></p><p>有限的步骤，解决逻辑或数学上的问题，这一门学科我们叫做算法(Algorithms)</p><p><strong>算法分为:质变算法和非质变算法。</strong></p><p>质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等</p><p>非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等</p><p>迭代器：容器和算法之间粘合剂</p><p>提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。</p><p>每个容器都有自己专属的迭代器</p><p>迭代器使用非常类似于指针，初学阶段我们可以先理解迭代器为指针</p><p>迭代器种类：</p><table><thead><tr><th>种类</th><th>功能</th><th>支持的运算</th></tr></thead><tbody><tr><td>输入迭代器</td><td>对数据的只读访问</td><td>只读，支持++、&#x3D;&#x3D;、!&#x3D;</td></tr><tr><td>输出迭代器</td><td>对数据的只写访问</td><td>只写，支持++</td></tr><tr><td>前向迭代器</td><td>读写操作，并能向前推进迭代器</td><td>读写，支持++、&#x3D;&#x3D;、!&#x3D;</td></tr><tr><td>双向迭代器</td><td>读写操作，并能向前或向后操作</td><td>读写，支持++、–</td></tr><tr><td>随机访问迭代器</td><td>读写操作，可以以跳跃的方式访问任意位置的数据，是功能最强的迭代器</td><td>读写，支持++， –， [n]、 -n、 &lt;、 &lt;&#x3D;、 &gt;、 &gt;&#x3D;</td></tr></tbody></table><p>常用的迭代器为双向迭代器和随机访问迭代器</p><p>迭代器性能</p><table><thead><tr><th align="center">迭代器功能</th><th align="center">随机</th><th align="center">输入</th><th align="center">输出</th><th align="center">正向</th><th align="center">双向</th></tr></thead><tbody><tr><td align="center">解除引用读取</td><td align="center">有</td><td align="center">有</td><td align="center">无</td><td align="center">有</td><td align="center">有</td></tr><tr><td align="center">解除引用写入</td><td align="center">有</td><td align="center">无</td><td align="center">有</td><td align="center">有</td><td align="center">有</td></tr><tr><td align="center">固定和可重复排序</td><td align="center">有</td><td align="center">无</td><td align="center">无</td><td align="center">有</td><td align="center">有</td></tr><tr><td align="center">++i  i++</td><td align="center">有</td><td align="center">有</td><td align="center">有</td><td align="center">有</td><td align="center">有</td></tr><tr><td align="center">–i  i–</td><td align="center">有</td><td align="center">无</td><td align="center">无</td><td align="center">无</td><td align="center">有</td></tr><tr><td align="center">i[n]</td><td align="center">有</td><td align="center">无</td><td align="center">无</td><td align="center">无</td><td align="center">无</td></tr><tr><td align="center">i + n</td><td align="center">有</td><td align="center">无</td><td align="center">无</td><td align="center">无</td><td align="center">无</td></tr><tr><td align="center">i - n</td><td align="center">有</td><td align="center">无</td><td align="center">无</td><td align="center">无</td><td align="center">无</td></tr><tr><td align="center">i +&#x3D; n</td><td align="center">有</td><td align="center">无</td><td align="center">无</td><td align="center">无</td><td align="center">无</td></tr><tr><td align="center">i -&#x3D; n</td><td align="center">有</td><td align="center">无</td><td align="center">无</td><td align="center">无</td><td align="center">无</td></tr></tbody></table><h3 id="容器算法迭代器初识"><a href="#容器算法迭代器初识" class="headerlink" title="容器算法迭代器初识"></a>容器算法迭代器初识</h3><p>了解STL中容器、算法、迭代器概念之后，我们利用代码感受STL的魅力</p><p>STL中最常用的容器为Vector，可以理解为数组，下面我们将学习如何向这个容器中插入数据、并遍历这个容器</p><h4 id="vector存放内置数据类型"><a href="#vector存放内置数据类型" class="headerlink" title="vector存放内置数据类型"></a>vector存放内置数据类型</h4><p>容器：vector</p><p>算法：for_each</p><p>迭代器：</p><p>$vector<int>::iterator$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyPrint</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建vector容器对象，并且通过模板参数指定存放的数据类型</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="comment">// 向容器中放数据</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每一个容器都有自己的迭代器，迭代器就是用来遍历容器中元素的工具</span></span><br><span class="line">    <span class="comment">//v.begin()返回迭代器，这个迭代器指向容器中第一个数据 </span></span><br><span class="line">    <span class="comment">//v.end()返回迭代器，这个迭代器指向容器元素的最后一个元素的下一个位置</span></span><br><span class="line">    <span class="comment">// vector&lt;int&gt;::iterator 拿到vector&lt;int&gt; 这种容器类型的迭代器类型</span></span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator pBegin = v.<span class="built_in">begin</span>();</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator pEnd = v.<span class="built_in">end</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一种遍历方式：</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第一种遍历方式：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">while</span>(pBegin != pEnd)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *pBegin &lt;&lt; endl;</span><br><span class="line">        pBegin++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二种遍历方式</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第二种遍历方式：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it &lt; v.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三种遍历方式</span></span><br><span class="line">    <span class="comment">// STL提供的标准遍历算法，包含于头文件 algorithm</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第三种遍历方式：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), MyPrint);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="vector存放用户自定义数据类型"><a href="#vector存放用户自定义数据类型" class="headerlink" title="vector存放用户自定义数据类型"></a>vector存放用户自定义数据类型</h4><p><strong>vector中存放自定义数据类型，并打印输出</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> string &amp;name, <span class="type">int</span> age) : <span class="built_in">Name</span>(name), <span class="built_in">Age</span>(age) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    string Name;</span><br><span class="line">    <span class="type">int</span> Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存放对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建数据</span></span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;eee&quot;</span>, <span class="number">50</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p4);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p5);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历</span></span><br><span class="line">    <span class="keyword">for</span>(vector&lt;Person&gt;::iterator it = v.<span class="built_in">begin</span>(); it &lt; v.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; (*it).Name &lt;&lt; <span class="string">&quot; Age: &quot;</span> &lt;&lt; (*it).Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存放对象指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;Person*&gt; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建数据</span></span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;eee&quot;</span>, <span class="number">50</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    v.<span class="built_in">push_back</span>(&amp;p1);</span><br><span class="line">    v.<span class="built_in">push_back</span>(&amp;p2);</span><br><span class="line">    v.<span class="built_in">push_back</span>(&amp;p3);</span><br><span class="line">    v.<span class="built_in">push_back</span>(&amp;p4);</span><br><span class="line">    v.<span class="built_in">push_back</span>(&amp;p5);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// it即为迭代器，相当于指针</span></span><br><span class="line">    <span class="keyword">for</span>(vector&lt;Person*&gt;::iterator it = v.<span class="built_in">begin</span>(); it &lt; v.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; (*it)-&gt;Name &lt;&lt; <span class="string">&quot; Age: &quot;</span> &lt;&lt; (*it)-&gt;Age &lt;&lt; endl;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// test01();</span></span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="vector嵌套vector"><a href="#vector嵌套vector" class="headerlink" title="vector嵌套vector"></a>vector嵌套vector</h4><p>容器中嵌套容器，我们将所有数据进行遍历输出</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 容器嵌套容器</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; v;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v3;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v4;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">            </span><br><span class="line">            v1.<span class="built_in">push_back</span>(i + <span class="number">1</span>); <span class="comment">// 1 2 3 4</span></span><br><span class="line">            v2.<span class="built_in">push_back</span>(i + <span class="number">2</span>); <span class="comment">// 2 3 4 5</span></span><br><span class="line">            v3.<span class="built_in">push_back</span>(i + <span class="number">3</span>); <span class="comment">// 3 4 5 6</span></span><br><span class="line">            v4.<span class="built_in">push_back</span>(i + <span class="number">4</span>); <span class="comment">// 4 5 6 7</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将容器元素插入到容器中</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(v1);</span><br><span class="line">    v.<span class="built_in">push_back</span>(v2);</span><br><span class="line">    v.<span class="built_in">push_back</span>(v3);</span><br><span class="line">    v.<span class="built_in">push_back</span>(v4);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;::iterator it = v.<span class="built_in">begin</span>(); it &lt; v.<span class="built_in">end</span>(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::iterator vit = (*it).<span class="built_in">begin</span>(); vit &lt; (*it).<span class="built_in">end</span>(); vit++)</span><br><span class="line">            cout &lt;&lt; *vit &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;            </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="STL-–-常用容器"><a href="#STL-–-常用容器" class="headerlink" title="STL – 常用容器"></a>STL – 常用容器</h2><p>在很多方面，使用string对象的方式与使用字符数组相同</p><ul><li>可以使用C-style 的字符串来初始化string对象</li><li>可以使用cin来将键盘输入存储到string对象中</li><li>可以使用cout来显示string对象</li><li>可以使用数组表示法来访问存储在string对象中的字符（提供了 operator[] 重载函数）</li></ul><p><strong>与字符数组之间的主要区别是：可以将string对象声明为简单变量，而不是数组</strong> </p><p>​string无法使用strlen、strcat、strcpy之类的函数，因为C对C++不兼容，string类本身提供了这些方法所以也不需要再回去使用C封装的函数。</p><p>​对于C-style的字符串，未经初始化时，’\0’出现在数组中的任何位置都不稀奇，所以执行strlen操作得到的数据也不尽相同，但是string不一样，未经初始化的string对象，长度为0。</p><p><strong>这里简单说一下C++11支持的字符串：</strong> </p><p>​除了char类型以外，C++还有类型wchar_t；而C++11新增了类型char16_t 和 char32_t 。可以创建这些类型的数组和这些类型的字符串字面值，C++分别使用前缀L、u和U表示，下面是一个如何使用这些前缀的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">wchar_t</span> title[] = <span class="string">L&quot;Chief Astrogator&quot;</span>;<span class="comment">// wchar_t string</span></span><br><span class="line"><span class="type">char16_t</span> name[] = <span class="string">u&quot;Felonia Ripova&quot;</span>;<span class="comment">// char6_t string</span></span><br><span class="line"><span class="type">char32_t</span> car[] = <span class="string">U&quot;Humber Super Snipe&quot;</span>;<span class="comment">// char32_t string</span></span><br></pre></td></tr></table></figure><p>​C++1还支持Unicode字符编码方案UTF-8。在这种方案中，根据编码的数字值，字符可能存储为1~4个八位组。C++使用前缀u8来表示这种类型的字符串字面值。</p><p>​C++11新增的ing一种类型是元三年hi（raw）字符串。在原始字符串中，字符表示的就是自己，例如，序列 \n 不表示换行符，而表示两个常规字符——斜杠和n，因此在屏幕上显示时，将显示这两个字符。另一个例子是，可在字符串中使用”，而无需再使用繁琐的 &quot;（转义字符）。当然，既然可以在字符串字面量中包含”，就不能再使用它来表示字符串的开头和结尾。因此，原始字符串将 “( 和 )” 用作界定符，并使用前缀R来表示原始字符串：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">R&quot;(Jim &quot;king&quot; Tutt uses &quot;\n&quot; instead of endl.)&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="comment">//上述代码将显示如下内容：</span></span><br><span class="line">Jim <span class="string">&quot;king&quot;</span> Tutt uses <span class="string">&quot;\n&quot;</span> instead of endl.</span><br></pre></td></tr></table></figure><p>​如果使用标准字符串字面值，将需编写如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;Jim \&quot;king\&quot; Tutt uses \&quot;\\n\&quot; instead of endl.&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure><p>​在上述代码中使用了 \ \ 来显示 \，因为单个 \ 表示转义序列的第一个字符。</p><p>​<strong>如何在原始字符串中包含 )”</strong> ，（编译器在见到第一个 )” 就会认为字符串到此结束），但是原始字符串语法允许在表示字符串开头的 “ 和 ( 之间添加其他字符，这意味着表示字符串结尾的 “ 和 ) 之间也必须包含这些字符。因此，使用 R”+( 表示原始字符串的开头时，必须使用 )+*” 标识原始字符串的结尾：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">R&quot;+*(&quot;(Who wouldn&#x27;t?)&quot;, she whispered.)+*&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 将显示以下内容：</span></span><br><span class="line"><span class="string">&quot;(Who wouldn&#x27;t?), she whispered.&quot;</span></span><br></pre></td></tr></table></figure><p>​总之，这使用”+* ( 和 )+ *” 替代了默认界定符 “( 和 )” 。自定义界定符时，在默认界定符之间添加任意数量的基本字符，但空格、左括号、右括号、斜杠和控制字符（如制表符和换行符）除外。</p><p>​可将前缀R与其它字符前缀组合使用，以标识wchar_t等类型的原始字符串。可将R放在前面，也可将其放在后面，如Ru、UR等。</p><h3 id="string容器"><a href="#string容器" class="headerlink" title="string容器"></a>string容器</h3><h4 id="string基本概念"><a href="#string基本概念" class="headerlink" title="string基本概念"></a>string基本概念</h4><p><strong>本质</strong>：</p><p>​string是C++风格的字符串，本质上是一个类</p><p>*<em>string和char <em>的区别</em></em></p><p>​char *定义的是指针</p><p>​string是一个类，实例化的是对象，string的类内封装了char *，管理这个字符串，是char *类型的容器</p><p><strong>特点</strong></p><p>​string类内封装了很多成员方法， 例如：查找find， 复制&#x2F;拷贝copy， 删除delete， 替换replace， 插入insert等</p><p>​string管理char *所分配的空间，不用担心赋值越界和取值越界等情况，由类内部负责处理。</p><h4 id="string构造函数"><a href="#string构造函数" class="headerlink" title="string构造函数"></a>string构造函数</h4><table><thead><tr><th align="left">构造函数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">string(char *s)</td><td align="left">将string初始化为s指向的NBTS</td></tr><tr><td align="left">string(size_type n, char c)</td><td align="left">创建一个包含n个元素的string对象，其中每个字符都初始化为字符c</td></tr><tr><td align="left">string(const string &amp;str)</td><td align="left">将一个string对象初始化为str（复制构造函数）</td></tr><tr><td align="left">string()</td><td align="left">创建一个string对象，长度为0（默认构造函数）</td></tr><tr><td align="left">string(const char *s, size_type n)</td><td align="left">将string对象初始化为s指向的NBTS的前n个字符，即使长度超过了NBTS结尾</td></tr><tr><td align="left">template&lt; class Iter &gt; string(Iter beg, Iter end)</td><td align="left">将string对象初始化为区间[begin, end)内的字符，其中begin和end的行为就像指针，用于指定位置，范围包括begin在内，但不包括end</td></tr><tr><td align="left">string(const string &amp;str, size_type pos &#x3D; 0, size_type n &#x3D; npos)</td><td align="left">将一个string对象初始化为对象str中从位置pos开始到结尾的字符，或从位置pos开始的n个字符</td></tr><tr><td align="left">string(string &amp;&amp;str) noexcept</td><td align="left">这是C++11新增的，它将一个string对象初始化为string对象str，并可能修改对象str（移动构造函数）</td></tr><tr><td align="left">string(initializer_lisr<char> il)</td><td align="left">这是C++11新增的，它将一个string对象初始化为初始化列表il中的字符</td></tr><tr><td align="left"></td><td align="left"></td></tr></tbody></table><p><strong>构造函数原型：</strong></p><ul><li>string(); &#x2F;&#x2F;创建一个空的字符串 例如: string str;</li><li>string(const char* s); &#x2F;&#x2F;使用字符串s初始化</li><li>string(const string&amp; str); &#x2F;&#x2F;使用一个string对象初始化另一个string对象</li><li>string(int n, char c); &#x2F;&#x2F;使用n个字符c初始化</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">string();   // 创建一个空的字符串</span></span><br><span class="line"><span class="comment">string(const char *s);   // 使用一个C-style的字符串初始化string</span></span><br><span class="line"><span class="comment">string(const string &amp;str);  // 使用一个string初始化string</span></span><br><span class="line"><span class="comment">string(int n, char c);  // 将string对象初始化为n个字符c</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// string构造</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str1;  <span class="comment">// 创建空串，调用无参构造</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *str = <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line">    <span class="function">string <span class="title">str2</span><span class="params">(str)</span></span>;   <span class="comment">// 将C-style字符串转换为string对象</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str2 = &quot;</span> &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">str3</span><span class="params">(str2)</span></span>;  <span class="comment">// 拷贝构造函数调用</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">str4</span><span class="params">(<span class="number">20</span>, <span class="string">&#x27;a&#x27;</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str4 = &quot;</span> &lt;&lt; str4 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="string赋值操作"><a href="#string赋值操作" class="headerlink" title="string赋值操作"></a>string赋值操作</h4><p><strong>功能：</strong></p><ul><li>给string字符串赋值</li></ul><p><strong>赋值的函数原型：</strong></p><p>运算符重载：</p><ul><li>string&amp; operator&#x3D;(const char *s);&#x2F;&#x2F; 将char＊类型的字符串赋给当前string对象</li><li>string&amp; operator&#x3D;(const string &amp;s);    &#x2F;&#x2F;  将string对象s赋值给当前string对象</li><li>string&amp; operator&#x3D;(char c);    &#x2F;&#x2F;将字符c赋值给当前string对象</li></ul><p>string类内方法：</p><ul><li>string&amp; assign(const char *s);    &#x2F;&#x2F; 将C-style字符串赋值给当前string对象</li><li>string&amp; assign(const char *s, int n);    &#x2F;&#x2F; 将字符串s的前n个字符赋值给当前string对象</li><li>string&amp; assign(const string &amp;s);    &#x2F;&#x2F; 将字符串对象s赋值给当前string对象</li><li>string&amp; assign(int n, char c);    &#x2F;&#x2F; 用n个字符c初始化当前string对象</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运算符重载：</span></span><br><span class="line"><span class="comment">- string&amp; operator=(const char *s);// 将char＊类型的字符串赋给当前string对象</span></span><br><span class="line"><span class="comment">- string&amp; operator=(const string &amp;s);    //  将string对象s赋值给当前string对象</span></span><br><span class="line"><span class="comment">- string&amp; operator=(char c);    //将字符c赋值给当前string对象</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">string提供的方法：</span></span><br><span class="line"><span class="comment">- string&amp; assign(const char *s);    // 将C-style字符串赋值给当前string对象</span></span><br><span class="line"><span class="comment">- string&amp; assign(const char *s, int n);    // 将字符串s的前n个字符赋值给当前string对象</span></span><br><span class="line"><span class="comment">- string&amp; assign(const string &amp;s);    // 将字符串对象s赋值给当前string对象</span></span><br><span class="line"><span class="comment">- string&amp; assign(int n, char c);    // 用n个字符c初始化当前string对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// string&amp; operator=(const char *s);</span></span><br><span class="line">    string str1;</span><br><span class="line">    str1 = <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// string&amp; operator=(const string &amp;s);</span></span><br><span class="line">    string str2 = str1; <span class="comment">// string str2; str2 = str1;</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str2 = &quot;</span> &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// string&amp; operator=(const char c);</span></span><br><span class="line">    string str3;</span><br><span class="line">    str3 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// string&amp; assign(const char *s);</span></span><br><span class="line">    string str4;</span><br><span class="line">    str4.<span class="built_in">assign</span>(<span class="string">&quot;Hello C++&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str4 = &quot;</span> &lt;&lt; str4 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// string&amp; assign(const char *s, int n);</span></span><br><span class="line">    string str5;</span><br><span class="line">    str5.<span class="built_in">assign</span>(<span class="string">&quot;Hello C++&quot;</span>, <span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str5 = &quot;</span> &lt;&lt; str5 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// string&amp; assign(const string &amp;s);</span></span><br><span class="line">    string str6;</span><br><span class="line">    str6.<span class="built_in">assign</span>(str5);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str6 = &quot;</span> &lt;&lt; str6 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// string&amp; assign(int n, char c);</span></span><br><span class="line">    string str7;</span><br><span class="line">    str7.<span class="built_in">assign</span>(<span class="number">5</span>, <span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str7 = &quot;</span> &lt;&lt; str7 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// string 类内提供的赋值方法有很多，但是直接使用 operator=() 的方式是最常用最实用的。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="string字符串拼接"><a href="#string字符串拼接" class="headerlink" title="string字符串拼接"></a>string字符串拼接</h4><p><strong>功能描述：</strong></p><ul><li>实现在字符串末尾拼接字符串</li></ul><p><strong>函数原型：</strong></p><p>运算符重载：</p><ul><li>string&amp; operator+&#x3D;(const char *str);    &#x2F;&#x2F; 重载 +&#x3D; 操作符</li><li>string&amp; operator+&#x3D;(const char c);    &#x2F;&#x2F; 重载 +&#x3D; 操作符</li><li>string&amp; operator+&#x3D;(const string &amp;str);    &#x2F;&#x2F; 重载 +&#x3D; 操作符</li></ul><p>string类内方法：</p><ul><li>string&amp; append(const char *s);    &#x2F;&#x2F; 将字符串s连接到当前string对象的末尾</li><li>string&amp; append(const char *s, int n);    &#x2F;&#x2F; 将字符串s的前n个字符连接到当前string对象的末尾</li><li>string&amp; append(const string &amp;s);    &#x2F;&#x2F; 与operator+(const string &amp;str);</li><li>string&amp; append(const string &amp;s, int pos, int n);    &#x2F;&#x2F; 从C-style字符串的pos位置开始的n个字符连接到当前string对象的末尾</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运算符重载：</span></span><br><span class="line"><span class="comment">- string&amp; operator+=(const char *str);    // 重载 += 操作符</span></span><br><span class="line"><span class="comment">- string&amp; operator+=(const char c);    // 重载 += 操作符</span></span><br><span class="line"><span class="comment">- string&amp; operator+=(const string &amp;str);    // 重载 += 操作符</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">string类内方法：</span></span><br><span class="line"><span class="comment">- string&amp; append(const char *s);    // 将字符串s连接到当前string对象的末尾</span></span><br><span class="line"><span class="comment">- string&amp; append(const char *s, int n);    // 将字符串s的前n个字符连接到当前string对象的末尾</span></span><br><span class="line"><span class="comment">- string&amp; append(const string &amp;s);    // 与operator+(const string &amp;str);</span></span><br><span class="line"><span class="comment">- string&amp; append(const string &amp;s, int pos, int n);    // 从C-style字符串的pos位置开始的n个字符连接到当前string对象的末尾</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 拼接</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// string&amp; operator=(const char *s);</span></span><br><span class="line">    <span class="comment">// string&amp; operator+=(const char *s);</span></span><br><span class="line">    string str1 = <span class="string">&quot;我&quot;</span>;</span><br><span class="line">    str1 += <span class="string">&quot;爱玩游戏&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// string&amp; operator+=(const char c)</span></span><br><span class="line">    str1 += <span class="string">&#x27;:&#x27;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// string&amp; operator+=(const string &amp;str);</span></span><br><span class="line">    string str2 = <span class="string">&quot;LOL DNF&quot;</span>;</span><br><span class="line">    str1 += str2;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    string str3 = <span class="string">&quot;I&quot;</span>;</span><br><span class="line">    str3.<span class="built_in">append</span>(<span class="string">&quot; Love &quot;</span>);</span><br><span class="line">    str3.<span class="built_in">append</span>(<span class="string">&quot;game abcde&quot;</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="comment">// str3.append(str2);   // 在str3之后追加str2</span></span><br><span class="line">    str3.<span class="built_in">append</span>(str2, <span class="number">4</span>, <span class="number">3</span>);    <span class="comment">// 从下标4位置开始，截取3个字符，拼接到字符串str3末尾</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="string查找和替换"><a href="#string查找和替换" class="headerlink" title="string查找和替换"></a>string查找和替换</h4><p>**功能描述： **</p><ul><li>查找： 查找指定字符串是否存在</li><li>替换： 在指定位置替换字符串</li></ul><p><strong>函数原型：</strong> </p><ul><li>int find(const string&amp; str, int pos &#x3D; 0) const; &#x2F;&#x2F;查找str第一次出现位置,从pos开始查找</li><li>int find(const char* s, int pos &#x3D; 0) const; &#x2F;&#x2F;查找s第一次出现位置,从pos开始查找</li><li>int find(const char* s, int pos, int n) const; &#x2F;&#x2F;从pos位置查找s的前n个字符第一次位置</li><li>int find(const char c, int pos &#x3D; 0) const; &#x2F;&#x2F;查找字符c第一次出现位置</li><li>int rfind(const string&amp; str, int pos &#x3D; npos) const; &#x2F;&#x2F;查找str最后一次位置,从pos开始查找</li><li>int rfind(const char* s, int pos &#x3D; npos) const; &#x2F;&#x2F;查找s最后一次出现位置,从pos开始查找</li><li>int rfind(const char* s, int pos, int n) const; &#x2F;&#x2F;从pos查找s的前n个字符最后一次位置</li><li>int rfind(const char c, int pos &#x3D; 0) const; &#x2F;&#x2F;查找字符c最后一次出现位置</li><li>string&amp; replace(int pos, int n, const string&amp; str); &#x2F;&#x2F;替换从pos开始n个字符为字符串str</li><li>string&amp; replace(int pos, int n,const char* s); &#x2F;&#x2F;替换从pos开始的n个字符为字符串s</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int find(const string&amp; str, int pos = 0) const; //查找str第一次出现位置,从pos开始查找</span></span><br><span class="line"><span class="comment">int find(const char* s, int pos = 0) const; //查找s第一次出现位置,从pos开始查找</span></span><br><span class="line"><span class="comment">int find(const char* s, int pos, int n) const; //从pos位置查找s的前n个字符第一次位置</span></span><br><span class="line"><span class="comment">int find(const char c, int pos = 0) const; //查找字符c第一次出现位置</span></span><br><span class="line"><span class="comment">int rfind(const string&amp; str, int pos = npos) const; //查找str最后一次位置,从pos开始查找</span></span><br><span class="line"><span class="comment">int rfind(const char* s, int pos = npos) const; //查找s最后一次出现位置,从pos开始查找</span></span><br><span class="line"><span class="comment">int rfind(const char* s, int pos, int n) const; //从pos查找s的前n个字符最后一次位置</span></span><br><span class="line"><span class="comment">int rfind(const char c, int pos = 0) const; //查找字符c最后一次出现位置</span></span><br><span class="line"><span class="comment">string&amp; replace(int pos, int n, const string&amp; str); //替换从pos开始n个字符为字符串str</span></span><br><span class="line"><span class="comment">string&amp; replace(int pos, int n,const char* s); //替换从pos开始的n个字符为字符串s</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找和替换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 查找</span></span><br><span class="line">    string str1 = <span class="string">&quot;abcdefgde&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pos = str1.<span class="built_in">find</span>(<span class="string">&quot;de&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pos == <span class="number">-1</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;未找到&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;pos = &quot;</span> &lt;&lt; pos &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    pos = str1.<span class="built_in">rfind</span>(<span class="string">&quot;de&quot;</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pos = &quot;</span> &lt;&lt; pos &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 替换</span></span><br><span class="line">    string str1 = <span class="string">&quot;abcdefgde&quot;</span>;</span><br><span class="line">    str1.<span class="built_in">replace</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="string">&quot;1111&quot;</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">find查找是从左往后，rfind从右往左</span></span><br><span class="line"><span class="comment">find找到字符串后返回查找的第一个字符位置，找不到返回-1</span></span><br><span class="line"><span class="comment">replace在替换时，要指定从哪个位置起，多少个字符，替换成什么样的字符串</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>find查找是从左往后，rfind从右往左</li><li>find找到字符串后返回查找的第一个字符位置，找不到返回-1</li><li>replace在替换时，要指定从哪个位置起，多少个字符，替换成什么样的字符串</li></ul><h4 id="string字符串比较"><a href="#string字符串比较" class="headerlink" title="string字符串比较"></a>string字符串比较</h4><p><strong>功能描述：</strong></p><ul><li>字符串之间的比较</li></ul><p><strong>比较方式：</strong></p><ul><li>比较字符串ASCII码</li></ul><blockquote><p>&gt; 返回 1， &#x3D; 返回 0，&lt; 返回 -1 </p></blockquote><p><strong>函数原型：</strong></p><ul><li>int compare(const string &amp;s) const; &#x2F;&#x2F;与字符串s比较</li><li>int compare(const char *s) const; &#x2F;&#x2F;与字符串s比较</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int compare(const string &amp;s) const; //与字符串s比较</span></span><br><span class="line"><span class="comment">int compare(const char *s) const; //与字符串s比较</span></span><br><span class="line"><span class="comment"> &gt; 返回 1， = 返回 0，&lt; 返回 -1 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    string str2 = <span class="string">&quot;Aello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = str1.<span class="built_in">compare</span>(str2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;str1 = str2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">1</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;str1 &gt; str2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;str1 &lt; str2&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：字符串对比主要是用于比较两个字符串是否相等，判断谁大谁小的意义并不是很大</p><h4 id="string字符存取"><a href="#string字符存取" class="headerlink" title="string字符存取"></a>string字符存取</h4><p>string中单个字符存取方式有两种</p><ul><li>char&amp; operator[](int n); &#x2F;&#x2F;通过[]方式取字符</li><li>char&amp; at(int n); &#x2F;&#x2F;通过at方法获取字符</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运算符重载：</span></span><br><span class="line"><span class="comment">char&amp; operator[](int n); //通过[]方式取字符</span></span><br><span class="line"><span class="comment">方法：</span></span><br><span class="line"><span class="comment">char&amp; at(int n); //通过at方法获取字符</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str = <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)</span><br><span class="line">        cout &lt;&lt; str[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)</span><br><span class="line">        cout &lt;&lt; str.<span class="built_in">at</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字符修改</span></span><br><span class="line">    str[<span class="number">0</span>] = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    str.<span class="built_in">at</span>(<span class="number">0</span>) = <span class="string">&#x27;H&#x27;</span>;</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：string字符串中单个字符存取有两种方式，利用 [ ] 或 at</p><h4 id="string插入和删除"><a href="#string插入和删除" class="headerlink" title="string插入和删除"></a>string插入和删除</h4><p><strong>功能描述：</strong></p><ul><li>对字符串进行字符的插入和删除操作</li></ul><p><strong>函数原型：</strong></p><ul><li>string&amp; insert(int pos, const char* s); &#x2F;&#x2F;插入字符串</li><li>string&amp; insert(int pos, const string&amp; str); &#x2F;&#x2F;插入字符串</li><li>string&amp; insert(int pos, int n, char c); &#x2F;&#x2F;在指定位置插入n个字符c </li><li>string&amp; erase(int pos, int n &#x3D; npos); &#x2F;&#x2F;删除从Pos开始的n个字符</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">string&amp; insert(int pos, const char* s); //插入字符串</span></span><br><span class="line"><span class="comment">string&amp; insert(int pos, const string&amp; str); //插入字符串</span></span><br><span class="line"><span class="comment">string&amp; insert(int pos, int n, char c); //在指定位置插入n个字符c </span></span><br><span class="line"><span class="comment">string&amp; erase(int pos, int n = npos); //删除从Pos开始的n个字符</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串插入和删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str = <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line">    str.<span class="built_in">insert</span>(<span class="number">1</span>, <span class="string">&quot;111&quot;</span>);</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    str.<span class="built_in">erase</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：插入和删除的起始下标都是从0开始</p><h4 id="string子串"><a href="#string子串" class="headerlink" title="string子串"></a>string子串</h4><p><strong>功能描述：</strong> </p><ul><li>从字符串中获取目标子串</li></ul><p><strong>函数原型：</strong></p><ul><li>string substr(int pos &#x3D; 0, int n &#x3D; npos) const; &#x2F;&#x2F;返回由pos开始的n个字符组成的字符串</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// string substr(int pos = 0, int n = npos) const; //返回由pos开始的n个字符组成的字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子串</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">    string substr = str.<span class="built_in">substr</span>(<span class="number">1</span>, <span class="number">3</span>);   <span class="comment">// bcd</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;substr = &quot;</span> &lt;&lt; substr &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    string email = <span class="string">&quot;hello@sina.com&quot;</span>;</span><br><span class="line">    <span class="type">int</span> pos = email.<span class="built_in">find</span>(<span class="string">&#x27;@&#x27;</span>);</span><br><span class="line">    string username = email.<span class="built_in">substr</span>(<span class="number">0</span>, pos);     <span class="comment">// hello </span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;username = &quot;</span> &lt;&lt; username &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结：灵活的运用求子串功能，可以在实际开发中获取有效的信息</p><p><img src="https://s2.loli.net/2023/03/25/raPLKIQUW3MEfqx.png" alt="string思维导图">  </p><h3 id="verctor容器"><a href="#verctor容器" class="headerlink" title="verctor容器"></a>verctor容器</h3><h4 id="vector基本概念"><a href="#vector基本概念" class="headerlink" title="vector基本概念"></a>vector基本概念</h4><p><strong>功能：</strong></p><ul><li>vector数据类型与<strong>数组</strong>非常<strong>相似</strong>，也被称为<strong>单端数组</strong></li></ul><p><strong>vector与普通数组的区别：</strong></p><ul><li>数组是静态空间，vector可以<strong>动态扩展</strong></li></ul><p><strong>动态扩展：</strong> </p><ul><li>并不是在原有空间的基础上续接新空间，而是寻找更大的空间，然后将数据拷贝到新空间中，释放原有空间</li></ul><p><img src="https://s2.loli.net/2023/03/25/chNIpJa7zAKlkML.png" alt="vector动态扩展"> </p><ul><li>vector容器的迭代器是支持随机访问的迭代器</li></ul><h4 id="4-2-2-vector构造函数"><a href="#4-2-2-vector构造函数" class="headerlink" title="4.2.2 vector构造函数"></a>4.2.2 vector构造函数</h4><p><strong>功能描述：</strong></p><ul><li>创建vector容器</li></ul><p><strong>函数原型：</strong></p><ul><li>vector<T> v; &#x2F;&#x2F;采用模板实现类实现，默认构造函数</li><li>vector(v.begin(), v.end()); &#x2F;&#x2F;将v[begin(), end())区间中的元素拷贝给本身。</li><li>vector(n, elem); &#x2F;&#x2F;构造函数将n个elem拷贝给本身。</li><li>vector(const vector &amp;vec); &#x2F;&#x2F;拷贝构造函数。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">vector&lt;T&gt; v; //采用模板实现类实现，默认构造函数</span></span><br><span class="line"><span class="comment">vector(v.begin(), v.end()); //将v[begin(), end())区间中的元素拷贝给本身。</span></span><br><span class="line"><span class="comment">vector(n, elem); //构造函数将n个elem拷贝给本身。</span></span><br><span class="line"><span class="comment">vector(const vector &amp;vec); //拷贝构造函数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建容器</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it &lt; v.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 无参构造</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="built_in">PrintVector</span>(v1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 区间拷贝</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v2</span><span class="params">(v1.begin(), v1.end())</span></span>;</span><br><span class="line">    <span class="built_in">PrintVector</span>(v2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单次多赋值</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">10</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="built_in">PrintVector</span>(v3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v4</span><span class="params">(v3)</span></span>;</span><br><span class="line">    <span class="built_in">PrintVector</span>(v4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**总结：**vector的多种构造方式没有可比性，灵活使用即可</p><h4 id="4-2-3-vector赋值操作"><a href="#4-2-3-vector赋值操作" class="headerlink" title="4.2.3 vector赋值操作"></a>4.2.3 vector赋值操作</h4><p><strong>功能描述：</strong></p><ul><li>给vector容器赋值</li></ul><p><strong>函数原型：</strong></p><ul><li>vector&amp; operator&#x3D;(const vector *vec);&#x2F;&#x2F; 重载赋值运算符</li><li>assign(vector.begin(), vector.end());    &#x2F;&#x2F; 将另一vector对象中[begin(), end())区间中的数据拷贝给当前对象</li><li>assign(n, elem);    &#x2F;&#x2F; 将n个elem值赋值给当前对象</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">vector&amp; operator=(const vector &amp;vec); //重载等号操作符</span></span><br><span class="line"><span class="comment">assign(beg, end); //将[beg, end)区间中的数据拷贝赋值给本身。</span></span><br><span class="line"><span class="comment">assign(n, elem); //将n个elem拷贝赋值给本身。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it &lt; v.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="built_in">PrintVector</span>(v1);</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">    v2 = v1;</span><br><span class="line">    <span class="built_in">PrintVector</span>(v2);</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v3;</span><br><span class="line">    v3.<span class="built_in">assign</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">PrintVector</span>(v3);</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v4;</span><br><span class="line">    v4.<span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="built_in">PrintVector</span>(v4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> vector赋值方式比较简单，使用operator&#x3D;，或者assign都可以</p><h4 id="4-2-4-vector容量和大小"><a href="#4-2-4-vector容量和大小" class="headerlink" title="4.2.4 vector容量和大小"></a>4.2.4 vector容量和大小</h4><p><strong>功能描述：</strong> </p><ul><li>对vector容器的容量和大小进行操作</li></ul><p><strong>函数原型：</strong> </p><ul><li>empty(); &#x2F;&#x2F;判断容器是否为空</li><li>capacity(); &#x2F;&#x2F;容器的容量</li><li>size(); &#x2F;&#x2F;返回容器中元素的个数</li><li>resize(int num); &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以默认值填充新位置。</li><li>&#x2F;&#x2F;如果容器变短，则末尾超出容器长度的元素被删除。</li><li>resize(int num, elem); &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以elem值填充新位置。</li><li>&#x2F;&#x2F;如果容器变短，则末尾超出容器长度的元素被删除</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">empty(); //判断容器是否为空</span></span><br><span class="line"><span class="comment">capacity(); //容器的容量</span></span><br><span class="line"><span class="comment">size(); //返回容器中元素的个数</span></span><br><span class="line"><span class="comment">resize(int num); //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。</span></span><br><span class="line"><span class="comment">//如果容器变短，则末尾超出容器长度的元素被删除。</span></span><br><span class="line"><span class="comment">resize(int num, elem); //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。</span></span><br><span class="line"><span class="comment">//如果容器变短，则末尾超出容器长度的元素被删除</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">    for_each(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), Print);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(v1.<span class="built_in">empty</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;v1为空。&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;v1不为空，&quot;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; v1的容量为： &quot;</span> &lt;&lt; v1.<span class="built_in">capacity</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; v1的大小为： &quot;</span> &lt;&lt; v1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// resize 重新指定大小， 若若指定的更大，则使用0填充新位置，可以使用重载版本替换默认填充</span></span><br><span class="line">    v1.<span class="built_in">resize</span>(<span class="number">15</span>, <span class="number">10</span>);</span><br><span class="line">    for_each(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), Print);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// resize 重新指定大小，若指定的更小，超出部分将被删除</span></span><br><span class="line">    v1.<span class="built_in">resize</span>(<span class="number">5</span>);</span><br><span class="line">    for_each(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(),Print); </span><br><span class="line">    cout &lt;&lt; endl;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li>判断是否为空 — empty </li><li>返回元素个数 — size </li><li>返回容器容量 — capacity </li><li>重新指定大小 — resize</li></ul><h4 id="4-2-5-vector插入和删除"><a href="#4-2-5-vector插入和删除" class="headerlink" title="4.2.5 vector插入和删除"></a>4.2.5 vector插入和删除</h4><p><strong>功能描述：</strong> </p><ul><li>对vector容器进行插入、删除操作</li></ul><p><strong>函数原型：</strong> </p><ul><li>push_back(elem); &#x2F;&#x2F;尾部插入元素elem</li><li>pop_back(); &#x2F;&#x2F;删除最后一个元素</li><li>insert(const_iterator pos, ele); &#x2F;&#x2F;迭代器指向位置pos插入元素ele</li><li>insert(const_iterator pos, int count,ele); &#x2F;&#x2F;迭代器指向位置pos插入count个元素ele</li><li>erase(const_iterator pos); &#x2F;&#x2F;删除迭代器指向的元素</li><li>erase(const_iterator start, const_iterator end); &#x2F;&#x2F;删除迭代器从start到end之间的元素</li><li>clear(); &#x2F;&#x2F;删除容器中所有元素</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">push_back(ele); //尾部插入元素ele</span></span><br><span class="line"><span class="comment">pop_back(); //删除最后一个元素</span></span><br><span class="line"><span class="comment">insert(const_iterator pos, ele); //迭代器指向位置pos插入元素ele</span></span><br><span class="line"><span class="comment">insert(const_iterator pos, int count,ele); //迭代器指向位置pos插入count个元素ele</span></span><br><span class="line"><span class="comment">erase(const_iterator pos); //删除迭代器指向的元素</span></span><br><span class="line"><span class="comment">erase(const_iterator start, const_iterator end); //删除迭代器从start到end之间的元素</span></span><br><span class="line"><span class="comment">clear(); //删除容器中所有元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="comment">// 尾插</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">    </span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), Print);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v是否为空：&quot;</span> &lt;&lt; v.<span class="built_in">empty</span>() &lt;&lt; <span class="string">&quot; v的大小： &quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尾删</span></span><br><span class="line">    v.<span class="built_in">pop_back</span>();</span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), Print);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v是否为空：&quot;</span> &lt;&lt; v.<span class="built_in">empty</span>() &lt;&lt; <span class="string">&quot; v的大小： &quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入</span></span><br><span class="line">    v.<span class="built_in">insert</span>(v.<span class="built_in">begin</span>(), <span class="number">100</span>);</span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), Print);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v是否为空：&quot;</span> &lt;&lt; v.<span class="built_in">empty</span>() &lt;&lt; <span class="string">&quot; v的大小： &quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    v.<span class="built_in">insert</span>(v.<span class="built_in">begin</span>(), <span class="number">2</span>, <span class="number">1000</span>);</span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), Print);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v是否为空：&quot;</span> &lt;&lt; v.<span class="built_in">empty</span>() &lt;&lt; <span class="string">&quot; v的大小： &quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除</span></span><br><span class="line">    v.<span class="built_in">erase</span>(v.<span class="built_in">begin</span>());</span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), Print);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v是否为空：&quot;</span> &lt;&lt; v.<span class="built_in">empty</span>() &lt;&lt; <span class="string">&quot; v的大小： &quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空</span></span><br><span class="line">    v.<span class="built_in">erase</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), Print);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v是否为空：&quot;</span> &lt;&lt; v.<span class="built_in">empty</span>() &lt;&lt; <span class="string">&quot; v的大小： &quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    v.<span class="built_in">clear</span>();</span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), Print);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v是否为空：&quot;</span> &lt;&lt; v.<span class="built_in">empty</span>() &lt;&lt; <span class="string">&quot; v的大小： &quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li>尾插 — push_back</li><li>尾删 — pop_back</li><li>插入 — insert (位置迭代器)</li><li>删除 — erase （位置迭代器）</li><li>清空 — clear</li></ul><h4 id="4-2-6-vector数据存取"><a href="#4-2-6-vector数据存取" class="headerlink" title="4.2.6 vector数据存取"></a>4.2.6 vector数据存取</h4><p><strong>功能描述：</strong></p><ul><li>对vector中的数据的存取操作</li></ul><p><strong>函数原型：</strong></p><ul><li>at(int index);&#x2F;&#x2F; 返回索引index所指的数据</li><li>operator[]    &#x2F;&#x2F; 返回索引index所指的数据</li><li>front();    &#x2F;&#x2F; 返回容器中第一个数据元素</li><li>back();    &#x2F;&#x2F; 返回容器中最后一个数据元素</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">at(int indx); // 返回索引index所指的数据</span></span><br><span class="line"><span class="comment">operator[]; // 返回索引index所指的数据</span></span><br><span class="line"><span class="comment">front(); // 返回容器中第一个数据元素</span></span><br><span class="line"><span class="comment">back(); // 返回容器中最后一个数据元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++)</span><br><span class="line">        v.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++)</span><br><span class="line">        cout &lt;&lt; v[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        cout &lt;&lt; v.<span class="built_in">at</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第一个元素：&quot;</span> &lt;&lt; v.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;最后一个元素：&quot;</span> &lt;&lt; v.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li>除了用迭代器获取vector容器中元素，[ ]和at也可以</li><li>front返回容器第一个元素</li><li>back返回容器最后一个元素</li></ul><h4 id="4-2-7-vector互换容器"><a href="#4-2-7-vector互换容器" class="headerlink" title="4.2.7 vector互换容器"></a>4.2.7 vector互换容器</h4><p><strong>功能描述：</strong> </p><ul><li>实现两个容器中全部元素互换</li></ul><p><strong>函数原型：</strong> </p><ul><li>swap(vec)    &#x2F;&#x2F; 将vec中数据与本身交换</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it &lt; v.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;交换前：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        v.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="built_in">PrintVector</span>(v);</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">10</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">        v2.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="built_in">PrintVector</span>(v2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 互换容器</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;互换后：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    v.<span class="built_in">swap</span>(v2);</span><br><span class="line">    <span class="built_in">PrintVector</span>(v);</span><br><span class="line">    <span class="built_in">PrintVector</span>(v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 巧用swap方法可以收缩内存空间</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i ++)</span><br><span class="line">        v.<span class="built_in">push_back</span>(i);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v的容量：&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v的大小：&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    v.<span class="built_in">resize</span>(<span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v的容量：&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v的大小：&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 收缩内存</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (v).<span class="built_in">swap</span>(v);  </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    vector&lt;int&gt; (v);  调用vector的拷贝构造函数，复制v创建匿名对象，匿名对象的容量和大小都跟v的大小一致；</span></span><br><span class="line"><span class="comment">    再做容器交换操作，匿名对象的空间和容量都给了v，v原有的空间和容量交给了匿名对象，而匿名对象将在此语句执行后之后被销毁。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v的容量：&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v的大小：&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// test01();</span></span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**总结：**swap可以使两个容器互换，可以达到实用的收缩内存效果</p><h4 id="4-2-8-预留空间"><a href="#4-2-8-预留空间" class="headerlink" title="4.2.8 预留空间"></a>4.2.8 预留空间</h4><p><strong>功能描述：</strong></p><ul><li>减少vector在所需空间很大时，动态扩展容量的次数</li></ul><p><strong>函数原型：</strong></p><ul><li>reserve(int len);    &#x2F;&#x2F; 容器预留len个元素长度，预留空间不初始化，不可访问</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数原型：</span></span><br><span class="line"><span class="comment">reserve(int len);   // 容器预留len个元素长度，预留位置空间不做初始化，不可访问</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reserved space</span></span><br><span class="line">    v.<span class="built_in">reserve</span>(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 一次性给预留空间赋值，使用num统计重新分配空间的次数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        v.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(p != &amp;v[<span class="number">0</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            p = &amp;v[<span class="number">0</span>];</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 如果预留空间则是1，如果没有预留空间则可能会重新分配多次。使用预留空间可以节约时间提高效率。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**总结：**如果数据量较大，可以一开始利用reserve预留空间</p><p><img src="https://s2.loli.net/2023/03/25/q1uzfw9noRrjkLv.png" alt="Vector思维导图">  </p><h4 id="4-2-9-模板类array"><a href="#4-2-9-模板类array" class="headerlink" title="4.2.9 模板类array"></a>4.2.9 模板类array</h4><p>​vector类的功能强大，但付出的代价是效率较低。如果需要的是长度固定的数组，使用数组是最佳的选，但代价是不那么方便和安全。有鉴于此，C++11新增了模板类array，让也位于名称空间std中。与数组一样，array对象的长度也是固定的，也使用栈（静态内存分配），而不是在自由存储区，因此其效率和数组一样，但更方便和安全。要创建array对象，需要包含头文件array。array对象的创建语法与vector稍有不同：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;array&gt;</span><br><span class="line">......</span><br><span class="line">using namespace std;</span><br><span class="line">array&lt;int, 5&gt; ai;// create array obj of 5 ints</span><br><span class="line">array&lt;double, 4&gt; ad = &#123; 1.2, 2.1, 3.43, 4.3 &#125;;</span><br><span class="line">// 推而广之，下面创建一个名为arr的array对象，它包含n_elem个类型为typename的元素：</span><br><span class="line">array&lt;typename, n_elem&gt; arr;</span><br></pre></td></tr></table></figure><p>​与创建vector对象不同的是，n_elem不能是变量。在C++11中，可以对vector和array对象使用初始化列表，在C++14中可以对vector使用初始化列表。</p><p>​无论是数组、vector对象还是array对象，都可以使用标准数组表示法来访问各个元素。其次，从地址可知，array对象和数组存储在相同的内存区域（即栈）中，而vector对象储存在另一个区域（自由存储区或堆）中。第三，注意到可以将一个array对象赋值给另一个array对象；而对于数组，必须逐元素复制数据。</p><p>​标准数组表示法访问数组是不安全的，使用了错误的下标值会导致程序错误中断，在vector对象中或者在array对象中使用成员函数at()可以作为另一种选择，起降在运行期间捕捉非法索引，而程序默认将中断。这种额外检查的代价是运行时间更长，这就是C++允许程序员使用任何一种表示法的原因所在。另外，这些类还能让程序员能够降低意外越界操作（包含begin()和end()，能够尽量避免越界。</p><h3 id="deque容器"><a href="#deque容器" class="headerlink" title="deque容器"></a>deque容器</h3><h4 id="deque基本概念"><a href="#deque基本概念" class="headerlink" title="deque基本概念"></a>deque基本概念</h4><p><strong>功能描述：</strong></p><ul><li>双端数组，可以对表头进行插入删除操作</li></ul><p><strong>deque和vector的区别：</strong> </p><ul><li>vector对头部的插入删除效率低，数据量越大，效率越低（时间复杂度为O(n)）</li><li>deque相对vector而言，对头部的插入删除速度更快</li><li>vector相较于deque访问元素的速度更快，这与两者的内部实现有关</li></ul><p><img src="https://s2.loli.net/2023/03/25/tR3cgkduYaj6zwA.png" alt="deque工作原理"></p><p><strong>deque内部工作原理：</strong> </p><ul><li>deque内部有个<strong>中控器</strong>，维护每段缓冲区中的内容，缓冲区中存放真实的数据，中控器维护的是每段缓冲区的地址，使deque在使用时就像一段连续的空间。</li></ul><p><img src="https://s2.loli.net/2023/03/25/lkRwuvCVMPz3nj5.png" alt="deque中控器"> </p><ul><li>deque容器的迭代器也是支持随机访问的</li></ul><h4 id="deque构造函数"><a href="#deque构造函数" class="headerlink" title="deque构造函数"></a>deque构造函数</h4><p><strong>功能描述：</strong></p><ul><li>deque容器构造</li></ul><p><strong>函数原型：</strong></p><ul><li>deque<T> deqT; &#x2F;&#x2F;默认构造形式</li><li>deque(beg, end); &#x2F;&#x2F;构造函数将[beg, end)区间中的元素拷贝给本身。</li><li>deque(n, elem); &#x2F;&#x2F;构造函数将n个elem拷贝给本身。</li><li>deque(const deque &amp;deq); &#x2F;&#x2F;拷贝构造函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用赋值运算符将现有deque容器赋值给目标deque</span></span><br><span class="line"><span class="comment">deque&lt;T&gt; deqT; //默认构造形式</span></span><br><span class="line"><span class="comment">deque(Deque_NAme.beg(), Deque_Nmae.end()); //构造函数将[beg, end)区间中的元素拷贝给本身。</span></span><br><span class="line"><span class="comment">deque(n, elem); //构造函数将n个elem拷贝给本身。</span></span><br><span class="line"><span class="comment">deque(const deque &amp;deq); //拷贝构造函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintDeque</span><span class="params">(<span class="type">const</span> deque&lt;<span class="type">int</span>&gt; d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(deque&lt;<span class="type">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it &lt; d.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// deque&lt;T&gt; Deque_Name; // 无参构造</span></span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; d1;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        d1.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">PrintDeque</span>(d1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// deque&lt;T&gt; Deque2_Name(Deque1_Name.begin(), Deque1_Name.end());    // 拷贝构造</span></span><br><span class="line">    <span class="function">deque&lt;<span class="type">int</span>&gt; <span class="title">d2</span><span class="params">(d1.begin(), d1.end())</span></span>;</span><br><span class="line">    <span class="built_in">PrintDeque</span>(d2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// deque&lt;T&gt; Deque2_Name(const deque&lt;T&gt; &amp;Deque1_Name);   // 拷贝构造</span></span><br><span class="line">    <span class="function">deque&lt;<span class="type">int</span>&gt; <span class="title">d3</span><span class="params">(d2)</span></span>;</span><br><span class="line">    <span class="built_in">PrintDeque</span>(d3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// deque(n, elem); //构造函数将n个elem拷贝给本身。</span></span><br><span class="line">    <span class="function">deque&lt;<span class="type">int</span>&gt; <span class="title">d4</span><span class="params">(<span class="number">10</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="built_in">PrintDeque</span>(d4);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// deque&lt;T&gt;&amp; operator=(const deque&lt;T&gt; &amp;Deque1_Name);    // 赋值运算符</span></span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; d5 = d4;</span><br><span class="line">    <span class="built_in">PrintDeque</span>(d5);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**总结：**deque容器和vector容器的构造方式几乎一致，灵活使用即可</p><h4 id="deque赋值操作"><a href="#deque赋值操作" class="headerlink" title="deque赋值操作"></a>deque赋值操作</h4><p><strong>功能描述：</strong></p><ul><li>给deque容器进行赋值</li></ul><p><strong>函数原型：</strong></p><ul><li>deque&amp; operator&#x3D;(const deque &amp;deq); &#x2F;&#x2F;重载等号操作符</li><li>assign(beg, end); &#x2F;&#x2F;将[beg, end)区间中的数据拷贝赋值给本身。</li><li>assign(n, elem); &#x2F;&#x2F;将n个elem拷贝赋值给本身。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运算符重载：</span></span><br><span class="line"><span class="comment">deque&lt;T&gt;&amp; operator=(const deque&lt;T&gt; &amp;deq);   // 重载赋值运算符</span></span><br><span class="line"><span class="comment">方法：</span></span><br><span class="line"><span class="comment">assign(deq.begin(), deq.end()); // 将deq[begin(), end())区间中的数据拷贝给当前对象</span></span><br><span class="line"><span class="comment">assign(n, val);    // 将deque中n个数赋值为val</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintDeque</span><span class="params">(<span class="type">const</span> deque&lt;<span class="type">int</span>&gt; &amp;d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(deque&lt;<span class="type">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it &lt; d.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; d1;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        d1.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="built_in">PrintDeque</span>(d1);</span><br><span class="line"></span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; d2 = d1;</span><br><span class="line">    <span class="built_in">PrintDeque</span>(d2);</span><br><span class="line"></span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; d3;</span><br><span class="line">    d3.<span class="built_in">assign</span>(d2.<span class="built_in">begin</span>(), d2.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">PrintDeque</span>(d3);</span><br><span class="line"></span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; d4;</span><br><span class="line">    d4.<span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="built_in">PrintDeque</span>(d4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**总结：**deque赋值操作也与vector相同，需熟练掌握</p><h4 id="deque大小操作"><a href="#deque大小操作" class="headerlink" title="deque大小操作"></a>deque大小操作</h4><p><strong>功能描述：</strong></p><ul><li>对deque容器的大小进行操作</li></ul><p><strong>函数原型：</strong></p><ul><li>deque.empty(); &#x2F;&#x2F;判断容器是否为空</li><li>deque.size(); &#x2F;&#x2F;返回容器中元素的个数</li><li>deque.resize(num); &#x2F;&#x2F;重新指定容器的长度为num,若容器变长，则以默认值填充新位置。</li><li>&#x2F;&#x2F;如果容器变短，则末尾超出容器长度的元素被删除。</li><li>deque.resize(num, elem); &#x2F;&#x2F;重新指定容器的长度为num,若容器变长，则以elem值填充新位置。</li><li>&#x2F;&#x2F;如果容器变短，则末尾超出容器长度的元素被删除。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">deque没有容量的概念，所以没有capacity()方法</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">deque.empty(); //判断容器是否为空//赋值操作 deque.size(); //返回容器中元素的个数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">deque.resize(num); //重新指定容器的长度为num,若容器变长，则以默认值填充新位置。</span></span><br><span class="line"><span class="comment">//如果容器变短，则末尾超出容器长度的元素被删除。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">deque.resize(num, elem); //重新指定容器的长度为num,若容器变长，则以elem值填充新位置。</span></span><br><span class="line"><span class="comment">//如果容器变短，则末尾超出容器长度的元素被删除。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintDeque</span><span class="params">(<span class="type">const</span> deque&lt;<span class="type">int</span>&gt; &amp;d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(deque&lt;<span class="type">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it &lt; d.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大小操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; d1;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        d1.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="built_in">PrintDeque</span>(d1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断deque容器是否为空，1是空，0是不为空</span></span><br><span class="line">    <span class="keyword">if</span>(!d1.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;容器不为空！&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 容器大小</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;容器大小为：&quot;</span> &lt;&lt; d1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;容器为空！&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新指定大小，大于原有空间的部分指定为val</span></span><br><span class="line">    d1.<span class="built_in">resize</span>(<span class="number">15</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">PrintDeque</span>(d1);</span><br><span class="line"></span><br><span class="line">    d1.<span class="built_in">resize</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">PrintDeque</span>(d1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li>deque没有容量的概念，没有 capacity() 方法</li><li>判断是否为空 — empty()</li><li>返回元素个数 — size()</li><li>重新指定个数 — resize()</li></ul><h4 id="deque插入和删除"><a href="#deque插入和删除" class="headerlink" title="deque插入和删除"></a>deque插入和删除</h4><p><strong>功能描述：</strong> </p><ul><li>向deque容器中插入和删除数据</li></ul><p><strong>函数原型：</strong></p><p>两端插入操作：</p><ul><li>push_back(elem); &#x2F;&#x2F;在容器尾部添加一个数据</li><li>push_front(elem); &#x2F;&#x2F;在容器头部插入一个数据</li><li>pop_back(); &#x2F;&#x2F;删除容器最后一个数据</li><li>pop_front(); &#x2F;&#x2F;删除容器第一个数据</li></ul><p>指定位置操作：</p><ul><li>insert(pos,elem); &#x2F;&#x2F;在pos位置插入一个elem元素的拷贝，返回新数据的位置。</li><li>insert(pos,n,elem); &#x2F;&#x2F;在pos位置插入n个elem数据，无返回值。</li><li>insert(pos,beg,end); &#x2F;&#x2F;在pos位置插入[beg,end)区间的数据，无返回值。</li><li>clear(); &#x2F;&#x2F;清空容器的所有数据</li><li>erase(beg,end); &#x2F;&#x2F;删除[beg,end)区间的数据，返回下一个数据的位置。</li><li>erase(pos); &#x2F;&#x2F;删除pos位置的数据，返回下一个数据的位置。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数原型：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">两端插入操作：</span></span><br><span class="line"><span class="comment">push_back(elem); //在容器尾部添加一个数据</span></span><br><span class="line"><span class="comment">push_front(elem); //在容器头部插入一个数据</span></span><br><span class="line"><span class="comment">pop_back(); //删除容器最后一个数据</span></span><br><span class="line"><span class="comment">pop_front(); //删除容器第一个数据</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">指定位置操作：</span></span><br><span class="line"><span class="comment">insert(pos,elem); //在pos位置插入一个elem元素的拷贝，返回新数据的位置。</span></span><br><span class="line"><span class="comment">insert(pos,n,elem); //在pos位置插入n个elem数据，无返回值。</span></span><br><span class="line"><span class="comment">insert(pos,beg,end); //在pos位置插入[beg,end)区间的数据，无返回值。</span></span><br><span class="line"><span class="comment">clear(); //清空容器的所有数据</span></span><br><span class="line"><span class="comment">erase(beg,end); //删除[beg,end)区间的数据，返回下一个数据的位置。</span></span><br><span class="line"><span class="comment">erase(pos); //删除pos位置的数据，返回下一个数据的位置。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintDeque</span><span class="params">(<span class="type">const</span> deque&lt;<span class="type">int</span>&gt; &amp;d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(deque&lt;<span class="type">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it &lt; d.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test01&quot;</span> &lt;&lt; endl;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; d1;</span><br><span class="line">    <span class="comment">// 尾插</span></span><br><span class="line">    d1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    d1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="comment">// 头插</span></span><br><span class="line">    d1.<span class="built_in">push_front</span>(<span class="number">30</span>);</span><br><span class="line">    d1.<span class="built_in">push_front</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PrintDeque</span>(d1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尾删</span></span><br><span class="line">    d1.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 头删</span></span><br><span class="line">    d1.<span class="built_in">pop_front</span>();</span><br><span class="line">    <span class="built_in">PrintDeque</span>(d1);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test02&quot;</span> &lt;&lt; endl;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; d2;</span><br><span class="line">    d2.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    d2.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    d2.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">    d2.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PrintDeque</span>(d2);</span><br><span class="line"></span><br><span class="line">    d2.<span class="built_in">erase</span>(d2.<span class="built_in">begin</span>(), d2.<span class="built_in">end</span>());</span><br><span class="line">    d2.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">PrintDeque</span>(d2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test03&quot;</span> &lt;&lt; endl;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; d3;</span><br><span class="line">    d3.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    d3.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    d3.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">    d3.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PrintDeque</span>(d3);</span><br><span class="line"></span><br><span class="line">    d3.<span class="built_in">erase</span>(d3.<span class="built_in">begin</span>());</span><br><span class="line">    <span class="built_in">PrintDeque</span>(d3);</span><br><span class="line"></span><br><span class="line">    d3.<span class="built_in">erase</span>(d3.<span class="built_in">begin</span>(), d3.<span class="built_in">end</span>());</span><br><span class="line">    d3.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">PrintDeque</span>(d3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="built_in">test03</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li>插入和删除提供的位置是迭代器！</li><li>尾插 — push_back</li><li>尾删 — pop_back</li><li>头插 — push_front</li><li>头删 — pop_front</li></ul><h4 id="deque数据存取"><a href="#deque数据存取" class="headerlink" title="deque数据存取"></a>deque数据存取</h4><p><strong>功能描述：</strong></p><ul><li>对deque 中的数据的存取操作</li></ul><p><strong>函数原型：</strong></p><ul><li>at(int idx); &#x2F;&#x2F;返回索引idx所指的数据</li><li>operator[ ]; &#x2F;&#x2F;返回索引idx所指的数据</li><li>front(); &#x2F;&#x2F;返回容器中第一个数据元素</li><li>back(); &#x2F;&#x2F;返回容器中最后一个数据元素</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">at(int idx); //返回索引idx所指的数据</span></span><br><span class="line"><span class="comment">operator[]; //返回索引idx所指的数据</span></span><br><span class="line"><span class="comment">front(); //返回容器中第一个数据元素</span></span><br><span class="line"><span class="comment">back(); //返回容器中最后一个数据元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintDeque</span><span class="params">(<span class="type">const</span> deque&lt;<span class="type">int</span>&gt; &amp;d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(deque&lt;<span class="type">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it &lt; d.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; *it&lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据存取</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">    d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">    d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PrintDeque</span>(d);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; d.<span class="built_in">size</span>(); i++)</span><br><span class="line">        cout &lt;&lt; d[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; d.<span class="built_in">size</span>(); i++)</span><br><span class="line">        cout &lt;&lt; d.<span class="built_in">at</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;front: &quot;</span> &lt;&lt; d.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;back: &quot;</span> &lt;&lt; d.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li>除了用迭代器获取deque容器中元素，[ ]和at也可以</li><li>front返回容器第一个元素</li><li>back返回容器最后一个元素</li></ul><h4 id="deque排序"><a href="#deque排序" class="headerlink" title="deque排序"></a>deque排序</h4><p><strong>功能描述：</strong></p><ul><li>利用算法对deque进行排序</li></ul><p><strong>函数原型：</strong></p><ul><li>sort(iterator beg, iterator end)&#x2F;&#x2F; 对[begin(), end())区间内的数据进行排序，可以自行制定排序策略</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintDeque</span><span class="params">(<span class="type">const</span> deque&lt;<span class="type">int</span>&gt; &amp;d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(deque&lt;<span class="type">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it &lt; d.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">    d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">    d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PrintDeque</span>(d);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">PrintDeque</span>(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li>只说了 sort() 算法的实用性，并没有强调排序算法理念，以及算法思想</li></ul><p><img src="https://s2.loli.net/2023/03/25/4jVBRUNqd7SmbOT.png" alt="Deque思维导图"> </p><h3 id="案例-评委打分"><a href="#案例-评委打分" class="headerlink" title="案例-评委打分"></a>案例-评委打分</h3><p><strong>描述：</strong></p><ul><li>有5名选手：选手ABCDE，10个评委分别对每一名选手打分，去除最高分，去除评委中最低分，取平均分。</li></ul><p><strong>步骤：</strong></p><ol><li>创建五名选手，放到vector中 </li><li>遍历vector容器，取出来每一个选手，执行for循环，可以把10个评分打分存到deque容器中</li><li>sort算法对deque容器中分数排序，去除最高和最低分</li><li>deque容器遍历一遍，累加总分</li><li>获取平均分</li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>(string name, <span class="type">float</span> scores) : <span class="built_in">Name</span>(name), <span class="built_in">FinalScores</span>(scores) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    string Name;</span><br><span class="line">    <span class="type">float</span> FinalScores;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreatPlayers</span><span class="params">(vector&lt;Person&gt; &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string NameSeed = <span class="string">&quot;ABCDE&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        string name = <span class="string">&quot;选手&quot;</span>;</span><br><span class="line">        name += NameSeed[i];</span><br><span class="line"></span><br><span class="line">        <span class="type">float</span> score = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">Person <span class="title">p</span><span class="params">(name, score)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将创建的Person对象放进vector中</span></span><br><span class="line">        v.<span class="built_in">push_back</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetScores</span><span class="params">(vector&lt;Person&gt; &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(vector&lt;Person&gt;::iterator it = v.<span class="built_in">begin</span>(); it &lt; v.<span class="built_in">end</span>(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 遍历vector模拟评委打分</span></span><br><span class="line">        deque&lt;<span class="type">float</span>&gt; d;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">float</span> score = <span class="built_in">rand</span>() % <span class="number">41</span> + <span class="number">60</span>; <span class="comment">// 60 ~ 100</span></span><br><span class="line">            d.<span class="built_in">push_back</span>(score);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; it -&gt; Name &lt;&lt; <span class="string">&quot;得分： &quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span>(deque&lt;<span class="type">float</span>&gt;::const_iterator dit = d.<span class="built_in">begin</span>(); dit &lt; d.<span class="built_in">end</span>(); dit ++)</span><br><span class="line">            cout &lt;&lt; *dit &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 排序</span></span><br><span class="line">        <span class="built_in">sort</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 去除最高分和最低分</span></span><br><span class="line">        d.<span class="built_in">pop_back</span>();</span><br><span class="line">        d.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加权平均分</span></span><br><span class="line">        <span class="type">float</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(deque&lt;<span class="type">float</span>&gt;::const_iterator dit = d.<span class="built_in">begin</span>(); dit &lt; d.<span class="built_in">end</span>(); dit++)</span><br><span class="line">            sum += *dit;</span><br><span class="line">        it -&gt; FinalScores = sum / d.<span class="built_in">size</span>();</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShowPerson</span><span class="params">(vector&lt;Person&gt; &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(vector&lt;Person&gt;::iterator it = v.<span class="built_in">begin</span>(); it &lt; v.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;Name &lt;&lt; <span class="string">&quot;\t得分： &quot;</span> &lt;&lt; it-&gt;FinalScores &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 随机数种子</span></span><br><span class="line">    <span class="built_in">srand</span>((<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、创建选手数组</span></span><br><span class="line">    vector&lt;Person&gt; v;</span><br><span class="line">    <span class="built_in">CreatPlayers</span>(v);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试</span></span><br><span class="line">    <span class="built_in">ShowPerson</span>(v);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、打分</span></span><br><span class="line">    <span class="built_in">SetScores</span>(v);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最终结果</span></span><br><span class="line">    <span class="built_in">ShowPerson</span>(v);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Version2:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Player</span>() &#123; &#125;</span><br><span class="line">    <span class="comment">// 列表初始化</span></span><br><span class="line">    <span class="built_in">Player</span>(string name, <span class="type">float</span> score) : <span class="built_in">Name</span>(name), <span class="built_in">FinalScore</span>(score) &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    string Name;</span><br><span class="line">    deque&lt;<span class="type">float</span>&gt; scores;</span><br><span class="line">    <span class="type">float</span> FinalScore;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreatPlayers</span><span class="params">(vector&lt;Player&gt; &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string NameSeed = <span class="string">&quot;ABCDE&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        string name = <span class="string">&quot;选手&quot;</span>;</span><br><span class="line">        name += NameSeed[i];</span><br><span class="line"></span><br><span class="line">        <span class="type">float</span> score = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">Player <span class="title">p</span><span class="params">(name, score)</span></span>;</span><br><span class="line"></span><br><span class="line">        v.<span class="built_in">push_back</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetScores</span><span class="params">(vector&lt;Player&gt; &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(vector&lt;Player&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 打分</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;Name &lt;&lt; <span class="string">&quot;\t得分： &quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">float</span> score = <span class="built_in">rand</span>() % <span class="number">41</span> + <span class="number">60</span>;</span><br><span class="line">            it-&gt;scores.<span class="built_in">push_back</span>(score);</span><br><span class="line">            cout &lt;&lt; score &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">sort</span>(it-&gt;scores.<span class="built_in">begin</span>(), it-&gt;scores.<span class="built_in">end</span>());</span><br><span class="line">        it-&gt;scores.<span class="built_in">pop_front</span>();</span><br><span class="line">        it-&gt;scores.<span class="built_in">pop_back</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="type">float</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(deque&lt;<span class="type">float</span>&gt;::const_iterator dit = it-&gt;scores.<span class="built_in">begin</span>(); dit &lt; it-&gt;scores.<span class="built_in">end</span>(); dit++)</span><br><span class="line">            sum += *dit;</span><br><span class="line">        it-&gt;FinalScore = sum / it-&gt;scores.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShowPlayer</span><span class="params">(vector&lt;Player&gt; &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(vector&lt;Player&gt;::iterator it = v.<span class="built_in">begin</span>(); it &lt; v.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;Name &lt;&lt; <span class="string">&quot; 得分： &quot;</span> &lt;&lt; it-&gt;FinalScore &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>((<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));<span class="comment">// 随机数种子</span></span><br><span class="line">    vector&lt;Player&gt; v;</span><br><span class="line">    <span class="built_in">CreatPlayers</span>(v);</span><br><span class="line">    <span class="built_in">SetScores</span>(v);</span><br><span class="line">    <span class="built_in">ShowPlayer</span>(v);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**总结：**选择不同的容器操作数据，能够提高效率</p><h3 id="stack容器"><a href="#stack容器" class="headerlink" title="stack容器"></a>stack容器</h3><h4 id="stack容器基本概念"><a href="#stack容器基本概念" class="headerlink" title="stack容器基本概念"></a>stack容器基本概念</h4><p><strong>概念：</strong> stack是一种<strong>先进后出</strong>（FILO）的数据结构，只有一个出口：栈顶（top）</p><p><img src="https://s2.loli.net/2023/03/25/E46TpVzULltqv2h.png" alt="Stack结构"> </p><p>在STL内置的容器中，栈（stack）不允许<strong>遍历</strong>，数据进出被称为<strong>压栈（入栈）<strong>和</strong>弹栈（出栈）</strong></p><h4 id="stack常用接口"><a href="#stack常用接口" class="headerlink" title="stack常用接口"></a>stack常用接口</h4><p><strong>功能描述：</strong> </p><ul><li>栈常用的对外接口</li></ul><p>构造函数：</p><ul><li>stack<T> stk; &#x2F;&#x2F;stack采用模板类实现， stack对象的默认构造形式</li><li>stack(const stack &amp;stk); &#x2F;&#x2F;拷贝构造函数</li></ul><p>赋值操作：</p><ul><li>stack&amp; operator&#x3D;(const stack &amp;stk); &#x2F;&#x2F;重载等号操作符</li></ul><p>数据存取：</p><ul><li>push(elem); &#x2F;&#x2F;向栈顶添加元素</li><li>pop(); &#x2F;&#x2F;从栈顶移除第一个元素</li><li>top(); &#x2F;&#x2F;返回栈顶元素</li></ul><p>大小操作：</p><ul><li>empty(); &#x2F;&#x2F;判断堆栈是否为空</li><li>size(); &#x2F;&#x2F;返回栈的大小</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">构造函数：</span></span><br><span class="line"><span class="comment">stack&lt;T&gt; stk; //stack采用模板类实现， stack对象的默认构造形式</span></span><br><span class="line"><span class="comment">stack(const stack &amp;stk); //拷贝构造函数</span></span><br><span class="line"><span class="comment">赋值操作：</span></span><br><span class="line"><span class="comment">stack&amp; operator=(const stack &amp;stk); //重载等号操作符</span></span><br><span class="line"><span class="comment">数据存取：</span></span><br><span class="line"><span class="comment">push(elem); //向栈顶添加元素</span></span><br><span class="line"><span class="comment">pop(); //从栈顶移除第一个元素</span></span><br><span class="line"><span class="comment">top(); //返回栈顶元素</span></span><br><span class="line"><span class="comment">大小操作：</span></span><br><span class="line"><span class="comment">empty(); //判断堆栈是否为空</span></span><br><span class="line"><span class="comment">size(); //返回栈的大小</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 常用接口</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建栈容器，FILO</span></span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 压栈</span></span><br><span class="line">    s.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line">    s.<span class="built_in">push</span>(<span class="number">20</span>);</span><br><span class="line">    s.<span class="built_in">push</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;栈顶元素为：&quot;</span> &lt;&lt; s.<span class="built_in">top</span>() &lt;&lt; endl;</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;        </span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;栈的大小为： &quot;</span> &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li>入栈 — push</li><li>出栈 — pop</li><li>返回栈顶 — top</li><li>判断栈是否为空 — empty</li><li>返回栈大小 — size</li></ul><p><img src="https://s2.loli.net/2023/03/25/dBRAZuWt17NgF68.png" alt="Stack">  </p><h3 id="queue容器"><a href="#queue容器" class="headerlink" title="queue容器"></a>queue容器</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p><strong>概念：</strong> Queue是一种<strong>先进先出</strong>(First In First Out,FIFO)的数据结构，它有两个出</p><p><img src="https://s2.loli.net/2023/03/25/YL73IA8qSmvOjpQ.png" alt="queue结构">  </p><ul><li>队列容器允许从一端新增元素，从另一端移除元素</li><li>队列中只有队头和队尾才可以被外界使用，因此队列不允许有遍历行为</li><li>队列中进数据称为 — 入队 push</li><li>队列中出数据称为 — 出队 pop</li></ul><h4 id="queue常用接口"><a href="#queue常用接口" class="headerlink" title="queue常用接口"></a>queue常用接口</h4><p><strong>构造函数：</strong>  </p><ul><li>queue<T> que; &#x2F;&#x2F;queue采用模板类实现，queue对象的默认构造形式</li><li>queue(const queue &amp;que); &#x2F;&#x2F;拷贝构造函数</li></ul><p><strong>赋值操作：</strong> </p><ul><li>queue&amp; operator&#x3D;(const queue &amp;que); &#x2F;&#x2F;重载等号操作符</li></ul><p><strong>数据存取：</strong></p><ul><li>push(elem); &#x2F;&#x2F;往队尾添加元素</li><li>pop(); &#x2F;&#x2F;从队头移除第一个元素</li><li>back(); &#x2F;&#x2F;返回最后一个元素</li><li>front(); &#x2F;&#x2F;返回第一个元素</li></ul><p><strong>大小操作：</strong></p><ul><li>empty(); &#x2F;&#x2F;判断堆栈是否为空</li><li>size(); &#x2F;&#x2F;返回栈的大小</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">构造函数：</span></span><br><span class="line"><span class="comment">queue&lt;T&gt; que; //queue采用模板类实现，queue对象的默认构造形式</span></span><br><span class="line"><span class="comment">queue(const queue &amp;que); //拷贝构造函数</span></span><br><span class="line"><span class="comment">赋值操作：</span></span><br><span class="line"><span class="comment">queue&amp; operator=(const queue &amp;que); //重载等号操作符</span></span><br><span class="line"><span class="comment">数据存取：</span></span><br><span class="line"><span class="comment">push(elem); //往队尾添加元素</span></span><br><span class="line"><span class="comment">pop(); //从队头移除第一个元素</span></span><br><span class="line"><span class="comment">back(); //返回最后一个元素</span></span><br><span class="line"><span class="comment">front(); //返回第一个元素</span></span><br><span class="line"><span class="comment">大小操作：</span></span><br><span class="line"><span class="comment">empty(); //判断堆栈是否为空</span></span><br><span class="line"><span class="comment">size(); //返回栈的大小</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string name, <span class="type">int</span> age) :  <span class="built_in">Name</span>(name), <span class="built_in">Age</span>(age) &#123; &#125;</span><br><span class="line">    string Name;</span><br><span class="line">    <span class="type">int</span> Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建队列</span></span><br><span class="line">    queue&lt;Person&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据</span></span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;唐僧&quot;</span>, <span class="number">30</span>)</span>, <span class="title">p2</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">500</span>)</span>, <span class="title">p3</span><span class="params">(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">1000</span>)</span>, <span class="title">p4</span><span class="params">(<span class="string">&quot;沙僧&quot;</span>, <span class="number">1000</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进队</span></span><br><span class="line">    q.<span class="built_in">push</span>(p1);</span><br><span class="line">    q.<span class="built_in">push</span>(p2);</span><br><span class="line">    q.<span class="built_in">push</span>(p3);</span><br><span class="line">    q.<span class="built_in">push</span>(p4);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列没有迭代器，也不支持随机存取</span></span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;队头元素： 姓名： &quot;</span> &lt;&lt; q.<span class="built_in">front</span>().Name &lt;&lt; <span class="string">&quot;年龄： &quot;</span> &lt;&lt; q.<span class="built_in">front</span>().Age &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;队尾元素： 姓名： &quot;</span> &lt;&lt; q.<span class="built_in">back</span>().Name &lt;&lt; <span class="string">&quot;年龄： &quot;</span> &lt;&lt; q.<span class="built_in">back</span>().Age &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;队列大小： &quot;</span> &lt;&lt; q.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li>入队 — push</li><li>出队 — pop</li><li>返回队头元素 — front</li><li>返回队尾元素 — back</li><li>判断队是否为空 — empty</li><li>返回队列大小 — size</li></ul><p><img src="https://s2.loli.net/2023/03/25/aEqgLcIpvsR1JdY.png" alt="Queue">  </p><h3 id="list容器"><a href="#list容器" class="headerlink" title="list容器"></a>list容器</h3><h4 id="list基本概念"><a href="#list基本概念" class="headerlink" title="list基本概念"></a>list基本概念</h4><p><strong>功能：</strong></p><ul><li>链式存储数据</li></ul><p><strong>链表：</strong></p><ul><li>逻辑上连续，但是物理上不一定连续的存储结构，使用指针存取</li></ul><p><strong>链表组成：</strong></p><ul><li>数据域+指针域</li></ul><p>STL里的 list 是双向循环链表，但是在实际使用时似乎并没有体现出它是循环链表，</p><p>优点：</p><ul><li><p>动态申请，不需要关心容量够不够（链表）</p></li><li><p>插入数据不需要大量移动元素（链表）</p></li><li><p>插入数据时，无论是头插还是尾插，时间复杂度都是O(1)（循环链表）</p></li></ul><p>缺点：</p><ul><li>遍历成本高，时间复杂度为O(n)</li><li>插入操作和删除操作都不会造成原有 list 迭代器的失效，这在vector是不成立的</li><li>不能随机存取</li></ul><p>总结：STL中<strong>List和vector是两个最常被使用的容器</strong>，各有优缺点</p><h4 id="list构造函数"><a href="#list构造函数" class="headerlink" title="list构造函数"></a>list构造函数</h4><p><strong>功能描述：</strong></p><ul><li>创建list容器</li></ul><p><strong>函数原型：</strong></p><ul><li>list<T> lst; &#x2F;&#x2F;list采用采用模板类实现,对象的默认构造形式：</li><li>list(beg,end); &#x2F;&#x2F;构造函数将[beg, end)区间中的元素拷贝给本身。</li><li>list(n,elem); &#x2F;&#x2F;构造函数将n个elem拷贝给本身。</li><li>list(const list &amp;lst); &#x2F;&#x2F;拷贝构造函数。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">list&lt;T&gt; lst; //list采用采用模板类实现,对象的默认构造形式：</span></span><br><span class="line"><span class="comment">list(beg,end); //构造函数将[beg, end)区间中的元素拷贝给本身。</span></span><br><span class="line"><span class="comment">list(n,elem); //构造函数将n个elem拷贝给本身。</span></span><br><span class="line"><span class="comment">list(const list &amp;lst); //拷贝构造函数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintList</span><span class="params">(<span class="type">const</span> list&lt;<span class="type">int</span>&gt; &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (list&lt;<span class="type">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) </span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>; </span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; L1;</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PrintList</span>(L1);</span><br><span class="line"></span><br><span class="line">    <span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">L2</span><span class="params">(L1.begin(), L1.end())</span></span>;</span><br><span class="line">    <span class="built_in">PrintList</span>(L2);</span><br><span class="line"></span><br><span class="line">    <span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">L3</span><span class="params">(L2)</span></span>;</span><br><span class="line">    <span class="built_in">PrintList</span>(L3);</span><br><span class="line"></span><br><span class="line">    <span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">L4</span><span class="params">(<span class="number">10</span>, <span class="number">1000</span>)</span></span>;</span><br><span class="line">    <span class="built_in">PrintList</span>(L4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> list构造方式同其他几个STL常用容器，熟练掌握即可</p><h4 id="list赋值和交换"><a href="#list赋值和交换" class="headerlink" title="list赋值和交换"></a>list赋值和交换</h4><p><strong>功能描述：</strong></p><ul><li>给list容器赋值，交换容器</li></ul><p><strong>函数原型：</strong></p><ul><li>assign(beg, end); &#x2F;&#x2F;将[beg, end)区间中的数据拷贝赋值给本身。</li><li>assign(n, elem); &#x2F;&#x2F;将n个elem拷贝赋值给本身。</li><li>list&amp; operator&#x3D;(const list &amp;lst); &#x2F;&#x2F;重载等号操作符</li><li>swap(lst); &#x2F;&#x2F;将lst与本身的元素互换。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">assign(beg, end); //将[beg, end)区间中的数据拷贝赋值给本身。</span></span><br><span class="line"><span class="comment">assign(n, elem); //将n个elem拷贝赋值给本身。</span></span><br><span class="line"><span class="comment">list&amp; operator=(const list &amp;lst); //重载等号操作符</span></span><br><span class="line"><span class="comment">swap(lst); //将lst与本身的元素互换。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintList</span><span class="params">(<span class="type">const</span> list&lt;<span class="type">int</span>&gt; &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// list不支持 关系运算符 &lt; 和 &gt;</span></span><br><span class="line">    <span class="keyword">for</span>(list&lt;<span class="type">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; L1;</span><br><span class="line">    <span class="comment">// 尾插</span></span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PrintList</span>(L1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值</span></span><br><span class="line">    list&lt;<span class="type">int</span>&gt; L2;</span><br><span class="line">    L2 = L1;</span><br><span class="line">    <span class="built_in">PrintList</span>(L2);</span><br><span class="line"></span><br><span class="line">    list&lt;<span class="type">int</span>&gt; L3;</span><br><span class="line">    L3.<span class="built_in">assign</span>(L2.<span class="built_in">begin</span>(), L2.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">PrintList</span>(L3);</span><br><span class="line"></span><br><span class="line">    list&lt;<span class="type">int</span>&gt; L4;</span><br><span class="line">    L4.<span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="built_in">PrintList</span>(L4);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; L1;</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    list&lt;<span class="type">int</span>&gt; L2;</span><br><span class="line">    L2.<span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;交换前： &quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">PrintList</span>(L1);</span><br><span class="line">    <span class="built_in">PrintList</span>(L2);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    L1.<span class="built_in">swap</span>(L2);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;交换后： &quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PrintList</span>(L1);</span><br><span class="line">    <span class="built_in">PrintList</span>(L2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="list大小操作"><a href="#list大小操作" class="headerlink" title="list大小操作"></a>list大小操作</h4><p><strong>功能描述：</strong></p><ul><li>list容器容量以及重新指定容器容量</li></ul><p><strong>函数原型：</strong></p><ul><li>size(); &#x2F;&#x2F;返回容器中元素的个数</li><li>empty(); &#x2F;&#x2F;判断容器是否为空</li><li>resize(num); &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以默认值填充新位置。</li><li>&#x2F;&#x2F;如果容器变短，则末尾超出容器长度的元素被删除。</li><li>resize(num, elem); &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以elem值填充新位置。</li><li>&#x2F;&#x2F;如果容器变短，则末尾超出容器长度的元素被删除。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">size(); //返回容器中元素的个数</span></span><br><span class="line"><span class="comment">empty(); //判断容器是否为空</span></span><br><span class="line"><span class="comment">resize(num); //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。</span></span><br><span class="line"><span class="comment">//如果容器变短，则末尾超出容器长度的元素被删除。</span></span><br><span class="line"><span class="comment">resize(num, elem); //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。</span></span><br><span class="line"><span class="comment">//如果容器变短，则末尾超出容器长度的元素被删除。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintList</span><span class="params">(<span class="type">const</span> list&lt;<span class="type">int</span>&gt; &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(list&lt;<span class="type">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大小操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; L1;</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PrintList</span>(L1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(L1.<span class="built_in">empty</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;L1为空！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;L1不为空;&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;L1的大小为： &quot;</span> &lt;&lt; L1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新指定大小</span></span><br><span class="line">    L1.<span class="built_in">resize</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">PrintList</span>(L1);</span><br><span class="line"></span><br><span class="line">    L1.<span class="built_in">resize</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">PrintList</span>(L1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="list插入与删除"><a href="#list插入与删除" class="headerlink" title="list插入与删除"></a>list插入与删除</h4><p><strong>功能描述：</strong></p><ul><li>向list容器中插入元素与删除list容器中的元素</li></ul><p><strong>函数原型：</strong></p><ul><li>push_back(elem);&#x2F;&#x2F;在容器尾部加入一个元素</li><li>pop_back();&#x2F;&#x2F;删除容器中最后一个元素</li><li>push_front(elem);&#x2F;&#x2F;在容器开头插入一个元素</li><li>pop_front();&#x2F;&#x2F;从容器开头移除第一个元素</li><li>insert(pos,elem);&#x2F;&#x2F;在pos位置插elem元素的拷贝，返回新数据的位置。</li><li>insert(pos,n,elem);&#x2F;&#x2F;在pos位置插入n个elem数据，无返回值。</li><li>insert(pos,beg,end);&#x2F;&#x2F;在pos位置插入[beg,end)区间的数据，无返回值。</li><li>clear();&#x2F;&#x2F;移除容器的所有数据</li><li>erase(beg,end);&#x2F;&#x2F;删除[beg,end)区间的数据，返回下一个数据的位置。</li><li>erase(pos);&#x2F;&#x2F;删除pos位置的数据，返回下一个数据的位置。</li><li>remove(elem);&#x2F;&#x2F;删除容器中所有与elem值匹配的元素。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">push_back(elem);//在容器尾部加入一个元素</span></span><br><span class="line"><span class="comment">pop_back();//删除容器中最后一个元素</span></span><br><span class="line"><span class="comment">push_front(elem);//在容器开头插入一个元素</span></span><br><span class="line"><span class="comment">pop_front();//从容器开头移除第一个元素</span></span><br><span class="line"><span class="comment">insert(pos,elem);//在pos位置插elem元素的拷贝，返回新数据的位置。</span></span><br><span class="line"><span class="comment">if (L1.empty()) &#123; cout &lt;&lt; &quot;L1为空&quot; &lt;&lt; endl; &#125;else &#123; cout &lt;&lt; &quot;L1不为空&quot; &lt;&lt; endl; cout &lt;&lt; &quot;L1的大小为： &quot; &lt;&lt; L1.size() &lt;&lt; endl; &#125;//重新指定大小 L1.resize(10); printList(L1); L1.resize(2); printList(L1); &#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 192021222324252627282930313233343536373839404142434445</span></span><br><span class="line"><span class="comment">insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。</span></span><br><span class="line"><span class="comment">insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。</span></span><br><span class="line"><span class="comment">clear();//移除容器的所有数据</span></span><br><span class="line"><span class="comment">erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。</span></span><br><span class="line"><span class="comment">erase(pos);//删除pos位置的数据，返回下一个数据的位置。</span></span><br><span class="line"><span class="comment">remove(elem);//删除容器中所有与elem值匹配的元素。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintList</span><span class="params">(<span class="type">const</span> list&lt;<span class="type">int</span>&gt; &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(list&lt;<span class="type">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; L1;</span><br><span class="line">    <span class="comment">// 尾插</span></span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">    <span class="comment">// 头插</span></span><br><span class="line">    L1.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">    L1.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line">    L1.<span class="built_in">push_front</span>(<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PrintList</span>(L1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尾删</span></span><br><span class="line">    L1.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="built_in">PrintList</span>(L1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 头删</span></span><br><span class="line">    L1.<span class="built_in">pop_front</span>();</span><br><span class="line">    <span class="built_in">PrintList</span>(L1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入</span></span><br><span class="line">    list&lt;<span class="type">int</span>&gt;::iterator it = L1.<span class="built_in">begin</span>();</span><br><span class="line">    L1.<span class="built_in">insert</span>(++it, <span class="number">100</span>);</span><br><span class="line">    <span class="built_in">PrintList</span>(L1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除</span></span><br><span class="line">    it = L1.<span class="built_in">begin</span>();</span><br><span class="line">    L1.<span class="built_in">erase</span>(++it);</span><br><span class="line">    <span class="built_in">PrintList</span>(L1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除</span></span><br><span class="line">    L1.<span class="built_in">push_front</span>(<span class="number">1000</span>);</span><br><span class="line">    L1.<span class="built_in">push_front</span>(<span class="number">1000</span>);</span><br><span class="line">    L1.<span class="built_in">push_front</span>(<span class="number">1000</span>);</span><br><span class="line">    L1.<span class="built_in">remove</span>(<span class="number">1000</span>);</span><br><span class="line">    <span class="built_in">PrintList</span>(L1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空</span></span><br><span class="line">    L1.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">PrintList</span>(L1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="list数据存取"><a href="#list数据存取" class="headerlink" title="list数据存取"></a>list数据存取</h4><p><strong>功能描述：</strong></p><ul><li>对list容器执行存取操作</li></ul><p><strong>函数原型：</strong></p><ul><li>front(); &#x2F;&#x2F;返回第一个元素。</li><li>back(); &#x2F;&#x2F;返回最后一个元素。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">front(); //返回第一个元素。</span></span><br><span class="line"><span class="comment">back(); //返回最后一个元素。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; L1;</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">    L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 链表不支持随机存取，不能使用 at() 方法，也不支持使用 [] 访问容器内的成员</span></span><br><span class="line">    <span class="comment">// 只能访问得到链表头尾元素，因为list是双向循环链表，表头元素访问时间复杂度为O(1)，表尾元素访问的时间复杂度也是O(1)</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第一个元素： &quot;</span> &lt;&lt; L1.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;最后一个元素： &quot;</span> &lt;&lt; L1.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// list的迭代器是双向迭代器，不支持随机访问</span></span><br><span class="line">    list&lt;<span class="type">int</span>&gt;::iterator it = L1.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="comment">// 不支持 it += 1; 不能跳跃</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="list反转与排序"><a href="#list反转与排序" class="headerlink" title="list反转与排序"></a>list反转与排序</h4><p><strong>功能描述：</strong></p><ul><li>将list容器中的数据反转与排序</li></ul><p><strong>函数原型：</strong></p><ul><li>reverse(); &#x2F;&#x2F;反转链表</li><li>sort(); &#x2F;&#x2F;链表排序</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">reverse(); //反转链表</span></span><br><span class="line"><span class="comment">sort(); //链表排序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintList</span><span class="params">(<span class="type">const</span> list&lt;<span class="type">int</span>&gt; &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(list&lt;<span class="type">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MyCompare</span><span class="params">(<span class="type">int</span> val1, <span class="type">int</span> val2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> val1 &gt; val2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l</span><br></pre></td></tr></table></figure><h4 id="排序案例"><a href="#排序案例" class="headerlink" title="排序案例"></a>排序案例</h4><ul><li>案例描述：将Person自定义数据类型进行排序，Person中属性有姓名、年龄、身高</li><li>排序规则：按照年龄进行升序，如果年龄相同按照身高进行降序（使用仿函数指定排序策略）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    按照年龄进行升序，如果年龄相同按照身高进行降序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>() &#123; &#125;</span><br><span class="line">    <span class="built_in">Person</span>(string name, <span class="type">int</span> age, <span class="type">int</span> height) : <span class="built_in">Name</span>(name), <span class="built_in">Age</span>(age), <span class="built_in">Height</span>(height) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    string Name;</span><br><span class="line">    <span class="type">int</span> Age;</span><br><span class="line">    <span class="type">int</span> Height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 排序策略</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MyCompare</span><span class="params">(Person &amp;p1, Person &amp;p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p1.Age == p2.Age)</span><br><span class="line">        <span class="keyword">return</span> p1.Height &gt; p2.Height;   <span class="comment">// 身高降序</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> p1.Age &lt; p2.Age; <span class="comment">// 年龄升序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintList</span><span class="params">(<span class="type">const</span> list&lt;Person&gt; &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(list&lt;Person&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; it-&gt;Age &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; it -&gt;Height &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    list&lt;Person&gt; L;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">35</span>, <span class="number">175</span>)</span>, <span class="title">p2</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">35</span>, <span class="number">200</span>)</span>, <span class="title">p3</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">35</span>, <span class="number">160</span>)</span>, <span class="title">p4</span><span class="params">(<span class="string">&quot;曹操&quot;</span>, <span class="number">45</span>, <span class="number">178</span>)</span>, <span class="title">p5</span><span class="params">(<span class="string">&quot;孙权&quot;</span>, <span class="number">40</span>, <span class="number">170</span>)</span>, <span class="title">p6</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">25</span>, <span class="number">190</span>)</span></span>;</span><br><span class="line">    L.<span class="built_in">push_back</span>(p1);</span><br><span class="line">    L.<span class="built_in">push_back</span>(p2);</span><br><span class="line">    L.<span class="built_in">push_back</span>(p3);</span><br><span class="line">    L.<span class="built_in">push_back</span>(p4);</span><br><span class="line">    L.<span class="built_in">push_back</span>(p5);</span><br><span class="line">    L.<span class="built_in">push_back</span>(p6);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;排序前：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">PrintList</span>(L);</span><br><span class="line"></span><br><span class="line">    L.<span class="built_in">sort</span>(MyCompare);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;排序后：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">PrintList</span>(L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> </p><ul><li>对于自定义数据类型，必须要指定排序规则，否则编译器不知道如何进行排序</li><li>高级排序只是在排序规则上再进行一次逻辑规则制定，并不复杂</li></ul><p><img src="https://s2.loli.net/2023/03/25/Pqde6wMWcO3F2yj.png" alt="List"> </p><h3 id="set-multiset-容器（集合）"><a href="#set-multiset-容器（集合）" class="headerlink" title="set&#x2F; multiset 容器（集合）"></a>set&#x2F; multiset 容器（集合）</h3><h4 id="set-multiset基本概念"><a href="#set-multiset基本概念" class="headerlink" title="set&#x2F;multiset基本概念"></a>set&#x2F;multiset基本概念</h4><p><strong>简介：</strong> </p><ul><li>所有元素都会在插入时自动被排序</li></ul><p><strong>本质：</strong> </p><ul><li>set&#x2F;multiset属于关联式容器，底层结构是用二叉树实现。</li></ul><p><strong>set和multiset区别：</strong> </p><ul><li>set不允许容器中有重复的元素</li><li>multiset允许容器中有重复的元素</li></ul><h4 id="set构造和赋值"><a href="#set构造和赋值" class="headerlink" title="set构造和赋值"></a>set构造和赋值</h4><p><strong>构造：</strong> </p><ul><li>set<T> st; &#x2F;&#x2F;默认构造函数：</li><li>set(const set &amp;st); &#x2F;&#x2F;拷贝构造函数</li></ul><p><strong>赋值：</strong> </p><ul><li>set&amp; operator&#x3D;(const set &amp;st); &#x2F;&#x2F;重载等号操作符</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">构造：</span></span><br><span class="line"><span class="comment">set&lt;T&gt; st; //默认构造函数：</span></span><br><span class="line"><span class="comment">set(const set &amp;st); //拷贝构造函数</span></span><br><span class="line"><span class="comment">赋值：</span></span><br><span class="line"><span class="comment">set&amp; operator=(const set &amp;st); //重载等号操作符</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintSet</span><span class="params">(<span class="type">const</span> set&lt;<span class="type">int</span>&gt; &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(set&lt;<span class="type">int</span>&gt;::const_iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Constructor and assignment</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 自动排序</span></span><br><span class="line">    set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">80</span>);</span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">90</span>);</span><br><span class="line">    <span class="built_in">PrintSet</span>(s1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造</span></span><br><span class="line">    <span class="function">set&lt;<span class="type">int</span>&gt; <span class="title">s2</span><span class="params">(s1)</span></span>;</span><br><span class="line">    <span class="built_in">PrintSet</span>(s2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 运算符重载</span></span><br><span class="line">    set&lt;<span class="type">int</span>&gt; s3;</span><br><span class="line">    s3 = s2;</span><br><span class="line">    <span class="built_in">PrintSet</span>(s3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li>set容器插入数据时用insert</li><li>set容器插入数据的数据会自动排序（自定义类型除外）</li></ul><h4 id="set大小和交换"><a href="#set大小和交换" class="headerlink" title="set大小和交换"></a>set大小和交换</h4><p><strong>功能描述：</strong> </p><ul><li>统计set容器大小以及交换set容器</li></ul><p><strong>函数原型：</strong> </p><ul><li>size(); &#x2F;&#x2F;返回容器中元素的数目</li><li>empty(); &#x2F;&#x2F;判断容器是否为空</li><li>swap(st); &#x2F;&#x2F;交换两个集合容器</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintSet</span><span class="params">(<span class="type">const</span> set&lt;<span class="type">int</span>&gt; &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(set&lt;<span class="type">int</span>&gt;::const_iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PrintSet</span>(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(s.<span class="built_in">empty</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;set容器为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;容器不为空且大小为：&quot;</span> &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; s1, s2;</span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">400</span>);</span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">200</span>);</span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    s2.<span class="built_in">insert</span>(<span class="number">100</span>);</span><br><span class="line">    s2.<span class="built_in">insert</span>(<span class="number">300</span>);</span><br><span class="line">    s2.<span class="built_in">insert</span>(<span class="number">200</span>);</span><br><span class="line">    s2.<span class="built_in">insert</span>(<span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;交换前：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">PrintSet</span>(s1);</span><br><span class="line">    <span class="built_in">PrintSet</span>(s2);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;交换后：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">PrintSet</span>(s1);</span><br><span class="line">    <span class="built_in">PrintSet</span>(s2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> </p><ul><li>统计大小 — size</li><li>判断是否为空 — empty</li><li>交换容器 — swap</li></ul><h4 id="set插入和删除"><a href="#set插入和删除" class="headerlink" title="set插入和删除"></a>set插入和删除</h4><p><strong>功能描述：</strong> </p><ul><li>set容器进行插入数据和删除数据</li></ul><p><strong>函数原型：</strong> </p><ul><li>insert(elem); &#x2F;&#x2F;在容器中插入元素。</li><li>clear(); &#x2F;&#x2F;清除所有元素</li><li>erase(pos); &#x2F;&#x2F;删除pos迭代器所指的元素，返回下一个元素的迭代器。</li><li>erase(beg, end); &#x2F;&#x2F;删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</li><li>erase(elem); &#x2F;&#x2F;删除容器中值为elem的元素。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">insert(elem); //在容器中插入元素。</span></span><br><span class="line"><span class="comment">clear(); //清除所有元素</span></span><br><span class="line"><span class="comment">erase(pos); //删除pos迭代器所指的元素，返回下一个元素的迭代器。</span></span><br><span class="line"><span class="comment">erase(beg, end); //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</span></span><br><span class="line"><span class="comment">erase(elem); //删除容器中值为elem的元素。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintSet</span><span class="params">(<span class="type">const</span> set&lt;<span class="type">int</span>&gt; &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(set&lt;<span class="type">int</span>&gt;::const_iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入和删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Insert data</span></span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PrintSet</span>(s);</span><br><span class="line"></span><br><span class="line">    s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>());</span><br><span class="line">    <span class="built_in">PrintSet</span>(s);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载版本，删除容器中所有相同元素</span></span><br><span class="line">    s.<span class="built_in">erase</span>(<span class="number">30</span>);</span><br><span class="line">    <span class="built_in">PrintSet</span>(s);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空</span></span><br><span class="line">    <span class="comment">// s.erase(s.begin(), s.end()); // 提供迭代器区间</span></span><br><span class="line">    s.<span class="built_in">clear</span>();  <span class="comment">// 不需要提供参数</span></span><br><span class="line">    <span class="built_in">PrintSet</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> </p><ul><li>插入 — insert</li><li>删除 — erase</li><li>清空 — clear</li></ul><h4 id="set查找和统计"><a href="#set查找和统计" class="headerlink" title="set查找和统计"></a>set查找和统计</h4><p><strong>功能描述：</strong> </p><ul><li>对set容器进行查找数据以及统计数据</li></ul><p><strong>函数原型：</strong> </p><ul><li>find(key); &#x2F;&#x2F;查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</li><li>count(key); &#x2F;&#x2F;统计key的元素个数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">find(key); //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</span></span><br><span class="line"><span class="comment">count(key); //统计key的元素个数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    set&lt;<span class="type">int</span>&gt;::iterator pos = s.<span class="built_in">find</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pos != s.<span class="built_in">end</span>())  <span class="comment">// end()位置不存储数据</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;找到了该元素&quot;</span> &lt;&lt; *pos &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;未找到该元素&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = s.<span class="built_in">count</span>(<span class="number">30</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> </p><ul><li>查找 — find （返回的是迭代器）</li><li>统计 — count （对于set，结果为0或者1）</li></ul><h4 id="set和multiset的区别"><a href="#set和multiset的区别" class="headerlink" title="set和multiset的区别"></a>set和multiset的区别</h4><p><strong>学习目标：</strong> </p><ul><li>掌握set和multiset的区别</li></ul><p><strong>区别：</strong> </p><ul><li>set不可以插入重复数据，而multiset可以</li><li>set插入数据的同时会返回插入结果，表示插入是否成功</li><li>multiset不会检测数据，因此可以插入重复数据</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintSet</span><span class="params">(<span class="type">const</span> set&lt;<span class="type">int</span>&gt; &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(set&lt;<span class="type">int</span>&gt;::const_iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set 和 multiset 的区别</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// set</span></span><br><span class="line">    set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    pair&lt;set&lt;<span class="type">int</span>&gt;::iterator,<span class="type">bool</span>&gt; ret = s.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret.second) </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;第一次插入成功&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;第一次插入失败&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    ret = s.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret.second) </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;第二次插入成功&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;第二次插入失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//只有第一次插入成功</span></span><br><span class="line">    <span class="built_in">PrintSet</span>(s);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// multiset</span></span><br><span class="line">    multiset&lt;<span class="type">int</span>&gt; ms;</span><br><span class="line">    ms.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    ms.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(multiset&lt;<span class="type">int</span>&gt;::iterator it = ms.<span class="built_in">begin</span>(); it != ms.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set 与二叉排序树相似，不能有相同的元素，如果需要有相同的元素，可以使用multiset</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> </p><p>如果不允许插入重复数据可以利用set</p><p>如果需要插入重复数据利用multiset</p><h4 id="pair队组创建"><a href="#pair队组创建" class="headerlink" title="pair队组创建"></a>pair队组创建</h4><p><strong>简介：</strong> </p><ul><li><p>pair是将2个数据组合成一组数据，如stl中的map就是将key和value放在一起来保存，或者当一个函数需要返回2个数据的时候，也可以选择pair</p></li><li><p>pair的实现是一个结构体，主要的两个成员变量first和second，分别存储两个数据， 因为是使用struct不是class，所以可以直接使用pair的成员变量。</p></li><li><p>pair类型定义在#include 头文件中，也可以使用std命名空间引入对组std::pair</p></li></ul><p><strong>定义如下：</strong> </p><ul><li>类模板：<ul><li>template&lt;class T1,class T2&gt; struct pair</li><li>T1是第一个值的数据类型，T2是第二个值的数据类型。</li></ul></li><li>功能：<ul><li>pair将一对值(T1和T2)组合成一个值，这一对值可以具有不同的数据类型（T1和T2），两个值可以分别用pair的两个成员first和second访问。</li></ul></li></ul><p><strong>功能描述：</strong> </p><ul><li>成对出现的数据，利用对组可以返回两个数据</li></ul><p><strong>两种创建方式：</strong> </p><ul><li>pair&lt;type, type&gt; p ( value1, value2 ); </li><li>pair&lt;type, type&gt; p &#x3D; make_pair( value1, value2 ); </li><li>make_pair函数生成pair时接受隐式的类型转换（pair&lt;string, int&gt;p2 &#x3D; make_pair(“Jerry”, 200);）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    使用pair创建对组，利用对组可以返回两个数据</span></span><br><span class="line"><span class="comment">    创建方式：</span></span><br><span class="line"><span class="comment">    pair&lt;type, type&gt; p ( value1, value2 ); </span></span><br><span class="line"><span class="comment">    pair&lt;type, type&gt; p = make_pair( value1, value2 );</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">pair&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; p.first &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p.second &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    pair&lt;string, <span class="type">int</span>&gt; p2 = <span class="built_in">make_pair</span>(<span class="string">&quot;Jerry&quot;</span>, <span class="number">30</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; p2.first &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p2.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> </p><ul><li>两种方式都可以创建对组，记住一种即可</li></ul><h4 id="set容器排序"><a href="#set容器排序" class="headerlink" title="set容器排序"></a>set容器排序</h4><p><strong>学习目标：</strong> </p><ul><li>set容器默认排序规则为从小到大，掌握如何改变排序规则</li></ul><p><strong>主要技术点：</strong> </p><ul><li>利用仿函数，可以改变排序规则</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set排序原则默认从小到大</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 仿函数，本质是类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCompare</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="comment">// 重载 () 运算符</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> v1 &gt; v2; <span class="comment">// 降序，大数先返回</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内置数据类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; s1; </span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">10</span>); </span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">40</span>); </span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">20</span>); </span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">30</span>); </span><br><span class="line">    s1.<span class="built_in">insert</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(set&lt;<span class="type">int</span>&gt;::iterator it = s1.<span class="built_in">begin</span>(); it != s1.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 改变排序规则需要在插入之前，利用仿函数修改</span></span><br><span class="line">    set&lt;<span class="type">int</span>, MyCompare&gt; s2;</span><br><span class="line">    s2.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    s2.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">    s2.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">    s2.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(set&lt;<span class="type">int</span>, MyCompare&gt;::iterator it = s2.<span class="built_in">begin</span>(); it != s2.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string name, <span class="type">int</span> age) : <span class="built_in">Name</span>(name), <span class="built_in">Age</span>(age) &#123; &#125;</span><br><span class="line">    string Name;</span><br><span class="line">    <span class="type">int</span> Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ComparePerson</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 函数必须使用括号将语句括起来</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Person &amp;p1, <span class="type">const</span> Person &amp;p2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1.Age &gt; p2.Age; <span class="comment">// 降序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义数据类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set&lt;Person, ComparePerson&gt; s;</span><br><span class="line">    <span class="comment">// 年龄必须不同，这是 set 的特性，根据comparePerson判断元素相同。</span></span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">23</span>)</span>, <span class="title">p2</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">35</span>)</span>, <span class="title">p3</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">35</span>)</span>, <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line">    s.<span class="built_in">insert</span>(p1);</span><br><span class="line">    s.<span class="built_in">insert</span>(p2);</span><br><span class="line">    s.<span class="built_in">insert</span>(p3);</span><br><span class="line">    s.<span class="built_in">insert</span>(p4);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(set&lt;Person, ComparePerson&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; it-&gt;Name &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; it-&gt;Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// test01();</span></span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> 利用仿函数可以指定set容器的排序规则， 对于自定义数据类型，set必须指定排序规则才可以插入数据</p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>若要用set或者multiset存放自定义类型数据，需要重载关系运算符 &lt;、&gt;和&#x3D;&#x3D;，可以选择重载 &lt;&lt; 运算符用于自定义类型数据，或者通过使用仿函数指定排序策略（必须在声明中写清楚）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 友元</span></span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;cout, <span class="type">const</span> Person &amp;p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Person &amp;p1, <span class="type">const</span> Person &amp;p2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> p1.Age &lt; p2.Age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Person</span>() &#123; &#125;</span><br><span class="line">    <span class="built_in">Person</span>(string name, <span class="type">int</span> age) : <span class="built_in">Name</span>(name), <span class="built_in">Age</span>(age) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    string Name;</span><br><span class="line">    <span class="type">int</span> Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, <span class="type">const</span> Person &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; p.Name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p.Age &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintSet</span><span class="params">(<span class="type">const</span> set&lt;Person&gt; &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(set&lt;Person&gt;::const_iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; *it;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set&lt;Person&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;s1&quot;</span>, <span class="number">23</span>)</span>, <span class="title">p2</span><span class="params">(<span class="string">&quot;s2&quot;</span>, <span class="number">24</span>)</span>, <span class="title">p3</span><span class="params">(<span class="string">&quot;s3&quot;</span>, <span class="number">25</span>)</span>, <span class="title">p4</span><span class="params">(<span class="string">&quot;s4&quot;</span>,<span class="number">26</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    s.<span class="built_in">insert</span>(p1);</span><br><span class="line">    s.<span class="built_in">insert</span>(p2);</span><br><span class="line">    s.<span class="built_in">insert</span>(p3);</span><br><span class="line">    s.<span class="built_in">insert</span>(p4);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PrintSet</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> 对于自定义数据类型，set必须指定排序规则才可以插入数据</p><p><img src="https://s2.loli.net/2023/03/25/gkNR37TcOqYiUuV.png" alt="Set"> </p><h3 id="map-multimap容器"><a href="#map-multimap容器" class="headerlink" title="map&#x2F; multimap容器"></a>map&#x2F; multimap容器</h3><h4 id="map-基本概念"><a href="#map-基本概念" class="headerlink" title="map 基本概念"></a>map 基本概念</h4><p><strong>简介：</strong> </p><ul><li>map中所有元素都是pair</li><li>pair中第一个元素为key（键值），起到索引作用，第二个元素为value（实值）</li><li>所有元素都会根据元素的键值自动排序</li></ul><p><strong>本质：</strong> </p><ul><li>map&#x2F;multimap属于关联式容器，底层结构是用二叉树实现。</li></ul><p><strong>优点：</strong> </p><ul><li>可以根据key值快速找到value值</li></ul><p><strong>map和multimap区别：</strong> </p><ul><li>map不允许容器中有重复key值元素</li><li>multimap允许容器中有重复key值元素</li></ul><h4 id="map-构造和赋值"><a href="#map-构造和赋值" class="headerlink" title="map 构造和赋值"></a>map 构造和赋值</h4><p><strong>功能描述：</strong> </p><ul><li>对map容器进行构造和赋值操作</li></ul><p><strong>函数原型：</strong> </p><ul><li>构造：<ul><li>map&lt;T1, T2&gt; mp; &#x2F;&#x2F;map默认构造函数: </li><li>map(const map &amp;mp); &#x2F;&#x2F;拷贝构造函数</li></ul></li><li>赋值：<ul><li>map&amp; operator&#x3D;(const map &amp;mp); &#x2F;&#x2F;重载等号操作符</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">构造：</span></span><br><span class="line"><span class="comment">map&lt;T1, T2&gt; mp; //map默认构造函数: map(const map &amp;mp); //拷贝构造函数</span></span><br><span class="line"><span class="comment">赋值：</span></span><br><span class="line"><span class="comment">map&amp; operator=(const map &amp;mp); //重载等号操作符</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 属于关联式容器，底层实现用的是二叉树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintMap</span><span class="params">(<span class="type">const</span> map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::const_iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 插入后自动排序</span></span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">    m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">    m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">    m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line">    <span class="built_in">PrintMap</span>(m);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">m2</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="built_in">PrintMap</span>(m2);</span><br><span class="line"></span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m3;</span><br><span class="line">    m3 = m2;</span><br><span class="line">    <span class="built_in">PrintMap</span>(m3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> map中所有元素都是成对出现，插入数据时候要使用对组</p><h4 id="map大小和交换"><a href="#map大小和交换" class="headerlink" title="map大小和交换"></a>map大小和交换</h4><p><strong>功能描述：</strong> </p><ul><li>统计map容器大小以及交换map容器</li></ul><p><strong>函数原型：</strong> </p><ul><li>size(); &#x2F;&#x2F;返回容器中元素的数目</li><li>empty(); &#x2F;&#x2F;判断容器是否为空</li><li>swap(st); &#x2F;&#x2F;交换两个集合容器</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintMap</span><span class="params">(<span class="type">const</span> map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::const_iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 大小</span></span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m1;</span><br><span class="line">    m1.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">    m1.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">    m1.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PrintMap</span>(m1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(m1.<span class="built_in">empty</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;m1为空！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;m1不为空且m1的大小为：&quot;</span> &lt;&lt; m1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换</span></span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m2;</span><br><span class="line">    m2.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">4</span>, <span class="number">400</span>));</span><br><span class="line">    m2.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">5</span>, <span class="number">500</span>));</span><br><span class="line">    m2.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">6</span>, <span class="number">600</span>));</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;交换前：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">PrintMap</span>(m1);</span><br><span class="line">    <span class="built_in">PrintMap</span>(m2);</span><br><span class="line"></span><br><span class="line">    m1.<span class="built_in">swap</span>(m2);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;交换后：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">PrintMap</span>(m1);</span><br><span class="line">    <span class="built_in">PrintMap</span>(m2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> </p><ul><li>统计大小 — size</li><li>判断是否为空 — empty</li><li>交换容器 — swap</li></ul><h4 id="map-插入和删除"><a href="#map-插入和删除" class="headerlink" title="map 插入和删除"></a>map 插入和删除</h4><p><strong>功能描述：</strong> </p><ul><li>map容器进行插入数据和删除数据</li></ul><p><strong>函数原型：</strong> </p><ul><li>insert(elem); &#x2F;&#x2F;在容器中插入元素。</li><li>clear(); &#x2F;&#x2F;清除所有元素</li><li>erase(pos); &#x2F;&#x2F;删除pos迭代器所指的元素，返回下一个元素的迭代器。</li><li>erase(beg, end); &#x2F;&#x2F;删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</li><li>erase(key); &#x2F;&#x2F;删除容器中值为key的元素。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintMap</span><span class="params">(<span class="type">const</span> map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::const_iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 插入</span></span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">    <span class="comment">// 第一种</span></span><br><span class="line">    m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二种</span></span><br><span class="line">    m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三种</span></span><br><span class="line">    m.<span class="built_in">insert</span>(map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::<span class="built_in">value_type</span>(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第四种</span></span><br><span class="line">    m[<span class="number">4</span>] = <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PrintMap</span>(m);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除</span></span><br><span class="line">    <span class="comment">// 提供迭代器作为索引</span></span><br><span class="line">    m.<span class="built_in">erase</span>(m.<span class="built_in">begin</span>());</span><br><span class="line">    <span class="built_in">PrintMap</span>(m);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供 key 值作为索引</span></span><br><span class="line">    m.<span class="built_in">erase</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">PrintMap</span>(m);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空</span></span><br><span class="line">    m.<span class="built_in">erase</span>(m.<span class="built_in">begin</span>(), m.<span class="built_in">end</span>());    <span class="comment">// 清空</span></span><br><span class="line">    m.<span class="built_in">clear</span>();  <span class="comment">// 清空</span></span><br><span class="line">    <span class="built_in">PrintMap</span>(m); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> </p><ul><li>map插入方式很多，记住其一即可</li><li>插入 — insert</li><li>删除 — erase</li><li>清空 — clear</li></ul><h4 id="map-查找和统计"><a href="#map-查找和统计" class="headerlink" title="map 查找和统计"></a>map 查找和统计</h4><p><strong>功能描述：</strong> </p><ul><li>对map容器进行查找数据以及统计数据</li></ul><p><strong>函数原型：</strong> </p><ul><li>find(key); &#x2F;&#x2F;查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</li><li>count(key); &#x2F;&#x2F;统计key的元素个数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数原型：</span></span><br><span class="line"><span class="comment">find(key); //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</span></span><br><span class="line"><span class="comment">count(key); //统计key的元素个数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">    m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">    m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">    m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找</span></span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator pos = m.<span class="built_in">find</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pos != m.<span class="built_in">end</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;找到了元素 key = &quot;</span> &lt;&lt; (*pos).first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; (*pos).second &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;未找到该元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 统计</span></span><br><span class="line">    <span class="type">int</span> num = m.<span class="built_in">count</span>(<span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> </p><ul><li>查找 — find （返回的是迭代器）</li><li>统计 — count （对于map，结果为0或者1）</li></ul><h4 id="map-容器排序"><a href="#map-容器排序" class="headerlink" title="map 容器排序"></a>map 容器排序</h4><p><strong>学习目标：</strong> </p><ul><li>map容器默认排序规则为 按照key值进行 从小到大排序，掌握如何改变排序规则</li></ul><p><strong>主要技术点:</strong> </p><ul><li>利用仿函数，可以改变排序规则</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改默认从小到大的升序原则</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCompare</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v1 &gt; v2; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Compare_by_value</span><span class="params">(<span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &amp;p1, <span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &amp;p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p1.second &gt; p2.second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 利用仿函数实现降序排序，插入时会判断插入的队组的second值，以此为依据确定两对组是否相等</span></span><br><span class="line">    multimap&lt;<span class="type">int</span>, <span class="type">int</span>, MyCompare&gt; m;</span><br><span class="line">    m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">    m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">    m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line">    m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">3</span>, <span class="number">60</span>));</span><br><span class="line">    m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">4</span>, <span class="number">40</span>));</span><br><span class="line">    m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">5</span>, <span class="number">50</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;按值排序:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 按照value进行排序</span></span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">v</span>(m.<span class="built_in">begin</span>(), m.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), Compare_by_value);</span><br><span class="line">    <span class="comment">// 将map中的数据存到vector中，并没有解决我的问题</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt;  <span class="string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 还有将排序依据作为key值的，这是很好的想法，但是投机取巧</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> </p><ul><li>利用仿函数可以指定map容器的排序规则</li><li>对于自定义数据类型，map必须要指定排序规则,同set容器</li></ul><p><img src="https://s2.loli.net/2023/03/25/Z8KqJljfDmNSiut.png" alt="Map"> </p><h4 id="案例-员工分组"><a href="#案例-员工分组" class="headerlink" title="案例-员工分组"></a>案例-员工分组</h4><p><strong>案例描述：</strong> </p><p>公司今天招聘了10个员工（ABCDEFGHIJ），10名员工进入公司之后，需要指派员工在那个部门工作</p><ul><li>员工信息有: 姓名 工资组成；部门分为：策划、美术、研发</li><li>随机给10名员工分配部门和工资</li><li>通过multimap进行信息的插入 key(部门编号) value(员工)</li><li>分部门显示员工信息</li></ul><p><strong>实现步骤：</strong> </p><ol><li>创建10名员工，放到vector中 </li><li>遍历vector容器，取出每个员工，进行随机分组</li><li>分组后，将员工部门编号作为key，具体员工作为value，放入到multimap容器中</li><li>分部门显示员工信息</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">公司今天招聘了10个员工（ABCDEFGHIJ），10名员工进入公司之后，需要指派员工在那个部门工作</span></span><br><span class="line"><span class="comment">员工信息有: 姓名 工资组成；部门分为：策划、美术、研发</span></span><br><span class="line"><span class="comment">随机给10名员工分配部门和工资</span></span><br><span class="line"><span class="comment">通过multimap进行信息的插入 key(部门编号) value(员工)</span></span><br><span class="line"><span class="comment">分部门显示员工信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESIGN 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ART 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEV 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Worker</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string Name;</span><br><span class="line">    <span class="type">int</span> Salary;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateWorker</span><span class="params">(vector&lt;Worker&gt; &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string NameSeed = <span class="string">&quot;ABCDEFGHIJ&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Worker w;</span><br><span class="line">        w.Name = <span class="string">&quot;员工&quot;</span>;</span><br><span class="line">        w.Name += NameSeed[i];</span><br><span class="line"></span><br><span class="line">        w.Salary = <span class="built_in">rand</span>() % <span class="number">10000</span> + <span class="number">10000</span>;  <span class="comment">// 10000 ~ 19999</span></span><br><span class="line">        <span class="comment">// 将员工放进容器</span></span><br><span class="line">        v.<span class="built_in">push_back</span>(w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 员工分组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetGroup</span><span class="params">(multimap&lt;<span class="type">int</span>, Worker&gt; &amp;m, vector&lt;Worker&gt; &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(vector&lt;Worker&gt;::const_iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 随机产生员工编号</span></span><br><span class="line">        <span class="type">int</span> deptID = <span class="built_in">rand</span>() % <span class="number">3</span>; <span class="comment">// 0 1 2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将员工插入到分组中，即将员工从 vector 中取出放到 map 中</span></span><br><span class="line">        m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(deptID, *it));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShowWorkerGroup</span><span class="params">(<span class="type">const</span> multimap&lt;<span class="type">int</span>, Worker&gt; &amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 0 A B C  1 D E   2 F G ...</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;策划部门&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 可以将 pos 视为 it，每次自增都是指向 key 都是一样的</span></span><br><span class="line">    multimap&lt;<span class="type">int</span>, Worker&gt;::const_iterator pos = m.<span class="built_in">find</span>(DESIGN);</span><br><span class="line">    <span class="type">int</span> count = m.<span class="built_in">count</span>(DESIGN);</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; pos != m.<span class="built_in">end</span>() &amp;&amp; index &lt; count; pos++, index++)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; pos-&gt;second.Name &lt;&lt; <span class="string">&quot; 薪水：&quot;</span> &lt;&lt; pos-&gt;second.Salary &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;美术部门：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    pos = m.<span class="built_in">find</span>(ART);</span><br><span class="line">    count = m.<span class="built_in">count</span>(ART);</span><br><span class="line">    <span class="keyword">for</span>(index = <span class="number">0</span>; pos != m.<span class="built_in">end</span>() &amp;&amp; index &lt; count; pos++, index++)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; pos-&gt;second.Name &lt;&lt; <span class="string">&quot; 薪水：&quot;</span> &lt;&lt; pos-&gt;second.Salary &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;开发部门：&quot;</span> &lt;&lt; endl;    </span><br><span class="line">    pos = m.<span class="built_in">find</span>(DEV);</span><br><span class="line">    count = m.<span class="built_in">count</span>(DEV);</span><br><span class="line">    <span class="keyword">for</span>(index = <span class="number">0</span>; pos != m.<span class="built_in">end</span>() &amp;&amp; index &lt; count; pos ++, index++)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; pos-&gt;second.Name &lt;&lt; <span class="string">&quot; 薪水：&quot;</span> &lt;&lt; pos-&gt;second.Salary &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 随机数种子</span></span><br><span class="line">    <span class="built_in">srand</span>((<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">    multimap&lt;<span class="type">int</span>, Worker&gt; m;</span><br><span class="line">    vector&lt;Worker&gt; v;</span><br><span class="line">    <span class="built_in">CreateWorker</span>(v);</span><br><span class="line">    <span class="built_in">SetGroup</span>(m, v);</span><br><span class="line">    <span class="built_in">ShowWorkerGroup</span>(m);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> 当数据以键值对形式存在，可以考虑用map 或 multimap</p><h4 id="其他库"><a href="#其他库" class="headerlink" title="其他库"></a>其他库</h4><ul><li>vector模板类是一个容器类和算法系统的一部分，它支持面向容器的操作；</li><li>valarrsy类模板是面向数值计算的，不是STL的一部分；</li><li>array是为替代内置数组而设计的，它通过提供更好、更安全的接口，让数组更紧凑，效率更高。array表示长度固定的数组，因此不支持push_back()和insert()，但是提供了多个STL方法，包括begin()、end()、rbegin()、rend()。</li></ul><p>valarray类重载了所有算术运算符，使其能够用于valarray对象。对valarray对象的每一个成员进行操作可以使用：</p><p><code>target = before op obj;</code> target表示想要得到的结果；before表示之前的valarray对象；obj可以是实数，也可以是valarray对象</p><p><code>vad3 *= 2.5 // 将每个元素扩大到原先的2.5倍</code> </p><p><code>vad3 = vad1 + vad2;// vad3中元素是其余两数组对应位置元素之和 </code>  </p><h4 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h4><p><code>std::vector&lt; double &gt; payments &#123; 45.99, 39.23, 19.95, 89.01 &#125;;</code> </p><p><code>shared_ptr&lt; double &gt; pd = &#123; new double &#125;;</code> </p><p><code>std::vector&lt; int &gt; vi(&#123;10&#125;)// set 1 element to 10</code> </p><p>大括号初始化的语法对于数据类型转换的要求更严格，初始化列表的语法不允许隐式的窄化转换（double -&gt; int）。</p><p>头文件：&lt; initializer_list &gt;</p><p>这个模板类支持对象按值传递，但是其迭代器为const类型，对元素只能读而不能更改。</p><h2 id="STL-–-函数对象"><a href="#STL-–-函数对象" class="headerlink" title="STL – 函数对象"></a>STL – 函数对象</h2><h3 id="5-1-函数对象的概念及使用方式"><a href="#5-1-函数对象的概念及使用方式" class="headerlink" title="5.1 函数对象的概念及使用方式"></a>5.1 函数对象的概念及使用方式</h3><p><strong>概念：</strong> </p><ul><li>重载函数调用操作符的类，其对象常称为函数对象</li><li>函数对象使用重载的()时，行为类似函数调用，也叫仿函数</li></ul><p><strong>本质：</strong> </p><ul><li>函数对象(仿函数)是一个类，不是一个函数</li></ul><p><strong>使用：</strong> </p><p><strong>特点：</strong> </p><ul><li>函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值</li><li>函数对象超出普通函数的概念，函数对象可以有自己的状态</li><li>函数对象可以作为参数传递</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、函数对象在使用时，可以像普通函数一样，可以有参数、返回值</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyAdd</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val1, <span class="type">int</span> val2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val1 + val2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyAdd myAdd;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">myAdd</span>(<span class="number">10</span>, <span class="number">10</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、函数对象可以有自己的状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyPrint</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string test)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; test &lt;&lt; endl;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyPrint myPrint;</span><br><span class="line">    <span class="built_in">myPrint</span>(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">    <span class="built_in">myPrint</span>(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">    <span class="built_in">myPrint</span>(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;MyPrint调用次数：&quot;</span> &lt;&lt; myPrint.count &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、函数对象可以作为参数传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoPrint</span><span class="params">(MyPrint &amp;mp, string test)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 调用仿函数</span></span><br><span class="line">    <span class="built_in">mp</span>(test);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyPrint myPrint;</span><br><span class="line">    <span class="comment">// 函数对象做实参</span></span><br><span class="line">    <span class="built_in">DoPrint</span>(myPrint, <span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// test01();</span></span><br><span class="line">    <span class="comment">// test02();</span></span><br><span class="line">    <span class="built_in">test03</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> 仿函数写法非常灵活，可以作为参数进行传递。</p><h3 id="谓词"><a href="#谓词" class="headerlink" title="谓词"></a>谓词</h3><ul><li><p>返回bool类型的仿函数称为<strong>谓词</strong> </p></li><li><p>一元谓词：如果operator()接受一个参数，那么叫做<strong>一元谓词</strong> </p></li><li><p>二元谓词：如果operator()接受两个参数，那么叫做<strong>二元谓词</strong></p></li></ul> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仿函数   返回值是bool类型，称为谓词</span></span><br><span class="line"><span class="comment">// 一元谓词</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GreaterThanFive</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val &gt; <span class="number">5</span>; <span class="comment">// 大于5为真</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        v.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 查找容器中有没有大于5的数字</span></span><br><span class="line">    <span class="comment">// 算法：find_if    找到的是 vector 中第一个符合要求的数据，并返回指向它的迭代器</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::const_iterator pos = <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">GreaterThanFive</span>());   </span><br><span class="line">    <span class="comment">// GreaterThanFive() 创建匿名函数对象</span></span><br><span class="line">    <span class="keyword">if</span>(pos == v.<span class="built_in">end</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;未找到&quot;</span> &lt;&lt; endl; </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;找到了大于5的数字：&quot;</span> &lt;&lt; *pos &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二元谓词，即参数是两个，返回值为 bool 类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyCompare</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val1, <span class="type">int</span> val2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val1 &gt; val2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::const_iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sort 默认从小到大，升序，所需为降序则需要以下操作</span></span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">MyCompare</span>());  <span class="comment">// 还是匿名函数对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> 有几个参数就是几元谓词</p><h3 id="内建函数对象"><a href="#内建函数对象" class="headerlink" title="内建函数对象"></a>内建函数对象</h3><p><strong>概念：</strong> </p><ul><li>STL内建了一些函数对象</li></ul><p><strong>分类:</strong> </p><ul><li>算术仿函数</li><li>关系仿函数</li><li>逻辑仿函数</li></ul><p><strong>用法：</strong> </p><p>这些仿函数所产生的对象，用法和一般函数完全相同</p><p>使用内建函数对象，需要引入头文件 #include<functional></p><h4 id="算数函数对象"><a href="#算数函数对象" class="headerlink" title="算数函数对象"></a>算数函数对象</h4><p><strong>功能描述：</strong> </p><ul><li>实现四则运算</li><li>其中negate是一元运算，其他都是二元运算</li></ul><p><strong>仿函数原型：</strong> </p><ul><li>template<class T> T plus<T> &#x2F;&#x2F;加法仿函数</li><li>template<class T> T minus<T> &#x2F;&#x2F;减法仿函数</li><li>template<class T> T multiplies<T> &#x2F;&#x2F;乘法仿函数</li><li>template<class T> T divides<T> &#x2F;&#x2F;除法仿函数</li><li>template<class T> T modulus<T> &#x2F;&#x2F;取模仿函数</li><li>template<class T> T negate<T> &#x2F;&#x2F;取反仿函数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">仿函数原型：</span><br><span class="line">template&lt;class T&gt; T plus&lt;T&gt; //加法仿函数</span><br><span class="line">template&lt;class T&gt; T minus&lt;T&gt; //减法仿函数</span><br><span class="line">template&lt;class T&gt; T multiplies&lt;T&gt; //乘法仿函数</span><br><span class="line">template&lt;class T&gt; T divides&lt;T&gt; //除法仿函数</span><br><span class="line">template&lt;class T&gt; T modulus&lt;T&gt; //取模仿函数</span><br><span class="line">template&lt;class T&gt; T negate&lt;T&gt; //取反仿函数</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">// negate</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">    negate&lt;int&gt; n;  // 加负号</span><br><span class="line">    cout &lt;&lt; n(50) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">    plus&lt;int&gt; p;</span><br><span class="line">    cout &lt;&lt; p(10, 20) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    test01();</span><br><span class="line">    test02();</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> 使用内建函数对象时，需要引入头文件 #include <functional></p><h4 id="关系仿函数"><a href="#关系仿函数" class="headerlink" title="关系仿函数"></a>关系仿函数</h4><p><strong>功能描述：</strong> </p><ul><li>实现关系对比</li></ul><p><strong>仿函数原型：</strong> </p><ul><li>template<class T> bool equal_to<T> &#x2F;&#x2F;等于</li><li>template<class T> bool not_equal_to<T> &#x2F;&#x2F;不等于</li><li>template<class T> bool greater<T> &#x2F;&#x2F;大于</li><li>template<class T> bool greater_equal<T> &#x2F;&#x2F;大于等于</li><li>template<class T> bool less<T> &#x2F;&#x2F;小于</li><li>template<class T> bool less_equal<T> &#x2F;&#x2F;小于等于</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">仿函数原型：</span></span><br><span class="line"><span class="comment">template&lt;class T&gt; bool equal_to&lt;T&gt; //等于</span></span><br><span class="line"><span class="comment">template&lt;class T&gt; bool not_equal_to&lt;T&gt; //不等于</span></span><br><span class="line"><span class="comment">template&lt;class T&gt; bool greater&lt;T&gt; //大于</span></span><br><span class="line"><span class="comment">template&lt;class T&gt; bool greater_equal&lt;T&gt; //大于等于</span></span><br><span class="line"><span class="comment">template&lt;class T&gt; bool less&lt;T&gt; //小于</span></span><br><span class="line"><span class="comment">template&lt;class T&gt; bool less_equal&lt;T&gt; //小于等于</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内建函数对象——关系仿函数</span></span><br><span class="line"><span class="comment">// 大于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyCompare</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T val1, T val2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val1 &gt; val2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::const_iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Print</span>(v);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());   <span class="comment">// 从小到大的顺序</span></span><br><span class="line">    <span class="built_in">Print</span>(v);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从大到小的顺序，这里使用的是自己实现的 模板 类型数据的</span></span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">MyCompare</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    <span class="built_in">Print</span>(v);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用</span></span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    <span class="built_in">Print</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> 关系仿函数中最常用的就是greater&lt;&gt;大于</p><h4 id="逻辑仿函数"><a href="#逻辑仿函数" class="headerlink" title="逻辑仿函数"></a>逻辑仿函数</h4><p><strong>功能描述：</strong> </p><ul><li>实现逻辑运算</li></ul><p><strong>函数原型：</strong> </p><ul><li>template<class T> bool logical_and<T> &#x2F;&#x2F;逻辑与</li><li>template<class T> bool logical_or<T> &#x2F;&#x2F;逻辑或</li><li>template<class T> bool logical_not<T> &#x2F;&#x2F;逻辑非</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">仿函数原型：</span></span><br><span class="line"><span class="comment">template&lt;class T&gt; bool logical_and&lt;T&gt; //逻辑与</span></span><br><span class="line"><span class="comment">template&lt;class T&gt; bool logical_or&lt;T&gt; //逻辑或</span></span><br><span class="line"><span class="comment">template&lt;class T&gt; bool logical_not&lt;T&gt; //逻辑非</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">bool</span>&gt; &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(vector&lt;<span class="type">bool</span>&gt;::const_iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;   <span class="comment">// 只支持内置数据类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt; v;</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="literal">true</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="literal">false</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="literal">true</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Print</span>(v);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逻辑非   将容器 v 搬运到 v2中， 并执行逻辑非操作</span></span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt; v2;</span><br><span class="line">    v2.<span class="built_in">resize</span>(v.<span class="built_in">size</span>());</span><br><span class="line">    <span class="built_in">transform</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), <span class="built_in">logical_not</span>&lt;<span class="type">bool</span>&gt;());</span><br><span class="line">    <span class="built_in">Print</span>(v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> 逻辑仿函数实际应用较少，了解即可</p><h2 id="STL-–-常用算法"><a href="#STL-–-常用算法" class="headerlink" title="STL – 常用算法"></a>STL – 常用算法</h2><p><strong>概述:</strong> </p><ul><li>算法主要是由头文件 <algorithm> <functional> <numeric> 组成。</li><li><algorithm> 是所有STL头文件中最大的一个，范围涉及到比较、 交换、查找、遍历操作、复制、修改等等</li><li><numeric> 体积很小，只包括几个在序列上面进行简单数学运算的模板函数</li><li><functional> 定义了一些模板类,用以声明函数对象。</li></ul><h3 id="常用遍历算法"><a href="#常用遍历算法" class="headerlink" title="常用遍历算法"></a>常用遍历算法</h3><p><strong>学习目标：</strong> </p><ul><li>掌握常用的遍历算法</li></ul><p><strong>算法简介：</strong> </p><ul><li>for_each(iterator beg, iterator end, _func);  &#x2F;&#x2F;遍历容器</li><li>transform(iterator beg1, iterator end1, iterator beg2, _func);  &#x2F;&#x2F;搬运容器到另一个容器中</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for_each(iterator beg, iterator end, _func);</span></span><br><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print01</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数对象</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Print02</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for_each() 基本用法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v = &#123; <span class="number">10</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span> &#125;;     <span class="comment">// 列表初始化</span></span><br><span class="line"></span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), Print01);  <span class="comment">// // 可能是为了区分匿名对象和普通函数，这里的函数调用不需要加括号</span></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">Print02</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常用遍历算法，搬运 transform()</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Transform</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Print</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        v.<span class="built_in">push_back</span>(i);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vTarget;</span><br><span class="line">    <span class="comment">// 预先分配空间</span></span><br><span class="line">    vTarget.<span class="built_in">resize</span>(v.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">transform</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>(), <span class="built_in">Transform</span>());    <span class="comment">// 将 v 中数据复制到 vTarget</span></span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">Print</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    for_each(vTarget.<span class="built_in">begin</span>(), vTarget.<span class="built_in">end</span>(), <span class="built_in">Print</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// for_each(iterator beg, iterator end, _func);</span></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// transform(iterator beg1, iterator end1, iterator beg2, _func);</span></span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**总结： ** </p><ul><li>for_each在实际开发中是最常用遍历算法，需要熟练掌握</li><li>搬运的目标容器必须要提前开辟空间，否则无法正常搬运</li></ul><h3 id="常用查找算法"><a href="#常用查找算法" class="headerlink" title="常用查找算法"></a>常用查找算法</h3><p><strong>学习目标：</strong> </p><ul><li>掌握常用的查找算法</li></ul><p><strong>算法简介：</strong></p><ul><li>查找具体元素，找到则返回该元素的第一个位置，找不到则返回end()：find(iterator beg, iterator end, value);</li><li>查找满足条件的元素，找到则返回该元素的第一个位置，找不到则返回end()：find_if(iterator beg, iterator end, _Pred);</li><li>查找相邻重复元素：adjacent_find(iterator beg, iterator end); 返回两个中靠前的那个</li><li>二分查找：bool binary_search(iterator beg, iterator end, value);</li><li>&#x2F;&#x2F; count(iterator beg, iterator end, value);    </li><li>&#x2F;&#x2F; 用于自定义数据类型的案例比较简单，差别在于查找的元素类型，还需要重载 &#x3D;&#x3D; 运算符，不再写。</li><li>统计满足条件的元素的个数：count_if(iterator beg, iterator end, _Pred);</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">iterator beg    初始位置迭代器</span></span><br><span class="line"><span class="comment">iterator end    末尾位置迭代器</span></span><br><span class="line"><span class="comment">_Pred   谓词</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找具体元素：find(iterator beg, iterator end, value);</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        v.<span class="built_in">push_back</span>(i+<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找容器中是否有 5 </span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::const_iterator pos = <span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span>(pos == v.<span class="built_in">end</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;查无此项&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;找到了&quot;</span> &lt;&lt; *pos &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 友元</span></span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, <span class="type">const</span> Person *p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造</span></span><br><span class="line">    <span class="built_in">Person</span>() &#123; &#125;</span><br><span class="line">    <span class="built_in">Person</span>(string name, <span class="type">int</span> age) : <span class="built_in">Name</span>(name), <span class="built_in">Age</span>(age) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Person &amp;p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;Name == p.Name &amp;&amp; <span class="keyword">this</span>-&gt;Age == p.Age)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    string Name;</span><br><span class="line">    <span class="type">int</span> Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, <span class="type">const</span> Person &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; p.Name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p.Age &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建数据</span></span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span>, <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">15</span>)</span>, <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">20</span>)</span>, <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 放进 vector</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p4);</span><br><span class="line"></span><br><span class="line">    vector&lt;Person&gt;::const_iterator pos = <span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), p2);</span><br><span class="line">    <span class="keyword">if</span>(pos == v.<span class="built_in">end</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;查无此项&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;找到了&quot;</span> &lt;&lt; *pos &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找满足条件的第一个元素：find_if(iterator beg, iterator end, _Pred);</span></span><br><span class="line"><span class="comment">// 内置数据类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GreaterThanFive</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val &gt; <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        v.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 需要一个一元谓词</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::const_iterator pos = <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">GreaterThanFive</span>());</span><br><span class="line">    <span class="keyword">if</span>(pos == v.<span class="built_in">end</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;查无此项&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span>    </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;找到了：&quot;</span> &lt;&lt; *pos &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义数据类型，这部分不需要重载 == 运算符</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">OlderThan20</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Person &amp;p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p.Age &gt; <span class="number">20</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test04</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建数据</span></span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">15</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 放进 vector</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p4);</span><br><span class="line"></span><br><span class="line">    vector&lt;Person&gt;::const_iterator pos = <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">OlderThan20</span>());</span><br><span class="line">    <span class="keyword">if</span>(pos == v.<span class="built_in">end</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;查无此项&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;找到了：&quot;</span> &lt;&lt; *pos &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找相邻重复元素：adjacent_find(iterator beg, iterator end); 返回两个中靠前的那个</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test05</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::const_iterator pos = <span class="built_in">adjacent_find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">if</span>(pos == v.<span class="built_in">end</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;查无此项&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;找到了：&quot;</span> &lt;&lt; *pos &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分查找：bool binary_search(iterator beg, iterator end, value);</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test06</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        v.<span class="built_in">push_back</span>(i);</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> ret = <span class="built_in">binary_search</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;在序列中找到了目标元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;查无此项&quot;</span> &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// count(iterator beg, iterator end, value);    </span></span><br><span class="line"><span class="comment">// 用于自定义数据类型的案例比较简单，差别在于查找的元素类型，还需要重载 == 运算符，不再写。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test07</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = <span class="built_in">count</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;num of 4 = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 统计满足条件的元素的个数：count_if(iterator beg, iterator end, _Pred);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GreaterThan4</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val &gt; <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test08</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">7</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = <span class="built_in">count_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">GreaterThan4</span>());</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;比4大的数有：&quot;</span> &lt;&lt; num &lt;&lt; <span class="string">&quot;个&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义数据类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">YoungerThan35</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Person &amp;p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p.Age &lt; <span class="number">35</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test09</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备数据</span></span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">35</span>)</span>, <span class="title">p2</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">35</span>)</span>, <span class="title">p3</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">35</span>)</span>, <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">25</span>)</span>, <span class="title">p5</span><span class="params">(<span class="string">&quot;小乔&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 放进 vector</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p4);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p5);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = <span class="built_in">count_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">YoungerThan35</span>());</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;列表中年龄小于35岁的有：&quot;</span> &lt;&lt; num &lt;&lt; <span class="string">&quot;个&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// find(iterator beg, iterator end, value);</span></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find_if(iterator beg, iterator end, _Pred);</span></span><br><span class="line">    <span class="built_in">test03</span>();</span><br><span class="line">    <span class="built_in">test04</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// adjacent_find(iterator beg, iterator end);</span></span><br><span class="line">    <span class="built_in">test05</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二分查找指定元素是否存在：bool binary_search(iterator beg, iterator end, value); 不可用于无序序列</span></span><br><span class="line">    <span class="built_in">test06</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// count(iterator beg, iterator end, value);</span></span><br><span class="line">    <span class="built_in">test07</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// count_if(iterator beg, iterator end, _Pred);</span></span><br><span class="line">    <span class="built_in">test08</span>();</span><br><span class="line">    <span class="built_in">test09</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> </p><ul><li><p>利用find可以在容器中找指定的元素，返回值是迭代器</p></li><li><p>find_if按条件查找使查找更加灵活，提供的仿函数可以改变不同的策略</p></li><li><p>面试题中如果出现查找相邻重复元素，记得用STL中的adjacent_find算法</p></li><li><p>二分查找法查找效率很高，值得注意的是查找的容器中元素必须的有序序列</p></li><li><p>按值统计用count，按条件统计用count_if</p></li></ul><h3 id="常用排序算法"><a href="#常用排序算法" class="headerlink" title="常用排序算法"></a>常用排序算法</h3><p><strong>学习目标：</strong> </p><ul><li>掌握常用的排序算法</li></ul><p><strong>算法简介：</strong> </p><ul><li>排序：sort(iterator beg, iterator end, _Pred);   &#x2F;&#x2F; 默认从小到大</li><li>洗牌：random_shuffle(iterator beg, iterator end);</li><li>合并容器：merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</li><li>反转：reverse(iterator beg, iterator end);</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 排序：sort(iterator beg, iterator end, _Pred);   // 默认从小到大</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::const_iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Descending</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val1, <span class="type">int</span> val2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val1 &gt; val2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v = &#123; <span class="number">10</span>, <span class="number">30</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">20</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sort 默认 升序</span></span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Print</span>(v);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 降序</span></span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">Descending</span>());</span><br><span class="line">    <span class="built_in">Print</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 洗牌：random_shuffle(iterator beg, iterator end);</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>((<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        v.<span class="built_in">push_back</span>(i);</span><br><span class="line"></span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">MyPrint</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打乱顺序</span></span><br><span class="line">    <span class="comment">// random_shuffle(v.begin(), v.end()); // 在 VS 里没问题</span></span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">MyPrint</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 3 8 5 2 1 7 0 9 4 6</span></span><br><span class="line">    <span class="comment">// 5 3 9 8 0 7 2 6 1 4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并容器：merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v1, v2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">        v2.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vTarget;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目标容器需要提前开辟空间</span></span><br><span class="line">    vTarget.<span class="built_in">resize</span>(v1.<span class="built_in">size</span>() + v2.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并 需要两个有序序列</span></span><br><span class="line">    <span class="built_in">sort</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">sort</span>(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">merge</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(),vTarget.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">    for_each(vTarget.<span class="built_in">begin</span>(), vTarget.<span class="built_in">end</span>(), <span class="built_in">MyPrint</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 翻转：reverse(iterator beg, iterator end);</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test04</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v = &#123; <span class="number">10</span>, <span class="number">30</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">20</span> &#125;;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;翻转前：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">MyPrint</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;翻转后：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">reverse</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">MyPrint</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// sort(iterator beg, iterator end, _Pred);</span></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// random_shuffle(iterator beg, iterator end);</span></span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</span></span><br><span class="line">    <span class="built_in">test03</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reverse(iterator beg, iterator end);</span></span><br><span class="line">    <span class="built_in">test04</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> </p><ul><li>sort属于开发中最常用的算法之一，需熟练掌握</li><li>random_shuffle洗牌算法比较实用，使用时记得加随机数种子</li><li>merge合并的两个容器必须是有序序列</li><li>reverse反转区间内元素，面试题可能涉及到</li></ul><h3 id="常用拷贝和替换算法"><a href="#常用拷贝和替换算法" class="headerlink" title="常用拷贝和替换算法"></a>常用拷贝和替换算法</h3><p><strong>学习目标：</strong> </p><ul><li>掌握常用的拷贝和替换算法</li></ul><p><strong>算法简介：</strong> </p><ul><li>copy(iterator beg, iterator end, iterator dest);  &#x2F;&#x2F; 容器内指定范围的元素拷贝到另一容器中</li><li>replace(iterator beg, iterator end, oldvalue, newvalue);  &#x2F;&#x2F; 将容器内指定范围的旧元素修改为新元素</li><li>replace_if(iterator beg, iterator end, _pred, newvalue); &#x2F;&#x2F; 按条件替换元素，满足条件的替换成指定元素</li><li>swap(container c1, container c2);  &#x2F;&#x2F; 互换两个容器的元素</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyPrint</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// copy(iterator beg, iterator end, iterator dest);</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v1, v2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">    </span><br><span class="line">    v2.<span class="built_in">resize</span>(v1.<span class="built_in">size</span>());   <span class="comment">// 提前申请空间</span></span><br><span class="line">    <span class="built_in">copy</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">    for_each(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), <span class="built_in">MyPrint</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v = &#123; <span class="number">20</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">10</span>, <span class="number">20</span> &#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;替换前：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">MyPrint</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将容器中的 20 替换成 2000</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;替换后：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">replace</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">20</span>, <span class="number">2000</span>);</span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">MyPrint</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// replace_if(iterator beg, iterator end, _pred, newvalue);</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Greater_equal30</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val &gt; <span class="number">30</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v = &#123; <span class="number">20</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">10</span>, <span class="number">20</span> &#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;替换前：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">MyPrint</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将容器中 大于等于 30 的数 替换成 3000</span></span><br><span class="line">    <span class="built_in">replace_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">Greater_equal30</span>(), <span class="number">3000</span>);</span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">MyPrint</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// swap(container c1, container c2);</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test04</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v1, v2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        v1.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">        v2.<span class="built_in">push_back</span>(i + <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;交换前：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    for_each(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), <span class="built_in">MyPrint</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    for_each(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), <span class="built_in">MyPrint</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">swap</span>(v1, v2);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;交换后：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    for_each(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), <span class="built_in">MyPrint</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    for_each(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), <span class="built_in">MyPrint</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// copy(iterator beg, iterator end, iterator dest);</span></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// replace(iterator beg, iterator end, oldvalue, newvalue);</span></span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// replace_if(iterator beg, iterator end, _pred, newvalue);</span></span><br><span class="line">    <span class="built_in">test03</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// swap(container c1, container c2);</span></span><br><span class="line">    <span class="built_in">test04</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> </p><ul><li>利用copy算法在拷贝时，目标容器记得提前开辟空间</li><li>replace会替换区间内满足条件的元素</li><li>replace_if按条件查找，可以利用仿函数灵活筛选满足的条件</li></ul><h3 id="常用算术生成算法"><a href="#常用算术生成算法" class="headerlink" title="常用算术生成算法"></a>常用算术生成算法</h3><p><strong>学习目标：</strong> </p><ul><li>掌握常用的算术生成算法</li></ul><p><strong>注意：</strong> </p><ul><li>算术生成算法属于小型算法，使用时包含的头文件为 #include <numeric></li></ul><p><strong>算法简介：</strong></p><ul><li>accumulate(iterator beg, iterator end, value);   &#x2F;&#x2F; 计算容器元素累计总和</li><li>fill(iterator beg, iterator end, value);    向容器中添加元素</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// accumulate(iterator beg, iterator end, value);</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++)</span><br><span class="line">        v.<span class="built_in">push_back</span>(i);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第三个参数是 算术运算开始前 total 的初始值</span></span><br><span class="line">    <span class="type">int</span> total = <span class="built_in">accumulate</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;total = &quot;</span> &lt;&lt; total &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fill(iterator beg, iterator end, value);</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyPrint</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line">    v.<span class="built_in">resize</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fill</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">MyPrint</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// accumulate(iterator beg, iterator end, value);</span></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fill(iterator beg, iterator end, value);</span></span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> </p><ul><li><p>accumulate使用时头文件注意是 numeric，这个算法很实用</p></li><li><p>利用fill可以将容器区间内元素填充为 指定的值</p></li></ul><h3 id="常用集合算法"><a href="#常用集合算法" class="headerlink" title="常用集合算法"></a>常用集合算法</h3><p><strong>学习目标：</strong> </p><ul><li>掌握常用的集合算法</li></ul><p><strong>算法简介：</strong> </p><ul><li>set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);    &#x2F;&#x2F; 求两个集合的交集</li><li>set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);    &#x2F;&#x2F; 求两个集合的并集</li><li>set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);    &#x2F;&#x2F; 求两个集合的差集</li><li><strong>注意:两个集合必须是有序序列</strong></li></ul><p><strong>总结：</strong> </p><ul><li>使用集合算法的前提是两个目标集合必须是有序集合；</li><li>求交集时，vTarget.resize(min(v1.size(),v2.size()))，求并集时，vTarget.resize(v1.size() + v2.size())，求差集时，vTarget.resize(max(v1.size(), v2.size()))；</li><li>常用集合算法的返回值都是结果中最后一个元素的位置。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyPrint</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交集：set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v1, v2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">        v2.<span class="built_in">push_back</span>(i + <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vTarget;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取两个 容器中容量最小的那个 为基准开辟空间</span></span><br><span class="line">    v1.<span class="built_in">size</span>() &gt; v2.<span class="built_in">size</span>() ? vTarget.<span class="built_in">resize</span>(v2.<span class="built_in">size</span>()): vTarget.<span class="built_in">resize</span>(v1.<span class="built_in">size</span>());</span><br><span class="line">    <span class="comment">// vTarget(min(v1.size(), v2.size()));</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回目标容器的最后一个元素的迭代器地址，这里其实不需要接收迭代器</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::const_iterator itEnd = </span><br><span class="line">            <span class="built_in">set_intersection</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line">    for_each(vTarget.<span class="built_in">begin</span>(), vTarget.<span class="built_in">end</span>(), <span class="built_in">MyPrint</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并集：set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v1, v2, vTarget;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">        v2.<span class="built_in">push_back</span>(i + <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取两容器容量之和给目标容器开辟空间</span></span><br><span class="line">    vTarget.<span class="built_in">resize</span>(v1.<span class="built_in">size</span>() + v2.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回目标容器的最后一个元素的迭代器地址，这里其实也不需要接收迭代器</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::const_iterator itEnd = </span><br><span class="line">            <span class="built_in">set_union</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line">    for_each(vTarget.<span class="built_in">begin</span>(), vTarget.<span class="built_in">end</span>(), <span class="built_in">MyPrint</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v1, v2, vTarget;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">        v2.<span class="built_in">push_back</span>(i + <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取两个容器中容量较大的那个为基准开辟空间</span></span><br><span class="line">    <span class="comment">// vTarget.resize(max(v1.size(), v2.size()));</span></span><br><span class="line">    v1.<span class="built_in">size</span>() &gt; v2.<span class="built_in">size</span>() ? vTarget.<span class="built_in">resize</span>(v1.<span class="built_in">size</span>()) : vTarget.<span class="built_in">resize</span>(v2.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回目标容器的最后一个元素的迭代器地址，这里其实还是不需要接收迭代器</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::const_iterator itEnd =</span><br><span class="line">            <span class="built_in">set_difference</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v1 与 v2 的差集：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    for_each(vTarget.<span class="built_in">begin</span>(), vTarget.<span class="built_in">end</span>(), <span class="built_in">MyPrint</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    itEnd = <span class="built_in">set_difference</span>(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v2 与 v1 的差集：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    for_each(vTarget.<span class="built_in">begin</span>(), vTarget.<span class="built_in">end</span>(), <span class="built_in">MyPrint</span>());</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</span></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</span></span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</span></span><br><span class="line">    <span class="built_in">test03</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="输出、输出和文件"><a href="#输出、输出和文件" class="headerlink" title="输出、输出和文件"></a>输出、输出和文件</h2><p>目前为止，接触得最多的是cin和cout对象，但是对于iostream中定义的输入方法以及输出格式化等相关内容现有涉猎，因此，这一张便是为了细细揣摩C++中输入输出流的一些内容</p><h3 id="流和缓冲区"><a href="#流和缓冲区" class="headerlink" title="流和缓冲区"></a>流和缓冲区</h3><p>C++程序将输入和输出看作字节流。输入时，程序从输入流中截取字节；输出时，将字节插入到输出流中。对面向文本的程序，每个字节代表一个字符，更通俗的说，字节可以构成字符或数字数据的二进制表示。C++程序只是检查字节流，而不需要知道字节来自何方。同理，通过使用流，C++程序处理输出的方式将独立于其去向。因此，管理输入包含两步：</p><ul><li>将流与输入去向的程序关联起来</li><li>将流与文件连接</li></ul><p>就像灌溉农田时，需要使用管道将水原与稻田连接。通常，通过缓冲区可以更高效地处理输入和输出。缓冲区是用做中介的内存块，它是将信息从设备传输到程序或者反过程的临时存储工具。缓冲区的大小一般为512个字节或者这个数据的整数倍。每次输出时都会刷新输出缓冲区，以备下一批输出使用。</p><p>定义在iostream中专门设计用来实现管理流和缓冲区的类</p><table><thead><tr><th>类</th><th>用途</th></tr></thead><tbody><tr><td>streambuf</td><td>为缓冲区提供方法，并提供了用于填充缓冲区、访问缓冲区内容、刷新缓冲区和管理缓冲区的类方法</td></tr><tr><td>ios_base</td><td>表示流的一般特征，如是否可读取、是二进制还是文本流等</td></tr><tr><td>ios</td><td>基于ios_base，其中包含一个指向streambuf对象的指针成员</td></tr><tr><td>ostream</td><td>从ios类派生而来的，提供输出方法</td></tr><tr><td>istream</td><td>从ios类派生而来，提供输入方法</td></tr><tr><td>iostream</td><td>基于istream和ostream类，继承了输入和输出方法</td></tr></tbody></table><ul><li>cin对象对应标准输入流。在默认情况下，这个流被关联到标准输入设备（一般为键盘），wcin对象与此类似但处理的是wchar_t类型</li><li>cout对象与输出标准流对应。在默认情况下，这个流被关联到标准输出设备（一般为显示器），wcout对象与此类似，但处理的是wchar_t类型</li><li>cerr对象与标准错误流相对应，可用于显示错误消息。默认被关联到标准输出设备。没有缓冲，wcerr对象与此类似但处理的是wchar_t类型</li><li>clog对象也对应标准错误流，默认标准输出设备。wclog对象与此类似，但处理的是wchar_t类型</li><li>对象代表流iostream文件为程序声明一个cout对象时，该对象包含存储了与输出有关的信息的数据成员</li></ul><h3 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h3><p>没怎么看懂</p><h3 id="关于输出"><a href="#关于输出" class="headerlink" title="关于输出"></a>关于输出</h3><p>ostream中重新定义的 &lt;&lt; 运算符称为 插入运算符，而不是左移运算符。插入运算符被重载使得 &lt;&lt; 能够识别C++中所有基本数据类型。<br>另外，由于插入运算符重载函数的返回值是 ostream&amp; 即输出流的引用，使得输出可以连续起来，被称为链式编程。</p><p><strong>其他ostream方法</strong><br>除了各种 operator&lt;&lt;() 函数外，ostream类还提供了put()方法和write()方法前者用于显示字符，后者用于显示字符串。<br>我觉得put()方法的参数应当为 int 或者 是一个字符型，即传入浮点型会发生窄化转换，向下取整。</p><p>write()方法传入一个字符串以及一个整型数据，表示输出该字符串中的前多少个字符，该方法不会在遇到空字符串时停止打印，而是一定会打印指定数目的字符。</p><p><strong>刷新输出缓冲区</strong><br><code>cout &lt;&lt; endl;</code> 会将缓冲区的内容显示到显示器，在最后添加换行符并刷新缓冲区。<br>或者使用其他刷新方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">flush</span>(cout);</span><br><span class="line">cout &lt;&lt; flush;</span><br></pre></td></tr></table></figure><p><strong>使用cout进行格式化</strong><br>对于浮点数，默认被显示为六位，末尾0不显示（显示的数字位数与数字被存储时的位数没有任何关系，党支书大于等于6或者小于等于-5时，将使用科学计数法表示数字。另外，字段宽度恰好容纳数字和负号（如果有的话）</p><p>控制进制：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; hex;</span><br><span class="line">cout &lt;&lt; dec;</span><br><span class="line">cout &lt;&lt; oct;</span><br></pre></td></tr></table></figure><p>控制字段宽度：</p><p><code>cout.width(12);</code> 设置字段宽度为12，默认右对齐。注意width()方法成员函数，必须使用对象（这里是cout）来调用它。并且在输出一个“项目”之后，字符宽度恢复为默认值。<br>C++不会截断数据，在数据位数大于位宽时，会自动提升位宽。</p><p><strong>填充字符</strong><br><code>cout.fill(&#39;*&#39;);</code> 将字段中未使用的部分填充为’*’。新填充的内容将一直有效，直到被更改。</p><p><strong>设置浮点数的显示精度</strong><br>浮点数京都的含义取决于输出模式。在默认模式下，指的是显示的总位数，即<code>cout.precision(2);</code> 是将显示的总位数设置为2，而不是保留两位小数。精度设置之后，将一直有效直到被修改。</p><p><strong>打印末尾的和小数点</strong><br><code>cout.setf(ios_base::showpoint);</code> 默认精度为6位。</p><p><strong>再谈setf</strong> </p><table><thead><tr><th>常量</th><th>含义</th></tr></thead><tbody><tr><td>ios_base::boolalpha</td><td>输入和输出bool值。可以为true或false</td></tr><tr><td>ios_base::showbase</td><td>对于输出，使用C++基数前缀（0，0x）</td></tr><tr><td>ios_base::showpoint</td><td>显示末尾小数点</td></tr><tr><td>ios_base::uppercase</td><td>对于十六进制，使用大写字母E，表示法</td></tr><tr><td>ios_base::showpos</td><td>显示正号</td></tr></tbody></table><table><thead><tr><th>第二个参数</th><th>第一个参数</th><th>含义</th></tr></thead><tbody><tr><td>ioos_base::basefield</td><td>ios_base::dec</td><td>使用基数10</td></tr><tr><td></td><td>ios_base::oct</td><td>使用基数8</td></tr><tr><td></td><td>ios_base::hex</td><td>使用基数16</td></tr><tr><td>ios_base::floatfield</td><td>ios_base::fixed</td><td>定点计数法</td></tr><tr><td></td><td>ios_base::scientific</td><td>科学计数法</td></tr><tr><td>ios_base::adjustfield</td><td>ios_base::left</td><td>左对齐</td></tr><tr><td></td><td>ios_base::right</td><td>右对齐</td></tr><tr><td></td><td>ios_base::internal</td><td>符号或基数前缀左对齐，值右对齐</td></tr></tbody></table><p><strong>标准控制符</strong><br>使用setf不是进行格式化的、对用户最友好的方式。C++提供了多个控制符，能够调用setf（），不能改自动提供正确的参数。<br><code>cout &lt;&lt; left &lt;&lt; fixed;</code><br>左对齐、定点小数模式</p><p><strong>iomanip头文件</strong><br>使用iostream工具来设置一些格式值（如字段宽度，每次使用都要着重新设置），为了简化工作，C++在iomanip头文件中提供了其他一些口感支付，能够提供前面讨论过的功能，而且使用起来更为方便。</p><ul><li>setprecisio()、stefill(char)和stew()，分别用于设置精度、填充字符和设置字段宽度。</li></ul><p><code>cout &lt;&lt; stew(6) &lt;&lt; setprecision(4) &lt;&lt; setfill(&#39;.&#39;);</code> </p><p>​ <font size=3 color=red>一些标准控制符：</font></p><table><thead><tr><th>操纵符</th><th>调用</th><th>操纵符</th><th>调用</th></tr></thead><tbody><tr><td>boolalpha</td><td>setf(ios_base::boolalpha)</td><td>nouppercase</td><td>unsetf(ios_base::nouppercase)</td></tr><tr><td>noboolalpha</td><td>unsetf(ios_base::noboolalpha)</td><td>iternal</td><td>setf(ios_base::iternal, ios_base::adjustfield)</td></tr><tr><td>showbase</td><td>setf(ios_base::showbase</td><td>left</td><td>setf(ios_base::left, ios_base::adjustfield)</td></tr><tr><td>noshowbase</td><td>unsetf(ios_base::showbase)</td><td>right</td><td>setf(ios_base::right, ios_base::adjustfield)</td></tr><tr><td>showpoint</td><td>setf(ios_base::showpoint)</td><td>dec</td><td>setf(ios-base::dec, ios_base::basefield)</td></tr><tr><td>noshowpoint</td><td>unsetf(ios_base::showpoint)</td><td>hex</td><td>set(ios_base::hex,ios_base::basefield)</td></tr><tr><td>showpos</td><td>setf(ios_base::showpos)</td><td>oct</td><td>stf(ios_base::oct, ios_base::oct)</td></tr><tr><td>unshowpos</td><td>unsetf(ios_base::showpos)</td><td>fixed</td><td>setf(ios_base::fixed,ios_base::floatfield)</td></tr><tr><td>uppercase</td><td>setf(ios_base::uppercase)</td><td>scientific</td><td>setf(ios_base::scientific, ios_base::floatfield)</td></tr></tbody></table><p>​                   <font size=3 color=red>格式方面的变化</font> </p><table><thead><tr><th>特性</th><th>老式C++</th><th>当前C++</th></tr></thead><tbody><tr><td>precision(n)</td><td>显示n位小数</td><td>在默认模式下，显示的总位数为n，在定点数模式和科学技术模式下，显示n位小数</td></tr><tr><td>ios_base::showpoint</td><td>显示末尾的小数点和末尾的0</td><td>显示末尾的小数点</td></tr><tr><td>ios_base::fixed,ios::base::scientific</td><td></td><td>显示末尾的0（参见关于precision的说明）</td></tr></tbody></table><h3 id="关于输入"><a href="#关于输入" class="headerlink" title="关于输入"></a>关于输入</h3><p>​<font size=3 color=red>流状态</font></p><table><thead><tr><th>成员</th><th>描述</th></tr></thead><tbody><tr><td>eofbit</td><td>如果达到文件尾则设置为1</td></tr><tr><td>badbit</td><td>流被破坏时设置为1，例如：文件读取错误</td></tr><tr><td>failbit</td><td>输入操作未能读取预期的字符或输出操作没有写入预期的字符，则设置为1</td></tr><tr><td>goodbit</td><td>另一种表示0的方法</td></tr><tr><td>good()</td><td>如果流可以使用（所有的位置都被清除），则返回true</td></tr><tr><td>eof()</td><td>如果eofbit被设置，则返回true</td></tr><tr><td>bad()</td><td>如果badbit被设置，则返回true</td></tr><tr><td>fail()</td><td>如果badbit或者failbit被设置，则返回true</td></tr><tr><td>rdstate()</td><td>返回流状态</td></tr><tr><td>exceptions()</td><td>返回一个掩码，指出哪些标记导致异常被触发</td></tr><tr><td>exceptions(iostate ex)</td><td>设置哪些状态将导致clear()引发异常，例如：如果ex时eofbit，则如果eofbit被设置，clear()将引发异常</td></tr><tr><td>clear(iostate s)</td><td>将流状态设置为s，s的默认值为0（goodbit）：如果（restate() &amp; exception()) !&#x3D; 0)，则将引发异常basic_ios::failure</td></tr><tr><td>setstate(iostate s)</td><td>调用clear(rdstate() | s)。这将设置与s中位置的为相对应的流状态位，其他流状态位保持不变</td></tr></tbody></table><p>重新设置流状态的理由：最常见的理由是，在输入不匹配或者达到文件尾时，需要使用不带参的clear()重新打开输入。</p><p><strong>I&#x2F;O异常</strong><br>主要说使用exceptions()函数，默认值为goodbit，即没有触发异常，如果设置为其他状态，则在输入流被置为相同状态时会触发异常，函数中可以使用按位或来设置两种状态。</p><p>设置状态位有一个严重的后果，在流状态为eofbit或者faibit时，无法读取流中数据，必须将流状态设置为良好，可以使用不带参的clear()。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (cin &gt;&gt; input)</span><br><span class="line">    sum += input;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Last value entered = &quot;</span> &lt;&lt; input &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Sum = &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (cin.<span class="built_in">fail</span>() &amp;&amp; !cin.<span class="built_in">eof</span>())</span><br><span class="line">&#123;</span><br><span class="line">    cin.<span class="built_in">clear</span>();    <span class="comment">// fail not eof</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isspace</span>(cin.<span class="built_in">get</span>())) </span><br><span class="line">        <span class="keyword">continue</span>;   <span class="comment">// throw away &quot;bad input&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>    <span class="comment">// else failure</span></span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;I cannot go on!\n&quot;</span>;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Now enter a new number: &quot;</span>;</span><br><span class="line">cin &gt;&gt; input;   <span class="comment">// works</span></span><br></pre></td></tr></table></figure><p><strong>其他输入方法</strong> </p><ol><li>单字符输入 <code>cin.get(char &amp;ch);</code> 可以获取空格（空白字符），直接使用<code>cin &gt;&gt;</code> 则达不到目的，而且除非输入类型不匹配才会停止输入。cin.get(char &amp;ch)不会将eof赋给ch，还将调用setstate(failbit)，导致cin的测试结果为false。<br> <code>get(void)</code> 将返回一个int或更大的整型，可以将其赋给char类型数据，但是不允许链式输入。</li></ol><table><thead><tr><th>特征</th><th>cin.get(ch)</th><th>ch &#x3D; cin.get()</th></tr></thead><tbody><tr><td>传输输入字符的方法</td><td>赋给默认参数ch</td><td>将函数返回值赋给ch</td></tr><tr><td>字符输入时函数的返回值</td><td>指向istream对象的引用</td><td>字符编码（int值）</td></tr><tr><td>到达文件尾是函数的返回值</td><td>转换为false</td><td>EOF</td></tr></tbody></table><ol start="2"><li>采用哪种但字符输入形式<br> 如果希望检查每个字符，使用get()，其中，get(char &amp;)更佳，get(void)的优点是与C语言中getchar()函数极其类似，可以用来代替getchar()，并且使用cout.put()代替putchar()。</li><li>字符串输入<br> <code>getline()  // 丢弃流中分界字符</code><br> <code>get()  // 保留流中分界字符</code><br> <code>ignore()   // 第一个参数指定要读取的最大字符数默认为1，第二个字符用作分界字符默认为EOF，导致读取指定数目的字符或读取到文件尾，函数返回值为istream &amp;</code> </li><li>意外字符串输入<br>  <strong>输入行为</strong></li></ol><table><thead><tr><th>方法</th><th>行为</th></tr></thead><tbody><tr><td>getline(char *, int)</td><td>如果没有读取任何字符（但换行符被视为读取了一个字符），则设置failbit，如果读取了最大数目的字符，但行中还有其它字符，则设置failbit</td></tr><tr><td>get(char *, int)</td><td>如果没有读取任何字符，则设置failbit</td></tr></tbody></table><ol start="5"><li>其他istream方法</li></ol><p>read()不会在输入后加上空值字符，因此不能将输入转换为字符串，最常与ostream&amp; write()结合使用，用于完成文件输入和输出。read()方法返回的是istream&amp;，所以有以下代码成立：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> gros[<span class="number">144</span>];</span><br><span class="line"><span class="type">char</span> score[<span class="number">20</span>];</span><br><span class="line">cin.<span class="built_in">read</span>(gross, <span class="number">144</span>).<span class="built_in">read</span>(score, <span class="number">20</span>);</span><br></pre></td></tr></table></figure><p>peek()函数返回输入中的下一个字符，但不抽取输入流中的字符。也就是说“只看不取”，用于判断是否进行读取操作。</p><p>gcount()方法返回最后一个非格式化抽泣方法读取的字符数。意味着字符是使用get()、getline()、ignore()或read()方法读取的，而不是由**抽取运算符&lt;&lt;**读取的，抽取运算符对输入进行格式化，使之与特定的数据类型匹配。</p><p>putback()函数将一个字符插入到输入字符串中，被插入的字符将是下一条输入语句读取的第一个字符。接受一个char类型的参数，返回istream&amp;，说明可与其他istream方法拼接起来使用。peek()就相当于使用get()读取一个字符，然后使用putback()放回去。另外，putback()函数允许将字符放在不是上一次读取操作的位置。</p><h3 id="文件-1"><a href="#文件-1" class="headerlink" title="文件"></a>文件</h3><p><code>is_open()   // member function of ifstream</code> </p><p>用来判断是否成功打开了文件</p><h2 id="C-11"><a href="#C-11" class="headerlink" title="C ++ 11"></a>C ++ 11</h2><h3 id="新类型"><a href="#新类型" class="headerlink" title="新类型"></a>新类型</h3><p>C++11 新增了类型long long 和unsigned long long 以支持64位或更宽的整型；新增了char16_t和char32_t，以支持16位或32位的字符表示；还新增了“原始”字符串。</p><h3 id="统一的初始化"><a href="#统一的初始化" class="headerlink" title="统一的初始化"></a>统一的初始化</h3><p>使用大括号括起的列表（初始化列表）的适用范围，使其可以用于所有内置类型和用户自定义类型（即类对象）。使用初始化列表时，可以使用赋值运算符也可以不使用。</p><p><font size=3 color=5>列表初始化的语法也可用于new表达式中</font></p><p><font size=3 color=5>创建对象时，也可使用大括号（而不是圆括号）括起的列表来调用构造函数。</font></p><p><font size=3 color=5>如果类有将模板std::initializer_list作为参数的构造函数，则只有构造函数可任意使用初始化列表形式。</font></p><p><strong>使用新式初始化方法的优点</strong> </p><ul><li>防止窄化操作</li><li>STL容器提供了将initializer_list作为参数模板的构造函数，除此之外，还可以将std::initializer_list用作常规函数的参数</li></ul><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><ol><li><h4 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h4></li></ol><p>C++11 将auto关键字用于实现自动类型推断。并要求显式初始化，让编译器能够变量的类型设置为初始值的类型。</p><p>可以简化模板声明（vector<int>::iterator）。</p><ol start="2"><li><h4 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h4></li></ol><p>decltype关键字将变量的类型声明为表达式指定的类型。</p><p><code>decltype(x) y;// 将y的类型设置为与x的一样</code> </p><p>功能比auto更复杂，根据使用的表达式，指定的类型可以是引用和const。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> j = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> &amp;k = j;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;n = j;</span><br><span class="line"><span class="keyword">decltype</span>(n) i1;<span class="comment">// i1 type const int&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(j) i2;<span class="comment">// i2 type int</span></span><br><span class="line"><span class="keyword">decltype</span>((j)) i3;<span class="comment">// i3 type int&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(k + <span class="number">1</span>) i4;<span class="comment">// i5 type int</span></span><br></pre></td></tr></table></figure><ol start="3"><li><h4 id="新增返回类型后置"><a href="#新增返回类型后置" class="headerlink" title="新增返回类型后置"></a>新增返回类型后置</h4></li></ol><p>C++11 新增了一种函数声明的语法：在函数名和参数列表后面（而不是前面）指定返回类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">f1</span><span class="params">(<span class="type">double</span>, <span class="type">int</span>)</span></span>;<span class="comment">// traditional syntax</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f2</span><span class="params">(<span class="type">double</span>, <span class="type">int</span>)</span> -&gt; <span class="type">double</span></span>;<span class="comment">// new syntax, return type is double</span></span><br></pre></td></tr></table></figure><p>这种语法使程序员使用decltype关键字来制定模板函数的返回类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ef</span><span class="params">(T t, U u)</span> -&gt; <span class="title">deltype</span><span class="params">(T * U)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// so something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里解决的问题是，在编译器遇到eff的参数列表前，T和U还不在作用域内，因此必须在参数列表后使用decltype。</p><p>可能是为了兼容lambda表达式</p><ol start="4"><li><h4 id="模板别名"><a href="#模板别名" class="headerlink" title="模板别名"></a>模板别名</h4></li></ol><p>对于冗长或复杂的标识符，如果能够创建其别名将很方便。以前C++为此提供了typedef：</p><p><code>typedef std::vector&lt;std::string&gt;::iterator itType;</code> </p><p>C++11提供了另一种创建别名的语法：</p><p><code>using itType = std::vector&lt;std::string&gt;::iterator;</code> </p><p>差别在于，新语法有也可以用于模板部分具体化，但是typedef不能：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">using</span> arr12 = std::array&lt;T, <span class="number">12</span>&gt;;<span class="comment">// template for multiple aliases</span></span><br></pre></td></tr></table></figure><p>上述语句具体化模板array&lt;T, int&gt; （将参数int设置为12）。则有下面语句成立：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr12&lt;<span class="type">double</span>&gt; a1;</span><br><span class="line">arr12&lt;std::string&gt; a2;</span><br></pre></td></tr></table></figure><ol start="5"><li><h4 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a>nullptr</h4></li></ol><p>安全性更高的空指针。</p><h3 id="智能指针-1"><a href="#智能指针-1" class="headerlink" title="智能指针"></a>智能指针</h3><p>C++11摒弃了auto_ptr，并且所有新增的智能指针都可以与STL以及移动语义协同工作。</p><h3 id="异常方面做出的修改"><a href="#异常方面做出的修改" class="headerlink" title="异常方面做出的修改"></a>异常方面做出的修改</h3><p>新增noexcept关键字指出方法不会出现问题。</p><h3 id="作用域内枚举"><a href="#作用域内枚举" class="headerlink" title="作用域内枚举"></a>作用域内枚举</h3><p>传统的C++枚举类型提供了一种创建名称常量的方式，缺点：</p><ul><li>类型检查相当低级。</li><li>枚举名的作用域为枚举类型定义所属的作用域，这意味着如果在同一个作用域内定义两个枚举，他们的枚举成员不能同名。</li><li>枚举可能不是可完全移植的，因为不同的实现可能选择不同的底层类型。</li></ul><p>为解决这些问题，C++11新增一种使用class或者struct定义的枚举：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">old1</span> &#123; yes, no, maybe &#125;;;<span class="comment">// traditional form</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">New1</span> &#123; never, sometimes, often, always &#125;;<span class="comment">// new form</span></span><br><span class="line"><span class="keyword">enum struct</span> <span class="title class_">New2</span> &#123; never, lever, server &#125;;<span class="comment">// new form</span></span><br></pre></td></tr></table></figure><p>新枚举类型要求显式限定，以免发生名称冲突。因此，引用特定枚举时，需要定义New1::never和New2::never等。</p><h3 id="对类的修改"><a href="#对类的修改" class="headerlink" title="对类的修改"></a>对类的修改</h3><ol><li><p>显式转换运算符</p><p> 自动类型转换可能导致意外转换的情况，为了解决这种问题，C++引入了explicit关键字，以禁止单参构造函数导致的自动转换：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Plebe</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Plebe</span>()&#123;&#125;<span class="comment">// default constructor</span></span><br><span class="line">    <span class="built_in">Plebe</span>(<span class="type">int</span>);<span class="comment">// automatic int-to-Plebe conversion</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Plebe</span><span class="params">(<span class="type">double</span>)</span></span>;<span class="comment">// require explicit use</span></span><br><span class="line">    <span class="comment">// something else</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// something else</span></span><br><span class="line">Plebe a, b;</span><br><span class="line">a = <span class="number">5</span>;<span class="comment">// implicit conversion call Plebe(5)</span></span><br><span class="line">b = <span class="number">0.5</span>;<span class="comment">// forbiden with use of explicit</span></span><br><span class="line">b = <span class="built_in">Plebe</span>(<span class="number">0.5</span>);<span class="comment">// 使用匿名对象进行赋值（注意new的使用）</span></span><br></pre></td></tr></table></figure><p> C++11拓展了explicit的这种用法，使得可对转换函数做类似的处理：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Plebe</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// something </span></span><br><span class="line">    <span class="comment">// conversion functions</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">// something else</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// something else</span></span><br><span class="line">Plebe a, b;</span><br><span class="line"><span class="type">int</span> n = a;<span class="comment">// int-to-PLebe automatic conversion</span></span><br><span class="line"><span class="type">double</span> x = b;<span class="comment">// explicit makes it forbiden</span></span><br><span class="line">x = <span class="built_in">double</span>(b);<span class="comment">// explicit conversion, allowed</span></span><br></pre></td></tr></table></figure></li><li><p>类内成员初始化</p></li></ol><p>可以在类内成员定义时使用赋值或大括号版本的初始化，但是不能使用圆括号版本的初始化。</p><p>可以使用传递参数覆盖默认参数。</p><ol start="3"><li>模板和STL方面的修改</li></ol><ul><li>带范围的for循环；</li><li>新的STL容器（STL效率不高）</li></ul><p>​forward_list、unordered_map、unordered_multimap、unordered_set、unordered_multiset。forward_list是一种单向链表，只能沿一个方向遍历；与list相比，更简单并且占用空间更小；</p><ul><li>新的STL方法（cbegin()、cend()返回指向容器的第一个元素和最后一个元素的迭代器。新方法视元素为const）；</li><li>valarray升级，添加两个函数（begin()、end()），都接受valarray作为参数，并返回迭代器，指向第一个元素和超尾元素；</li><li>摒弃export</li></ul><p>C++98新增export，旨在提供一种途径，让程序员能够将模板定义在接口文件和实现文件中，其中接口文件包含原型和模板声明，而实现文件包含模板函数方法和方法的定义。实践证明这并不现实，因此C++11终止这种用法并保留关键字export；</p><ul><li>尖括号（以前要求在使用嵌套模板时使用空格将结束时的尖括号隔开）</li></ul><h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><p>学习左值和右值主要是为了理解std::move()等一系列C++11之后的新语义。</p><ul><li>左值：<br>  即能出现在赋值号左边也能出现在赋值号右边的变量类型；<br>  左值是可寻址的变量，具有持久性。</li><li>右值<br>  只能出现在赋值号右边的变量类型，右值是不可寻址的变量（临时变量，匿名对象)，但是右值引用支持给临时变量位置分配一个名称，这种操作使得重复访问这块内存成为可能，并且将该内存变成一个对象。</li></ul><p>左值引用：<br>    常规方式声明的引用；<br>右值引用：<br>    与左值引用的声明方式相似但是使用的是两个&amp;&amp;符号，并且引用的是临时变量，比如：x * 6这种值又或者是没有赋值给某个变量的字符串（char *类型）。右值引用不能约束到左值上，比如使用右值引用的声明引用一个长期变量，并且，给一个临时变量以右值引用时，它就成了左值，不能再被另一个右值引用。</p><h3 id="移动语义与右值引用"><a href="#移动语义与右值引用" class="headerlink" title="移动语义与右值引用"></a>移动语义与右值引用</h3><p>C++11之前的复制过程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; vstr;</span><br><span class="line"><span class="comment">// build up a vector fo 200,000 strings, each of 1000 characters</span></span><br><span class="line"><span class="comment">// something</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">vstr_copy1</span><span class="params">(vstr)</span></span>;<span class="comment">// make vstr_copy1 a copy of vstr</span></span><br></pre></td></tr></table></figure><p>vstr 和 string 类都是用动态内存分配，因此它们必须定义使用某种new 版本复制构造函数。为初始化对象vstr_copy1，复制构造函数vector<string>将使用呢哇给20000个string对象分配内存，而每个string对象又将调用string的复制构造函数，该构造函数使用new为1000个字符分配内存。接下来，全部200，000，000个字符都将从vstr控制的内存中复制到vstr_copy1控制的内存中。这里的工作量很大，但是只要使用适当的操作即可。（这里是说，只要操作方式得当，并且得到了预期的结果即可）</p><p><strong>操作是否妥当</strong> </p><p>有时候这样的操作是不妥当的，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">allcaps</span><span class="params">(<span class="type">const</span> vector&lt;string&gt; &amp;vs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;string&gt; temp;</span><br><span class="line">    <span class="comment">// code that stores all-uppercagse version of vs in temp</span></span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// asume this function is invoked as bellow</span></span><br><span class="line">vector&lt;string&gt; vstr;</span><br><span class="line"><span class="comment">// build up a vector of 20,000 strings, each of 1000 characters</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">vstr_copy1</span><span class="params">(vstr)</span></span>;<span class="comment">// #1</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">vstr_copy2</span><span class="params">(allcaps(vstr))</span></span>; <span class="comment">// #2</span></span><br></pre></td></tr></table></figure><p>上面两条初始化语句似乎是一样的，都是用一个现有的对象初始化一个vector<string>对象。如果深入探索这些代码，将发现allcaps()创建了对象temp，该对象管理着200，000，000个字符；vector和string的复制构造函数创建这么多个字符，然后程序将删除函数返回的对象副本（迟钝的编译器甚至可能将temp赋值给一个临时返回对象，删除temp，再删除临时返回对象）。这里的要点是，做了大量的无用功。考虑到临时对象被删除了，如果编译器将数据的所有权直接转让给vstr_copy2，这样其实是更好的。也即是说直接将temp管理的空间交给vstr_copy2。这类似于在计算机中移动文件的情形；实际文件还留在原来的地方，只修改记录（改变文件地址映射）。这种方法被称为移动语义（move semantics）。有点悖论的是。移动语义实际上避免了移动原始数据，而只是修改了记录。</p><p>要实现移动语义，需要采取某种方式，让编译器知道什么时候需要复制，什么时候不需要。这就是右值引用发挥作用的地方。可定义两个构造函数。其中哦一个是常规复制构造函数，它使用const左值引用作为参数，这个引用关联到左值实参，如语句#1中的vstr；另一个是移动构造函数，它使用const右值引用作为参数，该引用关联到左值实参，如语句#2中sllcaps(vstr)的返回值。复制构造函数可执行深拷贝操作，而移动构造函数只调整记录。再将所有权转移给新对象的过程中，移动构造函数可能修改其实参，这意味着右值引用参数不应是const</p><h4 id="移动示例"><a href="#移动示例" class="headerlink" title="移动示例"></a>移动示例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Useless.cpp - an otherwise useless class with move semantics</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// interface</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Useless</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n;          <span class="comment">// number of elements</span></span><br><span class="line">    <span class="type">char</span> *pc;       <span class="comment">// pointer to data</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> ct;  <span class="comment">// number of data</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showObject</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Useless</span>();</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Useless</span><span class="params">(<span class="type">int</span> k)</span></span>;</span><br><span class="line">    <span class="built_in">Useless</span>(<span class="type">int</span> k, <span class="type">char</span> ch);</span><br><span class="line">    <span class="built_in">Useless</span>(<span class="type">const</span> Useless &amp;f);  <span class="comment">// regular copy constructor</span></span><br><span class="line">    <span class="built_in">Useless</span>(Useless &amp;&amp;f);       <span class="comment">// move constructor</span></span><br><span class="line">    ~<span class="built_in">Useless</span>();</span><br><span class="line">    Useless <span class="keyword">operator</span>+(<span class="type">const</span> Useless &amp;f)<span class="type">const</span>;</span><br><span class="line">    <span class="comment">// need operator=() in copy and move versions</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showData</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// implementation</span></span><br><span class="line"><span class="type">int</span> Useless::ct = <span class="number">0</span>;    <span class="comment">// only way to initialize static member virable</span></span><br><span class="line"></span><br><span class="line">Useless::<span class="built_in">Useless</span>()</span><br><span class="line">&#123;</span><br><span class="line">    ++ct;</span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line">    pc = <span class="literal">nullptr</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;defalut constructor called; number of objects: &quot;</span> &lt;&lt; ct &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">showObject</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Useless::<span class="built_in">Useless</span>(<span class="type">int</span> k) : <span class="built_in">n</span>(k)</span><br><span class="line">&#123;</span><br><span class="line">    ++ct;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;int constructor called; number of objects: &quot;</span> &lt;&lt; ct &lt;&lt; endl;</span><br><span class="line">    pc = <span class="keyword">new</span> <span class="built_in">char</span>(n);</span><br><span class="line">    <span class="built_in">showObject</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Useless::<span class="built_in">Useless</span>(<span class="type">int</span> k , <span class="type">char</span> ch) : <span class="built_in">n</span>(k)</span><br><span class="line">&#123;</span><br><span class="line">    ++ct;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;int, char constructor called; number of objects: &quot;</span> &lt;&lt; ct &lt;&lt; endl;</span><br><span class="line">    pc = <span class="keyword">new</span> <span class="built_in">char</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        pc[i] = ch;</span><br><span class="line">    <span class="built_in">showObject</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Useless::<span class="built_in">Useless</span>(<span class="type">const</span> Useless &amp;f) : <span class="built_in">n</span>(f.n)</span><br><span class="line">&#123;</span><br><span class="line">    ++ct;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;copy const called; number of objects: &quot;</span> &lt;&lt; ct &lt;&lt; endl;</span><br><span class="line">    pc = <span class="keyword">new</span> <span class="built_in">char</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        pc[i] = f.pc[i];</span><br><span class="line">    <span class="built_in">showObject</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Useless::<span class="built_in">Useless</span>(Useless &amp;&amp;f) : <span class="built_in">n</span>(f.n)</span><br><span class="line">&#123;</span><br><span class="line">    ++ct;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;move constructore called; number of objects: &quot;</span> &lt;&lt; ct &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span>[] pc;</span><br><span class="line">    pc = f.pc;</span><br><span class="line">    f.pc = <span class="literal">nullptr</span>;</span><br><span class="line">    f.n = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">showObject</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Useless::~<span class="built_in">Useless</span>()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;destructor called; objects left: &quot;</span> &lt;&lt; --ct &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;deleted object:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">showObject</span>();</span><br><span class="line">    <span class="keyword">delete</span>[] pc;</span><br><span class="line">    pc = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Useless Useless::<span class="keyword">operator</span>+(<span class="type">const</span> Useless &amp;f) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Entering operator+()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    Useless temp = <span class="built_in">Useless</span>(n + f.n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        temp.pc[i] = pc[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &lt; temp.n; ++i)</span><br><span class="line">        temp.pc[i] = f.pc[i - n];</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;temp object: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Leaving operator+()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Useless::showObject</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Number of elements: &quot;</span> &lt;&lt; n;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; Data address: &quot;</span> &lt;&lt; (<span class="type">void</span>*) pc &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Useless::showData</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;(Object empty)&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            cout &lt;&lt; pc[i];</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// application</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Useless <span class="title">one</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;x&#x27;</span>)</span></span>;</span><br><span class="line">    Useless two = one;  <span class="comment">// calls copy constructor</span></span><br><span class="line">    <span class="function">Useless <span class="title">three</span><span class="params">(<span class="number">20</span>, <span class="string">&#x27;o&#x27;</span>)</span></span>;</span><br><span class="line">    <span class="function">Useless <span class="title">four</span> <span class="params">(one + three)</span></span>; <span class="comment">// calls operator+(), move constructor, one + three is temporary</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;object one: &quot;</span>;</span><br><span class="line">    one.<span class="built_in">showData</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;object two: &quot;</span>;</span><br><span class="line">    two.<span class="built_in">showData</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;object three: &quot;</span>;</span><br><span class="line">    three.<span class="built_in">showData</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;object four: &quot;</span>;</span><br><span class="line">    four.<span class="built_in">showData</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>程序输出：</p><p>int, char constructor called; number of objects: 1<br>Number of elements: 10 Data address: 0x9120d0<br>copy const called; number of objects: 2<br>Number of elements: 10 Data address: 0x916b60<br>int, char constructor called; number of objects: 3<br>Number of elements: 20 Data address: 0x916bb0<br>Entering operator+()<br>int constructor called; number of objects: 4<br>Number of elements: 30 Data address: 0x916c00<br>temp object:<br>Leaving operator+()<br>object one: xxxxxxxxxx<br>object two: xxxxxxxxxx<br>object three: oooooooooooooooooooo<br>object four: xxxxxxxxxxoooooooooooooooooooo<br>请按任意键继续. . .<br>destructor called; objects left: 3<br>deleted object:<br>Number of elements: 30 Data address: 0x916c00<br>destructor called; objects left: 2<br>deleted object:<br>Number of elements: 20 Data address: 0x916bb0<br>destructor called; objects left: 1<br>deleted object:<br>Number of elements: 10 Data address: 0x916b60<br>destructor called; objects left: 0<br>deleted object:<br>Number of elements: 10 Data address: 0x9120d0</p></blockquote><p>VS说这里程序触发了断点，但是对于空指针使用delete[] 并不会产生问题，所以断点位置并不清晰。在vscode中没有断点提示但是只有在<code>return 0;</code> 前添加断点，才能输出全部内容。</p><h4 id="8-10-2-解释"><a href="#8-10-2-解释" class="headerlink" title="8.10.2 解释"></a>8.10.2 解释</h4><p>这里没有调用移动构造函数，书中的解释是，在创建对象four时，编译器推断出对象four时operator+()所做工作的受益者，因此将operator+()创建的对象转到four的名下。一般而言，编译器完全可以进行优化，只要结果与未优化时相同。即使忽略程序中移动构造函数，并使用g++进行编译，结果也将相同。</p><h4 id="8-10-3-赋值"><a href="#8-10-3-赋值" class="headerlink" title="8.10.3 赋值"></a>8.10.3 赋值</h4><p>赋值运算符：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Useless&amp; Useless::<span class="keyword">operator</span>=(<span class="type">const</span> Useless &amp;f) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;f)<span class="comment">// self assignment</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">   <span class="keyword">delete</span>[] pc;</span><br><span class="line">    n = f.n;</span><br><span class="line">    pc = <span class="keyword">new</span> <span class="built_in">char</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        pc[i] = f.pc[i];</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>移动赋值运算符</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Useless&amp; Useless::<span class="keyword">operator</span>=(Useless &amp;&amp;f)<span class="comment">// move assignment</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;f)</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">delete</span>[] pc;</span><br><span class="line">    n = f.n;</span><br><span class="line">    f.n = <span class="number">0</span>;</span><br><span class="line">    f.pc = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>移动赋值运算符删除目标对象中的原始数据，并将原对象的所有权转让给目标。不能让多个指针指向相同的数据（地址）。</p><p>与移动构造函数一样，移动赋值运算符的参数也不能是const引用，因为这个方法修改了原对象。</p><h4 id="8-10-4-强制移动"><a href="#8-10-4-强制移动" class="headerlink" title="8.10.4 强制移动"></a>8.10.4 强制移动</h4><p>移动构造函数和移动赋值运算符使用右值。如果要让它们使用左值（程序可能分析一个包含候选对象的数组，选择其中一个对象供以后使用，并丢弃数组）。如果可以使用移动构造函数或者移动赋值运算符来保留选定的对象，自然是极好的。</p><p>如此便有下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Useless choices[<span class="number">20</span>];</span><br><span class="line">Useless best;</span><br><span class="line"><span class="type">int</span> pick;</span><br><span class="line"><span class="comment">// select one object, set pick to index</span></span><br><span class="line">best = choices[pick];</span><br></pre></td></tr></table></figure><p>由于choices[pick] 是左值，因此上面的赋值语句将使用赋值构造函数，而不是移动赋值运算符。如果能使choices[pick]看起来更像右值，就可以使用移动赋值运算符。为此，可以使用强制类型转换运算符static_cast&lt;&gt;将对象的类型转换为Useless &amp;&amp;，但是C++11提供了一种更简单的方式——使用头文件utility中声明的函数std::move()。下面的例子演示了这种用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stdmove.cpp -- using std::move()</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// interface</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Useless</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n;<span class="comment">// number of elements</span></span><br><span class="line">    <span class="type">char</span> *pc;<span class="comment">// pointer to data</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> ct;<span class="comment">// number of objects</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showObject</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Useless</span>();</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Useless</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line">    <span class="built_in">Useless</span>(<span class="type">int</span> k, <span class="type">char</span> ch);</span><br><span class="line">    <span class="built_in">Useless</span>(<span class="type">const</span> Useless &amp;f);<span class="comment">// copy assignment</span></span><br><span class="line">    <span class="built_in">Useless</span>(Useless &amp;&amp;f);<span class="comment">// move assignment</span></span><br><span class="line">    ~<span class="built_in">Useless</span>();</span><br><span class="line">    Useless <span class="keyword">operator</span>+(<span class="type">const</span> Useless &amp;f) <span class="type">const</span>;</span><br><span class="line">    Useless&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Useless &amp;f);<span class="comment">// copy assignment;</span></span><br><span class="line">    Useless&amp; <span class="keyword">operator</span>=(Useless &amp;&amp;f);<span class="comment">// move assignment</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showData</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// implementation</span></span><br><span class="line"><span class="type">int</span> Useless::ct = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Useless::<span class="built_in">Useless</span>()</span><br><span class="line">&#123;</span><br><span class="line">    ++ct;</span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line">    pc = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Useless::<span class="built_in">Useless</span>(<span class="type">int</span> k) : <span class="built_in">n</span>(k)</span><br><span class="line">&#123;</span><br><span class="line">    ++ct;</span><br><span class="line">    pc = <span class="keyword">new</span> <span class="built_in">char</span>(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Useless::<span class="built_in">Useless</span>(<span class="type">int</span> k, <span class="type">char</span> ch) : <span class="built_in">n</span>(k)</span><br><span class="line">&#123;</span><br><span class="line">    ++ct;</span><br><span class="line">    pc = <span class="keyword">new</span> <span class="built_in">char</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        pc[i] = ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Useless::<span class="built_in">Useless</span>(<span class="type">const</span> Useless &amp;f) : <span class="built_in">n</span>(f.n)</span><br><span class="line">&#123;</span><br><span class="line">    ++ct;</span><br><span class="line">    pc = <span class="keyword">new</span> <span class="built_in">char</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        pc[i] = f.pc[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Useless::<span class="built_in">Useless</span>(Useless &amp;&amp;f)</span><br><span class="line">&#123;</span><br><span class="line">    ++ct;</span><br><span class="line">    pc = f.pc;</span><br><span class="line">    f.pc = <span class="literal">nullptr</span>;</span><br><span class="line">    f.n = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Useless::~<span class="built_in">Useless</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] pc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Useless Useless::<span class="keyword">operator</span>+(<span class="type">const</span> Useless &amp;f) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    Useless temp = <span class="built_in">Useless</span>(n + f.n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        temp.pc[i] = pc[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &lt; temp.n; ++i)</span><br><span class="line">        temp.pc[i] = f.pc[i - n];</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Useless&amp; Useless::<span class="keyword">operator</span>=(<span class="type">const</span> Useless &amp;f)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;copy assignement operator called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;f)</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    n = f.n;</span><br><span class="line">    <span class="keyword">delete</span>[] pc;</span><br><span class="line">    pc = <span class="keyword">new</span> <span class="built_in">char</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        pc[i] = f.pc[i];</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Useless&amp; Useless::<span class="keyword">operator</span>=(Useless &amp;&amp;f)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;move assignement operator called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;f)</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    n = f.n;</span><br><span class="line">    <span class="keyword">delete</span>[] pc;</span><br><span class="line">    pc = f.pc;</span><br><span class="line">    f.n = <span class="number">0</span>;</span><br><span class="line">    f.pc = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Useless::showObject</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Number of elements: &quot;</span> &lt;&lt; n;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; Data address: &quot;</span> &lt;&lt; (<span class="type">void</span>*) pc &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Useless::showData</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;(Object empty)&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            std::cout &lt;&lt; pc[i];</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// application</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Useless <span class="title">one</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;x&#x27;</span>)</span></span>;</span><br><span class="line">    Useless two = one + one;  <span class="comment">// calls copy constructor</span></span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;object one: &quot;</span>;</span><br><span class="line">    one.<span class="built_in">showData</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;object two: &quot;</span>;</span><br><span class="line">    two.<span class="built_in">showData</span>();</span><br><span class="line"></span><br><span class="line">    Useless three, four; </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;three = one&quot;</span> &lt;&lt; std::endl;;</span><br><span class="line">    three = one;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;now object three = &quot;</span>; </span><br><span class="line">    three.<span class="built_in">showData</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; and object one = &quot;</span>;</span><br><span class="line">    one.<span class="built_in">showData</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;object four = one + two&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    four = one + two;   <span class="comment">// automatic move assignment</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;now object four = &quot;</span>;</span><br><span class="line">    four.<span class="built_in">showData</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;four = move(one)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    four = std::<span class="built_in">move</span>(one);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;now object four = &quot;</span>;</span><br><span class="line">    four.<span class="built_in">showData</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; and object one = &quot;</span>;</span><br><span class="line">    one.<span class="built_in">showData</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="新的类功能"><a href="#新的类功能" class="headerlink" title="新的类功能"></a>新的类功能</h3><p>在原有4个特殊成员函数（默认构造函数、复制构造函数、赋值运算符和析构函数）的基础上，C++11新增了两个：移动构造函数和移动赋值运算符。这些成员函数是在编译器在各种情况下自动提供的。</p><p>假设类型为Someclass，则默认移动构造函数和默认移动赋值运算符的原型为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Someclass::<span class="built_in">Someclass</span>(<span class="type">const</span> Someclass &amp;);<span class="comment">// default copy constructor</span></span><br><span class="line">Someclass::<span class="built_in">Someclass</span>(Someclass &amp;&amp;);<span class="comment">// default move constructor</span></span><br></pre></td></tr></table></figure><h4 id="默认地方法和禁用的方法"><a href="#默认地方法和禁用的方法" class="headerlink" title="默认地方法和禁用的方法"></a>默认地方法和禁用的方法</h4><p>在函数定义之后加<code>=default</code> 将函数设为默认，加<code>=delete</code> 将函数禁用</p><h4 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h4><p>如果类提供了多个构造函数，程序员可能会重复编写相同的代码，也就是说，有些构造函数可能需要包含其他构造函数中已有的代码。为了让编码工作过更简单、更可靠，C++11允许程序员在一个构造函数的定义中使用另一个构造函数。这被称为委托，因为构造函数暂时将创建对象的工作委托给另一个构造函数。委托将使用成员初始化列表语法的变种：</p><p>即在初始化列表中调用同一类中的其它构造函数（与之同名，参数个数不同或者参数类型不同），执行其他构造函数之后再执行自身函数体。</p><h4 id="继承构造函数"><a href="#继承构造函数" class="headerlink" title="继承构造函数"></a>继承构造函数</h4><p>面向对象的主要思想或者主要工作就是代码复用，所以为了进一步简化编码工作，C++11提供了一种让派生类能够继承基类构造函数的机制。C++98则提供过一种让命名空间中函数可用的语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Box</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fn</span><span class="params">(<span class="type">int</span>)</span> </span>&#123; <span class="comment">/* do something */</span> &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">(<span class="type">double</span>)</span> </span>&#123; <span class="comment">/* do something */</span> &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *)</span> </span>&#123; <span class="comment">/* do something */</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> Box::fn;<span class="comment">// 让函数fn的所有重载版本都可用。也可使用这种方法让基类的所有非特殊成员函数对派生类可用</span></span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C1</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// define something</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fn</span><span class="params">(<span class="type">int</span>)</span> </span>&#123; <span class="comment">/* do something */</span> &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">(<span class="type">double</span>)</span> </span>&#123; <span class="comment">/* do something */</span> &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *)</span> </span>&#123; <span class="comment">/* do something */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C2</span> : <span class="keyword">public</span> C1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// define something else</span></span><br><span class="line">    <span class="function"><span class="keyword">using</span> <span class="title">C1::fn</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">(<span class="type">double</span>)</span> </span>&#123; <span class="comment">/* do something else */</span> &#125;;<span class="comment">// =default</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类C2中的using声明让C2对象可以使用C1的所有fn方法，但将选择C2而不是C1定义的方法fn(double)。</p><p>C++11将这种方法用与构造函数。这让派生类继承基类的所有构造函数（默认构造函数、复制构造函数和移动构造函数除外），但不会使用与派生类构造函数的 <font size=3 color=5>特征标</font> 相匹配的构造函数（如果有参数相同的函数，优先调用子类自定义的版本），应该说是提供了下转型对象的方法，继承的基类构造函数只能初始化基类成员，如果还要初始化派生类新增成员，还需要使用初始化列表的语法（感觉有点鸡肋，因为不适用using声明也可以使用基类构造函数加初始化列表初始化派生类对象）。</p><h4 id="管理虚方法：override-和-final"><a href="#管理虚方法：override-和-final" class="headerlink" title="管理虚方法：override 和 final"></a>管理虚方法：override 和 final</h4><p>前者用于指明，成员函数重写了基类中声明的虚函数。</p><p>后者则与Java中的final关键字作用相同，用于标识函数不允许重写。</p><p>这两个说明符并非关键字，而是具有特殊含义的标识符。</p><h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><h4 id="比较函数指针、函数对象和lambda表达式"><a href="#比较函数指针、函数对象和lambda表达式" class="headerlink" title="比较函数指针、函数对象和lambda表达式"></a>比较函数指针、函数对象和lambda表达式</h4><p>假设要生成一个随机整数列表，并判断其中有多少整数能够可以被3整除，多少个整数能够可被13整除。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">numbers</span><span class="params">(<span class="number">1000</span>)</span></span>;</span><br><span class="line">std::<span class="built_in">generate</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), std::rand);<span class="comment">// 指向标准函数rand的指针</span></span><br></pre></td></tr></table></figure><p>通过使用count_if函数可以轻松计算出有多少个能够被3整除的元素。与generate函数一样，前两个参数指定容器的区间，第三个参数应当是一个返回true或者false的函数对象（仿函数）。函数count_if计算这样的元素数，即它使得指定的函数对象返回true。为判断元素能否被3整除，可以使用下面的定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">f3</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x % <span class="number">3</span> == <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure><p>同样，为判断元素是否能够被13整除，可以使用下面的定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">f13</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x % <span class="number">13</span> == <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure><p>定义上述函数后，便可计算符合条件的元素数目了，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> count3 = std::<span class="built_in">count_if</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), f3);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Count of numbers division by 3: &quot;</span> &lt;&lt; count3 &lt;&lt; std::endl;</span><br><span class="line"><span class="type">int</span> count13 = std::<span class="built_in">count_if</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), f13);</span><br><span class="line">std::count &lt;&lt; <span class="string">&quot;Count of numbers division by 13: &quot;</span> &lt;&lt; count13 &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>函数指针：函数名不加函数调用符；函数对象：类内重载的函数调用符，类名加函数调用符。</p><p>最后是使用了lambda表达式的情况，名称来源于λ演算——一种定义和应用函数的数学系统。这个系统让程序员能够使用匿名函数——即无需给函数明明。在C++11中，对于接收函数指针或函数符的函数，可使用吗匿名函数定义lambda作为其参数。与前面函数f3对应的lambda如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[] (<span class="type">int</span> x) &#123; <span class="keyword">return</span> x % <span class="number">3</span> == <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure><p>再看一看f3()的定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">f3</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x % <span class="number">3</span> == <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure><p>差别：</p><ul><li>使用了[]代替函数名（这就是匿名的由来）；</li><li>没有生命返回类型</li></ul><p>返回类型相当于使用decltyp根据返回值推断得到的，这里为bool，如果lambda不返回语句，推断出的返回类型将为void，就这个示例而言，程序员将以如下方式使用该lambda：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> count3 = std::<span class="built_in">count_if</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), </span><br><span class="line">                           [] (<span class="type">int</span> x) &#123; <span class="keyword">return</span> x % <span class="number">3</span> == <span class="number">0</span>; &#125;);</span><br></pre></td></tr></table></figure><p>也就是说，使用整个lambda表达式替换函数指针或函数符构造函数。</p><p>仅当lambda表达式完全由一条返回语句组成时，自动类型推断才有用；否则，需要使用新增的返回值后置的语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[] (<span class="type">double</span> x) -&gt; <span class="type">double</span> &#123; <span class="type">int</span> y = x; <span class="keyword">return</span> x - y; &#125;<span class="comment">// reuturn type is double</span></span><br></pre></td></tr></table></figure><h4 id="为何使用lambda"><a href="#为何使用lambda" class="headerlink" title="为何使用lambda"></a>为何使用lambda</h4><ol><li>距离</li></ol><p>让定义位于使用的地方附近很有用。这样就无需翻阅多余代码，再修改代码的使用也会因为内容大多在附近而更方便；</p><ol start="2"><li>简洁</li></ol><p>从简洁的角度看，函数符代码比函数和lambda表达式更为繁琐。函数和lambda的简洁程度相当，一个显而易见的例外是，重复使用lambda时，可以选择复写代码或者给予lambda一个名字，并重复使用该名字：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> mod3 = [] (<span class="type">int</span> x) &#123; <span class="keyword">return</span> x % <span class="number">3</span> == <span class="number">0</span>; &#125;<span class="comment">// mod3 a name for the lambda</span></span><br><span class="line">count1 = std::<span class="built_in">count_if</span>(n1.<span class="built_in">begin</span>(), n1.<span class="built_in">end</span>(), mod3);</span><br><span class="line">count2 = std::<span class="built_in">count_id</span>(n2.<span class="built_in">begin</span>(), n3.<span class="built_in">end</span>(), mod3);</span><br><span class="line"><span class="comment">// 甚至可以像使用常规函数一样使用有名称的lambda</span></span><br><span class="line"><span class="type">bool</span> result = <span class="built_in">mod3</span>(z);<span class="comment">// result is true if z % 3 == 0</span></span><br></pre></td></tr></table></figure><p>然而，不同于常规函数，可在函数内部定义有名称的lambda。mod3的实际类型随实现而异，它取决于编译器使用什么类型来追踪lambda。</p><ol start="3"><li>效率</li></ol><p>这三种方法的效率取决于编译器内联的那些东西。函数指针方法阻止了内联，有因为编译器传统上不会内联其地址被获取的函数，因为函数的地址的概念意味着非内联函数（类的封装特性决定了类不会将开放的函数作为内联函数）。而函数符和lambda通常不会组织内联。</p><ol start="4"><li>功能</li></ol><p>lambda额外的功能：</p><ul><li>可访问作用域内的任何动态变量；</li><li>要捕获要使用的变量，可将其名称放在中括号内。如果只指定了变量名，如[Z]，将按值访问变量；如果在名称之前加上&amp;，如[&amp;count]，将按引用访问变量。（[&amp;]让程序员能够访问作用域内所有的动态变量（表达式所在的区域），而[&#x3D;]让程序员能够安置访问所有动态变量，甚至可以混合使用这两种方式）；</li><li>如果捕获列表中出现[&#x3D;, &amp;ted]，则说明只有ted可以按引用访问，其余动态变量只能是按值访问。</li></ul><p>​<font size=3 color=5><strong>总结</strong></font></p><p>在C++中引入lambda的主要目的是，让程序员能够将类似于函数的表达式用作接收函数指针或函数符的函数的参数。因此，典型的lambda是测试表达式或比较表达式，可变写一条返回语句。这使得lambda简洁而易于理解，且可自动推断返回类型。然而，有创意的C++程序员可能开发出其他用法。</p><h3 id="包装器"><a href="#包装器" class="headerlink" title="包装器"></a>包装器</h3><p>C++提供了多个包装器（也叫适配器），这些对象用于给其他编程接口提供更一致或更合适的接口。</p><p><code>answer = ef(q);</code> </p><p>这里的ef可以是函数、函数指针、函数对象甚至是带有名称的lambda表达式。所有这些都是可调用的类型。鉴于可调用的类型如此之多，这可能导致模板低效。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> F&gt;</span></span><br><span class="line"><span class="function">T <span class="title">use_f</span><span class="params">(T t, F f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    ++count;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; use_f count = &quot;</span> &lt;&lt; count &lt;&lt; <span class="string">&quot;, &amp;count = &quot;</span> &lt;&lt; &amp;count &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">f</span>(t);    <span class="comment">// 返回计算值</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fp</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> z_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Fp</span>(<span class="type">double</span> z = <span class="number">1.0</span>) : <span class="built_in">z_</span>(z) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">double</span> p)</span> </span>&#123; <span class="keyword">return</span> z_ * p; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fq</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> z_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Fq</span>(<span class="type">double</span> z = <span class="number">1.0</span>) : <span class="built_in">z_</span>(z) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">double</span> p)</span> </span>&#123; <span class="keyword">return</span> z_ + p; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;somedefs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">dub</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="number">2.0</span> * x; &#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">sqware</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123; <span class="keyword">return</span> x * x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出的六个count皆不同，大致分为三类，函数指针、函数对象、lambda，但是推导出的F的类型是一致的</span></span><br><span class="line"></span><br><span class="line">std::function&lt;<span class="type">double</span>(<span class="type">double</span>)&gt; ef = dub;</span><br><span class="line">std::function&lt;<span class="type">double</span>(<span class="type">double</span>)&gt; ef2 = sqware;</span><br><span class="line">std::function&lt;<span class="type">double</span>(<span class="type">double</span>)&gt; ef3 = <span class="built_in">Fp</span>(<span class="number">5.0</span>);</span><br><span class="line">std::function&lt;<span class="type">double</span>(<span class="type">double</span>)&gt; ef4 = <span class="built_in">Fq</span>(<span class="number">5.0</span>);</span><br><span class="line">std::function&lt;<span class="type">double</span>(<span class="type">double</span>)&gt; ef5 = [](<span class="type">double</span> u) &#123; <span class="keyword">return</span> u * u; &#125;;</span><br><span class="line">std::function&lt;<span class="type">double</span>(<span class="type">double</span>)&gt; ef6 = [](<span class="type">double</span> u) &#123; <span class="keyword">return</span> <span class="number">2.0</span> * u; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改之后输出的count完全一致，说明只执行另外一次类型推导</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::cout;</span><br><span class="line">    <span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; std::fixed;</span><br><span class="line">    cout.<span class="built_in">precision</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> y = <span class="number">1.21</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Function pointer dub: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; use_f(y, dub) &lt;&lt; endl;</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">use_f</span>(y, ef) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Function pointer sqware: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; use_f(y, sqware) &lt;&lt; endl;</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">use_f</span>(y, ef2) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Function object Fp: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; use_f(y, Fp(5.0)) &lt;&lt; endl;</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">use_f</span>(y, ef3) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Function object Fq: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; use_f(y, Fq(5.0));</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">use_f</span>(y, ef4) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Lambda expression 1:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; use_f(y, [] (double u) -&gt; double &#123; return u * u; &#125;) &lt;&lt; endl;</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">use_f</span>(y, ef5) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Lambda expression 2:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; use_f(y, [] (double u) -&gt; double &#123; return 2.0 * u; &#125;) &lt;&lt; endl;</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">use_f</span>(y, ef6) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他改良方式：</p><p>上面的例子中使用了六个function&lt;double(double)&gt;对象，现在，只使用了一个临时的function&lt;double(double)&gt;对象，将其用作函数use_f()的参数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> function&lt;<span class="type">double</span>(<span class="type">double</span>)&gt; fdd;<span class="comment">// simplify the type declaration</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">use_f</span>(y, <span class="built_in">fdd</span>(dub)) &lt;&lt; endl;<span class="comment">// create and initlize object to dub</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">use_f</span>(y, <span class="built_in">fdd</span>(sqware)) &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>在此基础上，将上面的例子改为如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">use_f</span><span class="params">(T t, std::function&lt;T(T) f)</span><span class="comment">// f call signature is T(T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    ++count;</span><br><span class="line"> std::cout &lt;&lt; <span class="string">&quot; use_f count = &quot;</span> &lt;&lt; count &lt;&lt; <span class="string">&quot;, &amp;count = &quot;</span> &lt;&lt; &amp;count &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">f</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">use_f</span>&lt;<span class="type">double</span>&gt;(y, dub) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">use_f</span>&lt;<span class="type">double</span>&gt;(y, <span class="built_in">Fq</span>(<span class="number">5.0</span>)) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">use_f</span>&lt;<span class="type">double</span>&gt;(y, [](<span class="type">double</span> u)&#123; <span class="keyword">return</span> u * u; &#125;) &lt;&lt; endl; </span><br></pre></td></tr></table></figure><p>参数dub、Fp(5.0)等本身的类型并不是function&lt;double(double)&gt;，因此在use_f后面使用了<double>来指出所需的具体化。这样，T被设置为double，而是std::function&lt;T(T)&gt;变成了std::function&lt;double(double)&gt;。</p><h3 id="可变参数模板"><a href="#可变参数模板" class="headerlink" title="可变参数模板"></a>可变参数模板</h3><p>递归展开参数包可能会出现传递全部参数导致程序无穷递归没有终止的情况，所以做出下面更改：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// definition for 0 parameter</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// deginition for 1 parameter</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(T value)</span> </span>&#123; cout &lt;&lt; T &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// definition for 2 or more parameters</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span> value, <span class="keyword">class</span>... args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; T &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line"><span class="built_in">show</span>(args...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在参数列表中还有多个参数的情况下，调用参数包版本；在只剩下最后一个参数的时候调用单参数模板输出并换行；在没有参数时，调用无参版本。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/04/08/hello-world/"/>
      <url>/2022/04/08/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 开始 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
